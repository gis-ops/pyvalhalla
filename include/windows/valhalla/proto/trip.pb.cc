// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#include "trip.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace valhalla {
PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_lanes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.to_lanes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_way_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_LaneConnectivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_LaneConnectivityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_LaneConnectivityDefaultTypeInternal() {}
  union {
    TripLeg_LaneConnectivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_TrafficSegment::TripLeg_TrafficSegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.segment_id_)*/uint64_t{0u}
  , /*decltype(_impl_.begin_percent_)*/0
  , /*decltype(_impl_.end_percent_)*/0
  , /*decltype(_impl_.starts_segment_)*/false
  , /*decltype(_impl_.ends_segment_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_TrafficSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_TrafficSegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_TrafficSegmentDefaultTypeInternal() {}
  union {
    TripLeg_TrafficSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Restriction::TripLeg_Restriction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_RestrictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_RestrictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_RestrictionDefaultTypeInternal() {}
  union {
    TripLeg_Restriction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Edge::TripLeg_Edge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{}
  , /*decltype(_impl_.lane_connectivity_)*/{}
  , /*decltype(_impl_.traffic_segment_)*/{}
  , /*decltype(_impl_.turn_lanes_)*/{}
  , /*decltype(_impl_.tagged_value_)*/{}
  , /*decltype(_impl_.sign_)*/nullptr
  , /*decltype(_impl_.transit_route_info_)*/nullptr
  , /*decltype(_impl_.restriction_)*/nullptr
  , /*decltype(_impl_.length_km_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.road_class_)*/0
  , /*decltype(_impl_.begin_heading_)*/0u
  , /*decltype(_impl_.end_heading_)*/0u
  , /*decltype(_impl_.begin_shape_index_)*/0u
  , /*decltype(_impl_.end_shape_index_)*/0u
  , /*decltype(_impl_.traversability_)*/0
  , /*decltype(_impl_.use_)*/0
  , /*decltype(_impl_.toll_)*/false
  , /*decltype(_impl_.unpaved_)*/false
  , /*decltype(_impl_.tunnel_)*/false
  , /*decltype(_impl_.bridge_)*/false
  , /*decltype(_impl_.surface_)*/0
  , /*decltype(_impl_.travel_mode_)*/0
  , /*decltype(_impl_.roundabout_)*/false
  , /*decltype(_impl_.internal_intersection_)*/false
  , /*decltype(_impl_.drive_on_left_)*/false
  , /*decltype(_impl_.bicycle_network_)*/false
  , /*decltype(_impl_.vehicle_type_)*/0
  , /*decltype(_impl_.pedestrian_type_)*/0
  , /*decltype(_impl_.bicycle_type_)*/0
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.transit_type_)*/0
  , /*decltype(_impl_.weighted_grade_)*/0
  , /*decltype(_impl_.way_id_)*/uint64_t{0u}
  , /*decltype(_impl_.max_upward_grade_)*/0
  , /*decltype(_impl_.max_downward_grade_)*/0
  , /*decltype(_impl_.lane_count_)*/0u
  , /*decltype(_impl_.cycle_lane_)*/0
  , /*decltype(_impl_.sidewalk_)*/0
  , /*decltype(_impl_.density_)*/0u
  , /*decltype(_impl_.speed_limit_)*/0u
  , /*decltype(_impl_.truck_speed_)*/0
  , /*decltype(_impl_.mean_elevation_)*/0
  , /*decltype(_impl_.truck_route_)*/false
  , /*decltype(_impl_.has_time_restrictions_)*/false
  , /*decltype(_impl_.destination_only_)*/false
  , /*decltype(_impl_.is_urban_)*/false
  , /*decltype(_impl_.default_speed_)*/0
  , /*decltype(_impl_.source_along_edge_)*/0
  , /*decltype(_impl_.target_along_edge_)*/0
  , /*decltype(_impl_.sac_scale_)*/0
  , /*decltype(_impl_.shoulder_)*/false
  , /*decltype(_impl_.indoor_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_EdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_EdgeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_EdgeDefaultTypeInternal() {}
  union {
    TripLeg_Edge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sign_)*/nullptr
  , /*decltype(_impl_.begin_heading_)*/0u
  , /*decltype(_impl_.prev_name_consistency_)*/false
  , /*decltype(_impl_.curr_name_consistency_)*/false
  , /*decltype(_impl_.driveability_)*/0
  , /*decltype(_impl_.cyclability_)*/0
  , /*decltype(_impl_.walkability_)*/0
  , /*decltype(_impl_.use_)*/0
  , /*decltype(_impl_.road_class_)*/0
  , /*decltype(_impl_.lane_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_IntersectingEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IntersectingEdgeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IntersectingEdgeDefaultTypeInternal() {}
  union {
    TripLeg_IntersectingEdge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Cost::TripLeg_Cost(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seconds_)*/0
  , /*decltype(_impl_.cost_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_CostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_CostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_CostDefaultTypeInternal() {}
  union {
    TripLeg_Cost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_PathCost::TripLeg_PathCost(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.elapsed_cost_)*/nullptr
  , /*decltype(_impl_.transition_cost_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_PathCostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_PathCostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_PathCostDefaultTypeInternal() {}
  union {
    TripLeg_PathCost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Node::TripLeg_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.intersecting_edge_)*/{}
  , /*decltype(_impl_.recosts_)*/{}
  , /*decltype(_impl_.time_zone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.edge_)*/nullptr
  , /*decltype(_impl_.transit_platform_info_)*/nullptr
  , /*decltype(_impl_.transit_station_info_)*/nullptr
  , /*decltype(_impl_.transit_egress_info_)*/nullptr
  , /*decltype(_impl_.cost_)*/nullptr
  , /*decltype(_impl_.bss_info_)*/nullptr
  , /*decltype(_impl_.admin_index_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.fork_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_NodeDefaultTypeInternal() {}
  union {
    TripLeg_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Admin::TripLeg_Admin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.country_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_AdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_AdminDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_AdminDefaultTypeInternal() {}
  union {
    TripLeg_Admin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.time_)*/{}
  , /*decltype(_impl_._time_cached_byte_size_)*/{0}
  , /*decltype(_impl_.length_)*/{}
  , /*decltype(_impl_._length_cached_byte_size_)*/{0}
  , /*decltype(_impl_.speed_)*/{}
  , /*decltype(_impl_._speed_cached_byte_size_)*/{0}
  , /*decltype(_impl_.speed_limit_)*/{}
  , /*decltype(_impl_._speed_limit_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_ShapeAttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ShapeAttributesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ShapeAttributesDefaultTypeInternal() {}
  union {
    TripLeg_ShapeAttributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Incident::TripLeg_Incident(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.begin_shape_index_)*/0u
  , /*decltype(_impl_.end_shape_index_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_IncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IncidentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IncidentDefaultTypeInternal() {}
  union {
    TripLeg_Incident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Closure::TripLeg_Closure(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_begin_shape_index_)*/{}
  , /*decltype(_impl_.has_end_shape_index_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_ClosureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ClosureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ClosureDefaultTypeInternal() {}
  union {
    TripLeg_Closure _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
PROTOBUF_CONSTEXPR TripLeg::TripLeg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/{}
  , /*decltype(_impl_.node_)*/{}
  , /*decltype(_impl_.admin_)*/{}
  , /*decltype(_impl_.incidents_)*/{}
  , /*decltype(_impl_.algorithms_)*/{}
  , /*decltype(_impl_.closures_)*/{}
  , /*decltype(_impl_.shape_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bbox_)*/nullptr
  , /*decltype(_impl_.shape_attributes_)*/nullptr
  , /*decltype(_impl_.osm_changeset_)*/uint64_t{0u}
  , /*decltype(_impl_.trip_id_)*/uint64_t{0u}
  , /*decltype(_impl_.leg_id_)*/0u
  , /*decltype(_impl_.leg_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLegDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLegDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLegDefaultTypeInternal() {}
  union {
    TripLeg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLegDefaultTypeInternal _TripLeg_default_instance_;
PROTOBUF_CONSTEXPR TripRoute::TripRoute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.legs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripRouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripRouteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripRouteDefaultTypeInternal() {}
  union {
    TripRoute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripRouteDefaultTypeInternal _TripRoute_default_instance_;
PROTOBUF_CONSTEXPR Trip::Trip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.routes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripDefaultTypeInternal() {}
  union {
    Trip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool TripLeg_Node_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Node_Type_strings[15] = {};

static const char TripLeg_Node_Type_names[] =
  "kBikeShare"
  "kBollard"
  "kBorderControl"
  "kBuildingEntrance"
  "kElevator"
  "kGate"
  "kMotorwayJunction"
  "kParking"
  "kStreetIntersection"
  "kSumpBuster"
  "kTollBooth"
  "kTollGantry"
  "kTransitEgress"
  "kTransitPlatform"
  "kTransitStation";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Node_Type_entries[] = {
  { {TripLeg_Node_Type_names + 0, 10}, 7 },
  { {TripLeg_Node_Type_names + 10, 8}, 2 },
  { {TripLeg_Node_Type_names + 18, 14}, 10 },
  { {TripLeg_Node_Type_names + 32, 17}, 13 },
  { {TripLeg_Node_Type_names + 49, 9}, 14 },
  { {TripLeg_Node_Type_names + 58, 5}, 1 },
  { {TripLeg_Node_Type_names + 63, 17}, 9 },
  { {TripLeg_Node_Type_names + 80, 8}, 8 },
  { {TripLeg_Node_Type_names + 88, 19}, 0 },
  { {TripLeg_Node_Type_names + 107, 11}, 12 },
  { {TripLeg_Node_Type_names + 118, 10}, 3 },
  { {TripLeg_Node_Type_names + 128, 11}, 11 },
  { {TripLeg_Node_Type_names + 139, 14}, 4 },
  { {TripLeg_Node_Type_names + 153, 16}, 6 },
  { {TripLeg_Node_Type_names + 169, 15}, 5 },
};

static const int TripLeg_Node_Type_entries_by_number[] = {
  8, // 0 -> kStreetIntersection
  5, // 1 -> kGate
  1, // 2 -> kBollard
  10, // 3 -> kTollBooth
  12, // 4 -> kTransitEgress
  14, // 5 -> kTransitStation
  13, // 6 -> kTransitPlatform
  0, // 7 -> kBikeShare
  7, // 8 -> kParking
  6, // 9 -> kMotorwayJunction
  2, // 10 -> kBorderControl
  11, // 11 -> kTollGantry
  9, // 12 -> kSumpBuster
  3, // 13 -> kBuildingEntrance
  4, // 14 -> kElevator
};

const std::string& TripLeg_Node_Type_Name(
    TripLeg_Node_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Node_Type_entries,
          TripLeg_Node_Type_entries_by_number,
          15, TripLeg_Node_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Node_Type_entries,
      TripLeg_Node_Type_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Node_Type_strings[idx].get();
}
bool TripLeg_Node_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Node_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Node_Type_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Node_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node::kGate;
constexpr TripLeg_Node_Type TripLeg_Node::kBollard;
constexpr TripLeg_Node_Type TripLeg_Node::kTollBooth;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitEgress;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitStation;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
constexpr TripLeg_Node_Type TripLeg_Node::kBikeShare;
constexpr TripLeg_Node_Type TripLeg_Node::kParking;
constexpr TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
constexpr TripLeg_Node_Type TripLeg_Node::kBorderControl;
constexpr TripLeg_Node_Type TripLeg_Node::kTollGantry;
constexpr TripLeg_Node_Type TripLeg_Node::kSumpBuster;
constexpr TripLeg_Node_Type TripLeg_Node::kBuildingEntrance;
constexpr TripLeg_Node_Type TripLeg_Node::kElevator;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MIN;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MAX;
constexpr int TripLeg_Node::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Traversability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Traversability_strings[4] = {};

static const char TripLeg_Traversability_names[] =
  "kBackward"
  "kBoth"
  "kForward"
  "kNone";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Traversability_entries[] = {
  { {TripLeg_Traversability_names + 0, 9}, 2 },
  { {TripLeg_Traversability_names + 9, 5}, 3 },
  { {TripLeg_Traversability_names + 14, 8}, 1 },
  { {TripLeg_Traversability_names + 22, 5}, 0 },
};

static const int TripLeg_Traversability_entries_by_number[] = {
  3, // 0 -> kNone
  2, // 1 -> kForward
  0, // 2 -> kBackward
  1, // 3 -> kBoth
};

const std::string& TripLeg_Traversability_Name(
    TripLeg_Traversability value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Traversability_entries,
          TripLeg_Traversability_entries_by_number,
          4, TripLeg_Traversability_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Traversability_entries,
      TripLeg_Traversability_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Traversability_strings[idx].get();
}
bool TripLeg_Traversability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Traversability* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Traversability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Traversability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Traversability TripLeg::kNone;
constexpr TripLeg_Traversability TripLeg::kForward;
constexpr TripLeg_Traversability TripLeg::kBackward;
constexpr TripLeg_Traversability TripLeg::kBoth;
constexpr TripLeg_Traversability TripLeg::Traversability_MIN;
constexpr TripLeg_Traversability TripLeg::Traversability_MAX;
constexpr int TripLeg::Traversability_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Use_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 40:
    case 41:
    case 42:
    case 43:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Use_strings[34] = {};

static const char TripLeg_Use_names[] =
  "kAlleyUse"
  "kBridlewayUse"
  "kBusUse"
  "kConstructionUse"
  "kCuldesacUse"
  "kCyclewayUse"
  "kDriveThruUse"
  "kDrivewayUse"
  "kEgressConnectionUse"
  "kElevatorUse"
  "kEmergencyAccessUse"
  "kEscalatorUse"
  "kFerryUse"
  "kFootwayUse"
  "kLivingStreetUse"
  "kMountainBikeUse"
  "kOtherUse"
  "kParkingAisleUse"
  "kPathUse"
  "kPedestrianCrossingUse"
  "kPedestrianUse"
  "kPlatformConnectionUse"
  "kRailFerryUse"
  "kRailUse"
  "kRampUse"
  "kRestAreaUse"
  "kRoadUse"
  "kServiceAreaUse"
  "kServiceRoadUse"
  "kSidewalkUse"
  "kStepsUse"
  "kTrackUse"
  "kTransitConnectionUse"
  "kTurnChannelUse";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Use_entries[] = {
  { {TripLeg_Use_names + 0, 9}, 5 },
  { {TripLeg_Use_names + 9, 13}, 29 },
  { {TripLeg_Use_names + 22, 7}, 51 },
  { {TripLeg_Use_names + 29, 16}, 43 },
  { {TripLeg_Use_names + 45, 12}, 9 },
  { {TripLeg_Use_names + 57, 12}, 20 },
  { {TripLeg_Use_names + 69, 13}, 8 },
  { {TripLeg_Use_names + 82, 12}, 4 },
  { {TripLeg_Use_names + 94, 20}, 52 },
  { {TripLeg_Use_names + 114, 12}, 33 },
  { {TripLeg_Use_names + 126, 19}, 7 },
  { {TripLeg_Use_names + 145, 13}, 34 },
  { {TripLeg_Use_names + 158, 9}, 41 },
  { {TripLeg_Use_names + 167, 11}, 25 },
  { {TripLeg_Use_names + 178, 16}, 10 },
  { {TripLeg_Use_names + 194, 16}, 21 },
  { {TripLeg_Use_names + 210, 9}, 40 },
  { {TripLeg_Use_names + 219, 16}, 6 },
  { {TripLeg_Use_names + 235, 8}, 27 },
  { {TripLeg_Use_names + 243, 22}, 32 },
  { {TripLeg_Use_names + 265, 14}, 28 },
  { {TripLeg_Use_names + 279, 22}, 53 },
  { {TripLeg_Use_names + 301, 13}, 42 },
  { {TripLeg_Use_names + 314, 8}, 50 },
  { {TripLeg_Use_names + 322, 8}, 1 },
  { {TripLeg_Use_names + 330, 12}, 30 },
  { {TripLeg_Use_names + 342, 8}, 0 },
  { {TripLeg_Use_names + 350, 15}, 31 },
  { {TripLeg_Use_names + 365, 15}, 11 },
  { {TripLeg_Use_names + 380, 12}, 24 },
  { {TripLeg_Use_names + 392, 9}, 26 },
  { {TripLeg_Use_names + 401, 9}, 3 },
  { {TripLeg_Use_names + 410, 21}, 54 },
  { {TripLeg_Use_names + 431, 15}, 2 },
};

static const int TripLeg_Use_entries_by_number[] = {
  26, // 0 -> kRoadUse
  24, // 1 -> kRampUse
  33, // 2 -> kTurnChannelUse
  31, // 3 -> kTrackUse
  7, // 4 -> kDrivewayUse
  0, // 5 -> kAlleyUse
  17, // 6 -> kParkingAisleUse
  10, // 7 -> kEmergencyAccessUse
  6, // 8 -> kDriveThruUse
  4, // 9 -> kCuldesacUse
  14, // 10 -> kLivingStreetUse
  28, // 11 -> kServiceRoadUse
  5, // 20 -> kCyclewayUse
  15, // 21 -> kMountainBikeUse
  29, // 24 -> kSidewalkUse
  13, // 25 -> kFootwayUse
  30, // 26 -> kStepsUse
  18, // 27 -> kPathUse
  20, // 28 -> kPedestrianUse
  1, // 29 -> kBridlewayUse
  25, // 30 -> kRestAreaUse
  27, // 31 -> kServiceAreaUse
  19, // 32 -> kPedestrianCrossingUse
  9, // 33 -> kElevatorUse
  11, // 34 -> kEscalatorUse
  16, // 40 -> kOtherUse
  12, // 41 -> kFerryUse
  22, // 42 -> kRailFerryUse
  3, // 43 -> kConstructionUse
  23, // 50 -> kRailUse
  2, // 51 -> kBusUse
  8, // 52 -> kEgressConnectionUse
  21, // 53 -> kPlatformConnectionUse
  32, // 54 -> kTransitConnectionUse
};

const std::string& TripLeg_Use_Name(
    TripLeg_Use value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Use_entries,
          TripLeg_Use_entries_by_number,
          34, TripLeg_Use_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Use_entries,
      TripLeg_Use_entries_by_number,
      34, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Use_strings[idx].get();
}
bool TripLeg_Use_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Use* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Use_entries, 34, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Use>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Use TripLeg::kRoadUse;
constexpr TripLeg_Use TripLeg::kRampUse;
constexpr TripLeg_Use TripLeg::kTurnChannelUse;
constexpr TripLeg_Use TripLeg::kTrackUse;
constexpr TripLeg_Use TripLeg::kDrivewayUse;
constexpr TripLeg_Use TripLeg::kAlleyUse;
constexpr TripLeg_Use TripLeg::kParkingAisleUse;
constexpr TripLeg_Use TripLeg::kEmergencyAccessUse;
constexpr TripLeg_Use TripLeg::kDriveThruUse;
constexpr TripLeg_Use TripLeg::kCuldesacUse;
constexpr TripLeg_Use TripLeg::kLivingStreetUse;
constexpr TripLeg_Use TripLeg::kServiceRoadUse;
constexpr TripLeg_Use TripLeg::kCyclewayUse;
constexpr TripLeg_Use TripLeg::kMountainBikeUse;
constexpr TripLeg_Use TripLeg::kSidewalkUse;
constexpr TripLeg_Use TripLeg::kFootwayUse;
constexpr TripLeg_Use TripLeg::kStepsUse;
constexpr TripLeg_Use TripLeg::kPathUse;
constexpr TripLeg_Use TripLeg::kPedestrianUse;
constexpr TripLeg_Use TripLeg::kBridlewayUse;
constexpr TripLeg_Use TripLeg::kPedestrianCrossingUse;
constexpr TripLeg_Use TripLeg::kElevatorUse;
constexpr TripLeg_Use TripLeg::kEscalatorUse;
constexpr TripLeg_Use TripLeg::kRestAreaUse;
constexpr TripLeg_Use TripLeg::kServiceAreaUse;
constexpr TripLeg_Use TripLeg::kOtherUse;
constexpr TripLeg_Use TripLeg::kFerryUse;
constexpr TripLeg_Use TripLeg::kRailFerryUse;
constexpr TripLeg_Use TripLeg::kConstructionUse;
constexpr TripLeg_Use TripLeg::kRailUse;
constexpr TripLeg_Use TripLeg::kBusUse;
constexpr TripLeg_Use TripLeg::kEgressConnectionUse;
constexpr TripLeg_Use TripLeg::kPlatformConnectionUse;
constexpr TripLeg_Use TripLeg::kTransitConnectionUse;
constexpr TripLeg_Use TripLeg::Use_MIN;
constexpr TripLeg_Use TripLeg::Use_MAX;
constexpr int TripLeg::Use_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Surface_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Surface_strings[8] = {};

static const char TripLeg_Surface_names[] =
  "kCompacted"
  "kDirt"
  "kGravel"
  "kImpassable"
  "kPath"
  "kPaved"
  "kPavedRough"
  "kPavedSmooth";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Surface_entries[] = {
  { {TripLeg_Surface_names + 0, 10}, 3 },
  { {TripLeg_Surface_names + 10, 5}, 4 },
  { {TripLeg_Surface_names + 15, 7}, 5 },
  { {TripLeg_Surface_names + 22, 11}, 7 },
  { {TripLeg_Surface_names + 33, 5}, 6 },
  { {TripLeg_Surface_names + 38, 6}, 1 },
  { {TripLeg_Surface_names + 44, 11}, 2 },
  { {TripLeg_Surface_names + 55, 12}, 0 },
};

static const int TripLeg_Surface_entries_by_number[] = {
  7, // 0 -> kPavedSmooth
  5, // 1 -> kPaved
  6, // 2 -> kPavedRough
  0, // 3 -> kCompacted
  1, // 4 -> kDirt
  2, // 5 -> kGravel
  4, // 6 -> kPath
  3, // 7 -> kImpassable
};

const std::string& TripLeg_Surface_Name(
    TripLeg_Surface value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Surface_entries,
          TripLeg_Surface_entries_by_number,
          8, TripLeg_Surface_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Surface_entries,
      TripLeg_Surface_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Surface_strings[idx].get();
}
bool TripLeg_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Surface* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Surface_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Surface>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Surface TripLeg::kPavedSmooth;
constexpr TripLeg_Surface TripLeg::kPaved;
constexpr TripLeg_Surface TripLeg::kPavedRough;
constexpr TripLeg_Surface TripLeg::kCompacted;
constexpr TripLeg_Surface TripLeg::kDirt;
constexpr TripLeg_Surface TripLeg::kGravel;
constexpr TripLeg_Surface TripLeg::kPath;
constexpr TripLeg_Surface TripLeg::kImpassable;
constexpr TripLeg_Surface TripLeg::Surface_MIN;
constexpr TripLeg_Surface TripLeg::Surface_MAX;
constexpr int TripLeg::Surface_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_CycleLane_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_CycleLane_strings[4] = {};

static const char TripLeg_CycleLane_names[] =
  "kDedicated"
  "kNoCycleLane"
  "kSeparated"
  "kShared";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_CycleLane_entries[] = {
  { {TripLeg_CycleLane_names + 0, 10}, 2 },
  { {TripLeg_CycleLane_names + 10, 12}, 0 },
  { {TripLeg_CycleLane_names + 22, 10}, 3 },
  { {TripLeg_CycleLane_names + 32, 7}, 1 },
};

static const int TripLeg_CycleLane_entries_by_number[] = {
  1, // 0 -> kNoCycleLane
  3, // 1 -> kShared
  0, // 2 -> kDedicated
  2, // 3 -> kSeparated
};

const std::string& TripLeg_CycleLane_Name(
    TripLeg_CycleLane value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_CycleLane_entries,
          TripLeg_CycleLane_entries_by_number,
          4, TripLeg_CycleLane_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_CycleLane_entries,
      TripLeg_CycleLane_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_CycleLane_strings[idx].get();
}
bool TripLeg_CycleLane_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_CycleLane* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_CycleLane_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_CycleLane>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_CycleLane TripLeg::kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg::kShared;
constexpr TripLeg_CycleLane TripLeg::kDedicated;
constexpr TripLeg_CycleLane TripLeg::kSeparated;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MIN;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MAX;
constexpr int TripLeg::CycleLane_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_SacScale_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_SacScale_strings[7] = {};

static const char TripLeg_SacScale_names[] =
  "kAlpineHiking"
  "kDemandingAlpineHiking"
  "kDemandingMountainHiking"
  "kDifficultAlpineHiking"
  "kHiking"
  "kMountainHiking"
  "kNoSacScale";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_SacScale_entries[] = {
  { {TripLeg_SacScale_names + 0, 13}, 4 },
  { {TripLeg_SacScale_names + 13, 22}, 5 },
  { {TripLeg_SacScale_names + 35, 24}, 3 },
  { {TripLeg_SacScale_names + 59, 22}, 6 },
  { {TripLeg_SacScale_names + 81, 7}, 1 },
  { {TripLeg_SacScale_names + 88, 15}, 2 },
  { {TripLeg_SacScale_names + 103, 11}, 0 },
};

static const int TripLeg_SacScale_entries_by_number[] = {
  6, // 0 -> kNoSacScale
  4, // 1 -> kHiking
  5, // 2 -> kMountainHiking
  2, // 3 -> kDemandingMountainHiking
  0, // 4 -> kAlpineHiking
  1, // 5 -> kDemandingAlpineHiking
  3, // 6 -> kDifficultAlpineHiking
};

const std::string& TripLeg_SacScale_Name(
    TripLeg_SacScale value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_SacScale_entries,
          TripLeg_SacScale_entries_by_number,
          7, TripLeg_SacScale_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_SacScale_entries,
      TripLeg_SacScale_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_SacScale_strings[idx].get();
}
bool TripLeg_SacScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_SacScale* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_SacScale_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_SacScale>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_SacScale TripLeg::kNoSacScale;
constexpr TripLeg_SacScale TripLeg::kHiking;
constexpr TripLeg_SacScale TripLeg::kMountainHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingMountainHiking;
constexpr TripLeg_SacScale TripLeg::kAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
constexpr TripLeg_SacScale TripLeg::SacScale_MIN;
constexpr TripLeg_SacScale TripLeg::SacScale_MAX;
constexpr int TripLeg::SacScale_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Sidewalk_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Sidewalk_strings[4] = {};

static const char TripLeg_Sidewalk_names[] =
  "kBothSides"
  "kLeft"
  "kNoSidewalk"
  "kRight";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Sidewalk_entries[] = {
  { {TripLeg_Sidewalk_names + 0, 10}, 3 },
  { {TripLeg_Sidewalk_names + 10, 5}, 1 },
  { {TripLeg_Sidewalk_names + 15, 11}, 0 },
  { {TripLeg_Sidewalk_names + 26, 6}, 2 },
};

static const int TripLeg_Sidewalk_entries_by_number[] = {
  2, // 0 -> kNoSidewalk
  1, // 1 -> kLeft
  3, // 2 -> kRight
  0, // 3 -> kBothSides
};

const std::string& TripLeg_Sidewalk_Name(
    TripLeg_Sidewalk value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Sidewalk_entries,
          TripLeg_Sidewalk_entries_by_number,
          4, TripLeg_Sidewalk_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Sidewalk_entries,
      TripLeg_Sidewalk_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Sidewalk_strings[idx].get();
}
bool TripLeg_Sidewalk_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Sidewalk* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Sidewalk_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Sidewalk>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Sidewalk TripLeg::kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg::kLeft;
constexpr TripLeg_Sidewalk TripLeg::kRight;
constexpr TripLeg_Sidewalk TripLeg::kBothSides;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
constexpr int TripLeg::Sidewalk_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class TripLeg_LaneConnectivity::_Internal {
 public:
};

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.LaneConnectivity)
}
TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_LaneConnectivity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_lanes_){}
    , decltype(_impl_.to_lanes_){}
    , decltype(_impl_.from_way_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.from_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_lanes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_from_lanes().empty()) {
    _this->_impl_.from_lanes_.Set(from._internal_from_lanes(), 
      _this->GetArenaForAllocation());
  }
  _impl_.to_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_lanes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_to_lanes().empty()) {
    _this->_impl_.to_lanes_.Set(from._internal_to_lanes(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.from_way_id_ = from._impl_.from_way_id_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}

inline void TripLeg_LaneConnectivity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_lanes_){}
    , decltype(_impl_.to_lanes_){}
    , decltype(_impl_.from_way_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.from_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_lanes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.to_lanes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_lanes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_LaneConnectivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.from_lanes_.Destroy();
  _impl_.to_lanes_.Destroy();
}

void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.from_lanes_.ClearToEmpty();
  _impl_.to_lanes_.ClearToEmpty();
  _impl_.from_way_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_LaneConnectivity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 from_way_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.from_way_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string from_lanes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_from_lanes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string to_lanes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_to_lanes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_LaneConnectivity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.LaneConnectivity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 from_way_id = 1;
  if (this->_internal_from_way_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_from_way_id(), target);
  }

  // string from_lanes = 2;
  if (!this->_internal_from_lanes().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_from_lanes().data(), static_cast<int>(this->_internal_from_lanes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.from_lanes");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_from_lanes(), target);
  }

  // string to_lanes = 3;
  if (!this->_internal_to_lanes().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_to_lanes().data(), static_cast<int>(this->_internal_to_lanes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.to_lanes");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_to_lanes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.LaneConnectivity)
  return target;
}

size_t TripLeg_LaneConnectivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string from_lanes = 2;
  if (!this->_internal_from_lanes().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_from_lanes());
  }

  // string to_lanes = 3;
  if (!this->_internal_to_lanes().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_to_lanes());
  }

  // uint64 from_way_id = 1;
  if (this->_internal_from_way_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from_way_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_LaneConnectivity*>(
      &from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
  TripLeg_LaneConnectivity* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_from_lanes().empty()) {
    _this->_internal_set_from_lanes(from._internal_from_lanes());
  }
  if (!from._internal_to_lanes().empty()) {
    _this->_internal_set_to_lanes(from._internal_to_lanes());
  }
  if (from._internal_from_way_id() != 0) {
    _this->_internal_set_from_way_id(from._internal_from_way_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_LaneConnectivity::IsInitialized() const {
  return true;
}

void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_lanes_, lhs_arena,
      &other->_impl_.from_lanes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.to_lanes_, lhs_arena,
      &other->_impl_.to_lanes_, rhs_arena
  );
  swap(_impl_.from_way_id_, other->_impl_.from_way_id_);
}

std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}


// ===================================================================

class TripLeg_TrafficSegment::_Internal {
 public:
};

TripLeg_TrafficSegment::TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TrafficSegment)
}
TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_TrafficSegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){}
    , decltype(_impl_.begin_percent_){}
    , decltype(_impl_.end_percent_){}
    , decltype(_impl_.starts_segment_){}
    , decltype(_impl_.ends_segment_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.segment_id_, &from._impl_.segment_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ends_segment_) -
    reinterpret_cast<char*>(&_impl_.segment_id_)) + sizeof(_impl_.ends_segment_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TrafficSegment)
}

inline void TripLeg_TrafficSegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){uint64_t{0u}}
    , decltype(_impl_.begin_percent_){0}
    , decltype(_impl_.end_percent_){0}
    , decltype(_impl_.starts_segment_){false}
    , decltype(_impl_.ends_segment_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_TrafficSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.segment_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ends_segment_) -
      reinterpret_cast<char*>(&_impl_.segment_id_)) + sizeof(_impl_.ends_segment_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_TrafficSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 segment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.segment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float begin_percent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.begin_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_percent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.end_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool starts_segment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.starts_segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ends_segment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.ends_segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_TrafficSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TrafficSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 segment_id = 1;
  if (this->_internal_segment_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_segment_id(), target);
  }

  // float begin_percent = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_begin_percent = this->_internal_begin_percent();
  uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_begin_percent(), target);
  }

  // float end_percent = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_percent = this->_internal_end_percent();
  uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_end_percent(), target);
  }

  // bool starts_segment = 4;
  if (this->_internal_starts_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_starts_segment(), target);
  }

  // bool ends_segment = 5;
  if (this->_internal_ends_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_ends_segment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TrafficSegment)
  return target;
}

size_t TripLeg_TrafficSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 segment_id = 1;
  if (this->_internal_segment_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_segment_id());
  }

  // float begin_percent = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_begin_percent = this->_internal_begin_percent();
  uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    total_size += 1 + 4;
  }

  // float end_percent = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_percent = this->_internal_end_percent();
  uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    total_size += 1 + 4;
  }

  // bool starts_segment = 4;
  if (this->_internal_starts_segment() != 0) {
    total_size += 1 + 1;
  }

  // bool ends_segment = 5;
  if (this->_internal_ends_segment() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_TrafficSegment*>(
      &from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
  TripLeg_TrafficSegment* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_segment_id() != 0) {
    _this->_internal_set_segment_id(from._internal_segment_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_begin_percent = from._internal_begin_percent();
  uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    _this->_internal_set_begin_percent(from._internal_begin_percent());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_percent = from._internal_end_percent();
  uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    _this->_internal_set_end_percent(from._internal_end_percent());
  }
  if (from._internal_starts_segment() != 0) {
    _this->_internal_set_starts_segment(from._internal_starts_segment());
  }
  if (from._internal_ends_segment() != 0) {
    _this->_internal_set_ends_segment(from._internal_ends_segment());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TrafficSegment::IsInitialized() const {
  return true;
}

void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_)
      + sizeof(TripLeg_TrafficSegment::_impl_.ends_segment_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_)>(
          reinterpret_cast<char*>(&_impl_.segment_id_),
          reinterpret_cast<char*>(&other->_impl_.segment_id_));
}

std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}


// ===================================================================

class TripLeg_Restriction::_Internal {
 public:
};

TripLeg_Restriction::TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Restriction)
}
TripLeg_Restriction::TripLeg_Restriction(const TripLeg_Restriction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Restriction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Restriction)
}

inline void TripLeg_Restriction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Restriction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Restriction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Restriction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Restriction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Restriction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Restriction)
  return target;
}

size_t TripLeg_Restriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Restriction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Restriction*>(
      &from));
}

void TripLeg_Restriction::MergeFrom(const TripLeg_Restriction& from) {
  TripLeg_Restriction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Restriction::IsInitialized() const {
  return true;
}

void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string TripLeg_Restriction::GetTypeName() const {
  return "valhalla.TripLeg.Restriction";
}


// ===================================================================

class TripLeg_Edge::_Internal {
 public:
  static const ::valhalla::TripSign& sign(const TripLeg_Edge* msg);
  static const ::valhalla::TransitRouteInfo& transit_route_info(const TripLeg_Edge* msg);
  static const ::valhalla::TripLeg_Restriction& restriction(const TripLeg_Edge* msg);
};

const ::valhalla::TripSign&
TripLeg_Edge::_Internal::sign(const TripLeg_Edge* msg) {
  return *msg->_impl_.sign_;
}
const ::valhalla::TransitRouteInfo&
TripLeg_Edge::_Internal::transit_route_info(const TripLeg_Edge* msg) {
  return *msg->_impl_.transit_route_info_;
}
const ::valhalla::TripLeg_Restriction&
TripLeg_Edge::_Internal::restriction(const TripLeg_Edge* msg) {
  return *msg->_impl_.restriction_;
}
void TripLeg_Edge::clear_name() {
  _impl_.name_.Clear();
}
void TripLeg_Edge::clear_sign() {
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
}
void TripLeg_Edge::clear_transit_route_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_route_info_ != nullptr) {
    delete _impl_.transit_route_info_;
  }
  _impl_.transit_route_info_ = nullptr;
}
void TripLeg_Edge::clear_turn_lanes() {
  _impl_.turn_lanes_.Clear();
}
void TripLeg_Edge::clear_tagged_value() {
  _impl_.tagged_value_.Clear();
}
TripLeg_Edge::TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge)
}
TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Edge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){from._impl_.name_}
    , decltype(_impl_.lane_connectivity_){from._impl_.lane_connectivity_}
    , decltype(_impl_.traffic_segment_){from._impl_.traffic_segment_}
    , decltype(_impl_.turn_lanes_){from._impl_.turn_lanes_}
    , decltype(_impl_.tagged_value_){from._impl_.tagged_value_}
    , decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.transit_route_info_){nullptr}
    , decltype(_impl_.restriction_){nullptr}
    , decltype(_impl_.length_km_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.road_class_){}
    , decltype(_impl_.begin_heading_){}
    , decltype(_impl_.end_heading_){}
    , decltype(_impl_.begin_shape_index_){}
    , decltype(_impl_.end_shape_index_){}
    , decltype(_impl_.traversability_){}
    , decltype(_impl_.use_){}
    , decltype(_impl_.toll_){}
    , decltype(_impl_.unpaved_){}
    , decltype(_impl_.tunnel_){}
    , decltype(_impl_.bridge_){}
    , decltype(_impl_.surface_){}
    , decltype(_impl_.travel_mode_){}
    , decltype(_impl_.roundabout_){}
    , decltype(_impl_.internal_intersection_){}
    , decltype(_impl_.drive_on_left_){}
    , decltype(_impl_.bicycle_network_){}
    , decltype(_impl_.vehicle_type_){}
    , decltype(_impl_.pedestrian_type_){}
    , decltype(_impl_.bicycle_type_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.transit_type_){}
    , decltype(_impl_.weighted_grade_){}
    , decltype(_impl_.way_id_){}
    , decltype(_impl_.max_upward_grade_){}
    , decltype(_impl_.max_downward_grade_){}
    , decltype(_impl_.lane_count_){}
    , decltype(_impl_.cycle_lane_){}
    , decltype(_impl_.sidewalk_){}
    , decltype(_impl_.density_){}
    , decltype(_impl_.speed_limit_){}
    , decltype(_impl_.truck_speed_){}
    , decltype(_impl_.mean_elevation_){}
    , decltype(_impl_.truck_route_){}
    , decltype(_impl_.has_time_restrictions_){}
    , decltype(_impl_.destination_only_){}
    , decltype(_impl_.is_urban_){}
    , decltype(_impl_.default_speed_){}
    , decltype(_impl_.source_along_edge_){}
    , decltype(_impl_.target_along_edge_){}
    , decltype(_impl_.sac_scale_){}
    , decltype(_impl_.shoulder_){}
    , decltype(_impl_.indoor_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    _this->_impl_.sign_ = new ::valhalla::TripSign(*from._impl_.sign_);
  }
  if (from._internal_has_transit_route_info()) {
    _this->_impl_.transit_route_info_ = new ::valhalla::TransitRouteInfo(*from._impl_.transit_route_info_);
  }
  if (from._internal_has_restriction()) {
    _this->_impl_.restriction_ = new ::valhalla::TripLeg_Restriction(*from._impl_.restriction_);
  }
  ::memcpy(&_impl_.length_km_, &from._impl_.length_km_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.indoor_) -
    reinterpret_cast<char*>(&_impl_.length_km_)) + sizeof(_impl_.indoor_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}

inline void TripLeg_Edge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){arena}
    , decltype(_impl_.lane_connectivity_){arena}
    , decltype(_impl_.traffic_segment_){arena}
    , decltype(_impl_.turn_lanes_){arena}
    , decltype(_impl_.tagged_value_){arena}
    , decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.transit_route_info_){nullptr}
    , decltype(_impl_.restriction_){nullptr}
    , decltype(_impl_.length_km_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.road_class_){0}
    , decltype(_impl_.begin_heading_){0u}
    , decltype(_impl_.end_heading_){0u}
    , decltype(_impl_.begin_shape_index_){0u}
    , decltype(_impl_.end_shape_index_){0u}
    , decltype(_impl_.traversability_){0}
    , decltype(_impl_.use_){0}
    , decltype(_impl_.toll_){false}
    , decltype(_impl_.unpaved_){false}
    , decltype(_impl_.tunnel_){false}
    , decltype(_impl_.bridge_){false}
    , decltype(_impl_.surface_){0}
    , decltype(_impl_.travel_mode_){0}
    , decltype(_impl_.roundabout_){false}
    , decltype(_impl_.internal_intersection_){false}
    , decltype(_impl_.drive_on_left_){false}
    , decltype(_impl_.bicycle_network_){false}
    , decltype(_impl_.vehicle_type_){0}
    , decltype(_impl_.pedestrian_type_){0}
    , decltype(_impl_.bicycle_type_){0}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.transit_type_){0}
    , decltype(_impl_.weighted_grade_){0}
    , decltype(_impl_.way_id_){uint64_t{0u}}
    , decltype(_impl_.max_upward_grade_){0}
    , decltype(_impl_.max_downward_grade_){0}
    , decltype(_impl_.lane_count_){0u}
    , decltype(_impl_.cycle_lane_){0}
    , decltype(_impl_.sidewalk_){0}
    , decltype(_impl_.density_){0u}
    , decltype(_impl_.speed_limit_){0u}
    , decltype(_impl_.truck_speed_){0}
    , decltype(_impl_.mean_elevation_){0}
    , decltype(_impl_.truck_route_){false}
    , decltype(_impl_.has_time_restrictions_){false}
    , decltype(_impl_.destination_only_){false}
    , decltype(_impl_.is_urban_){false}
    , decltype(_impl_.default_speed_){0}
    , decltype(_impl_.source_along_edge_){0}
    , decltype(_impl_.target_along_edge_){0}
    , decltype(_impl_.sac_scale_){0}
    , decltype(_impl_.shoulder_){false}
    , decltype(_impl_.indoor_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Edge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.~RepeatedPtrField();
  _impl_.lane_connectivity_.~RepeatedPtrField();
  _impl_.traffic_segment_.~RepeatedPtrField();
  _impl_.turn_lanes_.~RepeatedPtrField();
  _impl_.tagged_value_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.sign_;
  if (this != internal_default_instance()) delete _impl_.transit_route_info_;
  if (this != internal_default_instance()) delete _impl_.restriction_;
}

void TripLeg_Edge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.Clear();
  _impl_.lane_connectivity_.Clear();
  _impl_.traffic_segment_.Clear();
  _impl_.turn_lanes_.Clear();
  _impl_.tagged_value_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_route_info_ != nullptr) {
    delete _impl_.transit_route_info_;
  }
  _impl_.transit_route_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.restriction_ != nullptr) {
    delete _impl_.restriction_;
  }
  _impl_.restriction_ = nullptr;
  ::memset(&_impl_.length_km_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.indoor_) -
      reinterpret_cast<char*>(&_impl_.length_km_)) + sizeof(_impl_.indoor_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Edge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.StreetName name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_name(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float length_km = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.length_km_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.RoadClass road_class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_heading = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.begin_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_heading = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.end_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_shape_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability traversability = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_traversability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Use use = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
        } else
          goto handle_unusual;
        continue;
      // bool toll = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.toll_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool unpaved = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.unpaved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool tunnel = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.tunnel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bridge = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.bridge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool roundabout = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.roundabout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool internal_intersection = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.internal_intersection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool drive_on_left = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.drive_on_left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Surface surface = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_surface(static_cast<::valhalla::TripLeg_Surface>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripSign sign = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TravelMode travel_mode = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_travel_mode(static_cast<::valhalla::TravelMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.VehicleType vehicle_type = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_vehicle_type(static_cast<::valhalla::VehicleType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.PedestrianType pedestrian_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pedestrian_type(static_cast<::valhalla::PedestrianType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BicycleType bicycle_type = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_bicycle_type(static_cast<::valhalla::BicycleType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitType transit_type = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_transit_type(static_cast<::valhalla::TransitType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitRouteInfo transit_route_info = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_route_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 id = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 way_id = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _impl_.way_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float weighted_grade = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 229)) {
          _impl_.weighted_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 max_upward_grade = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _impl_.max_upward_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_downward_grade = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _impl_.max_downward_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 lane_count = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _impl_.lane_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.CycleLane cycle_lane = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cycle_lane(static_cast<::valhalla::TripLeg_CycleLane>(val));
        } else
          goto handle_unusual;
        continue;
      // bool bicycle_network = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.bicycle_network_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Sidewalk sidewalk = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sidewalk(static_cast<::valhalla::TripLeg_Sidewalk>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 density = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.density_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 speed_limit = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.speed_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float truck_speed = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.truck_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool truck_route = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.truck_route_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_lane_connectivity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<314>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 mean_elevation = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.mean_elevation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_traffic_segment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<330>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TurnLane turn_lanes = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_turn_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<338>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool has_time_restrictions = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.has_time_restrictions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float default_speed = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.default_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Restriction restriction = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_restriction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool destination_only = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.destination_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_urban = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.is_urban_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TaggedValue tagged_value = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tagged_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<386>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float source_along_edge = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _impl_.source_along_edge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float target_along_edge = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _impl_.target_along_edge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.SacScale sac_scale = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sac_scale(static_cast<::valhalla::TripLeg_SacScale>(val));
        } else
          goto handle_unusual;
        continue;
      // bool shoulder = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.shoulder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool indoor = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.indoor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Edge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_name_size()); i < n; i++) {
    const auto& repfield = this->_internal_name(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float length_km = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_km = this->_internal_length_km();
  uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_length_km(), target);
  }

  // float speed = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_speed(), target);
  }

  // .valhalla.RoadClass road_class = 4;
  if (this->_internal_road_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_road_class(), target);
  }

  // uint32 begin_heading = 5;
  if (this->_internal_begin_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_begin_heading(), target);
  }

  // uint32 end_heading = 6;
  if (this->_internal_end_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_end_heading(), target);
  }

  // uint32 begin_shape_index = 7;
  if (this->_internal_begin_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 8;
  if (this->_internal_end_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_end_shape_index(), target);
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (this->_internal_traversability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_traversability(), target);
  }

  // .valhalla.TripLeg.Use use = 10;
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_use(), target);
  }

  // bool toll = 11;
  if (this->_internal_toll() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_toll(), target);
  }

  // bool unpaved = 12;
  if (this->_internal_unpaved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_unpaved(), target);
  }

  // bool tunnel = 13;
  if (this->_internal_tunnel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_tunnel(), target);
  }

  // bool bridge = 14;
  if (this->_internal_bridge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_bridge(), target);
  }

  // bool roundabout = 15;
  if (this->_internal_roundabout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_roundabout(), target);
  }

  // bool internal_intersection = 16;
  if (this->_internal_internal_intersection() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_internal_intersection(), target);
  }

  // bool drive_on_left = 17;
  if (this->_internal_drive_on_left() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_drive_on_left(), target);
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (this->_internal_surface() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_surface(), target);
  }

  // .valhalla.TripSign sign = 19;
  if (this->_internal_has_sign()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::sign(this),
        _Internal::sign(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (this->_internal_travel_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_travel_mode(), target);
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (this->_internal_vehicle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      21, this->_internal_vehicle_type(), target);
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (this->_internal_pedestrian_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_pedestrian_type(), target);
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (this->_internal_bicycle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      23, this->_internal_bicycle_type(), target);
  }

  // .valhalla.TransitType transit_type = 24;
  if (this->_internal_transit_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      24, this->_internal_transit_type(), target);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->_internal_has_transit_route_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::transit_route_info(this),
        _Internal::transit_route_info(this).GetCachedSize(), target, stream);
  }

  // uint64 id = 26;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(26, this->_internal_id(), target);
  }

  // uint64 way_id = 27;
  if (this->_internal_way_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(27, this->_internal_way_id(), target);
  }

  // float weighted_grade = 28;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_weighted_grade = this->_internal_weighted_grade();
  uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(28, this->_internal_weighted_grade(), target);
  }

  // int32 max_upward_grade = 29;
  if (this->_internal_max_upward_grade() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_max_upward_grade(), target);
  }

  // int32 max_downward_grade = 30;
  if (this->_internal_max_downward_grade() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(30, this->_internal_max_downward_grade(), target);
  }

  // uint32 lane_count = 31;
  if (this->_internal_lane_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_lane_count(), target);
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (this->_internal_cycle_lane() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      32, this->_internal_cycle_lane(), target);
  }

  // bool bicycle_network = 33;
  if (this->_internal_bicycle_network() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(33, this->_internal_bicycle_network(), target);
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (this->_internal_sidewalk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      34, this->_internal_sidewalk(), target);
  }

  // uint32 density = 35;
  if (this->_internal_density() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_density(), target);
  }

  // uint32 speed_limit = 36;
  if (this->_internal_speed_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_speed_limit(), target);
  }

  // float truck_speed = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_truck_speed = this->_internal_truck_speed();
  uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(37, this->_internal_truck_speed(), target);
  }

  // bool truck_route = 38;
  if (this->_internal_truck_route() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(38, this->_internal_truck_route(), target);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lane_connectivity_size()); i < n; i++) {
    const auto& repfield = this->_internal_lane_connectivity(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(39, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 mean_elevation = 40;
  if (this->_internal_mean_elevation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(40, this->_internal_mean_elevation(), target);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_traffic_segment_size()); i < n; i++) {
    const auto& repfield = this->_internal_traffic_segment(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(41, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_turn_lanes_size()); i < n; i++) {
    const auto& repfield = this->_internal_turn_lanes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(42, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool has_time_restrictions = 43;
  if (this->_internal_has_time_restrictions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(43, this->_internal_has_time_restrictions(), target);
  }

  // float default_speed = 44;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_speed = this->_internal_default_speed();
  uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(44, this->_internal_default_speed(), target);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (this->_internal_has_restriction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(45, _Internal::restriction(this),
        _Internal::restriction(this).GetCachedSize(), target, stream);
  }

  // bool destination_only = 46;
  if (this->_internal_destination_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(46, this->_internal_destination_only(), target);
  }

  // bool is_urban = 47;
  if (this->_internal_is_urban() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(47, this->_internal_is_urban(), target);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tagged_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_tagged_value(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(48, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float source_along_edge = 49;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_source_along_edge = this->_internal_source_along_edge();
  uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(49, this->_internal_source_along_edge(), target);
  }

  // float target_along_edge = 50;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_target_along_edge = this->_internal_target_along_edge();
  uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(50, this->_internal_target_along_edge(), target);
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (this->_internal_sac_scale() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      51, this->_internal_sac_scale(), target);
  }

  // bool shoulder = 52;
  if (this->_internal_shoulder() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(52, this->_internal_shoulder(), target);
  }

  // bool indoor = 53;
  if (this->_internal_indoor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(53, this->_internal_indoor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge)
  return target;
}

size_t TripLeg_Edge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  total_size += 1UL * this->_internal_name_size();
  for (const auto& msg : this->_impl_.name_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2UL * this->_internal_lane_connectivity_size();
  for (const auto& msg : this->_impl_.lane_connectivity_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2UL * this->_internal_traffic_segment_size();
  for (const auto& msg : this->_impl_.traffic_segment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2UL * this->_internal_turn_lanes_size();
  for (const auto& msg : this->_impl_.turn_lanes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  total_size += 2UL * this->_internal_tagged_value_size();
  for (const auto& msg : this->_impl_.tagged_value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .valhalla.TripSign sign = 19;
  if (this->_internal_has_sign()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sign_);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->_internal_has_transit_route_info()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_route_info_);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (this->_internal_has_restriction()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.restriction_);
  }

  // float length_km = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_km = this->_internal_length_km();
  uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    total_size += 1 + 4;
  }

  // float speed = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // .valhalla.RoadClass road_class = 4;
  if (this->_internal_road_class() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_road_class());
  }

  // uint32 begin_heading = 5;
  if (this->_internal_begin_heading() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_heading());
  }

  // uint32 end_heading = 6;
  if (this->_internal_end_heading() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_heading());
  }

  // uint32 begin_shape_index = 7;
  if (this->_internal_begin_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
  }

  // uint32 end_shape_index = 8;
  if (this->_internal_end_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (this->_internal_traversability() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_traversability());
  }

  // .valhalla.TripLeg.Use use = 10;
  if (this->_internal_use() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
  }

  // bool toll = 11;
  if (this->_internal_toll() != 0) {
    total_size += 1 + 1;
  }

  // bool unpaved = 12;
  if (this->_internal_unpaved() != 0) {
    total_size += 1 + 1;
  }

  // bool tunnel = 13;
  if (this->_internal_tunnel() != 0) {
    total_size += 1 + 1;
  }

  // bool bridge = 14;
  if (this->_internal_bridge() != 0) {
    total_size += 1 + 1;
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (this->_internal_surface() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_surface());
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (this->_internal_travel_mode() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_travel_mode());
  }

  // bool roundabout = 15;
  if (this->_internal_roundabout() != 0) {
    total_size += 1 + 1;
  }

  // bool internal_intersection = 16;
  if (this->_internal_internal_intersection() != 0) {
    total_size += 2 + 1;
  }

  // bool drive_on_left = 17;
  if (this->_internal_drive_on_left() != 0) {
    total_size += 2 + 1;
  }

  // bool bicycle_network = 33;
  if (this->_internal_bicycle_network() != 0) {
    total_size += 2 + 1;
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (this->_internal_vehicle_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_vehicle_type());
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (this->_internal_pedestrian_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pedestrian_type());
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (this->_internal_bicycle_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_bicycle_type());
  }

  // uint64 id = 26;
  if (this->_internal_id() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_id());
  }

  // .valhalla.TransitType transit_type = 24;
  if (this->_internal_transit_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_transit_type());
  }

  // float weighted_grade = 28;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_weighted_grade = this->_internal_weighted_grade();
  uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    total_size += 2 + 4;
  }

  // uint64 way_id = 27;
  if (this->_internal_way_id() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_way_id());
  }

  // int32 max_upward_grade = 29;
  if (this->_internal_max_upward_grade() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_max_upward_grade());
  }

  // int32 max_downward_grade = 30;
  if (this->_internal_max_downward_grade() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_max_downward_grade());
  }

  // uint32 lane_count = 31;
  if (this->_internal_lane_count() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_lane_count());
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (this->_internal_cycle_lane() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_cycle_lane());
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (this->_internal_sidewalk() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_sidewalk());
  }

  // uint32 density = 35;
  if (this->_internal_density() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_density());
  }

  // uint32 speed_limit = 36;
  if (this->_internal_speed_limit() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_speed_limit());
  }

  // float truck_speed = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_truck_speed = this->_internal_truck_speed();
  uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    total_size += 2 + 4;
  }

  // int32 mean_elevation = 40;
  if (this->_internal_mean_elevation() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_mean_elevation());
  }

  // bool truck_route = 38;
  if (this->_internal_truck_route() != 0) {
    total_size += 2 + 1;
  }

  // bool has_time_restrictions = 43;
  if (this->_internal_has_time_restrictions() != 0) {
    total_size += 2 + 1;
  }

  // bool destination_only = 46;
  if (this->_internal_destination_only() != 0) {
    total_size += 2 + 1;
  }

  // bool is_urban = 47;
  if (this->_internal_is_urban() != 0) {
    total_size += 2 + 1;
  }

  // float default_speed = 44;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_speed = this->_internal_default_speed();
  uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    total_size += 2 + 4;
  }

  // float source_along_edge = 49;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_source_along_edge = this->_internal_source_along_edge();
  uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    total_size += 2 + 4;
  }

  // float target_along_edge = 50;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_target_along_edge = this->_internal_target_along_edge();
  uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    total_size += 2 + 4;
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (this->_internal_sac_scale() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_sac_scale());
  }

  // bool shoulder = 52;
  if (this->_internal_shoulder() != 0) {
    total_size += 2 + 1;
  }

  // bool indoor = 53;
  if (this->_internal_indoor() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Edge*>(
      &from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
  TripLeg_Edge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.name_.MergeFrom(from._impl_.name_);
  _this->_impl_.lane_connectivity_.MergeFrom(from._impl_.lane_connectivity_);
  _this->_impl_.traffic_segment_.MergeFrom(from._impl_.traffic_segment_);
  _this->_impl_.turn_lanes_.MergeFrom(from._impl_.turn_lanes_);
  _this->_impl_.tagged_value_.MergeFrom(from._impl_.tagged_value_);
  if (from._internal_has_sign()) {
    _this->_internal_mutable_sign()->::valhalla::TripSign::MergeFrom(
        from._internal_sign());
  }
  if (from._internal_has_transit_route_info()) {
    _this->_internal_mutable_transit_route_info()->::valhalla::TransitRouteInfo::MergeFrom(
        from._internal_transit_route_info());
  }
  if (from._internal_has_restriction()) {
    _this->_internal_mutable_restriction()->::valhalla::TripLeg_Restriction::MergeFrom(
        from._internal_restriction());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_km = from._internal_length_km();
  uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    _this->_internal_set_length_km(from._internal_length_km());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_road_class() != 0) {
    _this->_internal_set_road_class(from._internal_road_class());
  }
  if (from._internal_begin_heading() != 0) {
    _this->_internal_set_begin_heading(from._internal_begin_heading());
  }
  if (from._internal_end_heading() != 0) {
    _this->_internal_set_end_heading(from._internal_end_heading());
  }
  if (from._internal_begin_shape_index() != 0) {
    _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
  }
  if (from._internal_end_shape_index() != 0) {
    _this->_internal_set_end_shape_index(from._internal_end_shape_index());
  }
  if (from._internal_traversability() != 0) {
    _this->_internal_set_traversability(from._internal_traversability());
  }
  if (from._internal_use() != 0) {
    _this->_internal_set_use(from._internal_use());
  }
  if (from._internal_toll() != 0) {
    _this->_internal_set_toll(from._internal_toll());
  }
  if (from._internal_unpaved() != 0) {
    _this->_internal_set_unpaved(from._internal_unpaved());
  }
  if (from._internal_tunnel() != 0) {
    _this->_internal_set_tunnel(from._internal_tunnel());
  }
  if (from._internal_bridge() != 0) {
    _this->_internal_set_bridge(from._internal_bridge());
  }
  if (from._internal_surface() != 0) {
    _this->_internal_set_surface(from._internal_surface());
  }
  if (from._internal_travel_mode() != 0) {
    _this->_internal_set_travel_mode(from._internal_travel_mode());
  }
  if (from._internal_roundabout() != 0) {
    _this->_internal_set_roundabout(from._internal_roundabout());
  }
  if (from._internal_internal_intersection() != 0) {
    _this->_internal_set_internal_intersection(from._internal_internal_intersection());
  }
  if (from._internal_drive_on_left() != 0) {
    _this->_internal_set_drive_on_left(from._internal_drive_on_left());
  }
  if (from._internal_bicycle_network() != 0) {
    _this->_internal_set_bicycle_network(from._internal_bicycle_network());
  }
  if (from._internal_vehicle_type() != 0) {
    _this->_internal_set_vehicle_type(from._internal_vehicle_type());
  }
  if (from._internal_pedestrian_type() != 0) {
    _this->_internal_set_pedestrian_type(from._internal_pedestrian_type());
  }
  if (from._internal_bicycle_type() != 0) {
    _this->_internal_set_bicycle_type(from._internal_bicycle_type());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_transit_type() != 0) {
    _this->_internal_set_transit_type(from._internal_transit_type());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_weighted_grade = from._internal_weighted_grade();
  uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    _this->_internal_set_weighted_grade(from._internal_weighted_grade());
  }
  if (from._internal_way_id() != 0) {
    _this->_internal_set_way_id(from._internal_way_id());
  }
  if (from._internal_max_upward_grade() != 0) {
    _this->_internal_set_max_upward_grade(from._internal_max_upward_grade());
  }
  if (from._internal_max_downward_grade() != 0) {
    _this->_internal_set_max_downward_grade(from._internal_max_downward_grade());
  }
  if (from._internal_lane_count() != 0) {
    _this->_internal_set_lane_count(from._internal_lane_count());
  }
  if (from._internal_cycle_lane() != 0) {
    _this->_internal_set_cycle_lane(from._internal_cycle_lane());
  }
  if (from._internal_sidewalk() != 0) {
    _this->_internal_set_sidewalk(from._internal_sidewalk());
  }
  if (from._internal_density() != 0) {
    _this->_internal_set_density(from._internal_density());
  }
  if (from._internal_speed_limit() != 0) {
    _this->_internal_set_speed_limit(from._internal_speed_limit());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_truck_speed = from._internal_truck_speed();
  uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    _this->_internal_set_truck_speed(from._internal_truck_speed());
  }
  if (from._internal_mean_elevation() != 0) {
    _this->_internal_set_mean_elevation(from._internal_mean_elevation());
  }
  if (from._internal_truck_route() != 0) {
    _this->_internal_set_truck_route(from._internal_truck_route());
  }
  if (from._internal_has_time_restrictions() != 0) {
    _this->_internal_set_has_time_restrictions(from._internal_has_time_restrictions());
  }
  if (from._internal_destination_only() != 0) {
    _this->_internal_set_destination_only(from._internal_destination_only());
  }
  if (from._internal_is_urban() != 0) {
    _this->_internal_set_is_urban(from._internal_is_urban());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_speed = from._internal_default_speed();
  uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    _this->_internal_set_default_speed(from._internal_default_speed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_source_along_edge = from._internal_source_along_edge();
  uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    _this->_internal_set_source_along_edge(from._internal_source_along_edge());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_target_along_edge = from._internal_target_along_edge();
  uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    _this->_internal_set_target_along_edge(from._internal_target_along_edge());
  }
  if (from._internal_sac_scale() != 0) {
    _this->_internal_set_sac_scale(from._internal_sac_scale());
  }
  if (from._internal_shoulder() != 0) {
    _this->_internal_set_shoulder(from._internal_shoulder());
  }
  if (from._internal_indoor() != 0) {
    _this->_internal_set_indoor(from._internal_indoor());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Edge::IsInitialized() const {
  return true;
}

void TripLeg_Edge::InternalSwap(TripLeg_Edge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.name_.InternalSwap(&other->_impl_.name_);
  _impl_.lane_connectivity_.InternalSwap(&other->_impl_.lane_connectivity_);
  _impl_.traffic_segment_.InternalSwap(&other->_impl_.traffic_segment_);
  _impl_.turn_lanes_.InternalSwap(&other->_impl_.turn_lanes_);
  _impl_.tagged_value_.InternalSwap(&other->_impl_.tagged_value_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.indoor_)
      + sizeof(TripLeg_Edge::_impl_.indoor_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
}

std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}


// ===================================================================

class TripLeg_IntersectingEdge::_Internal {
 public:
  static const ::valhalla::TripSign& sign(const TripLeg_IntersectingEdge* msg);
};

const ::valhalla::TripSign&
TripLeg_IntersectingEdge::_Internal::sign(const TripLeg_IntersectingEdge* msg) {
  return *msg->_impl_.sign_;
}
void TripLeg_IntersectingEdge::clear_sign() {
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.IntersectingEdge)
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_IntersectingEdge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.begin_heading_){}
    , decltype(_impl_.prev_name_consistency_){}
    , decltype(_impl_.curr_name_consistency_){}
    , decltype(_impl_.driveability_){}
    , decltype(_impl_.cyclability_){}
    , decltype(_impl_.walkability_){}
    , decltype(_impl_.use_){}
    , decltype(_impl_.road_class_){}
    , decltype(_impl_.lane_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    _this->_impl_.sign_ = new ::valhalla::TripSign(*from._impl_.sign_);
  }
  ::memcpy(&_impl_.begin_heading_, &from._impl_.begin_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lane_count_) -
    reinterpret_cast<char*>(&_impl_.begin_heading_)) + sizeof(_impl_.lane_count_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}

inline void TripLeg_IntersectingEdge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.begin_heading_){0u}
    , decltype(_impl_.prev_name_consistency_){false}
    , decltype(_impl_.curr_name_consistency_){false}
    , decltype(_impl_.driveability_){0}
    , decltype(_impl_.cyclability_){0}
    , decltype(_impl_.walkability_){0}
    , decltype(_impl_.use_){0}
    , decltype(_impl_.road_class_){0}
    , decltype(_impl_.lane_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_IntersectingEdge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sign_;
}

void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
  ::memset(&_impl_.begin_heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.lane_count_) -
      reinterpret_cast<char*>(&_impl_.begin_heading_)) + sizeof(_impl_.lane_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_IntersectingEdge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 begin_heading = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.begin_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool prev_name_consistency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.prev_name_consistency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool curr_name_consistency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.curr_name_consistency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability driveability = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_driveability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability cyclability = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cyclability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability walkability = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_walkability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Use use = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.RoadClass road_class = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 lane_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.lane_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripSign sign = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_IntersectingEdge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.IntersectingEdge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 begin_heading = 1;
  if (this->_internal_begin_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_heading(), target);
  }

  // bool prev_name_consistency = 2;
  if (this->_internal_prev_name_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_prev_name_consistency(), target);
  }

  // bool curr_name_consistency = 3;
  if (this->_internal_curr_name_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_curr_name_consistency(), target);
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (this->_internal_driveability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_driveability(), target);
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (this->_internal_cyclability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_cyclability(), target);
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (this->_internal_walkability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_walkability(), target);
  }

  // .valhalla.TripLeg.Use use = 7;
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_use(), target);
  }

  // .valhalla.RoadClass road_class = 8;
  if (this->_internal_road_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_road_class(), target);
  }

  // uint32 lane_count = 9;
  if (this->_internal_lane_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_lane_count(), target);
  }

  // .valhalla.TripSign sign = 10;
  if (this->_internal_has_sign()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sign(this),
        _Internal::sign(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.IntersectingEdge)
  return target;
}

size_t TripLeg_IntersectingEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripSign sign = 10;
  if (this->_internal_has_sign()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sign_);
  }

  // uint32 begin_heading = 1;
  if (this->_internal_begin_heading() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_heading());
  }

  // bool prev_name_consistency = 2;
  if (this->_internal_prev_name_consistency() != 0) {
    total_size += 1 + 1;
  }

  // bool curr_name_consistency = 3;
  if (this->_internal_curr_name_consistency() != 0) {
    total_size += 1 + 1;
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (this->_internal_driveability() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_driveability());
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (this->_internal_cyclability() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_cyclability());
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (this->_internal_walkability() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_walkability());
  }

  // .valhalla.TripLeg.Use use = 7;
  if (this->_internal_use() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
  }

  // .valhalla.RoadClass road_class = 8;
  if (this->_internal_road_class() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_road_class());
  }

  // uint32 lane_count = 9;
  if (this->_internal_lane_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lane_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_IntersectingEdge*>(
      &from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
  TripLeg_IntersectingEdge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sign()) {
    _this->_internal_mutable_sign()->::valhalla::TripSign::MergeFrom(
        from._internal_sign());
  }
  if (from._internal_begin_heading() != 0) {
    _this->_internal_set_begin_heading(from._internal_begin_heading());
  }
  if (from._internal_prev_name_consistency() != 0) {
    _this->_internal_set_prev_name_consistency(from._internal_prev_name_consistency());
  }
  if (from._internal_curr_name_consistency() != 0) {
    _this->_internal_set_curr_name_consistency(from._internal_curr_name_consistency());
  }
  if (from._internal_driveability() != 0) {
    _this->_internal_set_driveability(from._internal_driveability());
  }
  if (from._internal_cyclability() != 0) {
    _this->_internal_set_cyclability(from._internal_cyclability());
  }
  if (from._internal_walkability() != 0) {
    _this->_internal_set_walkability(from._internal_walkability());
  }
  if (from._internal_use() != 0) {
    _this->_internal_set_use(from._internal_use());
  }
  if (from._internal_road_class() != 0) {
    _this->_internal_set_road_class(from._internal_road_class());
  }
  if (from._internal_lane_count() != 0) {
    _this->_internal_set_lane_count(from._internal_lane_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_IntersectingEdge::IsInitialized() const {
  return true;
}

void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_)
      + sizeof(TripLeg_IntersectingEdge::_impl_.lane_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
}

std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}


// ===================================================================

class TripLeg_Cost::_Internal {
 public:
};

TripLeg_Cost::TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Cost)
}
TripLeg_Cost::TripLeg_Cost(const TripLeg_Cost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Cost* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_){}
    , decltype(_impl_.cost_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cost_) -
    reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.cost_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Cost)
}

inline void TripLeg_Cost::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_){0}
    , decltype(_impl_.cost_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Cost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Cost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cost_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.cost_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Cost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Cost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Cost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double seconds = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_seconds = this->_internal_seconds();
  uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_seconds(), target);
  }

  // double cost = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cost = this->_internal_cost();
  uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Cost)
  return target;
}

size_t TripLeg_Cost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double seconds = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_seconds = this->_internal_seconds();
  uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    total_size += 1 + 8;
  }

  // double cost = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cost = this->_internal_cost();
  uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Cost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Cost*>(
      &from));
}

void TripLeg_Cost::MergeFrom(const TripLeg_Cost& from) {
  TripLeg_Cost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_seconds = from._internal_seconds();
  uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cost = from._internal_cost();
  uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    _this->_internal_set_cost(from._internal_cost());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Cost::IsInitialized() const {
  return true;
}

void TripLeg_Cost::InternalSwap(TripLeg_Cost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_)
      + sizeof(TripLeg_Cost::_impl_.cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string TripLeg_Cost::GetTypeName() const {
  return "valhalla.TripLeg.Cost";
}


// ===================================================================

class TripLeg_PathCost::_Internal {
 public:
  static const ::valhalla::TripLeg_Cost& elapsed_cost(const TripLeg_PathCost* msg);
  static const ::valhalla::TripLeg_Cost& transition_cost(const TripLeg_PathCost* msg);
};

const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::elapsed_cost(const TripLeg_PathCost* msg) {
  return *msg->_impl_.elapsed_cost_;
}
const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::transition_cost(const TripLeg_PathCost* msg) {
  return *msg->_impl_.transition_cost_;
}
TripLeg_PathCost::TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.PathCost)
}
TripLeg_PathCost::TripLeg_PathCost(const TripLeg_PathCost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_PathCost* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.elapsed_cost_){nullptr}
    , decltype(_impl_.transition_cost_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_elapsed_cost()) {
    _this->_impl_.elapsed_cost_ = new ::valhalla::TripLeg_Cost(*from._impl_.elapsed_cost_);
  }
  if (from._internal_has_transition_cost()) {
    _this->_impl_.transition_cost_ = new ::valhalla::TripLeg_Cost(*from._impl_.transition_cost_);
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}

inline void TripLeg_PathCost::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.elapsed_cost_){nullptr}
    , decltype(_impl_.transition_cost_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_PathCost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.elapsed_cost_;
  if (this != internal_default_instance()) delete _impl_.transition_cost_;
}

void TripLeg_PathCost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.elapsed_cost_ != nullptr) {
    delete _impl_.elapsed_cost_;
  }
  _impl_.elapsed_cost_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transition_cost_ != nullptr) {
    delete _impl_.transition_cost_;
  }
  _impl_.transition_cost_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_PathCost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.TripLeg.Cost elapsed_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_elapsed_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Cost transition_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transition_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_PathCost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.PathCost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->_internal_has_elapsed_cost()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::elapsed_cost(this),
        _Internal::elapsed_cost(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->_internal_has_transition_cost()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transition_cost(this),
        _Internal::transition_cost(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.PathCost)
  return target;
}

size_t TripLeg_PathCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->_internal_has_elapsed_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.elapsed_cost_);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->_internal_has_transition_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transition_cost_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_PathCost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_PathCost*>(
      &from));
}

void TripLeg_PathCost::MergeFrom(const TripLeg_PathCost& from) {
  TripLeg_PathCost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_elapsed_cost()) {
    _this->_internal_mutable_elapsed_cost()->::valhalla::TripLeg_Cost::MergeFrom(
        from._internal_elapsed_cost());
  }
  if (from._internal_has_transition_cost()) {
    _this->_internal_mutable_transition_cost()->::valhalla::TripLeg_Cost::MergeFrom(
        from._internal_transition_cost());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_PathCost::IsInitialized() const {
  return true;
}

void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_)
      + sizeof(TripLeg_PathCost::_impl_.transition_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_)>(
          reinterpret_cast<char*>(&_impl_.elapsed_cost_),
          reinterpret_cast<char*>(&other->_impl_.elapsed_cost_));
}

std::string TripLeg_PathCost::GetTypeName() const {
  return "valhalla.TripLeg.PathCost";
}


// ===================================================================

class TripLeg_Node::_Internal {
 public:
  static const ::valhalla::TripLeg_Edge& edge(const TripLeg_Node* msg);
  static const ::valhalla::TransitPlatformInfo& transit_platform_info(const TripLeg_Node* msg);
  static const ::valhalla::TransitStationInfo& transit_station_info(const TripLeg_Node* msg);
  static const ::valhalla::TransitEgressInfo& transit_egress_info(const TripLeg_Node* msg);
  static const ::valhalla::TripLeg_PathCost& cost(const TripLeg_Node* msg);
  static const ::valhalla::BikeShareStationInfo& bss_info(const TripLeg_Node* msg);
};

const ::valhalla::TripLeg_Edge&
TripLeg_Node::_Internal::edge(const TripLeg_Node* msg) {
  return *msg->_impl_.edge_;
}
const ::valhalla::TransitPlatformInfo&
TripLeg_Node::_Internal::transit_platform_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_platform_info_;
}
const ::valhalla::TransitStationInfo&
TripLeg_Node::_Internal::transit_station_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_station_info_;
}
const ::valhalla::TransitEgressInfo&
TripLeg_Node::_Internal::transit_egress_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_egress_info_;
}
const ::valhalla::TripLeg_PathCost&
TripLeg_Node::_Internal::cost(const TripLeg_Node* msg) {
  return *msg->_impl_.cost_;
}
const ::valhalla::BikeShareStationInfo&
TripLeg_Node::_Internal::bss_info(const TripLeg_Node* msg) {
  return *msg->_impl_.bss_info_;
}
void TripLeg_Node::clear_transit_platform_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_platform_info_ != nullptr) {
    delete _impl_.transit_platform_info_;
  }
  _impl_.transit_platform_info_ = nullptr;
}
void TripLeg_Node::clear_transit_station_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_station_info_ != nullptr) {
    delete _impl_.transit_station_info_;
  }
  _impl_.transit_station_info_ = nullptr;
}
void TripLeg_Node::clear_transit_egress_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_egress_info_ != nullptr) {
    delete _impl_.transit_egress_info_;
  }
  _impl_.transit_egress_info_ = nullptr;
}
void TripLeg_Node::clear_bss_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.bss_info_ != nullptr) {
    delete _impl_.bss_info_;
  }
  _impl_.bss_info_ = nullptr;
}
TripLeg_Node::TripLeg_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Node)
}
TripLeg_Node::TripLeg_Node(const TripLeg_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.intersecting_edge_){from._impl_.intersecting_edge_}
    , decltype(_impl_.recosts_){from._impl_.recosts_}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.edge_){nullptr}
    , decltype(_impl_.transit_platform_info_){nullptr}
    , decltype(_impl_.transit_station_info_){nullptr}
    , decltype(_impl_.transit_egress_info_){nullptr}
    , decltype(_impl_.cost_){nullptr}
    , decltype(_impl_.bss_info_){nullptr}
    , decltype(_impl_.admin_index_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.fork_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_time_zone().empty()) {
    _this->_impl_.time_zone_.Set(from._internal_time_zone(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_edge()) {
    _this->_impl_.edge_ = new ::valhalla::TripLeg_Edge(*from._impl_.edge_);
  }
  if (from._internal_has_transit_platform_info()) {
    _this->_impl_.transit_platform_info_ = new ::valhalla::TransitPlatformInfo(*from._impl_.transit_platform_info_);
  }
  if (from._internal_has_transit_station_info()) {
    _this->_impl_.transit_station_info_ = new ::valhalla::TransitStationInfo(*from._impl_.transit_station_info_);
  }
  if (from._internal_has_transit_egress_info()) {
    _this->_impl_.transit_egress_info_ = new ::valhalla::TransitEgressInfo(*from._impl_.transit_egress_info_);
  }
  if (from._internal_has_cost()) {
    _this->_impl_.cost_ = new ::valhalla::TripLeg_PathCost(*from._impl_.cost_);
  }
  if (from._internal_has_bss_info()) {
    _this->_impl_.bss_info_ = new ::valhalla::BikeShareStationInfo(*from._impl_.bss_info_);
  }
  ::memcpy(&_impl_.admin_index_, &from._impl_.admin_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fork_) -
    reinterpret_cast<char*>(&_impl_.admin_index_)) + sizeof(_impl_.fork_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}

inline void TripLeg_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.intersecting_edge_){arena}
    , decltype(_impl_.recosts_){arena}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.edge_){nullptr}
    , decltype(_impl_.transit_platform_info_){nullptr}
    , decltype(_impl_.transit_station_info_){nullptr}
    , decltype(_impl_.transit_egress_info_){nullptr}
    , decltype(_impl_.cost_){nullptr}
    , decltype(_impl_.bss_info_){nullptr}
    , decltype(_impl_.admin_index_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.fork_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.intersecting_edge_.~RepeatedPtrField();
  _impl_.recosts_.~RepeatedPtrField();
  _impl_.time_zone_.Destroy();
  if (this != internal_default_instance()) delete _impl_.edge_;
  if (this != internal_default_instance()) delete _impl_.transit_platform_info_;
  if (this != internal_default_instance()) delete _impl_.transit_station_info_;
  if (this != internal_default_instance()) delete _impl_.transit_egress_info_;
  if (this != internal_default_instance()) delete _impl_.cost_;
  if (this != internal_default_instance()) delete _impl_.bss_info_;
}

void TripLeg_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intersecting_edge_.Clear();
  _impl_.recosts_.Clear();
  _impl_.time_zone_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.edge_ != nullptr) {
    delete _impl_.edge_;
  }
  _impl_.edge_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_platform_info_ != nullptr) {
    delete _impl_.transit_platform_info_;
  }
  _impl_.transit_platform_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_station_info_ != nullptr) {
    delete _impl_.transit_station_info_;
  }
  _impl_.transit_station_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_egress_info_ != nullptr) {
    delete _impl_.transit_egress_info_;
  }
  _impl_.transit_egress_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.cost_ != nullptr) {
    delete _impl_.cost_;
  }
  _impl_.cost_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.bss_info_ != nullptr) {
    delete _impl_.bss_info_;
  }
  _impl_.bss_info_ = nullptr;
  ::memset(&_impl_.admin_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fork_) -
      reinterpret_cast<char*>(&_impl_.admin_index_)) + sizeof(_impl_.fork_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.TripLeg.Edge edge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_intersecting_edge(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 admin_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.admin_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Node.Type type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::valhalla::TripLeg_Node_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // bool fork = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.fork_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitPlatformInfo transit_platform_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_platform_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitStationInfo transit_station_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_station_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitEgressInfo transit_egress_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_egress_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string time_zone = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_time_zone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.PathCost cost = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.PathCost recosts = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_recosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BikeShareStationInfo bss_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bss_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.TripLeg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::edge(this),
        _Internal::edge(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_intersecting_edge_size()); i < n; i++) {
    const auto& repfield = this->_internal_intersecting_edge(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 admin_index = 3;
  if (this->_internal_admin_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_admin_index(), target);
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // bool fork = 5;
  if (this->_internal_fork() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_fork(), target);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->_internal_has_transit_platform_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transit_platform_info(this),
        _Internal::transit_platform_info(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->_internal_has_transit_station_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::transit_station_info(this),
        _Internal::transit_station_info(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->_internal_has_transit_egress_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::transit_egress_info(this),
        _Internal::transit_egress_info(this).GetCachedSize(), target, stream);
  }

  // string time_zone = 11;
  if (!this->_internal_time_zone().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_time_zone().data(), static_cast<int>(this->_internal_time_zone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Node.time_zone");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_time_zone(), target);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (this->_internal_has_cost()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::cost(this),
        _Internal::cost(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_recosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_recosts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->_internal_has_bss_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::bss_info(this),
        _Internal::bss_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Node)
  return target;
}

size_t TripLeg_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1UL * this->_internal_intersecting_edge_size();
  for (const auto& msg : this->_impl_.intersecting_edge_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  total_size += 1UL * this->_internal_recosts_size();
  for (const auto& msg : this->_impl_.recosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string time_zone = 11;
  if (!this->_internal_time_zone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_time_zone());
  }

  // .valhalla.TripLeg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.edge_);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->_internal_has_transit_platform_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_platform_info_);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->_internal_has_transit_station_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_station_info_);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->_internal_has_transit_egress_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_egress_info_);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (this->_internal_has_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cost_);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->_internal_has_bss_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bss_info_);
  }

  // uint32 admin_index = 3;
  if (this->_internal_admin_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_admin_index());
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // bool fork = 5;
  if (this->_internal_fork() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Node*>(
      &from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
  TripLeg_Node* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.intersecting_edge_.MergeFrom(from._impl_.intersecting_edge_);
  _this->_impl_.recosts_.MergeFrom(from._impl_.recosts_);
  if (!from._internal_time_zone().empty()) {
    _this->_internal_set_time_zone(from._internal_time_zone());
  }
  if (from._internal_has_edge()) {
    _this->_internal_mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(
        from._internal_edge());
  }
  if (from._internal_has_transit_platform_info()) {
    _this->_internal_mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(
        from._internal_transit_platform_info());
  }
  if (from._internal_has_transit_station_info()) {
    _this->_internal_mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(
        from._internal_transit_station_info());
  }
  if (from._internal_has_transit_egress_info()) {
    _this->_internal_mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(
        from._internal_transit_egress_info());
  }
  if (from._internal_has_cost()) {
    _this->_internal_mutable_cost()->::valhalla::TripLeg_PathCost::MergeFrom(
        from._internal_cost());
  }
  if (from._internal_has_bss_info()) {
    _this->_internal_mutable_bss_info()->::valhalla::BikeShareStationInfo::MergeFrom(
        from._internal_bss_info());
  }
  if (from._internal_admin_index() != 0) {
    _this->_internal_set_admin_index(from._internal_admin_index());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_fork() != 0) {
    _this->_internal_set_fork(from._internal_fork());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Node::IsInitialized() const {
  return true;
}

void TripLeg_Node::InternalSwap(TripLeg_Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.intersecting_edge_.InternalSwap(&other->_impl_.intersecting_edge_);
  _impl_.recosts_.InternalSwap(&other->_impl_.recosts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.time_zone_, lhs_arena,
      &other->_impl_.time_zone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.fork_)
      + sizeof(TripLeg_Node::_impl_.fork_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_)>(
          reinterpret_cast<char*>(&_impl_.edge_),
          reinterpret_cast<char*>(&other->_impl_.edge_));
}

std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}


// ===================================================================

class TripLeg_Admin::_Internal {
 public:
};

TripLeg_Admin::TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Admin)
}
TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Admin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.country_code_){}
    , decltype(_impl_.country_text_){}
    , decltype(_impl_.state_code_){}
    , decltype(_impl_.state_text_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_country_code().empty()) {
    _this->_impl_.country_code_.Set(from._internal_country_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.country_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_country_text().empty()) {
    _this->_impl_.country_text_.Set(from._internal_country_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.state_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state_code().empty()) {
    _this->_impl_.state_code_.Set(from._internal_state_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.state_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state_text().empty()) {
    _this->_impl_.state_text_.Set(from._internal_state_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}

inline void TripLeg_Admin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.country_code_){}
    , decltype(_impl_.country_text_){}
    , decltype(_impl_.state_code_){}
    , decltype(_impl_.state_text_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.country_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Admin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_code_.Destroy();
  _impl_.country_text_.Destroy();
  _impl_.state_code_.Destroy();
  _impl_.state_text_.Destroy();
}

void TripLeg_Admin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.country_code_.ClearToEmpty();
  _impl_.country_text_.ClearToEmpty();
  _impl_.state_code_.ClearToEmpty();
  _impl_.state_text_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Admin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string country_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string country_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_country_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string state_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_state_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string state_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_state_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Admin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Admin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string country_code = 1;
  if (!this->_internal_country_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_country_code().data(), static_cast<int>(this->_internal_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_code");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country_code(), target);
  }

  // string country_text = 2;
  if (!this->_internal_country_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_country_text().data(), static_cast<int>(this->_internal_country_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_country_text(), target);
  }

  // string state_code = 3;
  if (!this->_internal_state_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state_code().data(), static_cast<int>(this->_internal_state_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_state_code(), target);
  }

  // string state_text = 4;
  if (!this->_internal_state_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state_text().data(), static_cast<int>(this->_internal_state_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_text");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_state_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Admin)
  return target;
}

size_t TripLeg_Admin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string country_code = 1;
  if (!this->_internal_country_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_country_code());
  }

  // string country_text = 2;
  if (!this->_internal_country_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_country_text());
  }

  // string state_code = 3;
  if (!this->_internal_state_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_state_code());
  }

  // string state_text = 4;
  if (!this->_internal_state_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_state_text());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Admin*>(
      &from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
  TripLeg_Admin* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_country_code().empty()) {
    _this->_internal_set_country_code(from._internal_country_code());
  }
  if (!from._internal_country_text().empty()) {
    _this->_internal_set_country_text(from._internal_country_text());
  }
  if (!from._internal_state_code().empty()) {
    _this->_internal_set_state_code(from._internal_state_code());
  }
  if (!from._internal_state_text().empty()) {
    _this->_internal_set_state_text(from._internal_state_text());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Admin::IsInitialized() const {
  return true;
}

void TripLeg_Admin::InternalSwap(TripLeg_Admin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_code_, lhs_arena,
      &other->_impl_.country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_text_, lhs_arena,
      &other->_impl_.country_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.state_code_, lhs_arena,
      &other->_impl_.state_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.state_text_, lhs_arena,
      &other->_impl_.state_text_, rhs_arena
  );
}

std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}


// ===================================================================

class TripLeg_ShapeAttributes::_Internal {
 public:
};

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ShapeAttributes)
}
TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_ShapeAttributes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){from._impl_.time_}
    , /*decltype(_impl_._time_cached_byte_size_)*/{0}
    , decltype(_impl_.length_){from._impl_.length_}
    , /*decltype(_impl_._length_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_){from._impl_.speed_}
    , /*decltype(_impl_._speed_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_limit_){from._impl_.speed_limit_}
    , /*decltype(_impl_._speed_limit_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}

inline void TripLeg_ShapeAttributes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){arena}
    , /*decltype(_impl_._time_cached_byte_size_)*/{0}
    , decltype(_impl_.length_){arena}
    , /*decltype(_impl_._length_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_){arena}
    , /*decltype(_impl_._speed_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_limit_){arena}
    , /*decltype(_impl_._speed_limit_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_ShapeAttributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.time_.~RepeatedField();
  _impl_.length_.~RepeatedField();
  _impl_.speed_.~RepeatedField();
  _impl_.speed_limit_.~RepeatedField();
}

void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.time_.Clear();
  _impl_.length_.Clear();
  _impl_.speed_.Clear();
  _impl_.speed_limit_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_ShapeAttributes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 time = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_time(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_time(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 length = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_length(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 speed = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_speed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 speed_limit = 5 [packed = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed_limit(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_speed_limit(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_ShapeAttributes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ShapeAttributes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    int byte_size = _impl_._time_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_time(), byte_size, target);
    }
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int byte_size = _impl_._length_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_length(), byte_size, target);
    }
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int byte_size = _impl_._speed_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_speed(), byte_size, target);
    }
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    int byte_size = _impl_._speed_limit_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          5, _internal_speed_limit(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ShapeAttributes)
  return target;
}

size_t TripLeg_ShapeAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.time_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._time_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 length = 2 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.length_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._length_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.speed_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._speed_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.speed_limit_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._speed_limit_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_ShapeAttributes*>(
      &from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
  TripLeg_ShapeAttributes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.time_.MergeFrom(from._impl_.time_);
  _this->_impl_.length_.MergeFrom(from._impl_.length_);
  _this->_impl_.speed_.MergeFrom(from._impl_.speed_);
  _this->_impl_.speed_limit_.MergeFrom(from._impl_.speed_limit_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_ShapeAttributes::IsInitialized() const {
  return true;
}

void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.time_.InternalSwap(&other->_impl_.time_);
  _impl_.length_.InternalSwap(&other->_impl_.length_);
  _impl_.speed_.InternalSwap(&other->_impl_.speed_);
  _impl_.speed_limit_.InternalSwap(&other->_impl_.speed_limit_);
}

std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}


// ===================================================================

class TripLeg_Incident::_Internal {
 public:
  static const ::valhalla::IncidentsTile_Metadata& metadata(const TripLeg_Incident* msg);
};

const ::valhalla::IncidentsTile_Metadata&
TripLeg_Incident::_Internal::metadata(const TripLeg_Incident* msg) {
  return *msg->_impl_.metadata_;
}
void TripLeg_Incident::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
TripLeg_Incident::TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Incident)
}
TripLeg_Incident::TripLeg_Incident(const TripLeg_Incident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Incident* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.begin_shape_index_){}
    , decltype(_impl_.end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::valhalla::IncidentsTile_Metadata(*from._impl_.metadata_);
  }
  ::memcpy(&_impl_.begin_shape_index_, &from._impl_.begin_shape_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_shape_index_) -
    reinterpret_cast<char*>(&_impl_.begin_shape_index_)) + sizeof(_impl_.end_shape_index_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}

inline void TripLeg_Incident::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.begin_shape_index_){0u}
    , decltype(_impl_.end_shape_index_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Incident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void TripLeg_Incident::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
  ::memset(&_impl_.begin_shape_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.end_shape_index_) -
      reinterpret_cast<char*>(&_impl_.begin_shape_index_)) + sizeof(_impl_.end_shape_index_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Incident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.IncidentsTile.Metadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_shape_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Incident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Incident)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->_internal_has_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // uint32 begin_shape_index = 3;
  if (this->_internal_begin_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 4;
  if (this->_internal_end_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Incident)
  return target;
}

size_t TripLeg_Incident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->_internal_has_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  // uint32 begin_shape_index = 3;
  if (this->_internal_begin_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
  }

  // uint32 end_shape_index = 4;
  if (this->_internal_end_shape_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Incident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Incident*>(
      &from));
}

void TripLeg_Incident::MergeFrom(const TripLeg_Incident& from) {
  TripLeg_Incident* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::valhalla::IncidentsTile_Metadata::MergeFrom(
        from._internal_metadata());
  }
  if (from._internal_begin_shape_index() != 0) {
    _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
  }
  if (from._internal_end_shape_index() != 0) {
    _this->_internal_set_end_shape_index(from._internal_end_shape_index());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Incident::IsInitialized() const {
  return true;
}

void TripLeg_Incident::InternalSwap(TripLeg_Incident* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_)
      + sizeof(TripLeg_Incident::_impl_.end_shape_index_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

std::string TripLeg_Incident::GetTypeName() const {
  return "valhalla.TripLeg.Incident";
}


// ===================================================================

class TripLeg_Closure::_Internal {
 public:
};

TripLeg_Closure::TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Closure)
}
TripLeg_Closure::TripLeg_Closure(const TripLeg_Closure& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Closure* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_begin_shape_index();
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_shape_index();
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}

inline void TripLeg_Closure::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
}

TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Closure::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
}

void TripLeg_Closure::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Closure::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Closure::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Closure::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 begin_shape_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Closure::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Closure)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 begin_shape_index = 1;
  if (_internal_has_begin_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 2;
  if (_internal_has_end_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Closure)
  return target;
}

size_t TripLeg_Closure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_begin_shape_index_case()) {
    // uint32 begin_shape_index = 1;
    case kBeginShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // uint32 end_shape_index = 2;
    case kEndShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Closure::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Closure*>(
      &from));
}

void TripLeg_Closure::MergeFrom(const TripLeg_Closure& from) {
  TripLeg_Closure* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Closure::IsInitialized() const {
  return true;
}

void TripLeg_Closure::InternalSwap(TripLeg_Closure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_begin_shape_index_, other->_impl_.has_begin_shape_index_);
  swap(_impl_.has_end_shape_index_, other->_impl_.has_end_shape_index_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string TripLeg_Closure::GetTypeName() const {
  return "valhalla.TripLeg.Closure";
}


// ===================================================================

class TripLeg::_Internal {
 public:
  static const ::valhalla::BoundingBox& bbox(const TripLeg* msg);
  static const ::valhalla::TripLeg_ShapeAttributes& shape_attributes(const TripLeg* msg);
};

const ::valhalla::BoundingBox&
TripLeg::_Internal::bbox(const TripLeg* msg) {
  return *msg->_impl_.bbox_;
}
const ::valhalla::TripLeg_ShapeAttributes&
TripLeg::_Internal::shape_attributes(const TripLeg* msg) {
  return *msg->_impl_.shape_attributes_;
}
void TripLeg::clear_location() {
  _impl_.location_.Clear();
}
void TripLeg::clear_bbox() {
  if (GetArenaForAllocation() == nullptr && _impl_.bbox_ != nullptr) {
    delete _impl_.bbox_;
  }
  _impl_.bbox_ = nullptr;
}
TripLeg::TripLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg)
}
TripLeg::TripLeg(const TripLeg& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){from._impl_.location_}
    , decltype(_impl_.node_){from._impl_.node_}
    , decltype(_impl_.admin_){from._impl_.admin_}
    , decltype(_impl_.incidents_){from._impl_.incidents_}
    , decltype(_impl_.algorithms_){from._impl_.algorithms_}
    , decltype(_impl_.closures_){from._impl_.closures_}
    , decltype(_impl_.shape_){}
    , decltype(_impl_.bbox_){nullptr}
    , decltype(_impl_.shape_attributes_){nullptr}
    , decltype(_impl_.osm_changeset_){}
    , decltype(_impl_.trip_id_){}
    , decltype(_impl_.leg_id_){}
    , decltype(_impl_.leg_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.shape_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shape_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_shape().empty()) {
    _this->_impl_.shape_.Set(from._internal_shape(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_bbox()) {
    _this->_impl_.bbox_ = new ::valhalla::BoundingBox(*from._impl_.bbox_);
  }
  if (from._internal_has_shape_attributes()) {
    _this->_impl_.shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes(*from._impl_.shape_attributes_);
  }
  ::memcpy(&_impl_.osm_changeset_, &from._impl_.osm_changeset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.leg_count_) -
    reinterpret_cast<char*>(&_impl_.osm_changeset_)) + sizeof(_impl_.leg_count_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}

inline void TripLeg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){arena}
    , decltype(_impl_.node_){arena}
    , decltype(_impl_.admin_){arena}
    , decltype(_impl_.incidents_){arena}
    , decltype(_impl_.algorithms_){arena}
    , decltype(_impl_.closures_){arena}
    , decltype(_impl_.shape_){}
    , decltype(_impl_.bbox_){nullptr}
    , decltype(_impl_.shape_attributes_){nullptr}
    , decltype(_impl_.osm_changeset_){uint64_t{0u}}
    , decltype(_impl_.trip_id_){uint64_t{0u}}
    , decltype(_impl_.leg_id_){0u}
    , decltype(_impl_.leg_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.shape_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shape_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.location_.~RepeatedPtrField();
  _impl_.node_.~RepeatedPtrField();
  _impl_.admin_.~RepeatedPtrField();
  _impl_.incidents_.~RepeatedPtrField();
  _impl_.algorithms_.~RepeatedPtrField();
  _impl_.closures_.~RepeatedPtrField();
  _impl_.shape_.Destroy();
  if (this != internal_default_instance()) delete _impl_.bbox_;
  if (this != internal_default_instance()) delete _impl_.shape_attributes_;
}

void TripLeg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.location_.Clear();
  _impl_.node_.Clear();
  _impl_.admin_.Clear();
  _impl_.incidents_.Clear();
  _impl_.algorithms_.Clear();
  _impl_.closures_.Clear();
  _impl_.shape_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.bbox_ != nullptr) {
    delete _impl_.bbox_;
  }
  _impl_.bbox_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.shape_attributes_ != nullptr) {
    delete _impl_.shape_attributes_;
  }
  _impl_.shape_attributes_ = nullptr;
  ::memset(&_impl_.osm_changeset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.leg_count_) -
      reinterpret_cast<char*>(&_impl_.osm_changeset_)) + sizeof(_impl_.leg_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 osm_changeset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.osm_changeset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 trip_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.trip_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 leg_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.leg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 leg_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.leg_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_location(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Node node = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Admin admin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_admin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string shape = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_shape();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BoundingBox bbox = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bbox(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_attributes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Incident incidents = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incidents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string algorithms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_algorithms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Closure closures = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_closures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 osm_changeset = 1;
  if (this->_internal_osm_changeset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_osm_changeset(), target);
  }

  // uint64 trip_id = 2;
  if (this->_internal_trip_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_trip_id(), target);
  }

  // uint32 leg_id = 3;
  if (this->_internal_leg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_leg_id(), target);
  }

  // uint32 leg_count = 4;
  if (this->_internal_leg_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_leg_count(), target);
  }

  // repeated .valhalla.Location location = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_location_size()); i < n; i++) {
    const auto& repfield = this->_internal_location(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_size()); i < n; i++) {
    const auto& repfield = this->_internal_node(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_admin_size()); i < n; i++) {
    const auto& repfield = this->_internal_admin(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string shape = 8;
  if (!this->_internal_shape().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_shape().data(), static_cast<int>(this->_internal_shape().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.shape");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_shape(), target);
  }

  // .valhalla.BoundingBox bbox = 9;
  if (this->_internal_has_bbox()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::bbox(this),
        _Internal::bbox(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->_internal_has_shape_attributes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::shape_attributes(this),
        _Internal::shape_attributes(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incidents_size()); i < n; i++) {
    const auto& repfield = this->_internal_incidents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string algorithms = 12;
  for (int i = 0, n = this->_internal_algorithms_size(); i < n; i++) {
    const auto& s = this->_internal_algorithms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.algorithms");
    target = stream->WriteString(12, s, target);
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_closures_size()); i < n; i++) {
    const auto& repfield = this->_internal_closures(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg)
  return target;
}

size_t TripLeg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.Location location = 5;
  total_size += 1UL * this->_internal_location_size();
  for (const auto& msg : this->_impl_.location_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->_impl_.node_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1UL * this->_internal_admin_size();
  for (const auto& msg : this->_impl_.admin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  total_size += 1UL * this->_internal_incidents_size();
  for (const auto& msg : this->_impl_.incidents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string algorithms = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.algorithms_.size());
  for (int i = 0, n = _impl_.algorithms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.algorithms_.Get(i));
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  total_size += 1UL * this->_internal_closures_size();
  for (const auto& msg : this->_impl_.closures_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string shape = 8;
  if (!this->_internal_shape().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shape());
  }

  // .valhalla.BoundingBox bbox = 9;
  if (this->_internal_has_bbox()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bbox_);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->_internal_has_shape_attributes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.shape_attributes_);
  }

  // uint64 osm_changeset = 1;
  if (this->_internal_osm_changeset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_osm_changeset());
  }

  // uint64 trip_id = 2;
  if (this->_internal_trip_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_trip_id());
  }

  // uint32 leg_id = 3;
  if (this->_internal_leg_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leg_id());
  }

  // uint32 leg_count = 4;
  if (this->_internal_leg_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leg_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg*>(
      &from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
  TripLeg* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.location_.MergeFrom(from._impl_.location_);
  _this->_impl_.node_.MergeFrom(from._impl_.node_);
  _this->_impl_.admin_.MergeFrom(from._impl_.admin_);
  _this->_impl_.incidents_.MergeFrom(from._impl_.incidents_);
  _this->_impl_.algorithms_.MergeFrom(from._impl_.algorithms_);
  _this->_impl_.closures_.MergeFrom(from._impl_.closures_);
  if (!from._internal_shape().empty()) {
    _this->_internal_set_shape(from._internal_shape());
  }
  if (from._internal_has_bbox()) {
    _this->_internal_mutable_bbox()->::valhalla::BoundingBox::MergeFrom(
        from._internal_bbox());
  }
  if (from._internal_has_shape_attributes()) {
    _this->_internal_mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(
        from._internal_shape_attributes());
  }
  if (from._internal_osm_changeset() != 0) {
    _this->_internal_set_osm_changeset(from._internal_osm_changeset());
  }
  if (from._internal_trip_id() != 0) {
    _this->_internal_set_trip_id(from._internal_trip_id());
  }
  if (from._internal_leg_id() != 0) {
    _this->_internal_set_leg_id(from._internal_leg_id());
  }
  if (from._internal_leg_count() != 0) {
    _this->_internal_set_leg_count(from._internal_leg_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg::IsInitialized() const {
  return true;
}

void TripLeg::InternalSwap(TripLeg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.location_.InternalSwap(&other->_impl_.location_);
  _impl_.node_.InternalSwap(&other->_impl_.node_);
  _impl_.admin_.InternalSwap(&other->_impl_.admin_);
  _impl_.incidents_.InternalSwap(&other->_impl_.incidents_);
  _impl_.algorithms_.InternalSwap(&other->_impl_.algorithms_);
  _impl_.closures_.InternalSwap(&other->_impl_.closures_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.shape_, lhs_arena,
      &other->_impl_.shape_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_)
      + sizeof(TripLeg::_impl_.leg_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_)>(
          reinterpret_cast<char*>(&_impl_.bbox_),
          reinterpret_cast<char*>(&other->_impl_.bbox_));
}

std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}


// ===================================================================

class TripRoute::_Internal {
 public:
};

TripRoute::TripRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripRoute)
}
TripRoute::TripRoute(const TripRoute& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripRoute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.legs_){from._impl_.legs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}

inline void TripRoute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.legs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripRoute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.legs_.~RepeatedPtrField();
}

void TripRoute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.legs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripRoute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripLeg legs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_legs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripRoute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripRoute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_legs_size()); i < n; i++) {
    const auto& repfield = this->_internal_legs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripRoute)
  return target;
}

size_t TripRoute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1UL * this->_internal_legs_size();
  for (const auto& msg : this->_impl_.legs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripRoute*>(
      &from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
  TripRoute* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.legs_.MergeFrom(from._impl_.legs_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripRoute::IsInitialized() const {
  return true;
}

void TripRoute::InternalSwap(TripRoute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.legs_.InternalSwap(&other->_impl_.legs_);
}

std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}


// ===================================================================

class Trip::_Internal {
 public:
};

Trip::Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Trip)
}
Trip::Trip(const Trip& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Trip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.routes_){from._impl_.routes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}

inline void Trip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.routes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Trip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.routes_.~RepeatedPtrField();
}

void Trip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.routes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Trip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripRoute routes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_routes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Trip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_routes_size()); i < n; i++) {
    const auto& repfield = this->_internal_routes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Trip)
  return target;
}

size_t Trip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->_impl_.routes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Trip*>(
      &from));
}

void Trip::MergeFrom(const Trip& from) {
  Trip* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.routes_.MergeFrom(from._impl_.routes_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trip::IsInitialized() const {
  return true;
}

void Trip::InternalSwap(Trip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.routes_.InternalSwap(&other->_impl_.routes_);
}

std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_LaneConnectivity*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_LaneConnectivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_LaneConnectivity >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_TrafficSegment*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_TrafficSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_TrafficSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Restriction*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Restriction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Restriction >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Edge*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Edge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Edge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_IntersectingEdge*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_IntersectingEdge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_IntersectingEdge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Cost*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Cost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Cost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_PathCost*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_PathCost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_PathCost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Node*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Admin*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Admin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Admin >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_ShapeAttributes*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_ShapeAttributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_ShapeAttributes >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Incident*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Incident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Incident >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Closure*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Closure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Closure >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg*
Arena::CreateMaybeMessage< ::valhalla::TripLeg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripRoute*
Arena::CreateMaybeMessage< ::valhalla::TripRoute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripRoute >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Trip*
Arena::CreateMaybeMessage< ::valhalla::Trip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Trip >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
