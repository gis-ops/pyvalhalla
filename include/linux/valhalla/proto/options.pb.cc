// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#include "options.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace valhalla {
PROTOBUF_CONSTEXPR Contour::Contour(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_time_)*/{}
  , /*decltype(_impl_.has_color_)*/{}
  , /*decltype(_impl_.has_distance_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ContourDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContourDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContourDefaultTypeInternal() {}
  union {
    Contour _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContourDefaultTypeInternal _Contour_default_instance_;
PROTOBUF_CONSTEXPR Ring::Ring(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.coords_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RingDefaultTypeInternal() {}
  union {
    Ring _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RingDefaultTypeInternal _Ring_default_instance_;
PROTOBUF_CONSTEXPR PbfFieldSelector::PbfFieldSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.options_)*/false
  , /*decltype(_impl_.trip_)*/false
  , /*decltype(_impl_.directions_)*/false
  , /*decltype(_impl_.status_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PbfFieldSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbfFieldSelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbfFieldSelectorDefaultTypeInternal() {}
  union {
    PbfFieldSelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbfFieldSelectorDefaultTypeInternal _PbfFieldSelector_default_instance_;
PROTOBUF_CONSTEXPR AvoidEdge::AvoidEdge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_id_)*/{}
  , /*decltype(_impl_.has_percent_along_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AvoidEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvoidEdgeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvoidEdgeDefaultTypeInternal() {}
  union {
    AvoidEdge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvoidEdgeDefaultTypeInternal _AvoidEdge_default_instance_;
PROTOBUF_CONSTEXPR Costing_Options::Costing_Options(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.filter_stop_ids_)*/{}
  , /*decltype(_impl_.filter_operator_ids_)*/{}
  , /*decltype(_impl_.filter_route_ids_)*/{}
  , /*decltype(_impl_.exclude_edges_)*/{}
  , /*decltype(_impl_.filter_stop_action_)*/0
  , /*decltype(_impl_.filter_operator_action_)*/0
  , /*decltype(_impl_.filter_route_action_)*/0
  , /*decltype(_impl_.has_maneuver_penalty_)*/{}
  , /*decltype(_impl_.has_destination_only_penalty_)*/{}
  , /*decltype(_impl_.has_gate_cost_)*/{}
  , /*decltype(_impl_.has_gate_penalty_)*/{}
  , /*decltype(_impl_.has_toll_booth_cost_)*/{}
  , /*decltype(_impl_.has_toll_booth_penalty_)*/{}
  , /*decltype(_impl_.has_alley_penalty_)*/{}
  , /*decltype(_impl_.has_country_crossing_cost_)*/{}
  , /*decltype(_impl_.has_country_crossing_penalty_)*/{}
  , /*decltype(_impl_.has_ferry_cost_)*/{}
  , /*decltype(_impl_.has_avoid_bad_surfaces_)*/{}
  , /*decltype(_impl_.has_use_ferry_)*/{}
  , /*decltype(_impl_.has_use_highways_)*/{}
  , /*decltype(_impl_.has_use_tolls_)*/{}
  , /*decltype(_impl_.has_use_roads_)*/{}
  , /*decltype(_impl_.has_max_distance_)*/{}
  , /*decltype(_impl_.has_walking_speed_)*/{}
  , /*decltype(_impl_.has_step_penalty_)*/{}
  , /*decltype(_impl_.has_max_grade_)*/{}
  , /*decltype(_impl_.has_max_hiking_difficulty_)*/{}
  , /*decltype(_impl_.has_mode_factor_)*/{}
  , /*decltype(_impl_.has_walkway_factor_)*/{}
  , /*decltype(_impl_.has_sidewalk_factor_)*/{}
  , /*decltype(_impl_.has_alley_factor_)*/{}
  , /*decltype(_impl_.has_driveway_factor_)*/{}
  , /*decltype(_impl_.has_driveway_penalty_)*/{}
  , /*decltype(_impl_.has_transit_start_end_max_distance_)*/{}
  , /*decltype(_impl_.has_transit_transfer_max_distance_)*/{}
  , /*decltype(_impl_.has_transport_type_)*/{}
  , /*decltype(_impl_.has_top_speed_)*/{}
  , /*decltype(_impl_.has_use_hills_)*/{}
  , /*decltype(_impl_.has_use_primary_)*/{}
  , /*decltype(_impl_.has_use_trails_)*/{}
  , /*decltype(_impl_.has_low_class_penalty_)*/{}
  , /*decltype(_impl_.has_hazmat_)*/{}
  , /*decltype(_impl_.has_weight_)*/{}
  , /*decltype(_impl_.has_axle_load_)*/{}
  , /*decltype(_impl_.has_height_)*/{}
  , /*decltype(_impl_.has_width_)*/{}
  , /*decltype(_impl_.has_length_)*/{}
  , /*decltype(_impl_.has_cycling_speed_)*/{}
  , /*decltype(_impl_.has_wheelchair_)*/{}
  , /*decltype(_impl_.has_bicycle_)*/{}
  , /*decltype(_impl_.has_use_bus_)*/{}
  , /*decltype(_impl_.has_use_rail_)*/{}
  , /*decltype(_impl_.has_use_transfers_)*/{}
  , /*decltype(_impl_.has_transfer_cost_)*/{}
  , /*decltype(_impl_.has_transfer_penalty_)*/{}
  , /*decltype(_impl_.has_flow_mask_)*/{}
  , /*decltype(_impl_.has_bike_share_cost_)*/{}
  , /*decltype(_impl_.has_bike_share_penalty_)*/{}
  , /*decltype(_impl_.has_rail_ferry_cost_)*/{}
  , /*decltype(_impl_.has_use_rail_ferry_)*/{}
  , /*decltype(_impl_.has_ignore_restrictions_)*/{}
  , /*decltype(_impl_.has_ignore_oneways_)*/{}
  , /*decltype(_impl_.has_ignore_access_)*/{}
  , /*decltype(_impl_.has_ignore_closures_)*/{}
  , /*decltype(_impl_.has_shortest_)*/{}
  , /*decltype(_impl_.has_service_penalty_)*/{}
  , /*decltype(_impl_.has_use_tracks_)*/{}
  , /*decltype(_impl_.has_use_distance_)*/{}
  , /*decltype(_impl_.has_use_living_streets_)*/{}
  , /*decltype(_impl_.has_service_factor_)*/{}
  , /*decltype(_impl_.has_closure_factor_)*/{}
  , /*decltype(_impl_.has_private_access_penalty_)*/{}
  , /*decltype(_impl_.has_exclude_unpaved_)*/{}
  , /*decltype(_impl_.has_include_hot_)*/{}
  , /*decltype(_impl_.has_include_hov2_)*/{}
  , /*decltype(_impl_.has_include_hov3_)*/{}
  , /*decltype(_impl_.has_exclude_cash_only_tolls_)*/{}
  , /*decltype(_impl_.has_restriction_probability_)*/{}
  , /*decltype(_impl_.has_elevator_penalty_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Costing_OptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Costing_OptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Costing_OptionsDefaultTypeInternal() {}
  union {
    Costing_Options _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Costing_OptionsDefaultTypeInternal _Costing_Options_default_instance_;
PROTOBUF_CONSTEXPR Costing::Costing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.has_options_)*/{}
  , /*decltype(_impl_.has_name_)*/{}
  , /*decltype(_impl_.has_filter_closures_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CostingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CostingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CostingDefaultTypeInternal() {}
  union {
    Costing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CostingDefaultTypeInternal _Costing_default_instance_;
PROTOBUF_CONSTEXPR Options_CostingsEntry_DoNotUse::Options_CostingsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Options_CostingsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Options_CostingsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Options_CostingsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Options_CostingsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Options_CostingsEntry_DoNotUseDefaultTypeInternal _Options_CostingsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Options::Options(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.costings_)*/{}
  , /*decltype(_impl_.locations_)*/{}
  , /*decltype(_impl_.exclude_locations_)*/{}
  , /*decltype(_impl_.sources_)*/{}
  , /*decltype(_impl_.targets_)*/{}
  , /*decltype(_impl_.shape_)*/{}
  , /*decltype(_impl_.contours_)*/{}
  , /*decltype(_impl_.trace_)*/{}
  , /*decltype(_impl_.filter_attributes_)*/{}
  , /*decltype(_impl_.recostings_)*/{}
  , /*decltype(_impl_.exclude_polygons_)*/{}
  , /*decltype(_impl_.expansion_properties_)*/{}
  , /*decltype(_impl_._expansion_properties_cached_byte_size_)*/{0}
  , /*decltype(_impl_.pbf_field_selector_)*/nullptr
  , /*decltype(_impl_.units_)*/0
  , /*decltype(_impl_.directions_type_)*/0
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_.costing_type_)*/0
  , /*decltype(_impl_.date_time_type_)*/0
  , /*decltype(_impl_.shape_match_)*/0
  , /*decltype(_impl_.filter_action_)*/0
  , /*decltype(_impl_.shape_format_)*/0
  , /*decltype(_impl_.reverse_)*/false
  , /*decltype(_impl_.matrix_locations_)*/0u
  , /*decltype(_impl_.has_language_)*/{}
  , /*decltype(_impl_.has_id_)*/{}
  , /*decltype(_impl_.has_jsonp_)*/{}
  , /*decltype(_impl_.has_encoded_polyline_)*/{}
  , /*decltype(_impl_.has_range_)*/{}
  , /*decltype(_impl_.has_verbose_)*/{}
  , /*decltype(_impl_.has_date_time_)*/{}
  , /*decltype(_impl_.has_resample_distance_)*/{}
  , /*decltype(_impl_.has_polygons_)*/{}
  , /*decltype(_impl_.has_denoise_)*/{}
  , /*decltype(_impl_.has_generalize_)*/{}
  , /*decltype(_impl_.has_show_locations_)*/{}
  , /*decltype(_impl_.has_gps_accuracy_)*/{}
  , /*decltype(_impl_.has_search_radius_)*/{}
  , /*decltype(_impl_.has_turn_penalty_factor_)*/{}
  , /*decltype(_impl_.has_breakage_distance_)*/{}
  , /*decltype(_impl_.has_use_timestamps_)*/{}
  , /*decltype(_impl_.has_alternates_)*/{}
  , /*decltype(_impl_.has_interpolation_distance_)*/{}
  , /*decltype(_impl_.has_guidance_views_)*/{}
  , /*decltype(_impl_.has_height_precision_)*/{}
  , /*decltype(_impl_.has_roundabout_exits_)*/{}
  , /*decltype(_impl_.has_linear_references_)*/{}
  , /*decltype(_impl_.has_prioritize_bidirectional_)*/{}
  , /*decltype(_impl_.has_expansion_action_)*/{}
  , /*decltype(_impl_.has_skip_opposites_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct OptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptionsDefaultTypeInternal() {}
  union {
    Options _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptionsDefaultTypeInternal _Options_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool Costing_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Costing_Type_strings[12] = {};

static const char Costing_Type_names[] =
  "auto_"
  "bicycle"
  "bikeshare"
  "bus"
  "motor_scooter"
  "motorcycle"
  "multimodal"
  "none_"
  "pedestrian"
  "taxi"
  "transit"
  "truck";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Costing_Type_entries[] = {
  { {Costing_Type_names + 0, 5}, 10 },
  { {Costing_Type_names + 5, 7}, 1 },
  { {Costing_Type_names + 12, 9}, 11 },
  { {Costing_Type_names + 21, 3}, 2 },
  { {Costing_Type_names + 24, 13}, 3 },
  { {Costing_Type_names + 37, 10}, 8 },
  { {Costing_Type_names + 47, 10}, 4 },
  { {Costing_Type_names + 57, 5}, 0 },
  { {Costing_Type_names + 62, 10}, 5 },
  { {Costing_Type_names + 72, 4}, 9 },
  { {Costing_Type_names + 76, 7}, 6 },
  { {Costing_Type_names + 83, 5}, 7 },
};

static const int Costing_Type_entries_by_number[] = {
  7, // 0 -> none_
  1, // 1 -> bicycle
  3, // 2 -> bus
  4, // 3 -> motor_scooter
  6, // 4 -> multimodal
  8, // 5 -> pedestrian
  10, // 6 -> transit
  11, // 7 -> truck
  5, // 8 -> motorcycle
  9, // 9 -> taxi
  0, // 10 -> auto_
  2, // 11 -> bikeshare
};

const std::string& Costing_Type_Name(
    Costing_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Costing_Type_entries,
          Costing_Type_entries_by_number,
          12, Costing_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Costing_Type_entries,
      Costing_Type_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Costing_Type_strings[idx].get();
}
bool Costing_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Costing_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Costing_Type_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<Costing_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Costing_Type Costing::none_;
constexpr Costing_Type Costing::bicycle;
constexpr Costing_Type Costing::bus;
constexpr Costing_Type Costing::motor_scooter;
constexpr Costing_Type Costing::multimodal;
constexpr Costing_Type Costing::pedestrian;
constexpr Costing_Type Costing::transit;
constexpr Costing_Type Costing::truck;
constexpr Costing_Type Costing::motorcycle;
constexpr Costing_Type Costing::taxi;
constexpr Costing_Type Costing::auto_;
constexpr Costing_Type Costing::bikeshare;
constexpr Costing_Type Costing::Type_MIN;
constexpr Costing_Type Costing::Type_MAX;
constexpr int Costing::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Options_Units_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_Units_strings[2] = {};

static const char Options_Units_names[] =
  "kilometers"
  "miles";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_Units_entries[] = {
  { {Options_Units_names + 0, 10}, 0 },
  { {Options_Units_names + 10, 5}, 1 },
};

static const int Options_Units_entries_by_number[] = {
  0, // 0 -> kilometers
  1, // 1 -> miles
};

const std::string& Options_Units_Name(
    Options_Units value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_Units_entries,
          Options_Units_entries_by_number,
          2, Options_Units_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_Units_entries,
      Options_Units_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_Units_strings[idx].get();
}
bool Options_Units_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Units* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_Units_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Options_Units>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Options_Units Options::kilometers;
constexpr Options_Units Options::miles;
constexpr Options_Units Options::Units_MIN;
constexpr Options_Units Options::Units_MAX;
constexpr int Options::Units_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Options_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_Format_strings[4] = {};

static const char Options_Format_names[] =
  "gpx"
  "json"
  "osrm"
  "pbf";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_Format_entries[] = {
  { {Options_Format_names + 0, 3}, 1 },
  { {Options_Format_names + 3, 4}, 0 },
  { {Options_Format_names + 7, 4}, 2 },
  { {Options_Format_names + 11, 3}, 3 },
};

static const int Options_Format_entries_by_number[] = {
  1, // 0 -> json
  0, // 1 -> gpx
  2, // 2 -> osrm
  3, // 3 -> pbf
};

const std::string& Options_Format_Name(
    Options_Format value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_Format_entries,
          Options_Format_entries_by_number,
          4, Options_Format_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_Format_entries,
      Options_Format_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_Format_strings[idx].get();
}
bool Options_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Format* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_Format_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Options_Format>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Options_Format Options::json;
constexpr Options_Format Options::gpx;
constexpr Options_Format Options::osrm;
constexpr Options_Format Options::pbf;
constexpr Options_Format Options::Format_MIN;
constexpr Options_Format Options::Format_MAX;
constexpr int Options::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Options_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_Action_strings[13] = {};

static const char Options_Action_names[] =
  "centroid"
  "expansion"
  "height"
  "isochrone"
  "locate"
  "no_action"
  "optimized_route"
  "route"
  "sources_to_targets"
  "status"
  "trace_attributes"
  "trace_route"
  "transit_available";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_Action_entries[] = {
  { {Options_Action_names + 0, 8}, 11 },
  { {Options_Action_names + 8, 9}, 10 },
  { {Options_Action_names + 17, 6}, 8 },
  { {Options_Action_names + 23, 9}, 5 },
  { {Options_Action_names + 32, 6}, 2 },
  { {Options_Action_names + 38, 9}, 0 },
  { {Options_Action_names + 47, 15}, 4 },
  { {Options_Action_names + 62, 5}, 1 },
  { {Options_Action_names + 67, 18}, 3 },
  { {Options_Action_names + 85, 6}, 12 },
  { {Options_Action_names + 91, 16}, 7 },
  { {Options_Action_names + 107, 11}, 6 },
  { {Options_Action_names + 118, 17}, 9 },
};

static const int Options_Action_entries_by_number[] = {
  5, // 0 -> no_action
  7, // 1 -> route
  4, // 2 -> locate
  8, // 3 -> sources_to_targets
  6, // 4 -> optimized_route
  3, // 5 -> isochrone
  11, // 6 -> trace_route
  10, // 7 -> trace_attributes
  2, // 8 -> height
  12, // 9 -> transit_available
  1, // 10 -> expansion
  0, // 11 -> centroid
  9, // 12 -> status
};

const std::string& Options_Action_Name(
    Options_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_Action_entries,
          Options_Action_entries_by_number,
          13, Options_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_Action_entries,
      Options_Action_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_Action_strings[idx].get();
}
bool Options_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_Action_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<Options_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Options_Action Options::no_action;
constexpr Options_Action Options::route;
constexpr Options_Action Options::locate;
constexpr Options_Action Options::sources_to_targets;
constexpr Options_Action Options::optimized_route;
constexpr Options_Action Options::isochrone;
constexpr Options_Action Options::trace_route;
constexpr Options_Action Options::trace_attributes;
constexpr Options_Action Options::height;
constexpr Options_Action Options::transit_available;
constexpr Options_Action Options::expansion;
constexpr Options_Action Options::centroid;
constexpr Options_Action Options::status;
constexpr Options_Action Options::Action_MIN;
constexpr Options_Action Options::Action_MAX;
constexpr int Options::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Options_DateTimeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_DateTimeType_strings[5] = {};

static const char Options_DateTimeType_names[] =
  "arrive_by"
  "current"
  "depart_at"
  "invariant"
  "no_time";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_DateTimeType_entries[] = {
  { {Options_DateTimeType_names + 0, 9}, 3 },
  { {Options_DateTimeType_names + 9, 7}, 1 },
  { {Options_DateTimeType_names + 16, 9}, 2 },
  { {Options_DateTimeType_names + 25, 9}, 4 },
  { {Options_DateTimeType_names + 34, 7}, 0 },
};

static const int Options_DateTimeType_entries_by_number[] = {
  4, // 0 -> no_time
  1, // 1 -> current
  2, // 2 -> depart_at
  0, // 3 -> arrive_by
  3, // 4 -> invariant
};

const std::string& Options_DateTimeType_Name(
    Options_DateTimeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_DateTimeType_entries,
          Options_DateTimeType_entries_by_number,
          5, Options_DateTimeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_DateTimeType_entries,
      Options_DateTimeType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_DateTimeType_strings[idx].get();
}
bool Options_DateTimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_DateTimeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_DateTimeType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Options_DateTimeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Options_DateTimeType Options::no_time;
constexpr Options_DateTimeType Options::current;
constexpr Options_DateTimeType Options::depart_at;
constexpr Options_DateTimeType Options::arrive_by;
constexpr Options_DateTimeType Options::invariant;
constexpr Options_DateTimeType Options::DateTimeType_MIN;
constexpr Options_DateTimeType Options::DateTimeType_MAX;
constexpr int Options::DateTimeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Options_ExpansionProperties_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_ExpansionProperties_strings[5] = {};

static const char Options_ExpansionProperties_names[] =
  "costs"
  "distances"
  "durations"
  "edge_ids"
  "statuses";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_ExpansionProperties_entries[] = {
  { {Options_ExpansionProperties_names + 0, 5}, 0 },
  { {Options_ExpansionProperties_names + 5, 9}, 2 },
  { {Options_ExpansionProperties_names + 14, 9}, 1 },
  { {Options_ExpansionProperties_names + 23, 8}, 4 },
  { {Options_ExpansionProperties_names + 31, 8}, 3 },
};

static const int Options_ExpansionProperties_entries_by_number[] = {
  0, // 0 -> costs
  2, // 1 -> durations
  1, // 2 -> distances
  4, // 3 -> statuses
  3, // 4 -> edge_ids
};

const std::string& Options_ExpansionProperties_Name(
    Options_ExpansionProperties value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_ExpansionProperties_entries,
          Options_ExpansionProperties_entries_by_number,
          5, Options_ExpansionProperties_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_ExpansionProperties_entries,
      Options_ExpansionProperties_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_ExpansionProperties_strings[idx].get();
}
bool Options_ExpansionProperties_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_ExpansionProperties* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_ExpansionProperties_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Options_ExpansionProperties>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Options_ExpansionProperties Options::costs;
constexpr Options_ExpansionProperties Options::durations;
constexpr Options_ExpansionProperties Options::distances;
constexpr Options_ExpansionProperties Options::statuses;
constexpr Options_ExpansionProperties Options::edge_ids;
constexpr Options_ExpansionProperties Options::ExpansionProperties_MIN;
constexpr Options_ExpansionProperties Options::ExpansionProperties_MAX;
constexpr int Options::ExpansionProperties_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ShapeMatch_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShapeMatch_strings[3] = {};

static const char ShapeMatch_names[] =
  "edge_walk"
  "map_snap"
  "walk_or_snap";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShapeMatch_entries[] = {
  { {ShapeMatch_names + 0, 9}, 1 },
  { {ShapeMatch_names + 9, 8}, 2 },
  { {ShapeMatch_names + 17, 12}, 0 },
};

static const int ShapeMatch_entries_by_number[] = {
  2, // 0 -> walk_or_snap
  0, // 1 -> edge_walk
  1, // 2 -> map_snap
};

const std::string& ShapeMatch_Name(
    ShapeMatch value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShapeMatch_entries,
          ShapeMatch_entries_by_number,
          3, ShapeMatch_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShapeMatch_entries,
      ShapeMatch_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShapeMatch_strings[idx].get();
}
bool ShapeMatch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeMatch* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShapeMatch_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShapeMatch>(int_value);
  }
  return success;
}
bool FilterAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FilterAction_strings[3] = {};

static const char FilterAction_names[] =
  "exclude"
  "include"
  "no_action";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FilterAction_entries[] = {
  { {FilterAction_names + 0, 7}, 1 },
  { {FilterAction_names + 7, 7}, 2 },
  { {FilterAction_names + 14, 9}, 0 },
};

static const int FilterAction_entries_by_number[] = {
  2, // 0 -> no_action
  0, // 1 -> exclude
  1, // 2 -> include
};

const std::string& FilterAction_Name(
    FilterAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FilterAction_entries,
          FilterAction_entries_by_number,
          3, FilterAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FilterAction_entries,
      FilterAction_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FilterAction_strings[idx].get();
}
bool FilterAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FilterAction_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FilterAction>(int_value);
  }
  return success;
}
bool DirectionsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DirectionsType_strings[3] = {};

static const char DirectionsType_names[] =
  "instructions"
  "maneuvers"
  "none";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DirectionsType_entries[] = {
  { {DirectionsType_names + 0, 12}, 0 },
  { {DirectionsType_names + 12, 9}, 2 },
  { {DirectionsType_names + 21, 4}, 1 },
};

static const int DirectionsType_entries_by_number[] = {
  0, // 0 -> instructions
  2, // 1 -> none
  1, // 2 -> maneuvers
};

const std::string& DirectionsType_Name(
    DirectionsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DirectionsType_entries,
          DirectionsType_entries_by_number,
          3, DirectionsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DirectionsType_entries,
      DirectionsType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DirectionsType_strings[idx].get();
}
bool DirectionsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DirectionsType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DirectionsType>(int_value);
  }
  return success;
}
bool ShapeFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShapeFormat_strings[3] = {};

static const char ShapeFormat_names[] =
  "geojson"
  "polyline5"
  "polyline6";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShapeFormat_entries[] = {
  { {ShapeFormat_names + 0, 7}, 2 },
  { {ShapeFormat_names + 7, 9}, 1 },
  { {ShapeFormat_names + 16, 9}, 0 },
};

static const int ShapeFormat_entries_by_number[] = {
  2, // 0 -> polyline6
  1, // 1 -> polyline5
  0, // 2 -> geojson
};

const std::string& ShapeFormat_Name(
    ShapeFormat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShapeFormat_entries,
          ShapeFormat_entries_by_number,
          3, ShapeFormat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShapeFormat_entries,
      ShapeFormat_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShapeFormat_strings[idx].get();
}
bool ShapeFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeFormat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShapeFormat_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShapeFormat>(int_value);
  }
  return success;
}

// ===================================================================

class Contour::_Internal {
 public:
};

Contour::Contour(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Contour)
}
Contour::Contour(const Contour& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Contour* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_time_){}
    , decltype(_impl_.has_color_){}
    , decltype(_impl_.has_distance_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_time();
  switch (from.has_time_case()) {
    case kTime: {
      _this->_internal_set_time(from._internal_time());
      break;
    }
    case HAS_TIME_NOT_SET: {
      break;
    }
  }
  clear_has_has_color();
  switch (from.has_color_case()) {
    case kColor: {
      _this->_internal_set_color(from._internal_color());
      break;
    }
    case HAS_COLOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_distance();
  switch (from.has_distance_case()) {
    case kDistance: {
      _this->_internal_set_distance(from._internal_distance());
      break;
    }
    case HAS_DISTANCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.Contour)
}

inline void Contour::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_time_){}
    , decltype(_impl_.has_color_){}
    , decltype(_impl_.has_distance_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_time();
  clear_has_has_color();
  clear_has_has_distance();
}

Contour::~Contour() {
  // @@protoc_insertion_point(destructor:valhalla.Contour)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Contour::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_time()) {
    clear_has_time();
  }
  if (has_has_color()) {
    clear_has_color();
  }
  if (has_has_distance()) {
    clear_has_distance();
  }
}

void Contour::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Contour::clear_has_time() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Contour)
  switch (has_time_case()) {
    case kTime: {
      // No need to clear
      break;
    }
    case HAS_TIME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_TIME_NOT_SET;
}

void Contour::clear_has_color() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Contour)
  switch (has_color_case()) {
    case kColor: {
      _impl_.has_color_.color_.Destroy();
      break;
    }
    case HAS_COLOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_COLOR_NOT_SET;
}

void Contour::clear_has_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Contour)
  switch (has_distance_case()) {
    case kDistance: {
      // No need to clear
      break;
    }
    case HAS_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_DISTANCE_NOT_SET;
}


void Contour::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Contour)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_time();
  clear_has_color();
  clear_has_distance();
  _internal_metadata_.Clear<std::string>();
}

const char* Contour::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _internal_set_time(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _internal_set_distance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Contour::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Contour)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float time = 1;
  if (_internal_has_time()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_time(), target);
  }

  // string color = 2;
  if (_internal_has_color()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Contour.color");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_color(), target);
  }

  // float distance = 3;
  if (_internal_has_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Contour)
  return target;
}

size_t Contour::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Contour)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_time_case()) {
    // float time = 1;
    case kTime: {
      total_size += 1 + 4;
      break;
    }
    case HAS_TIME_NOT_SET: {
      break;
    }
  }
  switch (has_color_case()) {
    // string color = 2;
    case kColor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_color());
      break;
    }
    case HAS_COLOR_NOT_SET: {
      break;
    }
  }
  switch (has_distance_case()) {
    // float distance = 3;
    case kDistance: {
      total_size += 1 + 4;
      break;
    }
    case HAS_DISTANCE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Contour::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Contour*>(
      &from));
}

void Contour::MergeFrom(const Contour& from) {
  Contour* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Contour)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_time_case()) {
    case kTime: {
      _this->_internal_set_time(from._internal_time());
      break;
    }
    case HAS_TIME_NOT_SET: {
      break;
    }
  }
  switch (from.has_color_case()) {
    case kColor: {
      _this->_internal_set_color(from._internal_color());
      break;
    }
    case HAS_COLOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_distance_case()) {
    case kDistance: {
      _this->_internal_set_distance(from._internal_distance());
      break;
    }
    case HAS_DISTANCE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Contour::CopyFrom(const Contour& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Contour)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contour::IsInitialized() const {
  return true;
}

void Contour::InternalSwap(Contour* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_time_, other->_impl_.has_time_);
  swap(_impl_.has_color_, other->_impl_.has_color_);
  swap(_impl_.has_distance_, other->_impl_.has_distance_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
}

std::string Contour::GetTypeName() const {
  return "valhalla.Contour";
}


// ===================================================================

class Ring::_Internal {
 public:
};

void Ring::clear_coords() {
  _impl_.coords_.Clear();
}
Ring::Ring(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Ring)
}
Ring::Ring(const Ring& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Ring* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.coords_){from._impl_.coords_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.Ring)
}

inline void Ring::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.coords_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Ring::~Ring() {
  // @@protoc_insertion_point(destructor:valhalla.Ring)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ring::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.coords_.~RepeatedPtrField();
}

void Ring::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ring::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Ring)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.coords_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ring::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.LatLng coords = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coords(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ring::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Ring)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.LatLng coords = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coords_size()); i < n; i++) {
    const auto& repfield = this->_internal_coords(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Ring)
  return target;
}

size_t Ring::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Ring)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.LatLng coords = 1;
  total_size += 1UL * this->_internal_coords_size();
  for (const auto& msg : this->_impl_.coords_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ring::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ring*>(
      &from));
}

void Ring::MergeFrom(const Ring& from) {
  Ring* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Ring)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.coords_.MergeFrom(from._impl_.coords_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ring::CopyFrom(const Ring& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Ring)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ring::IsInitialized() const {
  return true;
}

void Ring::InternalSwap(Ring* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.coords_.InternalSwap(&other->_impl_.coords_);
}

std::string Ring::GetTypeName() const {
  return "valhalla.Ring";
}


// ===================================================================

class PbfFieldSelector::_Internal {
 public:
};

PbfFieldSelector::PbfFieldSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.PbfFieldSelector)
}
PbfFieldSelector::PbfFieldSelector(const PbfFieldSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PbfFieldSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.options_){}
    , decltype(_impl_.trip_){}
    , decltype(_impl_.directions_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.options_, &from._impl_.options_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.options_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:valhalla.PbfFieldSelector)
}

inline void PbfFieldSelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.options_){false}
    , decltype(_impl_.trip_){false}
    , decltype(_impl_.directions_){false}
    , decltype(_impl_.status_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PbfFieldSelector::~PbfFieldSelector() {
  // @@protoc_insertion_point(destructor:valhalla.PbfFieldSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbfFieldSelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PbfFieldSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbfFieldSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.PbfFieldSelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.options_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.options_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<std::string>();
}

const char* PbfFieldSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.options_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool trip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.trip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool directions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.directions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PbfFieldSelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.PbfFieldSelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool options = 1;
  if (this->_internal_options() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_options(), target);
  }

  // bool trip = 2;
  if (this->_internal_trip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_trip(), target);
  }

  // bool directions = 3;
  if (this->_internal_directions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_directions(), target);
  }

  // bool status = 4;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.PbfFieldSelector)
  return target;
}

size_t PbfFieldSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.PbfFieldSelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool options = 1;
  if (this->_internal_options() != 0) {
    total_size += 1 + 1;
  }

  // bool trip = 2;
  if (this->_internal_trip() != 0) {
    total_size += 1 + 1;
  }

  // bool directions = 3;
  if (this->_internal_directions() != 0) {
    total_size += 1 + 1;
  }

  // bool status = 4;
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PbfFieldSelector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PbfFieldSelector*>(
      &from));
}

void PbfFieldSelector::MergeFrom(const PbfFieldSelector& from) {
  PbfFieldSelector* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.PbfFieldSelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_options() != 0) {
    _this->_internal_set_options(from._internal_options());
  }
  if (from._internal_trip() != 0) {
    _this->_internal_set_trip(from._internal_trip());
  }
  if (from._internal_directions() != 0) {
    _this->_internal_set_directions(from._internal_directions());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PbfFieldSelector::CopyFrom(const PbfFieldSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.PbfFieldSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbfFieldSelector::IsInitialized() const {
  return true;
}

void PbfFieldSelector::InternalSwap(PbfFieldSelector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.status_)
      + sizeof(PbfFieldSelector::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(PbfFieldSelector, _impl_.options_)>(
          reinterpret_cast<char*>(&_impl_.options_),
          reinterpret_cast<char*>(&other->_impl_.options_));
}

std::string PbfFieldSelector::GetTypeName() const {
  return "valhalla.PbfFieldSelector";
}


// ===================================================================

class AvoidEdge::_Internal {
 public:
};

AvoidEdge::AvoidEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.AvoidEdge)
}
AvoidEdge::AvoidEdge(const AvoidEdge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AvoidEdge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_id_){}
    , decltype(_impl_.has_percent_along_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_id();
  switch (from.has_id_case()) {
    case kId: {
      _this->_internal_set_id(from._internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_percent_along();
  switch (from.has_percent_along_case()) {
    case kPercentAlong: {
      _this->_internal_set_percent_along(from._internal_percent_along());
      break;
    }
    case HAS_PERCENT_ALONG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.AvoidEdge)
}

inline void AvoidEdge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_id_){}
    , decltype(_impl_.has_percent_along_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_id();
  clear_has_has_percent_along();
}

AvoidEdge::~AvoidEdge() {
  // @@protoc_insertion_point(destructor:valhalla.AvoidEdge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AvoidEdge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_id()) {
    clear_has_id();
  }
  if (has_has_percent_along()) {
    clear_has_percent_along();
  }
}

void AvoidEdge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AvoidEdge::clear_has_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.AvoidEdge)
  switch (has_id_case()) {
    case kId: {
      // No need to clear
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_ID_NOT_SET;
}

void AvoidEdge::clear_has_percent_along() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.AvoidEdge)
  switch (has_percent_along_case()) {
    case kPercentAlong: {
      // No need to clear
      break;
    }
    case HAS_PERCENT_ALONG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_PERCENT_ALONG_NOT_SET;
}


void AvoidEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.AvoidEdge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_id();
  clear_has_percent_along();
  _internal_metadata_.Clear<std::string>();
}

const char* AvoidEdge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float percent_along = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_percent_along(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvoidEdge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.AvoidEdge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // float percent_along = 2;
  if (_internal_has_percent_along()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_percent_along(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.AvoidEdge)
  return target;
}

size_t AvoidEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.AvoidEdge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_id_case()) {
    // uint64 id = 1;
    case kId: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (has_percent_along_case()) {
    // float percent_along = 2;
    case kPercentAlong: {
      total_size += 1 + 4;
      break;
    }
    case HAS_PERCENT_ALONG_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvoidEdge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AvoidEdge*>(
      &from));
}

void AvoidEdge::MergeFrom(const AvoidEdge& from) {
  AvoidEdge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.AvoidEdge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_id_case()) {
    case kId: {
      _this->_internal_set_id(from._internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_percent_along_case()) {
    case kPercentAlong: {
      _this->_internal_set_percent_along(from._internal_percent_along());
      break;
    }
    case HAS_PERCENT_ALONG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvoidEdge::CopyFrom(const AvoidEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.AvoidEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvoidEdge::IsInitialized() const {
  return true;
}

void AvoidEdge::InternalSwap(AvoidEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_id_, other->_impl_.has_id_);
  swap(_impl_.has_percent_along_, other->_impl_.has_percent_along_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string AvoidEdge::GetTypeName() const {
  return "valhalla.AvoidEdge";
}


// ===================================================================

class Costing_Options::_Internal {
 public:
};

Costing_Options::Costing_Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Costing.Options)
}
Costing_Options::Costing_Options(const Costing_Options& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Costing_Options* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.filter_stop_ids_){from._impl_.filter_stop_ids_}
    , decltype(_impl_.filter_operator_ids_){from._impl_.filter_operator_ids_}
    , decltype(_impl_.filter_route_ids_){from._impl_.filter_route_ids_}
    , decltype(_impl_.exclude_edges_){from._impl_.exclude_edges_}
    , decltype(_impl_.filter_stop_action_){}
    , decltype(_impl_.filter_operator_action_){}
    , decltype(_impl_.filter_route_action_){}
    , decltype(_impl_.has_maneuver_penalty_){}
    , decltype(_impl_.has_destination_only_penalty_){}
    , decltype(_impl_.has_gate_cost_){}
    , decltype(_impl_.has_gate_penalty_){}
    , decltype(_impl_.has_toll_booth_cost_){}
    , decltype(_impl_.has_toll_booth_penalty_){}
    , decltype(_impl_.has_alley_penalty_){}
    , decltype(_impl_.has_country_crossing_cost_){}
    , decltype(_impl_.has_country_crossing_penalty_){}
    , decltype(_impl_.has_ferry_cost_){}
    , decltype(_impl_.has_avoid_bad_surfaces_){}
    , decltype(_impl_.has_use_ferry_){}
    , decltype(_impl_.has_use_highways_){}
    , decltype(_impl_.has_use_tolls_){}
    , decltype(_impl_.has_use_roads_){}
    , decltype(_impl_.has_max_distance_){}
    , decltype(_impl_.has_walking_speed_){}
    , decltype(_impl_.has_step_penalty_){}
    , decltype(_impl_.has_max_grade_){}
    , decltype(_impl_.has_max_hiking_difficulty_){}
    , decltype(_impl_.has_mode_factor_){}
    , decltype(_impl_.has_walkway_factor_){}
    , decltype(_impl_.has_sidewalk_factor_){}
    , decltype(_impl_.has_alley_factor_){}
    , decltype(_impl_.has_driveway_factor_){}
    , decltype(_impl_.has_driveway_penalty_){}
    , decltype(_impl_.has_transit_start_end_max_distance_){}
    , decltype(_impl_.has_transit_transfer_max_distance_){}
    , decltype(_impl_.has_transport_type_){}
    , decltype(_impl_.has_top_speed_){}
    , decltype(_impl_.has_use_hills_){}
    , decltype(_impl_.has_use_primary_){}
    , decltype(_impl_.has_use_trails_){}
    , decltype(_impl_.has_low_class_penalty_){}
    , decltype(_impl_.has_hazmat_){}
    , decltype(_impl_.has_weight_){}
    , decltype(_impl_.has_axle_load_){}
    , decltype(_impl_.has_height_){}
    , decltype(_impl_.has_width_){}
    , decltype(_impl_.has_length_){}
    , decltype(_impl_.has_cycling_speed_){}
    , decltype(_impl_.has_wheelchair_){}
    , decltype(_impl_.has_bicycle_){}
    , decltype(_impl_.has_use_bus_){}
    , decltype(_impl_.has_use_rail_){}
    , decltype(_impl_.has_use_transfers_){}
    , decltype(_impl_.has_transfer_cost_){}
    , decltype(_impl_.has_transfer_penalty_){}
    , decltype(_impl_.has_flow_mask_){}
    , decltype(_impl_.has_bike_share_cost_){}
    , decltype(_impl_.has_bike_share_penalty_){}
    , decltype(_impl_.has_rail_ferry_cost_){}
    , decltype(_impl_.has_use_rail_ferry_){}
    , decltype(_impl_.has_ignore_restrictions_){}
    , decltype(_impl_.has_ignore_oneways_){}
    , decltype(_impl_.has_ignore_access_){}
    , decltype(_impl_.has_ignore_closures_){}
    , decltype(_impl_.has_shortest_){}
    , decltype(_impl_.has_service_penalty_){}
    , decltype(_impl_.has_use_tracks_){}
    , decltype(_impl_.has_use_distance_){}
    , decltype(_impl_.has_use_living_streets_){}
    , decltype(_impl_.has_service_factor_){}
    , decltype(_impl_.has_closure_factor_){}
    , decltype(_impl_.has_private_access_penalty_){}
    , decltype(_impl_.has_exclude_unpaved_){}
    , decltype(_impl_.has_include_hot_){}
    , decltype(_impl_.has_include_hov2_){}
    , decltype(_impl_.has_include_hov3_){}
    , decltype(_impl_.has_exclude_cash_only_tolls_){}
    , decltype(_impl_.has_restriction_probability_){}
    , decltype(_impl_.has_elevator_penalty_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.filter_stop_action_, &from._impl_.filter_stop_action_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.filter_route_action_) -
    reinterpret_cast<char*>(&_impl_.filter_stop_action_)) + sizeof(_impl_.filter_route_action_));
  clear_has_has_maneuver_penalty();
  switch (from.has_maneuver_penalty_case()) {
    case kManeuverPenalty: {
      _this->_internal_set_maneuver_penalty(from._internal_maneuver_penalty());
      break;
    }
    case HAS_MANEUVER_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_destination_only_penalty();
  switch (from.has_destination_only_penalty_case()) {
    case kDestinationOnlyPenalty: {
      _this->_internal_set_destination_only_penalty(from._internal_destination_only_penalty());
      break;
    }
    case HAS_DESTINATION_ONLY_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_gate_cost();
  switch (from.has_gate_cost_case()) {
    case kGateCost: {
      _this->_internal_set_gate_cost(from._internal_gate_cost());
      break;
    }
    case HAS_GATE_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_gate_penalty();
  switch (from.has_gate_penalty_case()) {
    case kGatePenalty: {
      _this->_internal_set_gate_penalty(from._internal_gate_penalty());
      break;
    }
    case HAS_GATE_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_toll_booth_cost();
  switch (from.has_toll_booth_cost_case()) {
    case kTollBoothCost: {
      _this->_internal_set_toll_booth_cost(from._internal_toll_booth_cost());
      break;
    }
    case HAS_TOLL_BOOTH_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_toll_booth_penalty();
  switch (from.has_toll_booth_penalty_case()) {
    case kTollBoothPenalty: {
      _this->_internal_set_toll_booth_penalty(from._internal_toll_booth_penalty());
      break;
    }
    case HAS_TOLL_BOOTH_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_alley_penalty();
  switch (from.has_alley_penalty_case()) {
    case kAlleyPenalty: {
      _this->_internal_set_alley_penalty(from._internal_alley_penalty());
      break;
    }
    case HAS_ALLEY_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_country_crossing_cost();
  switch (from.has_country_crossing_cost_case()) {
    case kCountryCrossingCost: {
      _this->_internal_set_country_crossing_cost(from._internal_country_crossing_cost());
      break;
    }
    case HAS_COUNTRY_CROSSING_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_country_crossing_penalty();
  switch (from.has_country_crossing_penalty_case()) {
    case kCountryCrossingPenalty: {
      _this->_internal_set_country_crossing_penalty(from._internal_country_crossing_penalty());
      break;
    }
    case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_ferry_cost();
  switch (from.has_ferry_cost_case()) {
    case kFerryCost: {
      _this->_internal_set_ferry_cost(from._internal_ferry_cost());
      break;
    }
    case HAS_FERRY_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_avoid_bad_surfaces();
  switch (from.has_avoid_bad_surfaces_case()) {
    case kAvoidBadSurfaces: {
      _this->_internal_set_avoid_bad_surfaces(from._internal_avoid_bad_surfaces());
      break;
    }
    case HAS_AVOID_BAD_SURFACES_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_ferry();
  switch (from.has_use_ferry_case()) {
    case kUseFerry: {
      _this->_internal_set_use_ferry(from._internal_use_ferry());
      break;
    }
    case HAS_USE_FERRY_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_highways();
  switch (from.has_use_highways_case()) {
    case kUseHighways: {
      _this->_internal_set_use_highways(from._internal_use_highways());
      break;
    }
    case HAS_USE_HIGHWAYS_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_tolls();
  switch (from.has_use_tolls_case()) {
    case kUseTolls: {
      _this->_internal_set_use_tolls(from._internal_use_tolls());
      break;
    }
    case HAS_USE_TOLLS_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_roads();
  switch (from.has_use_roads_case()) {
    case kUseRoads: {
      _this->_internal_set_use_roads(from._internal_use_roads());
      break;
    }
    case HAS_USE_ROADS_NOT_SET: {
      break;
    }
  }
  clear_has_has_max_distance();
  switch (from.has_max_distance_case()) {
    case kMaxDistance: {
      _this->_internal_set_max_distance(from._internal_max_distance());
      break;
    }
    case HAS_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_walking_speed();
  switch (from.has_walking_speed_case()) {
    case kWalkingSpeed: {
      _this->_internal_set_walking_speed(from._internal_walking_speed());
      break;
    }
    case HAS_WALKING_SPEED_NOT_SET: {
      break;
    }
  }
  clear_has_has_step_penalty();
  switch (from.has_step_penalty_case()) {
    case kStepPenalty: {
      _this->_internal_set_step_penalty(from._internal_step_penalty());
      break;
    }
    case HAS_STEP_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_max_grade();
  switch (from.has_max_grade_case()) {
    case kMaxGrade: {
      _this->_internal_set_max_grade(from._internal_max_grade());
      break;
    }
    case HAS_MAX_GRADE_NOT_SET: {
      break;
    }
  }
  clear_has_has_max_hiking_difficulty();
  switch (from.has_max_hiking_difficulty_case()) {
    case kMaxHikingDifficulty: {
      _this->_internal_set_max_hiking_difficulty(from._internal_max_hiking_difficulty());
      break;
    }
    case HAS_MAX_HIKING_DIFFICULTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_mode_factor();
  switch (from.has_mode_factor_case()) {
    case kModeFactor: {
      _this->_internal_set_mode_factor(from._internal_mode_factor());
      break;
    }
    case HAS_MODE_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_walkway_factor();
  switch (from.has_walkway_factor_case()) {
    case kWalkwayFactor: {
      _this->_internal_set_walkway_factor(from._internal_walkway_factor());
      break;
    }
    case HAS_WALKWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_sidewalk_factor();
  switch (from.has_sidewalk_factor_case()) {
    case kSidewalkFactor: {
      _this->_internal_set_sidewalk_factor(from._internal_sidewalk_factor());
      break;
    }
    case HAS_SIDEWALK_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_alley_factor();
  switch (from.has_alley_factor_case()) {
    case kAlleyFactor: {
      _this->_internal_set_alley_factor(from._internal_alley_factor());
      break;
    }
    case HAS_ALLEY_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_driveway_factor();
  switch (from.has_driveway_factor_case()) {
    case kDrivewayFactor: {
      _this->_internal_set_driveway_factor(from._internal_driveway_factor());
      break;
    }
    case HAS_DRIVEWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_driveway_penalty();
  switch (from.has_driveway_penalty_case()) {
    case kDrivewayPenalty: {
      _this->_internal_set_driveway_penalty(from._internal_driveway_penalty());
      break;
    }
    case HAS_DRIVEWAY_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_transit_start_end_max_distance();
  switch (from.has_transit_start_end_max_distance_case()) {
    case kTransitStartEndMaxDistance: {
      _this->_internal_set_transit_start_end_max_distance(from._internal_transit_start_end_max_distance());
      break;
    }
    case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_transit_transfer_max_distance();
  switch (from.has_transit_transfer_max_distance_case()) {
    case kTransitTransferMaxDistance: {
      _this->_internal_set_transit_transfer_max_distance(from._internal_transit_transfer_max_distance());
      break;
    }
    case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_transport_type();
  switch (from.has_transport_type_case()) {
    case kTransportType: {
      _this->_internal_set_transport_type(from._internal_transport_type());
      break;
    }
    case HAS_TRANSPORT_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_has_top_speed();
  switch (from.has_top_speed_case()) {
    case kTopSpeed: {
      _this->_internal_set_top_speed(from._internal_top_speed());
      break;
    }
    case HAS_TOP_SPEED_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_hills();
  switch (from.has_use_hills_case()) {
    case kUseHills: {
      _this->_internal_set_use_hills(from._internal_use_hills());
      break;
    }
    case HAS_USE_HILLS_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_primary();
  switch (from.has_use_primary_case()) {
    case kUsePrimary: {
      _this->_internal_set_use_primary(from._internal_use_primary());
      break;
    }
    case HAS_USE_PRIMARY_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_trails();
  switch (from.has_use_trails_case()) {
    case kUseTrails: {
      _this->_internal_set_use_trails(from._internal_use_trails());
      break;
    }
    case HAS_USE_TRAILS_NOT_SET: {
      break;
    }
  }
  clear_has_has_low_class_penalty();
  switch (from.has_low_class_penalty_case()) {
    case kLowClassPenalty: {
      _this->_internal_set_low_class_penalty(from._internal_low_class_penalty());
      break;
    }
    case HAS_LOW_CLASS_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_hazmat();
  switch (from.has_hazmat_case()) {
    case kHazmat: {
      _this->_internal_set_hazmat(from._internal_hazmat());
      break;
    }
    case HAS_HAZMAT_NOT_SET: {
      break;
    }
  }
  clear_has_has_weight();
  switch (from.has_weight_case()) {
    case kWeight: {
      _this->_internal_set_weight(from._internal_weight());
      break;
    }
    case HAS_WEIGHT_NOT_SET: {
      break;
    }
  }
  clear_has_has_axle_load();
  switch (from.has_axle_load_case()) {
    case kAxleLoad: {
      _this->_internal_set_axle_load(from._internal_axle_load());
      break;
    }
    case HAS_AXLE_LOAD_NOT_SET: {
      break;
    }
  }
  clear_has_has_height();
  switch (from.has_height_case()) {
    case kHeight: {
      _this->_internal_set_height(from._internal_height());
      break;
    }
    case HAS_HEIGHT_NOT_SET: {
      break;
    }
  }
  clear_has_has_width();
  switch (from.has_width_case()) {
    case kWidth: {
      _this->_internal_set_width(from._internal_width());
      break;
    }
    case HAS_WIDTH_NOT_SET: {
      break;
    }
  }
  clear_has_has_length();
  switch (from.has_length_case()) {
    case kLength: {
      _this->_internal_set_length(from._internal_length());
      break;
    }
    case HAS_LENGTH_NOT_SET: {
      break;
    }
  }
  clear_has_has_cycling_speed();
  switch (from.has_cycling_speed_case()) {
    case kCyclingSpeed: {
      _this->_internal_set_cycling_speed(from._internal_cycling_speed());
      break;
    }
    case HAS_CYCLING_SPEED_NOT_SET: {
      break;
    }
  }
  clear_has_has_wheelchair();
  switch (from.has_wheelchair_case()) {
    case kWheelchair: {
      _this->_internal_set_wheelchair(from._internal_wheelchair());
      break;
    }
    case HAS_WHEELCHAIR_NOT_SET: {
      break;
    }
  }
  clear_has_has_bicycle();
  switch (from.has_bicycle_case()) {
    case kBicycle: {
      _this->_internal_set_bicycle(from._internal_bicycle());
      break;
    }
    case HAS_BICYCLE_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_bus();
  switch (from.has_use_bus_case()) {
    case kUseBus: {
      _this->_internal_set_use_bus(from._internal_use_bus());
      break;
    }
    case HAS_USE_BUS_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_rail();
  switch (from.has_use_rail_case()) {
    case kUseRail: {
      _this->_internal_set_use_rail(from._internal_use_rail());
      break;
    }
    case HAS_USE_RAIL_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_transfers();
  switch (from.has_use_transfers_case()) {
    case kUseTransfers: {
      _this->_internal_set_use_transfers(from._internal_use_transfers());
      break;
    }
    case HAS_USE_TRANSFERS_NOT_SET: {
      break;
    }
  }
  clear_has_has_transfer_cost();
  switch (from.has_transfer_cost_case()) {
    case kTransferCost: {
      _this->_internal_set_transfer_cost(from._internal_transfer_cost());
      break;
    }
    case HAS_TRANSFER_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_transfer_penalty();
  switch (from.has_transfer_penalty_case()) {
    case kTransferPenalty: {
      _this->_internal_set_transfer_penalty(from._internal_transfer_penalty());
      break;
    }
    case HAS_TRANSFER_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_flow_mask();
  switch (from.has_flow_mask_case()) {
    case kFlowMask: {
      _this->_internal_set_flow_mask(from._internal_flow_mask());
      break;
    }
    case HAS_FLOW_MASK_NOT_SET: {
      break;
    }
  }
  clear_has_has_bike_share_cost();
  switch (from.has_bike_share_cost_case()) {
    case kBikeShareCost: {
      _this->_internal_set_bike_share_cost(from._internal_bike_share_cost());
      break;
    }
    case HAS_BIKE_SHARE_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_bike_share_penalty();
  switch (from.has_bike_share_penalty_case()) {
    case kBikeSharePenalty: {
      _this->_internal_set_bike_share_penalty(from._internal_bike_share_penalty());
      break;
    }
    case HAS_BIKE_SHARE_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_rail_ferry_cost();
  switch (from.has_rail_ferry_cost_case()) {
    case kRailFerryCost: {
      _this->_internal_set_rail_ferry_cost(from._internal_rail_ferry_cost());
      break;
    }
    case HAS_RAIL_FERRY_COST_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_rail_ferry();
  switch (from.has_use_rail_ferry_case()) {
    case kUseRailFerry: {
      _this->_internal_set_use_rail_ferry(from._internal_use_rail_ferry());
      break;
    }
    case HAS_USE_RAIL_FERRY_NOT_SET: {
      break;
    }
  }
  clear_has_has_ignore_restrictions();
  switch (from.has_ignore_restrictions_case()) {
    case kIgnoreRestrictions: {
      _this->_internal_set_ignore_restrictions(from._internal_ignore_restrictions());
      break;
    }
    case HAS_IGNORE_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  clear_has_has_ignore_oneways();
  switch (from.has_ignore_oneways_case()) {
    case kIgnoreOneways: {
      _this->_internal_set_ignore_oneways(from._internal_ignore_oneways());
      break;
    }
    case HAS_IGNORE_ONEWAYS_NOT_SET: {
      break;
    }
  }
  clear_has_has_ignore_access();
  switch (from.has_ignore_access_case()) {
    case kIgnoreAccess: {
      _this->_internal_set_ignore_access(from._internal_ignore_access());
      break;
    }
    case HAS_IGNORE_ACCESS_NOT_SET: {
      break;
    }
  }
  clear_has_has_ignore_closures();
  switch (from.has_ignore_closures_case()) {
    case kIgnoreClosures: {
      _this->_internal_set_ignore_closures(from._internal_ignore_closures());
      break;
    }
    case HAS_IGNORE_CLOSURES_NOT_SET: {
      break;
    }
  }
  clear_has_has_shortest();
  switch (from.has_shortest_case()) {
    case kShortest: {
      _this->_internal_set_shortest(from._internal_shortest());
      break;
    }
    case HAS_SHORTEST_NOT_SET: {
      break;
    }
  }
  clear_has_has_service_penalty();
  switch (from.has_service_penalty_case()) {
    case kServicePenalty: {
      _this->_internal_set_service_penalty(from._internal_service_penalty());
      break;
    }
    case HAS_SERVICE_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_tracks();
  switch (from.has_use_tracks_case()) {
    case kUseTracks: {
      _this->_internal_set_use_tracks(from._internal_use_tracks());
      break;
    }
    case HAS_USE_TRACKS_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_distance();
  switch (from.has_use_distance_case()) {
    case kUseDistance: {
      _this->_internal_set_use_distance(from._internal_use_distance());
      break;
    }
    case HAS_USE_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_living_streets();
  switch (from.has_use_living_streets_case()) {
    case kUseLivingStreets: {
      _this->_internal_set_use_living_streets(from._internal_use_living_streets());
      break;
    }
    case HAS_USE_LIVING_STREETS_NOT_SET: {
      break;
    }
  }
  clear_has_has_service_factor();
  switch (from.has_service_factor_case()) {
    case kServiceFactor: {
      _this->_internal_set_service_factor(from._internal_service_factor());
      break;
    }
    case HAS_SERVICE_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_closure_factor();
  switch (from.has_closure_factor_case()) {
    case kClosureFactor: {
      _this->_internal_set_closure_factor(from._internal_closure_factor());
      break;
    }
    case HAS_CLOSURE_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_private_access_penalty();
  switch (from.has_private_access_penalty_case()) {
    case kPrivateAccessPenalty: {
      _this->_internal_set_private_access_penalty(from._internal_private_access_penalty());
      break;
    }
    case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET: {
      break;
    }
  }
  clear_has_has_exclude_unpaved();
  switch (from.has_exclude_unpaved_case()) {
    case kExcludeUnpaved: {
      _this->_internal_set_exclude_unpaved(from._internal_exclude_unpaved());
      break;
    }
    case HAS_EXCLUDE_UNPAVED_NOT_SET: {
      break;
    }
  }
  clear_has_has_include_hot();
  switch (from.has_include_hot_case()) {
    case kIncludeHot: {
      _this->_internal_set_include_hot(from._internal_include_hot());
      break;
    }
    case HAS_INCLUDE_HOT_NOT_SET: {
      break;
    }
  }
  clear_has_has_include_hov2();
  switch (from.has_include_hov2_case()) {
    case kIncludeHov2: {
      _this->_internal_set_include_hov2(from._internal_include_hov2());
      break;
    }
    case HAS_INCLUDE_HOV2_NOT_SET: {
      break;
    }
  }
  clear_has_has_include_hov3();
  switch (from.has_include_hov3_case()) {
    case kIncludeHov3: {
      _this->_internal_set_include_hov3(from._internal_include_hov3());
      break;
    }
    case HAS_INCLUDE_HOV3_NOT_SET: {
      break;
    }
  }
  clear_has_has_exclude_cash_only_tolls();
  switch (from.has_exclude_cash_only_tolls_case()) {
    case kExcludeCashOnlyTolls: {
      _this->_internal_set_exclude_cash_only_tolls(from._internal_exclude_cash_only_tolls());
      break;
    }
    case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET: {
      break;
    }
  }
  clear_has_has_restriction_probability();
  switch (from.has_restriction_probability_case()) {
    case kRestrictionProbability: {
      _this->_internal_set_restriction_probability(from._internal_restriction_probability());
      break;
    }
    case HAS_RESTRICTION_PROBABILITY_NOT_SET: {
      break;
    }
  }
  clear_has_has_elevator_penalty();
  switch (from.has_elevator_penalty_case()) {
    case kElevatorPenalty: {
      _this->_internal_set_elevator_penalty(from._internal_elevator_penalty());
      break;
    }
    case HAS_ELEVATOR_PENALTY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.Costing.Options)
}

inline void Costing_Options::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.filter_stop_ids_){arena}
    , decltype(_impl_.filter_operator_ids_){arena}
    , decltype(_impl_.filter_route_ids_){arena}
    , decltype(_impl_.exclude_edges_){arena}
    , decltype(_impl_.filter_stop_action_){0}
    , decltype(_impl_.filter_operator_action_){0}
    , decltype(_impl_.filter_route_action_){0}
    , decltype(_impl_.has_maneuver_penalty_){}
    , decltype(_impl_.has_destination_only_penalty_){}
    , decltype(_impl_.has_gate_cost_){}
    , decltype(_impl_.has_gate_penalty_){}
    , decltype(_impl_.has_toll_booth_cost_){}
    , decltype(_impl_.has_toll_booth_penalty_){}
    , decltype(_impl_.has_alley_penalty_){}
    , decltype(_impl_.has_country_crossing_cost_){}
    , decltype(_impl_.has_country_crossing_penalty_){}
    , decltype(_impl_.has_ferry_cost_){}
    , decltype(_impl_.has_avoid_bad_surfaces_){}
    , decltype(_impl_.has_use_ferry_){}
    , decltype(_impl_.has_use_highways_){}
    , decltype(_impl_.has_use_tolls_){}
    , decltype(_impl_.has_use_roads_){}
    , decltype(_impl_.has_max_distance_){}
    , decltype(_impl_.has_walking_speed_){}
    , decltype(_impl_.has_step_penalty_){}
    , decltype(_impl_.has_max_grade_){}
    , decltype(_impl_.has_max_hiking_difficulty_){}
    , decltype(_impl_.has_mode_factor_){}
    , decltype(_impl_.has_walkway_factor_){}
    , decltype(_impl_.has_sidewalk_factor_){}
    , decltype(_impl_.has_alley_factor_){}
    , decltype(_impl_.has_driveway_factor_){}
    , decltype(_impl_.has_driveway_penalty_){}
    , decltype(_impl_.has_transit_start_end_max_distance_){}
    , decltype(_impl_.has_transit_transfer_max_distance_){}
    , decltype(_impl_.has_transport_type_){}
    , decltype(_impl_.has_top_speed_){}
    , decltype(_impl_.has_use_hills_){}
    , decltype(_impl_.has_use_primary_){}
    , decltype(_impl_.has_use_trails_){}
    , decltype(_impl_.has_low_class_penalty_){}
    , decltype(_impl_.has_hazmat_){}
    , decltype(_impl_.has_weight_){}
    , decltype(_impl_.has_axle_load_){}
    , decltype(_impl_.has_height_){}
    , decltype(_impl_.has_width_){}
    , decltype(_impl_.has_length_){}
    , decltype(_impl_.has_cycling_speed_){}
    , decltype(_impl_.has_wheelchair_){}
    , decltype(_impl_.has_bicycle_){}
    , decltype(_impl_.has_use_bus_){}
    , decltype(_impl_.has_use_rail_){}
    , decltype(_impl_.has_use_transfers_){}
    , decltype(_impl_.has_transfer_cost_){}
    , decltype(_impl_.has_transfer_penalty_){}
    , decltype(_impl_.has_flow_mask_){}
    , decltype(_impl_.has_bike_share_cost_){}
    , decltype(_impl_.has_bike_share_penalty_){}
    , decltype(_impl_.has_rail_ferry_cost_){}
    , decltype(_impl_.has_use_rail_ferry_){}
    , decltype(_impl_.has_ignore_restrictions_){}
    , decltype(_impl_.has_ignore_oneways_){}
    , decltype(_impl_.has_ignore_access_){}
    , decltype(_impl_.has_ignore_closures_){}
    , decltype(_impl_.has_shortest_){}
    , decltype(_impl_.has_service_penalty_){}
    , decltype(_impl_.has_use_tracks_){}
    , decltype(_impl_.has_use_distance_){}
    , decltype(_impl_.has_use_living_streets_){}
    , decltype(_impl_.has_service_factor_){}
    , decltype(_impl_.has_closure_factor_){}
    , decltype(_impl_.has_private_access_penalty_){}
    , decltype(_impl_.has_exclude_unpaved_){}
    , decltype(_impl_.has_include_hot_){}
    , decltype(_impl_.has_include_hov2_){}
    , decltype(_impl_.has_include_hov3_){}
    , decltype(_impl_.has_exclude_cash_only_tolls_){}
    , decltype(_impl_.has_restriction_probability_){}
    , decltype(_impl_.has_elevator_penalty_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_maneuver_penalty();
  clear_has_has_destination_only_penalty();
  clear_has_has_gate_cost();
  clear_has_has_gate_penalty();
  clear_has_has_toll_booth_cost();
  clear_has_has_toll_booth_penalty();
  clear_has_has_alley_penalty();
  clear_has_has_country_crossing_cost();
  clear_has_has_country_crossing_penalty();
  clear_has_has_ferry_cost();
  clear_has_has_avoid_bad_surfaces();
  clear_has_has_use_ferry();
  clear_has_has_use_highways();
  clear_has_has_use_tolls();
  clear_has_has_use_roads();
  clear_has_has_max_distance();
  clear_has_has_walking_speed();
  clear_has_has_step_penalty();
  clear_has_has_max_grade();
  clear_has_has_max_hiking_difficulty();
  clear_has_has_mode_factor();
  clear_has_has_walkway_factor();
  clear_has_has_sidewalk_factor();
  clear_has_has_alley_factor();
  clear_has_has_driveway_factor();
  clear_has_has_driveway_penalty();
  clear_has_has_transit_start_end_max_distance();
  clear_has_has_transit_transfer_max_distance();
  clear_has_has_transport_type();
  clear_has_has_top_speed();
  clear_has_has_use_hills();
  clear_has_has_use_primary();
  clear_has_has_use_trails();
  clear_has_has_low_class_penalty();
  clear_has_has_hazmat();
  clear_has_has_weight();
  clear_has_has_axle_load();
  clear_has_has_height();
  clear_has_has_width();
  clear_has_has_length();
  clear_has_has_cycling_speed();
  clear_has_has_wheelchair();
  clear_has_has_bicycle();
  clear_has_has_use_bus();
  clear_has_has_use_rail();
  clear_has_has_use_transfers();
  clear_has_has_transfer_cost();
  clear_has_has_transfer_penalty();
  clear_has_has_flow_mask();
  clear_has_has_bike_share_cost();
  clear_has_has_bike_share_penalty();
  clear_has_has_rail_ferry_cost();
  clear_has_has_use_rail_ferry();
  clear_has_has_ignore_restrictions();
  clear_has_has_ignore_oneways();
  clear_has_has_ignore_access();
  clear_has_has_ignore_closures();
  clear_has_has_shortest();
  clear_has_has_service_penalty();
  clear_has_has_use_tracks();
  clear_has_has_use_distance();
  clear_has_has_use_living_streets();
  clear_has_has_service_factor();
  clear_has_has_closure_factor();
  clear_has_has_private_access_penalty();
  clear_has_has_exclude_unpaved();
  clear_has_has_include_hot();
  clear_has_has_include_hov2();
  clear_has_has_include_hov3();
  clear_has_has_exclude_cash_only_tolls();
  clear_has_has_restriction_probability();
  clear_has_has_elevator_penalty();
}

Costing_Options::~Costing_Options() {
  // @@protoc_insertion_point(destructor:valhalla.Costing.Options)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Costing_Options::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filter_stop_ids_.~RepeatedPtrField();
  _impl_.filter_operator_ids_.~RepeatedPtrField();
  _impl_.filter_route_ids_.~RepeatedPtrField();
  _impl_.exclude_edges_.~RepeatedPtrField();
  if (has_has_maneuver_penalty()) {
    clear_has_maneuver_penalty();
  }
  if (has_has_destination_only_penalty()) {
    clear_has_destination_only_penalty();
  }
  if (has_has_gate_cost()) {
    clear_has_gate_cost();
  }
  if (has_has_gate_penalty()) {
    clear_has_gate_penalty();
  }
  if (has_has_toll_booth_cost()) {
    clear_has_toll_booth_cost();
  }
  if (has_has_toll_booth_penalty()) {
    clear_has_toll_booth_penalty();
  }
  if (has_has_alley_penalty()) {
    clear_has_alley_penalty();
  }
  if (has_has_country_crossing_cost()) {
    clear_has_country_crossing_cost();
  }
  if (has_has_country_crossing_penalty()) {
    clear_has_country_crossing_penalty();
  }
  if (has_has_ferry_cost()) {
    clear_has_ferry_cost();
  }
  if (has_has_avoid_bad_surfaces()) {
    clear_has_avoid_bad_surfaces();
  }
  if (has_has_use_ferry()) {
    clear_has_use_ferry();
  }
  if (has_has_use_highways()) {
    clear_has_use_highways();
  }
  if (has_has_use_tolls()) {
    clear_has_use_tolls();
  }
  if (has_has_use_roads()) {
    clear_has_use_roads();
  }
  if (has_has_max_distance()) {
    clear_has_max_distance();
  }
  if (has_has_walking_speed()) {
    clear_has_walking_speed();
  }
  if (has_has_step_penalty()) {
    clear_has_step_penalty();
  }
  if (has_has_max_grade()) {
    clear_has_max_grade();
  }
  if (has_has_max_hiking_difficulty()) {
    clear_has_max_hiking_difficulty();
  }
  if (has_has_mode_factor()) {
    clear_has_mode_factor();
  }
  if (has_has_walkway_factor()) {
    clear_has_walkway_factor();
  }
  if (has_has_sidewalk_factor()) {
    clear_has_sidewalk_factor();
  }
  if (has_has_alley_factor()) {
    clear_has_alley_factor();
  }
  if (has_has_driveway_factor()) {
    clear_has_driveway_factor();
  }
  if (has_has_driveway_penalty()) {
    clear_has_driveway_penalty();
  }
  if (has_has_transit_start_end_max_distance()) {
    clear_has_transit_start_end_max_distance();
  }
  if (has_has_transit_transfer_max_distance()) {
    clear_has_transit_transfer_max_distance();
  }
  if (has_has_transport_type()) {
    clear_has_transport_type();
  }
  if (has_has_top_speed()) {
    clear_has_top_speed();
  }
  if (has_has_use_hills()) {
    clear_has_use_hills();
  }
  if (has_has_use_primary()) {
    clear_has_use_primary();
  }
  if (has_has_use_trails()) {
    clear_has_use_trails();
  }
  if (has_has_low_class_penalty()) {
    clear_has_low_class_penalty();
  }
  if (has_has_hazmat()) {
    clear_has_hazmat();
  }
  if (has_has_weight()) {
    clear_has_weight();
  }
  if (has_has_axle_load()) {
    clear_has_axle_load();
  }
  if (has_has_height()) {
    clear_has_height();
  }
  if (has_has_width()) {
    clear_has_width();
  }
  if (has_has_length()) {
    clear_has_length();
  }
  if (has_has_cycling_speed()) {
    clear_has_cycling_speed();
  }
  if (has_has_wheelchair()) {
    clear_has_wheelchair();
  }
  if (has_has_bicycle()) {
    clear_has_bicycle();
  }
  if (has_has_use_bus()) {
    clear_has_use_bus();
  }
  if (has_has_use_rail()) {
    clear_has_use_rail();
  }
  if (has_has_use_transfers()) {
    clear_has_use_transfers();
  }
  if (has_has_transfer_cost()) {
    clear_has_transfer_cost();
  }
  if (has_has_transfer_penalty()) {
    clear_has_transfer_penalty();
  }
  if (has_has_flow_mask()) {
    clear_has_flow_mask();
  }
  if (has_has_bike_share_cost()) {
    clear_has_bike_share_cost();
  }
  if (has_has_bike_share_penalty()) {
    clear_has_bike_share_penalty();
  }
  if (has_has_rail_ferry_cost()) {
    clear_has_rail_ferry_cost();
  }
  if (has_has_use_rail_ferry()) {
    clear_has_use_rail_ferry();
  }
  if (has_has_ignore_restrictions()) {
    clear_has_ignore_restrictions();
  }
  if (has_has_ignore_oneways()) {
    clear_has_ignore_oneways();
  }
  if (has_has_ignore_access()) {
    clear_has_ignore_access();
  }
  if (has_has_ignore_closures()) {
    clear_has_ignore_closures();
  }
  if (has_has_shortest()) {
    clear_has_shortest();
  }
  if (has_has_service_penalty()) {
    clear_has_service_penalty();
  }
  if (has_has_use_tracks()) {
    clear_has_use_tracks();
  }
  if (has_has_use_distance()) {
    clear_has_use_distance();
  }
  if (has_has_use_living_streets()) {
    clear_has_use_living_streets();
  }
  if (has_has_service_factor()) {
    clear_has_service_factor();
  }
  if (has_has_closure_factor()) {
    clear_has_closure_factor();
  }
  if (has_has_private_access_penalty()) {
    clear_has_private_access_penalty();
  }
  if (has_has_exclude_unpaved()) {
    clear_has_exclude_unpaved();
  }
  if (has_has_include_hot()) {
    clear_has_include_hot();
  }
  if (has_has_include_hov2()) {
    clear_has_include_hov2();
  }
  if (has_has_include_hov3()) {
    clear_has_include_hov3();
  }
  if (has_has_exclude_cash_only_tolls()) {
    clear_has_exclude_cash_only_tolls();
  }
  if (has_has_restriction_probability()) {
    clear_has_restriction_probability();
  }
  if (has_has_elevator_penalty()) {
    clear_has_elevator_penalty();
  }
}

void Costing_Options::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Costing_Options::clear_has_maneuver_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_maneuver_penalty_case()) {
    case kManeuverPenalty: {
      // No need to clear
      break;
    }
    case HAS_MANEUVER_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_MANEUVER_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_destination_only_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_destination_only_penalty_case()) {
    case kDestinationOnlyPenalty: {
      // No need to clear
      break;
    }
    case HAS_DESTINATION_ONLY_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_gate_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_gate_cost_case()) {
    case kGateCost: {
      // No need to clear
      break;
    }
    case HAS_GATE_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_GATE_COST_NOT_SET;
}

void Costing_Options::clear_has_gate_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_gate_penalty_case()) {
    case kGatePenalty: {
      // No need to clear
      break;
    }
    case HAS_GATE_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_GATE_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_toll_booth_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_toll_booth_cost_case()) {
    case kTollBoothCost: {
      // No need to clear
      break;
    }
    case HAS_TOLL_BOOTH_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_TOLL_BOOTH_COST_NOT_SET;
}

void Costing_Options::clear_has_toll_booth_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_toll_booth_penalty_case()) {
    case kTollBoothPenalty: {
      // No need to clear
      break;
    }
    case HAS_TOLL_BOOTH_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_alley_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_alley_penalty_case()) {
    case kAlleyPenalty: {
      // No need to clear
      break;
    }
    case HAS_ALLEY_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_ALLEY_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_country_crossing_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_country_crossing_cost_case()) {
    case kCountryCrossingCost: {
      // No need to clear
      break;
    }
    case HAS_COUNTRY_CROSSING_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_COUNTRY_CROSSING_COST_NOT_SET;
}

void Costing_Options::clear_has_country_crossing_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_country_crossing_penalty_case()) {
    case kCountryCrossingPenalty: {
      // No need to clear
      break;
    }
    case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_ferry_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_ferry_cost_case()) {
    case kFerryCost: {
      // No need to clear
      break;
    }
    case HAS_FERRY_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = HAS_FERRY_COST_NOT_SET;
}

void Costing_Options::clear_has_avoid_bad_surfaces() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_avoid_bad_surfaces_case()) {
    case kAvoidBadSurfaces: {
      // No need to clear
      break;
    }
    case HAS_AVOID_BAD_SURFACES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = HAS_AVOID_BAD_SURFACES_NOT_SET;
}

void Costing_Options::clear_has_use_ferry() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_ferry_case()) {
    case kUseFerry: {
      // No need to clear
      break;
    }
    case HAS_USE_FERRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = HAS_USE_FERRY_NOT_SET;
}

void Costing_Options::clear_has_use_highways() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_highways_case()) {
    case kUseHighways: {
      // No need to clear
      break;
    }
    case HAS_USE_HIGHWAYS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[12] = HAS_USE_HIGHWAYS_NOT_SET;
}

void Costing_Options::clear_has_use_tolls() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_tolls_case()) {
    case kUseTolls: {
      // No need to clear
      break;
    }
    case HAS_USE_TOLLS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[13] = HAS_USE_TOLLS_NOT_SET;
}

void Costing_Options::clear_has_use_roads() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_roads_case()) {
    case kUseRoads: {
      // No need to clear
      break;
    }
    case HAS_USE_ROADS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[14] = HAS_USE_ROADS_NOT_SET;
}

void Costing_Options::clear_has_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_max_distance_case()) {
    case kMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[15] = HAS_MAX_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_walking_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_walking_speed_case()) {
    case kWalkingSpeed: {
      // No need to clear
      break;
    }
    case HAS_WALKING_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[16] = HAS_WALKING_SPEED_NOT_SET;
}

void Costing_Options::clear_has_step_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_step_penalty_case()) {
    case kStepPenalty: {
      // No need to clear
      break;
    }
    case HAS_STEP_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[17] = HAS_STEP_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_max_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_max_grade_case()) {
    case kMaxGrade: {
      // No need to clear
      break;
    }
    case HAS_MAX_GRADE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[18] = HAS_MAX_GRADE_NOT_SET;
}

void Costing_Options::clear_has_max_hiking_difficulty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_max_hiking_difficulty_case()) {
    case kMaxHikingDifficulty: {
      // No need to clear
      break;
    }
    case HAS_MAX_HIKING_DIFFICULTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[19] = HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}

void Costing_Options::clear_has_mode_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_mode_factor_case()) {
    case kModeFactor: {
      // No need to clear
      break;
    }
    case HAS_MODE_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[20] = HAS_MODE_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_walkway_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_walkway_factor_case()) {
    case kWalkwayFactor: {
      // No need to clear
      break;
    }
    case HAS_WALKWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[21] = HAS_WALKWAY_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_sidewalk_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_sidewalk_factor_case()) {
    case kSidewalkFactor: {
      // No need to clear
      break;
    }
    case HAS_SIDEWALK_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[22] = HAS_SIDEWALK_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_alley_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_alley_factor_case()) {
    case kAlleyFactor: {
      // No need to clear
      break;
    }
    case HAS_ALLEY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[23] = HAS_ALLEY_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_driveway_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_driveway_factor_case()) {
    case kDrivewayFactor: {
      // No need to clear
      break;
    }
    case HAS_DRIVEWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[24] = HAS_DRIVEWAY_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_driveway_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_driveway_penalty_case()) {
    case kDrivewayPenalty: {
      // No need to clear
      break;
    }
    case HAS_DRIVEWAY_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[25] = HAS_DRIVEWAY_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_transit_start_end_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_transit_start_end_max_distance_case()) {
    case kTransitStartEndMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[26] = HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_transit_transfer_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_transit_transfer_max_distance_case()) {
    case kTransitTransferMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[27] = HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_transport_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_transport_type_case()) {
    case kTransportType: {
      _impl_.has_transport_type_.transport_type_.Destroy();
      break;
    }
    case HAS_TRANSPORT_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[28] = HAS_TRANSPORT_TYPE_NOT_SET;
}

void Costing_Options::clear_has_top_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_top_speed_case()) {
    case kTopSpeed: {
      // No need to clear
      break;
    }
    case HAS_TOP_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[29] = HAS_TOP_SPEED_NOT_SET;
}

void Costing_Options::clear_has_use_hills() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_hills_case()) {
    case kUseHills: {
      // No need to clear
      break;
    }
    case HAS_USE_HILLS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[30] = HAS_USE_HILLS_NOT_SET;
}

void Costing_Options::clear_has_use_primary() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_primary_case()) {
    case kUsePrimary: {
      // No need to clear
      break;
    }
    case HAS_USE_PRIMARY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[31] = HAS_USE_PRIMARY_NOT_SET;
}

void Costing_Options::clear_has_use_trails() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_trails_case()) {
    case kUseTrails: {
      // No need to clear
      break;
    }
    case HAS_USE_TRAILS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[32] = HAS_USE_TRAILS_NOT_SET;
}

void Costing_Options::clear_has_low_class_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_low_class_penalty_case()) {
    case kLowClassPenalty: {
      // No need to clear
      break;
    }
    case HAS_LOW_CLASS_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[33] = HAS_LOW_CLASS_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_hazmat() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_hazmat_case()) {
    case kHazmat: {
      // No need to clear
      break;
    }
    case HAS_HAZMAT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[34] = HAS_HAZMAT_NOT_SET;
}

void Costing_Options::clear_has_weight() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_weight_case()) {
    case kWeight: {
      // No need to clear
      break;
    }
    case HAS_WEIGHT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[35] = HAS_WEIGHT_NOT_SET;
}

void Costing_Options::clear_has_axle_load() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_axle_load_case()) {
    case kAxleLoad: {
      // No need to clear
      break;
    }
    case HAS_AXLE_LOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[36] = HAS_AXLE_LOAD_NOT_SET;
}

void Costing_Options::clear_has_height() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_height_case()) {
    case kHeight: {
      // No need to clear
      break;
    }
    case HAS_HEIGHT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[37] = HAS_HEIGHT_NOT_SET;
}

void Costing_Options::clear_has_width() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_width_case()) {
    case kWidth: {
      // No need to clear
      break;
    }
    case HAS_WIDTH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[38] = HAS_WIDTH_NOT_SET;
}

void Costing_Options::clear_has_length() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_length_case()) {
    case kLength: {
      // No need to clear
      break;
    }
    case HAS_LENGTH_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[39] = HAS_LENGTH_NOT_SET;
}

void Costing_Options::clear_has_cycling_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_cycling_speed_case()) {
    case kCyclingSpeed: {
      // No need to clear
      break;
    }
    case HAS_CYCLING_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[40] = HAS_CYCLING_SPEED_NOT_SET;
}

void Costing_Options::clear_has_wheelchair() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_wheelchair_case()) {
    case kWheelchair: {
      // No need to clear
      break;
    }
    case HAS_WHEELCHAIR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[41] = HAS_WHEELCHAIR_NOT_SET;
}

void Costing_Options::clear_has_bicycle() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_bicycle_case()) {
    case kBicycle: {
      // No need to clear
      break;
    }
    case HAS_BICYCLE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[42] = HAS_BICYCLE_NOT_SET;
}

void Costing_Options::clear_has_use_bus() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_bus_case()) {
    case kUseBus: {
      // No need to clear
      break;
    }
    case HAS_USE_BUS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[43] = HAS_USE_BUS_NOT_SET;
}

void Costing_Options::clear_has_use_rail() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_rail_case()) {
    case kUseRail: {
      // No need to clear
      break;
    }
    case HAS_USE_RAIL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[44] = HAS_USE_RAIL_NOT_SET;
}

void Costing_Options::clear_has_use_transfers() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_transfers_case()) {
    case kUseTransfers: {
      // No need to clear
      break;
    }
    case HAS_USE_TRANSFERS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[45] = HAS_USE_TRANSFERS_NOT_SET;
}

void Costing_Options::clear_has_transfer_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_transfer_cost_case()) {
    case kTransferCost: {
      // No need to clear
      break;
    }
    case HAS_TRANSFER_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[46] = HAS_TRANSFER_COST_NOT_SET;
}

void Costing_Options::clear_has_transfer_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_transfer_penalty_case()) {
    case kTransferPenalty: {
      // No need to clear
      break;
    }
    case HAS_TRANSFER_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[47] = HAS_TRANSFER_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_flow_mask() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_flow_mask_case()) {
    case kFlowMask: {
      // No need to clear
      break;
    }
    case HAS_FLOW_MASK_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[48] = HAS_FLOW_MASK_NOT_SET;
}

void Costing_Options::clear_has_bike_share_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_bike_share_cost_case()) {
    case kBikeShareCost: {
      // No need to clear
      break;
    }
    case HAS_BIKE_SHARE_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[49] = HAS_BIKE_SHARE_COST_NOT_SET;
}

void Costing_Options::clear_has_bike_share_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_bike_share_penalty_case()) {
    case kBikeSharePenalty: {
      // No need to clear
      break;
    }
    case HAS_BIKE_SHARE_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[50] = HAS_BIKE_SHARE_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_rail_ferry_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_rail_ferry_cost_case()) {
    case kRailFerryCost: {
      // No need to clear
      break;
    }
    case HAS_RAIL_FERRY_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[51] = HAS_RAIL_FERRY_COST_NOT_SET;
}

void Costing_Options::clear_has_use_rail_ferry() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_rail_ferry_case()) {
    case kUseRailFerry: {
      // No need to clear
      break;
    }
    case HAS_USE_RAIL_FERRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[52] = HAS_USE_RAIL_FERRY_NOT_SET;
}

void Costing_Options::clear_has_ignore_restrictions() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_ignore_restrictions_case()) {
    case kIgnoreRestrictions: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[53] = HAS_IGNORE_RESTRICTIONS_NOT_SET;
}

void Costing_Options::clear_has_ignore_oneways() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_ignore_oneways_case()) {
    case kIgnoreOneways: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_ONEWAYS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[54] = HAS_IGNORE_ONEWAYS_NOT_SET;
}

void Costing_Options::clear_has_ignore_access() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_ignore_access_case()) {
    case kIgnoreAccess: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_ACCESS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[55] = HAS_IGNORE_ACCESS_NOT_SET;
}

void Costing_Options::clear_has_ignore_closures() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_ignore_closures_case()) {
    case kIgnoreClosures: {
      // No need to clear
      break;
    }
    case HAS_IGNORE_CLOSURES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[56] = HAS_IGNORE_CLOSURES_NOT_SET;
}

void Costing_Options::clear_has_shortest() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_shortest_case()) {
    case kShortest: {
      // No need to clear
      break;
    }
    case HAS_SHORTEST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[57] = HAS_SHORTEST_NOT_SET;
}

void Costing_Options::clear_has_service_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_service_penalty_case()) {
    case kServicePenalty: {
      // No need to clear
      break;
    }
    case HAS_SERVICE_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[58] = HAS_SERVICE_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_use_tracks() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_tracks_case()) {
    case kUseTracks: {
      // No need to clear
      break;
    }
    case HAS_USE_TRACKS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[59] = HAS_USE_TRACKS_NOT_SET;
}

void Costing_Options::clear_has_use_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_distance_case()) {
    case kUseDistance: {
      // No need to clear
      break;
    }
    case HAS_USE_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[60] = HAS_USE_DISTANCE_NOT_SET;
}

void Costing_Options::clear_has_use_living_streets() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_use_living_streets_case()) {
    case kUseLivingStreets: {
      // No need to clear
      break;
    }
    case HAS_USE_LIVING_STREETS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[61] = HAS_USE_LIVING_STREETS_NOT_SET;
}

void Costing_Options::clear_has_service_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_service_factor_case()) {
    case kServiceFactor: {
      // No need to clear
      break;
    }
    case HAS_SERVICE_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[62] = HAS_SERVICE_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_closure_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_closure_factor_case()) {
    case kClosureFactor: {
      // No need to clear
      break;
    }
    case HAS_CLOSURE_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[63] = HAS_CLOSURE_FACTOR_NOT_SET;
}

void Costing_Options::clear_has_private_access_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_private_access_penalty_case()) {
    case kPrivateAccessPenalty: {
      // No need to clear
      break;
    }
    case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[64] = HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}

void Costing_Options::clear_has_exclude_unpaved() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_exclude_unpaved_case()) {
    case kExcludeUnpaved: {
      // No need to clear
      break;
    }
    case HAS_EXCLUDE_UNPAVED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[65] = HAS_EXCLUDE_UNPAVED_NOT_SET;
}

void Costing_Options::clear_has_include_hot() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_include_hot_case()) {
    case kIncludeHot: {
      // No need to clear
      break;
    }
    case HAS_INCLUDE_HOT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[66] = HAS_INCLUDE_HOT_NOT_SET;
}

void Costing_Options::clear_has_include_hov2() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_include_hov2_case()) {
    case kIncludeHov2: {
      // No need to clear
      break;
    }
    case HAS_INCLUDE_HOV2_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[67] = HAS_INCLUDE_HOV2_NOT_SET;
}

void Costing_Options::clear_has_include_hov3() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_include_hov3_case()) {
    case kIncludeHov3: {
      // No need to clear
      break;
    }
    case HAS_INCLUDE_HOV3_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[68] = HAS_INCLUDE_HOV3_NOT_SET;
}

void Costing_Options::clear_has_exclude_cash_only_tolls() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_exclude_cash_only_tolls_case()) {
    case kExcludeCashOnlyTolls: {
      // No need to clear
      break;
    }
    case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[69] = HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}

void Costing_Options::clear_has_restriction_probability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_restriction_probability_case()) {
    case kRestrictionProbability: {
      // No need to clear
      break;
    }
    case HAS_RESTRICTION_PROBABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[70] = HAS_RESTRICTION_PROBABILITY_NOT_SET;
}

void Costing_Options::clear_has_elevator_penalty() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing.Options)
  switch (has_elevator_penalty_case()) {
    case kElevatorPenalty: {
      // No need to clear
      break;
    }
    case HAS_ELEVATOR_PENALTY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[71] = HAS_ELEVATOR_PENALTY_NOT_SET;
}


void Costing_Options::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Costing.Options)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filter_stop_ids_.Clear();
  _impl_.filter_operator_ids_.Clear();
  _impl_.filter_route_ids_.Clear();
  _impl_.exclude_edges_.Clear();
  ::memset(&_impl_.filter_stop_action_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.filter_route_action_) -
      reinterpret_cast<char*>(&_impl_.filter_stop_action_)) + sizeof(_impl_.filter_route_action_));
  clear_has_maneuver_penalty();
  clear_has_destination_only_penalty();
  clear_has_gate_cost();
  clear_has_gate_penalty();
  clear_has_toll_booth_cost();
  clear_has_toll_booth_penalty();
  clear_has_alley_penalty();
  clear_has_country_crossing_cost();
  clear_has_country_crossing_penalty();
  clear_has_ferry_cost();
  clear_has_avoid_bad_surfaces();
  clear_has_use_ferry();
  clear_has_use_highways();
  clear_has_use_tolls();
  clear_has_use_roads();
  clear_has_max_distance();
  clear_has_walking_speed();
  clear_has_step_penalty();
  clear_has_max_grade();
  clear_has_max_hiking_difficulty();
  clear_has_mode_factor();
  clear_has_walkway_factor();
  clear_has_sidewalk_factor();
  clear_has_alley_factor();
  clear_has_driveway_factor();
  clear_has_driveway_penalty();
  clear_has_transit_start_end_max_distance();
  clear_has_transit_transfer_max_distance();
  clear_has_transport_type();
  clear_has_top_speed();
  clear_has_use_hills();
  clear_has_use_primary();
  clear_has_use_trails();
  clear_has_low_class_penalty();
  clear_has_hazmat();
  clear_has_weight();
  clear_has_axle_load();
  clear_has_height();
  clear_has_width();
  clear_has_length();
  clear_has_cycling_speed();
  clear_has_wheelchair();
  clear_has_bicycle();
  clear_has_use_bus();
  clear_has_use_rail();
  clear_has_use_transfers();
  clear_has_transfer_cost();
  clear_has_transfer_penalty();
  clear_has_flow_mask();
  clear_has_bike_share_cost();
  clear_has_bike_share_penalty();
  clear_has_rail_ferry_cost();
  clear_has_use_rail_ferry();
  clear_has_ignore_restrictions();
  clear_has_ignore_oneways();
  clear_has_ignore_access();
  clear_has_ignore_closures();
  clear_has_shortest();
  clear_has_service_penalty();
  clear_has_use_tracks();
  clear_has_use_distance();
  clear_has_use_living_streets();
  clear_has_service_factor();
  clear_has_closure_factor();
  clear_has_private_access_penalty();
  clear_has_exclude_unpaved();
  clear_has_include_hot();
  clear_has_include_hov2();
  clear_has_include_hov3();
  clear_has_exclude_cash_only_tolls();
  clear_has_restriction_probability();
  clear_has_elevator_penalty();
  _internal_metadata_.Clear<std::string>();
}

const char* Costing_Options::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float maneuver_penalty = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _internal_set_maneuver_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float destination_only_penalty = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_destination_only_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float gate_cost = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _internal_set_gate_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float gate_penalty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _internal_set_gate_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float toll_booth_cost = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _internal_set_toll_booth_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float toll_booth_penalty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _internal_set_toll_booth_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float alley_penalty = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _internal_set_alley_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float country_crossing_cost = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _internal_set_country_crossing_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float country_crossing_penalty = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _internal_set_country_crossing_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ferry_cost = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _internal_set_ferry_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float avoid_bad_surfaces = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _internal_set_avoid_bad_surfaces(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_ferry = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _internal_set_use_ferry(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_highways = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _internal_set_use_highways(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_tolls = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _internal_set_use_tolls(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_roads = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _internal_set_use_roads(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_distance = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _internal_set_max_distance(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float walking_speed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _internal_set_walking_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float step_penalty = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _internal_set_step_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_grade = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _internal_set_max_grade(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_hiking_difficulty = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _internal_set_max_hiking_difficulty(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float mode_factor = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _internal_set_mode_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float walkway_factor = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _internal_set_walkway_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float sidewalk_factor = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _internal_set_sidewalk_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float alley_factor = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _internal_set_alley_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float driveway_factor = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _internal_set_driveway_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float driveway_penalty = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 213)) {
          _internal_set_driveway_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 transit_start_end_max_distance = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _internal_set_transit_start_end_max_distance(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 transit_transfer_max_distance = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _internal_set_transit_transfer_max_distance(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string transport_type = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_transport_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float top_speed = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 245)) {
          _internal_set_top_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_hills = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          _internal_set_use_hills(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_primary = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          _internal_set_use_primary(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_trails = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _internal_set_use_trails(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float low_class_penalty = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_low_class_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool hazmat = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_hazmat(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float weight = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _internal_set_weight(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float axle_load = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _internal_set_axle_load(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float height = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _internal_set_height(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float width = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _internal_set_width(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float length = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _internal_set_length(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float cycling_speed = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _internal_set_cycling_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool wheelchair = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _internal_set_wheelchair(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bicycle = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_bicycle(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float use_bus = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _internal_set_use_bus(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_rail = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _internal_set_use_rail(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_transfers = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _internal_set_use_transfers(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float transfer_cost = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _internal_set_transfer_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float transfer_penalty = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _internal_set_transfer_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.FilterAction filter_stop_action = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_filter_stop_action(static_cast<::valhalla::FilterAction>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string filter_stop_ids = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_stop_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<402>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.FilterAction filter_operator_action = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_filter_operator_action(static_cast<::valhalla::FilterAction>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string filter_operator_ids = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_operator_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<418>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.FilterAction filter_route_action = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_filter_route_action(static_cast<::valhalla::FilterAction>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string filter_route_ids = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_route_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<434>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 flow_mask = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _internal_set_flow_mask(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float bike_share_cost = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _internal_set_bike_share_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float bike_share_penalty = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _internal_set_bike_share_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rail_ferry_cost = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 213)) {
          _internal_set_rail_ferry_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_rail_ferry = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 221)) {
          _internal_set_use_rail_ferry(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool ignore_restrictions = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _internal_set_ignore_restrictions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ignore_oneways = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _internal_set_ignore_oneways(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ignore_access = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _internal_set_ignore_access(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ignore_closures = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _internal_set_ignore_closures(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool shortest = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _internal_set_shortest(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float service_penalty = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _internal_set_service_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_tracks = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_use_tracks(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_distance = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _internal_set_use_distance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float use_living_streets = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _internal_set_use_living_streets(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float service_factor = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _internal_set_service_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float closure_factor = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _internal_set_closure_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float private_access_penalty = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _internal_set_private_access_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool exclude_unpaved = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_exclude_unpaved(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool include_hot = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _internal_set_include_hot(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool include_hov2 = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _internal_set_include_hov2(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool include_hov3 = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_include_hov3(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool exclude_cash_only_tolls = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_exclude_cash_only_tolls(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 restriction_probability = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _internal_set_restriction_probability(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.AvoidEdge exclude_edges = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_exclude_edges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<626>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float elevator_penalty = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _internal_set_elevator_penalty(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Costing_Options::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Costing.Options)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float maneuver_penalty = 1;
  if (_internal_has_maneuver_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_maneuver_penalty(), target);
  }

  // float destination_only_penalty = 2;
  if (_internal_has_destination_only_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_destination_only_penalty(), target);
  }

  // float gate_cost = 3;
  if (_internal_has_gate_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_gate_cost(), target);
  }

  // float gate_penalty = 4;
  if (_internal_has_gate_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_gate_penalty(), target);
  }

  // float toll_booth_cost = 5;
  if (_internal_has_toll_booth_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_toll_booth_cost(), target);
  }

  // float toll_booth_penalty = 6;
  if (_internal_has_toll_booth_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_toll_booth_penalty(), target);
  }

  // float alley_penalty = 7;
  if (_internal_has_alley_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_alley_penalty(), target);
  }

  // float country_crossing_cost = 8;
  if (_internal_has_country_crossing_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_country_crossing_cost(), target);
  }

  // float country_crossing_penalty = 9;
  if (_internal_has_country_crossing_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_country_crossing_penalty(), target);
  }

  // float ferry_cost = 10;
  if (_internal_has_ferry_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_ferry_cost(), target);
  }

  // float avoid_bad_surfaces = 11;
  if (_internal_has_avoid_bad_surfaces()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_avoid_bad_surfaces(), target);
  }

  // float use_ferry = 12;
  if (_internal_has_use_ferry()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_use_ferry(), target);
  }

  // float use_highways = 13;
  if (_internal_has_use_highways()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_use_highways(), target);
  }

  // float use_tolls = 14;
  if (_internal_has_use_tolls()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_use_tolls(), target);
  }

  // float use_roads = 15;
  if (_internal_has_use_roads()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_use_roads(), target);
  }

  // uint32 max_distance = 16;
  if (_internal_has_max_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_max_distance(), target);
  }

  // float walking_speed = 17;
  if (_internal_has_walking_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_walking_speed(), target);
  }

  // float step_penalty = 18;
  if (_internal_has_step_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_step_penalty(), target);
  }

  // uint32 max_grade = 19;
  if (_internal_has_max_grade()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_max_grade(), target);
  }

  // uint32 max_hiking_difficulty = 20;
  if (_internal_has_max_hiking_difficulty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_max_hiking_difficulty(), target);
  }

  // float mode_factor = 21;
  if (_internal_has_mode_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_mode_factor(), target);
  }

  // float walkway_factor = 22;
  if (_internal_has_walkway_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_walkway_factor(), target);
  }

  // float sidewalk_factor = 23;
  if (_internal_has_sidewalk_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(23, this->_internal_sidewalk_factor(), target);
  }

  // float alley_factor = 24;
  if (_internal_has_alley_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_alley_factor(), target);
  }

  // float driveway_factor = 25;
  if (_internal_has_driveway_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_driveway_factor(), target);
  }

  // float driveway_penalty = 26;
  if (_internal_has_driveway_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(26, this->_internal_driveway_penalty(), target);
  }

  // uint32 transit_start_end_max_distance = 27;
  if (_internal_has_transit_start_end_max_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_transit_start_end_max_distance(), target);
  }

  // uint32 transit_transfer_max_distance = 28;
  if (_internal_has_transit_transfer_max_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_transit_transfer_max_distance(), target);
  }

  // string transport_type = 29;
  if (_internal_has_transport_type()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transport_type().data(), static_cast<int>(this->_internal_transport_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Costing.Options.transport_type");
    target = stream->WriteStringMaybeAliased(
        29, this->_internal_transport_type(), target);
  }

  // float top_speed = 30;
  if (_internal_has_top_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(30, this->_internal_top_speed(), target);
  }

  // float use_hills = 31;
  if (_internal_has_use_hills()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(31, this->_internal_use_hills(), target);
  }

  // float use_primary = 32;
  if (_internal_has_use_primary()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(32, this->_internal_use_primary(), target);
  }

  // float use_trails = 33;
  if (_internal_has_use_trails()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(33, this->_internal_use_trails(), target);
  }

  // float low_class_penalty = 34;
  if (_internal_has_low_class_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(34, this->_internal_low_class_penalty(), target);
  }

  // bool hazmat = 35;
  if (_internal_has_hazmat()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(35, this->_internal_hazmat(), target);
  }

  // float weight = 36;
  if (_internal_has_weight()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(36, this->_internal_weight(), target);
  }

  // float axle_load = 37;
  if (_internal_has_axle_load()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(37, this->_internal_axle_load(), target);
  }

  // float height = 38;
  if (_internal_has_height()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(38, this->_internal_height(), target);
  }

  // float width = 39;
  if (_internal_has_width()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(39, this->_internal_width(), target);
  }

  // float length = 40;
  if (_internal_has_length()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(40, this->_internal_length(), target);
  }

  // float cycling_speed = 41;
  if (_internal_has_cycling_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(41, this->_internal_cycling_speed(), target);
  }

  // bool wheelchair = 42;
  if (_internal_has_wheelchair()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(42, this->_internal_wheelchair(), target);
  }

  // bool bicycle = 43;
  if (_internal_has_bicycle()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(43, this->_internal_bicycle(), target);
  }

  // float use_bus = 44;
  if (_internal_has_use_bus()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(44, this->_internal_use_bus(), target);
  }

  // float use_rail = 45;
  if (_internal_has_use_rail()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(45, this->_internal_use_rail(), target);
  }

  // float use_transfers = 46;
  if (_internal_has_use_transfers()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(46, this->_internal_use_transfers(), target);
  }

  // float transfer_cost = 47;
  if (_internal_has_transfer_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(47, this->_internal_transfer_cost(), target);
  }

  // float transfer_penalty = 48;
  if (_internal_has_transfer_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(48, this->_internal_transfer_penalty(), target);
  }

  // .valhalla.FilterAction filter_stop_action = 49;
  if (this->_internal_filter_stop_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      49, this->_internal_filter_stop_action(), target);
  }

  // repeated string filter_stop_ids = 50;
  for (int i = 0, n = this->_internal_filter_stop_ids_size(); i < n; i++) {
    const auto& s = this->_internal_filter_stop_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Costing.Options.filter_stop_ids");
    target = stream->WriteString(50, s, target);
  }

  // .valhalla.FilterAction filter_operator_action = 51;
  if (this->_internal_filter_operator_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      51, this->_internal_filter_operator_action(), target);
  }

  // repeated string filter_operator_ids = 52;
  for (int i = 0, n = this->_internal_filter_operator_ids_size(); i < n; i++) {
    const auto& s = this->_internal_filter_operator_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Costing.Options.filter_operator_ids");
    target = stream->WriteString(52, s, target);
  }

  // .valhalla.FilterAction filter_route_action = 53;
  if (this->_internal_filter_route_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      53, this->_internal_filter_route_action(), target);
  }

  // repeated string filter_route_ids = 54;
  for (int i = 0, n = this->_internal_filter_route_ids_size(); i < n; i++) {
    const auto& s = this->_internal_filter_route_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Costing.Options.filter_route_ids");
    target = stream->WriteString(54, s, target);
  }

  // uint32 flow_mask = 55;
  if (_internal_has_flow_mask()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(55, this->_internal_flow_mask(), target);
  }

  // float bike_share_cost = 56;
  if (_internal_has_bike_share_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(56, this->_internal_bike_share_cost(), target);
  }

  // float bike_share_penalty = 57;
  if (_internal_has_bike_share_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(57, this->_internal_bike_share_penalty(), target);
  }

  // float rail_ferry_cost = 58;
  if (_internal_has_rail_ferry_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(58, this->_internal_rail_ferry_cost(), target);
  }

  // float use_rail_ferry = 59;
  if (_internal_has_use_rail_ferry()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(59, this->_internal_use_rail_ferry(), target);
  }

  // bool ignore_restrictions = 60;
  if (_internal_has_ignore_restrictions()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(60, this->_internal_ignore_restrictions(), target);
  }

  // bool ignore_oneways = 61;
  if (_internal_has_ignore_oneways()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(61, this->_internal_ignore_oneways(), target);
  }

  // bool ignore_access = 62;
  if (_internal_has_ignore_access()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(62, this->_internal_ignore_access(), target);
  }

  // bool ignore_closures = 63;
  if (_internal_has_ignore_closures()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(63, this->_internal_ignore_closures(), target);
  }

  // bool shortest = 64;
  if (_internal_has_shortest()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(64, this->_internal_shortest(), target);
  }

  // float service_penalty = 65;
  if (_internal_has_service_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(65, this->_internal_service_penalty(), target);
  }

  // float use_tracks = 66;
  if (_internal_has_use_tracks()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(66, this->_internal_use_tracks(), target);
  }

  // float use_distance = 67;
  if (_internal_has_use_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(67, this->_internal_use_distance(), target);
  }

  // float use_living_streets = 68;
  if (_internal_has_use_living_streets()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(68, this->_internal_use_living_streets(), target);
  }

  // float service_factor = 69;
  if (_internal_has_service_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(69, this->_internal_service_factor(), target);
  }

  // float closure_factor = 70;
  if (_internal_has_closure_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(70, this->_internal_closure_factor(), target);
  }

  // float private_access_penalty = 71;
  if (_internal_has_private_access_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(71, this->_internal_private_access_penalty(), target);
  }

  // bool exclude_unpaved = 72;
  if (_internal_has_exclude_unpaved()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(72, this->_internal_exclude_unpaved(), target);
  }

  // bool include_hot = 73;
  if (_internal_has_include_hot()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(73, this->_internal_include_hot(), target);
  }

  // bool include_hov2 = 74;
  if (_internal_has_include_hov2()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(74, this->_internal_include_hov2(), target);
  }

  // bool include_hov3 = 75;
  if (_internal_has_include_hov3()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(75, this->_internal_include_hov3(), target);
  }

  // bool exclude_cash_only_tolls = 76;
  if (_internal_has_exclude_cash_only_tolls()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(76, this->_internal_exclude_cash_only_tolls(), target);
  }

  // uint32 restriction_probability = 77;
  if (_internal_has_restriction_probability()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(77, this->_internal_restriction_probability(), target);
  }

  // repeated .valhalla.AvoidEdge exclude_edges = 78;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exclude_edges_size()); i < n; i++) {
    const auto& repfield = this->_internal_exclude_edges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(78, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float elevator_penalty = 79;
  if (_internal_has_elevator_penalty()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(79, this->_internal_elevator_penalty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Costing.Options)
  return target;
}

size_t Costing_Options::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Costing.Options)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string filter_stop_ids = 50;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.filter_stop_ids_.size());
  for (int i = 0, n = _impl_.filter_stop_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.filter_stop_ids_.Get(i));
  }

  // repeated string filter_operator_ids = 52;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.filter_operator_ids_.size());
  for (int i = 0, n = _impl_.filter_operator_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.filter_operator_ids_.Get(i));
  }

  // repeated string filter_route_ids = 54;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.filter_route_ids_.size());
  for (int i = 0, n = _impl_.filter_route_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.filter_route_ids_.Get(i));
  }

  // repeated .valhalla.AvoidEdge exclude_edges = 78;
  total_size += 2UL * this->_internal_exclude_edges_size();
  for (const auto& msg : this->_impl_.exclude_edges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .valhalla.FilterAction filter_stop_action = 49;
  if (this->_internal_filter_stop_action() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filter_stop_action());
  }

  // .valhalla.FilterAction filter_operator_action = 51;
  if (this->_internal_filter_operator_action() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filter_operator_action());
  }

  // .valhalla.FilterAction filter_route_action = 53;
  if (this->_internal_filter_route_action() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filter_route_action());
  }

  switch (has_maneuver_penalty_case()) {
    // float maneuver_penalty = 1;
    case kManeuverPenalty: {
      total_size += 1 + 4;
      break;
    }
    case HAS_MANEUVER_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_destination_only_penalty_case()) {
    // float destination_only_penalty = 2;
    case kDestinationOnlyPenalty: {
      total_size += 1 + 4;
      break;
    }
    case HAS_DESTINATION_ONLY_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_gate_cost_case()) {
    // float gate_cost = 3;
    case kGateCost: {
      total_size += 1 + 4;
      break;
    }
    case HAS_GATE_COST_NOT_SET: {
      break;
    }
  }
  switch (has_gate_penalty_case()) {
    // float gate_penalty = 4;
    case kGatePenalty: {
      total_size += 1 + 4;
      break;
    }
    case HAS_GATE_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_toll_booth_cost_case()) {
    // float toll_booth_cost = 5;
    case kTollBoothCost: {
      total_size += 1 + 4;
      break;
    }
    case HAS_TOLL_BOOTH_COST_NOT_SET: {
      break;
    }
  }
  switch (has_toll_booth_penalty_case()) {
    // float toll_booth_penalty = 6;
    case kTollBoothPenalty: {
      total_size += 1 + 4;
      break;
    }
    case HAS_TOLL_BOOTH_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_alley_penalty_case()) {
    // float alley_penalty = 7;
    case kAlleyPenalty: {
      total_size += 1 + 4;
      break;
    }
    case HAS_ALLEY_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_country_crossing_cost_case()) {
    // float country_crossing_cost = 8;
    case kCountryCrossingCost: {
      total_size += 1 + 4;
      break;
    }
    case HAS_COUNTRY_CROSSING_COST_NOT_SET: {
      break;
    }
  }
  switch (has_country_crossing_penalty_case()) {
    // float country_crossing_penalty = 9;
    case kCountryCrossingPenalty: {
      total_size += 1 + 4;
      break;
    }
    case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_ferry_cost_case()) {
    // float ferry_cost = 10;
    case kFerryCost: {
      total_size += 1 + 4;
      break;
    }
    case HAS_FERRY_COST_NOT_SET: {
      break;
    }
  }
  switch (has_avoid_bad_surfaces_case()) {
    // float avoid_bad_surfaces = 11;
    case kAvoidBadSurfaces: {
      total_size += 1 + 4;
      break;
    }
    case HAS_AVOID_BAD_SURFACES_NOT_SET: {
      break;
    }
  }
  switch (has_use_ferry_case()) {
    // float use_ferry = 12;
    case kUseFerry: {
      total_size += 1 + 4;
      break;
    }
    case HAS_USE_FERRY_NOT_SET: {
      break;
    }
  }
  switch (has_use_highways_case()) {
    // float use_highways = 13;
    case kUseHighways: {
      total_size += 1 + 4;
      break;
    }
    case HAS_USE_HIGHWAYS_NOT_SET: {
      break;
    }
  }
  switch (has_use_tolls_case()) {
    // float use_tolls = 14;
    case kUseTolls: {
      total_size += 1 + 4;
      break;
    }
    case HAS_USE_TOLLS_NOT_SET: {
      break;
    }
  }
  switch (has_use_roads_case()) {
    // float use_roads = 15;
    case kUseRoads: {
      total_size += 1 + 4;
      break;
    }
    case HAS_USE_ROADS_NOT_SET: {
      break;
    }
  }
  switch (has_max_distance_case()) {
    // uint32 max_distance = 16;
    case kMaxDistance: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_max_distance());
      break;
    }
    case HAS_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_walking_speed_case()) {
    // float walking_speed = 17;
    case kWalkingSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_WALKING_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_step_penalty_case()) {
    // float step_penalty = 18;
    case kStepPenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_STEP_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_max_grade_case()) {
    // uint32 max_grade = 19;
    case kMaxGrade: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_max_grade());
      break;
    }
    case HAS_MAX_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_max_hiking_difficulty_case()) {
    // uint32 max_hiking_difficulty = 20;
    case kMaxHikingDifficulty: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_max_hiking_difficulty());
      break;
    }
    case HAS_MAX_HIKING_DIFFICULTY_NOT_SET: {
      break;
    }
  }
  switch (has_mode_factor_case()) {
    // float mode_factor = 21;
    case kModeFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_MODE_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_walkway_factor_case()) {
    // float walkway_factor = 22;
    case kWalkwayFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_WALKWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_sidewalk_factor_case()) {
    // float sidewalk_factor = 23;
    case kSidewalkFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_SIDEWALK_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_alley_factor_case()) {
    // float alley_factor = 24;
    case kAlleyFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_ALLEY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_driveway_factor_case()) {
    // float driveway_factor = 25;
    case kDrivewayFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_DRIVEWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_driveway_penalty_case()) {
    // float driveway_penalty = 26;
    case kDrivewayPenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_DRIVEWAY_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_transit_start_end_max_distance_case()) {
    // uint32 transit_start_end_max_distance = 27;
    case kTransitStartEndMaxDistance: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_transit_start_end_max_distance());
      break;
    }
    case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_transit_transfer_max_distance_case()) {
    // uint32 transit_transfer_max_distance = 28;
    case kTransitTransferMaxDistance: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_transit_transfer_max_distance());
      break;
    }
    case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_transport_type_case()) {
    // string transport_type = 29;
    case kTransportType: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transport_type());
      break;
    }
    case HAS_TRANSPORT_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_top_speed_case()) {
    // float top_speed = 30;
    case kTopSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TOP_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_use_hills_case()) {
    // float use_hills = 31;
    case kUseHills: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_HILLS_NOT_SET: {
      break;
    }
  }
  switch (has_use_primary_case()) {
    // float use_primary = 32;
    case kUsePrimary: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_PRIMARY_NOT_SET: {
      break;
    }
  }
  switch (has_use_trails_case()) {
    // float use_trails = 33;
    case kUseTrails: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_TRAILS_NOT_SET: {
      break;
    }
  }
  switch (has_low_class_penalty_case()) {
    // float low_class_penalty = 34;
    case kLowClassPenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_LOW_CLASS_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_hazmat_case()) {
    // bool hazmat = 35;
    case kHazmat: {
      total_size += 2 + 1;
      break;
    }
    case HAS_HAZMAT_NOT_SET: {
      break;
    }
  }
  switch (has_weight_case()) {
    // float weight = 36;
    case kWeight: {
      total_size += 2 + 4;
      break;
    }
    case HAS_WEIGHT_NOT_SET: {
      break;
    }
  }
  switch (has_axle_load_case()) {
    // float axle_load = 37;
    case kAxleLoad: {
      total_size += 2 + 4;
      break;
    }
    case HAS_AXLE_LOAD_NOT_SET: {
      break;
    }
  }
  switch (has_height_case()) {
    // float height = 38;
    case kHeight: {
      total_size += 2 + 4;
      break;
    }
    case HAS_HEIGHT_NOT_SET: {
      break;
    }
  }
  switch (has_width_case()) {
    // float width = 39;
    case kWidth: {
      total_size += 2 + 4;
      break;
    }
    case HAS_WIDTH_NOT_SET: {
      break;
    }
  }
  switch (has_length_case()) {
    // float length = 40;
    case kLength: {
      total_size += 2 + 4;
      break;
    }
    case HAS_LENGTH_NOT_SET: {
      break;
    }
  }
  switch (has_cycling_speed_case()) {
    // float cycling_speed = 41;
    case kCyclingSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_CYCLING_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_wheelchair_case()) {
    // bool wheelchair = 42;
    case kWheelchair: {
      total_size += 2 + 1;
      break;
    }
    case HAS_WHEELCHAIR_NOT_SET: {
      break;
    }
  }
  switch (has_bicycle_case()) {
    // bool bicycle = 43;
    case kBicycle: {
      total_size += 2 + 1;
      break;
    }
    case HAS_BICYCLE_NOT_SET: {
      break;
    }
  }
  switch (has_use_bus_case()) {
    // float use_bus = 44;
    case kUseBus: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_BUS_NOT_SET: {
      break;
    }
  }
  switch (has_use_rail_case()) {
    // float use_rail = 45;
    case kUseRail: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_RAIL_NOT_SET: {
      break;
    }
  }
  switch (has_use_transfers_case()) {
    // float use_transfers = 46;
    case kUseTransfers: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_TRANSFERS_NOT_SET: {
      break;
    }
  }
  switch (has_transfer_cost_case()) {
    // float transfer_cost = 47;
    case kTransferCost: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TRANSFER_COST_NOT_SET: {
      break;
    }
  }
  switch (has_transfer_penalty_case()) {
    // float transfer_penalty = 48;
    case kTransferPenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TRANSFER_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_flow_mask_case()) {
    // uint32 flow_mask = 55;
    case kFlowMask: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_flow_mask());
      break;
    }
    case HAS_FLOW_MASK_NOT_SET: {
      break;
    }
  }
  switch (has_bike_share_cost_case()) {
    // float bike_share_cost = 56;
    case kBikeShareCost: {
      total_size += 2 + 4;
      break;
    }
    case HAS_BIKE_SHARE_COST_NOT_SET: {
      break;
    }
  }
  switch (has_bike_share_penalty_case()) {
    // float bike_share_penalty = 57;
    case kBikeSharePenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_BIKE_SHARE_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_rail_ferry_cost_case()) {
    // float rail_ferry_cost = 58;
    case kRailFerryCost: {
      total_size += 2 + 4;
      break;
    }
    case HAS_RAIL_FERRY_COST_NOT_SET: {
      break;
    }
  }
  switch (has_use_rail_ferry_case()) {
    // float use_rail_ferry = 59;
    case kUseRailFerry: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_RAIL_FERRY_NOT_SET: {
      break;
    }
  }
  switch (has_ignore_restrictions_case()) {
    // bool ignore_restrictions = 60;
    case kIgnoreRestrictions: {
      total_size += 2 + 1;
      break;
    }
    case HAS_IGNORE_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  switch (has_ignore_oneways_case()) {
    // bool ignore_oneways = 61;
    case kIgnoreOneways: {
      total_size += 2 + 1;
      break;
    }
    case HAS_IGNORE_ONEWAYS_NOT_SET: {
      break;
    }
  }
  switch (has_ignore_access_case()) {
    // bool ignore_access = 62;
    case kIgnoreAccess: {
      total_size += 2 + 1;
      break;
    }
    case HAS_IGNORE_ACCESS_NOT_SET: {
      break;
    }
  }
  switch (has_ignore_closures_case()) {
    // bool ignore_closures = 63;
    case kIgnoreClosures: {
      total_size += 2 + 1;
      break;
    }
    case HAS_IGNORE_CLOSURES_NOT_SET: {
      break;
    }
  }
  switch (has_shortest_case()) {
    // bool shortest = 64;
    case kShortest: {
      total_size += 2 + 1;
      break;
    }
    case HAS_SHORTEST_NOT_SET: {
      break;
    }
  }
  switch (has_service_penalty_case()) {
    // float service_penalty = 65;
    case kServicePenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_SERVICE_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_use_tracks_case()) {
    // float use_tracks = 66;
    case kUseTracks: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_TRACKS_NOT_SET: {
      break;
    }
  }
  switch (has_use_distance_case()) {
    // float use_distance = 67;
    case kUseDistance: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_use_living_streets_case()) {
    // float use_living_streets = 68;
    case kUseLivingStreets: {
      total_size += 2 + 4;
      break;
    }
    case HAS_USE_LIVING_STREETS_NOT_SET: {
      break;
    }
  }
  switch (has_service_factor_case()) {
    // float service_factor = 69;
    case kServiceFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_SERVICE_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_closure_factor_case()) {
    // float closure_factor = 70;
    case kClosureFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_CLOSURE_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_private_access_penalty_case()) {
    // float private_access_penalty = 71;
    case kPrivateAccessPenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (has_exclude_unpaved_case()) {
    // bool exclude_unpaved = 72;
    case kExcludeUnpaved: {
      total_size += 2 + 1;
      break;
    }
    case HAS_EXCLUDE_UNPAVED_NOT_SET: {
      break;
    }
  }
  switch (has_include_hot_case()) {
    // bool include_hot = 73;
    case kIncludeHot: {
      total_size += 2 + 1;
      break;
    }
    case HAS_INCLUDE_HOT_NOT_SET: {
      break;
    }
  }
  switch (has_include_hov2_case()) {
    // bool include_hov2 = 74;
    case kIncludeHov2: {
      total_size += 2 + 1;
      break;
    }
    case HAS_INCLUDE_HOV2_NOT_SET: {
      break;
    }
  }
  switch (has_include_hov3_case()) {
    // bool include_hov3 = 75;
    case kIncludeHov3: {
      total_size += 2 + 1;
      break;
    }
    case HAS_INCLUDE_HOV3_NOT_SET: {
      break;
    }
  }
  switch (has_exclude_cash_only_tolls_case()) {
    // bool exclude_cash_only_tolls = 76;
    case kExcludeCashOnlyTolls: {
      total_size += 2 + 1;
      break;
    }
    case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET: {
      break;
    }
  }
  switch (has_restriction_probability_case()) {
    // uint32 restriction_probability = 77;
    case kRestrictionProbability: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_restriction_probability());
      break;
    }
    case HAS_RESTRICTION_PROBABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_elevator_penalty_case()) {
    // float elevator_penalty = 79;
    case kElevatorPenalty: {
      total_size += 2 + 4;
      break;
    }
    case HAS_ELEVATOR_PENALTY_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Costing_Options::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Costing_Options*>(
      &from));
}

void Costing_Options::MergeFrom(const Costing_Options& from) {
  Costing_Options* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Costing.Options)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.filter_stop_ids_.MergeFrom(from._impl_.filter_stop_ids_);
  _this->_impl_.filter_operator_ids_.MergeFrom(from._impl_.filter_operator_ids_);
  _this->_impl_.filter_route_ids_.MergeFrom(from._impl_.filter_route_ids_);
  _this->_impl_.exclude_edges_.MergeFrom(from._impl_.exclude_edges_);
  if (from._internal_filter_stop_action() != 0) {
    _this->_internal_set_filter_stop_action(from._internal_filter_stop_action());
  }
  if (from._internal_filter_operator_action() != 0) {
    _this->_internal_set_filter_operator_action(from._internal_filter_operator_action());
  }
  if (from._internal_filter_route_action() != 0) {
    _this->_internal_set_filter_route_action(from._internal_filter_route_action());
  }
  switch (from.has_maneuver_penalty_case()) {
    case kManeuverPenalty: {
      _this->_internal_set_maneuver_penalty(from._internal_maneuver_penalty());
      break;
    }
    case HAS_MANEUVER_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_destination_only_penalty_case()) {
    case kDestinationOnlyPenalty: {
      _this->_internal_set_destination_only_penalty(from._internal_destination_only_penalty());
      break;
    }
    case HAS_DESTINATION_ONLY_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_gate_cost_case()) {
    case kGateCost: {
      _this->_internal_set_gate_cost(from._internal_gate_cost());
      break;
    }
    case HAS_GATE_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_gate_penalty_case()) {
    case kGatePenalty: {
      _this->_internal_set_gate_penalty(from._internal_gate_penalty());
      break;
    }
    case HAS_GATE_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_toll_booth_cost_case()) {
    case kTollBoothCost: {
      _this->_internal_set_toll_booth_cost(from._internal_toll_booth_cost());
      break;
    }
    case HAS_TOLL_BOOTH_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_toll_booth_penalty_case()) {
    case kTollBoothPenalty: {
      _this->_internal_set_toll_booth_penalty(from._internal_toll_booth_penalty());
      break;
    }
    case HAS_TOLL_BOOTH_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_alley_penalty_case()) {
    case kAlleyPenalty: {
      _this->_internal_set_alley_penalty(from._internal_alley_penalty());
      break;
    }
    case HAS_ALLEY_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_country_crossing_cost_case()) {
    case kCountryCrossingCost: {
      _this->_internal_set_country_crossing_cost(from._internal_country_crossing_cost());
      break;
    }
    case HAS_COUNTRY_CROSSING_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_country_crossing_penalty_case()) {
    case kCountryCrossingPenalty: {
      _this->_internal_set_country_crossing_penalty(from._internal_country_crossing_penalty());
      break;
    }
    case HAS_COUNTRY_CROSSING_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_ferry_cost_case()) {
    case kFerryCost: {
      _this->_internal_set_ferry_cost(from._internal_ferry_cost());
      break;
    }
    case HAS_FERRY_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_avoid_bad_surfaces_case()) {
    case kAvoidBadSurfaces: {
      _this->_internal_set_avoid_bad_surfaces(from._internal_avoid_bad_surfaces());
      break;
    }
    case HAS_AVOID_BAD_SURFACES_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_ferry_case()) {
    case kUseFerry: {
      _this->_internal_set_use_ferry(from._internal_use_ferry());
      break;
    }
    case HAS_USE_FERRY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_highways_case()) {
    case kUseHighways: {
      _this->_internal_set_use_highways(from._internal_use_highways());
      break;
    }
    case HAS_USE_HIGHWAYS_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_tolls_case()) {
    case kUseTolls: {
      _this->_internal_set_use_tolls(from._internal_use_tolls());
      break;
    }
    case HAS_USE_TOLLS_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_roads_case()) {
    case kUseRoads: {
      _this->_internal_set_use_roads(from._internal_use_roads());
      break;
    }
    case HAS_USE_ROADS_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_distance_case()) {
    case kMaxDistance: {
      _this->_internal_set_max_distance(from._internal_max_distance());
      break;
    }
    case HAS_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_walking_speed_case()) {
    case kWalkingSpeed: {
      _this->_internal_set_walking_speed(from._internal_walking_speed());
      break;
    }
    case HAS_WALKING_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_step_penalty_case()) {
    case kStepPenalty: {
      _this->_internal_set_step_penalty(from._internal_step_penalty());
      break;
    }
    case HAS_STEP_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_grade_case()) {
    case kMaxGrade: {
      _this->_internal_set_max_grade(from._internal_max_grade());
      break;
    }
    case HAS_MAX_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_hiking_difficulty_case()) {
    case kMaxHikingDifficulty: {
      _this->_internal_set_max_hiking_difficulty(from._internal_max_hiking_difficulty());
      break;
    }
    case HAS_MAX_HIKING_DIFFICULTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_mode_factor_case()) {
    case kModeFactor: {
      _this->_internal_set_mode_factor(from._internal_mode_factor());
      break;
    }
    case HAS_MODE_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_walkway_factor_case()) {
    case kWalkwayFactor: {
      _this->_internal_set_walkway_factor(from._internal_walkway_factor());
      break;
    }
    case HAS_WALKWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_sidewalk_factor_case()) {
    case kSidewalkFactor: {
      _this->_internal_set_sidewalk_factor(from._internal_sidewalk_factor());
      break;
    }
    case HAS_SIDEWALK_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_alley_factor_case()) {
    case kAlleyFactor: {
      _this->_internal_set_alley_factor(from._internal_alley_factor());
      break;
    }
    case HAS_ALLEY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_driveway_factor_case()) {
    case kDrivewayFactor: {
      _this->_internal_set_driveway_factor(from._internal_driveway_factor());
      break;
    }
    case HAS_DRIVEWAY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_driveway_penalty_case()) {
    case kDrivewayPenalty: {
      _this->_internal_set_driveway_penalty(from._internal_driveway_penalty());
      break;
    }
    case HAS_DRIVEWAY_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_transit_start_end_max_distance_case()) {
    case kTransitStartEndMaxDistance: {
      _this->_internal_set_transit_start_end_max_distance(from._internal_transit_start_end_max_distance());
      break;
    }
    case HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_transit_transfer_max_distance_case()) {
    case kTransitTransferMaxDistance: {
      _this->_internal_set_transit_transfer_max_distance(from._internal_transit_transfer_max_distance());
      break;
    }
    case HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_transport_type_case()) {
    case kTransportType: {
      _this->_internal_set_transport_type(from._internal_transport_type());
      break;
    }
    case HAS_TRANSPORT_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_top_speed_case()) {
    case kTopSpeed: {
      _this->_internal_set_top_speed(from._internal_top_speed());
      break;
    }
    case HAS_TOP_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_hills_case()) {
    case kUseHills: {
      _this->_internal_set_use_hills(from._internal_use_hills());
      break;
    }
    case HAS_USE_HILLS_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_primary_case()) {
    case kUsePrimary: {
      _this->_internal_set_use_primary(from._internal_use_primary());
      break;
    }
    case HAS_USE_PRIMARY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_trails_case()) {
    case kUseTrails: {
      _this->_internal_set_use_trails(from._internal_use_trails());
      break;
    }
    case HAS_USE_TRAILS_NOT_SET: {
      break;
    }
  }
  switch (from.has_low_class_penalty_case()) {
    case kLowClassPenalty: {
      _this->_internal_set_low_class_penalty(from._internal_low_class_penalty());
      break;
    }
    case HAS_LOW_CLASS_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_hazmat_case()) {
    case kHazmat: {
      _this->_internal_set_hazmat(from._internal_hazmat());
      break;
    }
    case HAS_HAZMAT_NOT_SET: {
      break;
    }
  }
  switch (from.has_weight_case()) {
    case kWeight: {
      _this->_internal_set_weight(from._internal_weight());
      break;
    }
    case HAS_WEIGHT_NOT_SET: {
      break;
    }
  }
  switch (from.has_axle_load_case()) {
    case kAxleLoad: {
      _this->_internal_set_axle_load(from._internal_axle_load());
      break;
    }
    case HAS_AXLE_LOAD_NOT_SET: {
      break;
    }
  }
  switch (from.has_height_case()) {
    case kHeight: {
      _this->_internal_set_height(from._internal_height());
      break;
    }
    case HAS_HEIGHT_NOT_SET: {
      break;
    }
  }
  switch (from.has_width_case()) {
    case kWidth: {
      _this->_internal_set_width(from._internal_width());
      break;
    }
    case HAS_WIDTH_NOT_SET: {
      break;
    }
  }
  switch (from.has_length_case()) {
    case kLength: {
      _this->_internal_set_length(from._internal_length());
      break;
    }
    case HAS_LENGTH_NOT_SET: {
      break;
    }
  }
  switch (from.has_cycling_speed_case()) {
    case kCyclingSpeed: {
      _this->_internal_set_cycling_speed(from._internal_cycling_speed());
      break;
    }
    case HAS_CYCLING_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_wheelchair_case()) {
    case kWheelchair: {
      _this->_internal_set_wheelchair(from._internal_wheelchair());
      break;
    }
    case HAS_WHEELCHAIR_NOT_SET: {
      break;
    }
  }
  switch (from.has_bicycle_case()) {
    case kBicycle: {
      _this->_internal_set_bicycle(from._internal_bicycle());
      break;
    }
    case HAS_BICYCLE_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_bus_case()) {
    case kUseBus: {
      _this->_internal_set_use_bus(from._internal_use_bus());
      break;
    }
    case HAS_USE_BUS_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_rail_case()) {
    case kUseRail: {
      _this->_internal_set_use_rail(from._internal_use_rail());
      break;
    }
    case HAS_USE_RAIL_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_transfers_case()) {
    case kUseTransfers: {
      _this->_internal_set_use_transfers(from._internal_use_transfers());
      break;
    }
    case HAS_USE_TRANSFERS_NOT_SET: {
      break;
    }
  }
  switch (from.has_transfer_cost_case()) {
    case kTransferCost: {
      _this->_internal_set_transfer_cost(from._internal_transfer_cost());
      break;
    }
    case HAS_TRANSFER_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_transfer_penalty_case()) {
    case kTransferPenalty: {
      _this->_internal_set_transfer_penalty(from._internal_transfer_penalty());
      break;
    }
    case HAS_TRANSFER_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_flow_mask_case()) {
    case kFlowMask: {
      _this->_internal_set_flow_mask(from._internal_flow_mask());
      break;
    }
    case HAS_FLOW_MASK_NOT_SET: {
      break;
    }
  }
  switch (from.has_bike_share_cost_case()) {
    case kBikeShareCost: {
      _this->_internal_set_bike_share_cost(from._internal_bike_share_cost());
      break;
    }
    case HAS_BIKE_SHARE_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_bike_share_penalty_case()) {
    case kBikeSharePenalty: {
      _this->_internal_set_bike_share_penalty(from._internal_bike_share_penalty());
      break;
    }
    case HAS_BIKE_SHARE_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_rail_ferry_cost_case()) {
    case kRailFerryCost: {
      _this->_internal_set_rail_ferry_cost(from._internal_rail_ferry_cost());
      break;
    }
    case HAS_RAIL_FERRY_COST_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_rail_ferry_case()) {
    case kUseRailFerry: {
      _this->_internal_set_use_rail_ferry(from._internal_use_rail_ferry());
      break;
    }
    case HAS_USE_RAIL_FERRY_NOT_SET: {
      break;
    }
  }
  switch (from.has_ignore_restrictions_case()) {
    case kIgnoreRestrictions: {
      _this->_internal_set_ignore_restrictions(from._internal_ignore_restrictions());
      break;
    }
    case HAS_IGNORE_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  switch (from.has_ignore_oneways_case()) {
    case kIgnoreOneways: {
      _this->_internal_set_ignore_oneways(from._internal_ignore_oneways());
      break;
    }
    case HAS_IGNORE_ONEWAYS_NOT_SET: {
      break;
    }
  }
  switch (from.has_ignore_access_case()) {
    case kIgnoreAccess: {
      _this->_internal_set_ignore_access(from._internal_ignore_access());
      break;
    }
    case HAS_IGNORE_ACCESS_NOT_SET: {
      break;
    }
  }
  switch (from.has_ignore_closures_case()) {
    case kIgnoreClosures: {
      _this->_internal_set_ignore_closures(from._internal_ignore_closures());
      break;
    }
    case HAS_IGNORE_CLOSURES_NOT_SET: {
      break;
    }
  }
  switch (from.has_shortest_case()) {
    case kShortest: {
      _this->_internal_set_shortest(from._internal_shortest());
      break;
    }
    case HAS_SHORTEST_NOT_SET: {
      break;
    }
  }
  switch (from.has_service_penalty_case()) {
    case kServicePenalty: {
      _this->_internal_set_service_penalty(from._internal_service_penalty());
      break;
    }
    case HAS_SERVICE_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_tracks_case()) {
    case kUseTracks: {
      _this->_internal_set_use_tracks(from._internal_use_tracks());
      break;
    }
    case HAS_USE_TRACKS_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_distance_case()) {
    case kUseDistance: {
      _this->_internal_set_use_distance(from._internal_use_distance());
      break;
    }
    case HAS_USE_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_living_streets_case()) {
    case kUseLivingStreets: {
      _this->_internal_set_use_living_streets(from._internal_use_living_streets());
      break;
    }
    case HAS_USE_LIVING_STREETS_NOT_SET: {
      break;
    }
  }
  switch (from.has_service_factor_case()) {
    case kServiceFactor: {
      _this->_internal_set_service_factor(from._internal_service_factor());
      break;
    }
    case HAS_SERVICE_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_closure_factor_case()) {
    case kClosureFactor: {
      _this->_internal_set_closure_factor(from._internal_closure_factor());
      break;
    }
    case HAS_CLOSURE_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_private_access_penalty_case()) {
    case kPrivateAccessPenalty: {
      _this->_internal_set_private_access_penalty(from._internal_private_access_penalty());
      break;
    }
    case HAS_PRIVATE_ACCESS_PENALTY_NOT_SET: {
      break;
    }
  }
  switch (from.has_exclude_unpaved_case()) {
    case kExcludeUnpaved: {
      _this->_internal_set_exclude_unpaved(from._internal_exclude_unpaved());
      break;
    }
    case HAS_EXCLUDE_UNPAVED_NOT_SET: {
      break;
    }
  }
  switch (from.has_include_hot_case()) {
    case kIncludeHot: {
      _this->_internal_set_include_hot(from._internal_include_hot());
      break;
    }
    case HAS_INCLUDE_HOT_NOT_SET: {
      break;
    }
  }
  switch (from.has_include_hov2_case()) {
    case kIncludeHov2: {
      _this->_internal_set_include_hov2(from._internal_include_hov2());
      break;
    }
    case HAS_INCLUDE_HOV2_NOT_SET: {
      break;
    }
  }
  switch (from.has_include_hov3_case()) {
    case kIncludeHov3: {
      _this->_internal_set_include_hov3(from._internal_include_hov3());
      break;
    }
    case HAS_INCLUDE_HOV3_NOT_SET: {
      break;
    }
  }
  switch (from.has_exclude_cash_only_tolls_case()) {
    case kExcludeCashOnlyTolls: {
      _this->_internal_set_exclude_cash_only_tolls(from._internal_exclude_cash_only_tolls());
      break;
    }
    case HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET: {
      break;
    }
  }
  switch (from.has_restriction_probability_case()) {
    case kRestrictionProbability: {
      _this->_internal_set_restriction_probability(from._internal_restriction_probability());
      break;
    }
    case HAS_RESTRICTION_PROBABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_elevator_penalty_case()) {
    case kElevatorPenalty: {
      _this->_internal_set_elevator_penalty(from._internal_elevator_penalty());
      break;
    }
    case HAS_ELEVATOR_PENALTY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Costing_Options::CopyFrom(const Costing_Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Costing.Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Costing_Options::IsInitialized() const {
  return true;
}

void Costing_Options::InternalSwap(Costing_Options* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.filter_stop_ids_.InternalSwap(&other->_impl_.filter_stop_ids_);
  _impl_.filter_operator_ids_.InternalSwap(&other->_impl_.filter_operator_ids_);
  _impl_.filter_route_ids_.InternalSwap(&other->_impl_.filter_route_ids_);
  _impl_.exclude_edges_.InternalSwap(&other->_impl_.exclude_edges_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_route_action_)
      + sizeof(Costing_Options::_impl_.filter_route_action_)
      - PROTOBUF_FIELD_OFFSET(Costing_Options, _impl_.filter_stop_action_)>(
          reinterpret_cast<char*>(&_impl_.filter_stop_action_),
          reinterpret_cast<char*>(&other->_impl_.filter_stop_action_));
  swap(_impl_.has_maneuver_penalty_, other->_impl_.has_maneuver_penalty_);
  swap(_impl_.has_destination_only_penalty_, other->_impl_.has_destination_only_penalty_);
  swap(_impl_.has_gate_cost_, other->_impl_.has_gate_cost_);
  swap(_impl_.has_gate_penalty_, other->_impl_.has_gate_penalty_);
  swap(_impl_.has_toll_booth_cost_, other->_impl_.has_toll_booth_cost_);
  swap(_impl_.has_toll_booth_penalty_, other->_impl_.has_toll_booth_penalty_);
  swap(_impl_.has_alley_penalty_, other->_impl_.has_alley_penalty_);
  swap(_impl_.has_country_crossing_cost_, other->_impl_.has_country_crossing_cost_);
  swap(_impl_.has_country_crossing_penalty_, other->_impl_.has_country_crossing_penalty_);
  swap(_impl_.has_ferry_cost_, other->_impl_.has_ferry_cost_);
  swap(_impl_.has_avoid_bad_surfaces_, other->_impl_.has_avoid_bad_surfaces_);
  swap(_impl_.has_use_ferry_, other->_impl_.has_use_ferry_);
  swap(_impl_.has_use_highways_, other->_impl_.has_use_highways_);
  swap(_impl_.has_use_tolls_, other->_impl_.has_use_tolls_);
  swap(_impl_.has_use_roads_, other->_impl_.has_use_roads_);
  swap(_impl_.has_max_distance_, other->_impl_.has_max_distance_);
  swap(_impl_.has_walking_speed_, other->_impl_.has_walking_speed_);
  swap(_impl_.has_step_penalty_, other->_impl_.has_step_penalty_);
  swap(_impl_.has_max_grade_, other->_impl_.has_max_grade_);
  swap(_impl_.has_max_hiking_difficulty_, other->_impl_.has_max_hiking_difficulty_);
  swap(_impl_.has_mode_factor_, other->_impl_.has_mode_factor_);
  swap(_impl_.has_walkway_factor_, other->_impl_.has_walkway_factor_);
  swap(_impl_.has_sidewalk_factor_, other->_impl_.has_sidewalk_factor_);
  swap(_impl_.has_alley_factor_, other->_impl_.has_alley_factor_);
  swap(_impl_.has_driveway_factor_, other->_impl_.has_driveway_factor_);
  swap(_impl_.has_driveway_penalty_, other->_impl_.has_driveway_penalty_);
  swap(_impl_.has_transit_start_end_max_distance_, other->_impl_.has_transit_start_end_max_distance_);
  swap(_impl_.has_transit_transfer_max_distance_, other->_impl_.has_transit_transfer_max_distance_);
  swap(_impl_.has_transport_type_, other->_impl_.has_transport_type_);
  swap(_impl_.has_top_speed_, other->_impl_.has_top_speed_);
  swap(_impl_.has_use_hills_, other->_impl_.has_use_hills_);
  swap(_impl_.has_use_primary_, other->_impl_.has_use_primary_);
  swap(_impl_.has_use_trails_, other->_impl_.has_use_trails_);
  swap(_impl_.has_low_class_penalty_, other->_impl_.has_low_class_penalty_);
  swap(_impl_.has_hazmat_, other->_impl_.has_hazmat_);
  swap(_impl_.has_weight_, other->_impl_.has_weight_);
  swap(_impl_.has_axle_load_, other->_impl_.has_axle_load_);
  swap(_impl_.has_height_, other->_impl_.has_height_);
  swap(_impl_.has_width_, other->_impl_.has_width_);
  swap(_impl_.has_length_, other->_impl_.has_length_);
  swap(_impl_.has_cycling_speed_, other->_impl_.has_cycling_speed_);
  swap(_impl_.has_wheelchair_, other->_impl_.has_wheelchair_);
  swap(_impl_.has_bicycle_, other->_impl_.has_bicycle_);
  swap(_impl_.has_use_bus_, other->_impl_.has_use_bus_);
  swap(_impl_.has_use_rail_, other->_impl_.has_use_rail_);
  swap(_impl_.has_use_transfers_, other->_impl_.has_use_transfers_);
  swap(_impl_.has_transfer_cost_, other->_impl_.has_transfer_cost_);
  swap(_impl_.has_transfer_penalty_, other->_impl_.has_transfer_penalty_);
  swap(_impl_.has_flow_mask_, other->_impl_.has_flow_mask_);
  swap(_impl_.has_bike_share_cost_, other->_impl_.has_bike_share_cost_);
  swap(_impl_.has_bike_share_penalty_, other->_impl_.has_bike_share_penalty_);
  swap(_impl_.has_rail_ferry_cost_, other->_impl_.has_rail_ferry_cost_);
  swap(_impl_.has_use_rail_ferry_, other->_impl_.has_use_rail_ferry_);
  swap(_impl_.has_ignore_restrictions_, other->_impl_.has_ignore_restrictions_);
  swap(_impl_.has_ignore_oneways_, other->_impl_.has_ignore_oneways_);
  swap(_impl_.has_ignore_access_, other->_impl_.has_ignore_access_);
  swap(_impl_.has_ignore_closures_, other->_impl_.has_ignore_closures_);
  swap(_impl_.has_shortest_, other->_impl_.has_shortest_);
  swap(_impl_.has_service_penalty_, other->_impl_.has_service_penalty_);
  swap(_impl_.has_use_tracks_, other->_impl_.has_use_tracks_);
  swap(_impl_.has_use_distance_, other->_impl_.has_use_distance_);
  swap(_impl_.has_use_living_streets_, other->_impl_.has_use_living_streets_);
  swap(_impl_.has_service_factor_, other->_impl_.has_service_factor_);
  swap(_impl_.has_closure_factor_, other->_impl_.has_closure_factor_);
  swap(_impl_.has_private_access_penalty_, other->_impl_.has_private_access_penalty_);
  swap(_impl_.has_exclude_unpaved_, other->_impl_.has_exclude_unpaved_);
  swap(_impl_.has_include_hot_, other->_impl_.has_include_hot_);
  swap(_impl_.has_include_hov2_, other->_impl_.has_include_hov2_);
  swap(_impl_.has_include_hov3_, other->_impl_.has_include_hov3_);
  swap(_impl_.has_exclude_cash_only_tolls_, other->_impl_.has_exclude_cash_only_tolls_);
  swap(_impl_.has_restriction_probability_, other->_impl_.has_restriction_probability_);
  swap(_impl_.has_elevator_penalty_, other->_impl_.has_elevator_penalty_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
  swap(_impl_._oneof_case_[12], other->_impl_._oneof_case_[12]);
  swap(_impl_._oneof_case_[13], other->_impl_._oneof_case_[13]);
  swap(_impl_._oneof_case_[14], other->_impl_._oneof_case_[14]);
  swap(_impl_._oneof_case_[15], other->_impl_._oneof_case_[15]);
  swap(_impl_._oneof_case_[16], other->_impl_._oneof_case_[16]);
  swap(_impl_._oneof_case_[17], other->_impl_._oneof_case_[17]);
  swap(_impl_._oneof_case_[18], other->_impl_._oneof_case_[18]);
  swap(_impl_._oneof_case_[19], other->_impl_._oneof_case_[19]);
  swap(_impl_._oneof_case_[20], other->_impl_._oneof_case_[20]);
  swap(_impl_._oneof_case_[21], other->_impl_._oneof_case_[21]);
  swap(_impl_._oneof_case_[22], other->_impl_._oneof_case_[22]);
  swap(_impl_._oneof_case_[23], other->_impl_._oneof_case_[23]);
  swap(_impl_._oneof_case_[24], other->_impl_._oneof_case_[24]);
  swap(_impl_._oneof_case_[25], other->_impl_._oneof_case_[25]);
  swap(_impl_._oneof_case_[26], other->_impl_._oneof_case_[26]);
  swap(_impl_._oneof_case_[27], other->_impl_._oneof_case_[27]);
  swap(_impl_._oneof_case_[28], other->_impl_._oneof_case_[28]);
  swap(_impl_._oneof_case_[29], other->_impl_._oneof_case_[29]);
  swap(_impl_._oneof_case_[30], other->_impl_._oneof_case_[30]);
  swap(_impl_._oneof_case_[31], other->_impl_._oneof_case_[31]);
  swap(_impl_._oneof_case_[32], other->_impl_._oneof_case_[32]);
  swap(_impl_._oneof_case_[33], other->_impl_._oneof_case_[33]);
  swap(_impl_._oneof_case_[34], other->_impl_._oneof_case_[34]);
  swap(_impl_._oneof_case_[35], other->_impl_._oneof_case_[35]);
  swap(_impl_._oneof_case_[36], other->_impl_._oneof_case_[36]);
  swap(_impl_._oneof_case_[37], other->_impl_._oneof_case_[37]);
  swap(_impl_._oneof_case_[38], other->_impl_._oneof_case_[38]);
  swap(_impl_._oneof_case_[39], other->_impl_._oneof_case_[39]);
  swap(_impl_._oneof_case_[40], other->_impl_._oneof_case_[40]);
  swap(_impl_._oneof_case_[41], other->_impl_._oneof_case_[41]);
  swap(_impl_._oneof_case_[42], other->_impl_._oneof_case_[42]);
  swap(_impl_._oneof_case_[43], other->_impl_._oneof_case_[43]);
  swap(_impl_._oneof_case_[44], other->_impl_._oneof_case_[44]);
  swap(_impl_._oneof_case_[45], other->_impl_._oneof_case_[45]);
  swap(_impl_._oneof_case_[46], other->_impl_._oneof_case_[46]);
  swap(_impl_._oneof_case_[47], other->_impl_._oneof_case_[47]);
  swap(_impl_._oneof_case_[48], other->_impl_._oneof_case_[48]);
  swap(_impl_._oneof_case_[49], other->_impl_._oneof_case_[49]);
  swap(_impl_._oneof_case_[50], other->_impl_._oneof_case_[50]);
  swap(_impl_._oneof_case_[51], other->_impl_._oneof_case_[51]);
  swap(_impl_._oneof_case_[52], other->_impl_._oneof_case_[52]);
  swap(_impl_._oneof_case_[53], other->_impl_._oneof_case_[53]);
  swap(_impl_._oneof_case_[54], other->_impl_._oneof_case_[54]);
  swap(_impl_._oneof_case_[55], other->_impl_._oneof_case_[55]);
  swap(_impl_._oneof_case_[56], other->_impl_._oneof_case_[56]);
  swap(_impl_._oneof_case_[57], other->_impl_._oneof_case_[57]);
  swap(_impl_._oneof_case_[58], other->_impl_._oneof_case_[58]);
  swap(_impl_._oneof_case_[59], other->_impl_._oneof_case_[59]);
  swap(_impl_._oneof_case_[60], other->_impl_._oneof_case_[60]);
  swap(_impl_._oneof_case_[61], other->_impl_._oneof_case_[61]);
  swap(_impl_._oneof_case_[62], other->_impl_._oneof_case_[62]);
  swap(_impl_._oneof_case_[63], other->_impl_._oneof_case_[63]);
  swap(_impl_._oneof_case_[64], other->_impl_._oneof_case_[64]);
  swap(_impl_._oneof_case_[65], other->_impl_._oneof_case_[65]);
  swap(_impl_._oneof_case_[66], other->_impl_._oneof_case_[66]);
  swap(_impl_._oneof_case_[67], other->_impl_._oneof_case_[67]);
  swap(_impl_._oneof_case_[68], other->_impl_._oneof_case_[68]);
  swap(_impl_._oneof_case_[69], other->_impl_._oneof_case_[69]);
  swap(_impl_._oneof_case_[70], other->_impl_._oneof_case_[70]);
  swap(_impl_._oneof_case_[71], other->_impl_._oneof_case_[71]);
}

std::string Costing_Options::GetTypeName() const {
  return "valhalla.Costing.Options";
}


// ===================================================================

class Costing::_Internal {
 public:
  static const ::valhalla::Costing_Options& options(const Costing* msg);
};

const ::valhalla::Costing_Options&
Costing::_Internal::options(const Costing* msg) {
  return *msg->_impl_.has_options_.options_;
}
void Costing::set_allocated_options(::valhalla::Costing_Options* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_has_options();
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
    _impl_.has_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Costing.options)
}
Costing::Costing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Costing)
}
Costing::Costing(const Costing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Costing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.has_options_){}
    , decltype(_impl_.has_name_){}
    , decltype(_impl_.has_filter_closures_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_has_options();
  switch (from.has_options_case()) {
    case kOptions: {
      _this->_internal_mutable_options()->::valhalla::Costing_Options::MergeFrom(
          from._internal_options());
      break;
    }
    case HAS_OPTIONS_NOT_SET: {
      break;
    }
  }
  clear_has_has_name();
  switch (from.has_name_case()) {
    case kName: {
      _this->_internal_set_name(from._internal_name());
      break;
    }
    case HAS_NAME_NOT_SET: {
      break;
    }
  }
  clear_has_has_filter_closures();
  switch (from.has_filter_closures_case()) {
    case kFilterClosures: {
      _this->_internal_set_filter_closures(from._internal_filter_closures());
      break;
    }
    case HAS_FILTER_CLOSURES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.Costing)
}

inline void Costing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , decltype(_impl_.has_options_){}
    , decltype(_impl_.has_name_){}
    , decltype(_impl_.has_filter_closures_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_options();
  clear_has_has_name();
  clear_has_has_filter_closures();
}

Costing::~Costing() {
  // @@protoc_insertion_point(destructor:valhalla.Costing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Costing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_options()) {
    clear_has_options();
  }
  if (has_has_name()) {
    clear_has_name();
  }
  if (has_has_filter_closures()) {
    clear_has_filter_closures();
  }
}

void Costing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Costing::clear_has_options() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing)
  switch (has_options_case()) {
    case kOptions: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.has_options_.options_;
      }
      break;
    }
    case HAS_OPTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_OPTIONS_NOT_SET;
}

void Costing::clear_has_name() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing)
  switch (has_name_case()) {
    case kName: {
      _impl_.has_name_.name_.Destroy();
      break;
    }
    case HAS_NAME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_NAME_NOT_SET;
}

void Costing::clear_has_filter_closures() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Costing)
  switch (has_filter_closures_case()) {
    case kFilterClosures: {
      // No need to clear
      break;
    }
    case HAS_FILTER_CLOSURES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_FILTER_CLOSURES_NOT_SET;
}


void Costing::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Costing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  clear_has_options();
  clear_has_name();
  clear_has_filter_closures();
  _internal_metadata_.Clear<std::string>();
}

const char* Costing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.Costing.Options options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.Costing.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::valhalla::Costing_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool filter_closures = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_filter_closures(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Costing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Costing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.Costing.Options options = 1;
  if (_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  // .valhalla.Costing.Type type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // string name = 3;
  if (_internal_has_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Costing.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // bool filter_closures = 4;
  if (_internal_has_filter_closures()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_filter_closures(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Costing)
  return target;
}

size_t Costing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Costing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.Costing.Type type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  switch (has_options_case()) {
    // .valhalla.Costing.Options options = 1;
    case kOptions: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.has_options_.options_);
      break;
    }
    case HAS_OPTIONS_NOT_SET: {
      break;
    }
  }
  switch (has_name_case()) {
    // string name = 3;
    case kName: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
      break;
    }
    case HAS_NAME_NOT_SET: {
      break;
    }
  }
  switch (has_filter_closures_case()) {
    // bool filter_closures = 4;
    case kFilterClosures: {
      total_size += 1 + 1;
      break;
    }
    case HAS_FILTER_CLOSURES_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Costing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Costing*>(
      &from));
}

void Costing::MergeFrom(const Costing& from) {
  Costing* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Costing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  switch (from.has_options_case()) {
    case kOptions: {
      _this->_internal_mutable_options()->::valhalla::Costing_Options::MergeFrom(
          from._internal_options());
      break;
    }
    case HAS_OPTIONS_NOT_SET: {
      break;
    }
  }
  switch (from.has_name_case()) {
    case kName: {
      _this->_internal_set_name(from._internal_name());
      break;
    }
    case HAS_NAME_NOT_SET: {
      break;
    }
  }
  switch (from.has_filter_closures_case()) {
    case kFilterClosures: {
      _this->_internal_set_filter_closures(from._internal_filter_closures());
      break;
    }
    case HAS_FILTER_CLOSURES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Costing::CopyFrom(const Costing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Costing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Costing::IsInitialized() const {
  return true;
}

void Costing::InternalSwap(Costing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_.has_options_, other->_impl_.has_options_);
  swap(_impl_.has_name_, other->_impl_.has_name_);
  swap(_impl_.has_filter_closures_, other->_impl_.has_filter_closures_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
}

std::string Costing::GetTypeName() const {
  return "valhalla.Costing";
}


// ===================================================================

Options_CostingsEntry_DoNotUse::Options_CostingsEntry_DoNotUse() {}
Options_CostingsEntry_DoNotUse::Options_CostingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Options_CostingsEntry_DoNotUse::MergeFrom(const Options_CostingsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class Options::_Internal {
 public:
  static const ::valhalla::PbfFieldSelector& pbf_field_selector(const Options* msg);
};

const ::valhalla::PbfFieldSelector&
Options::_Internal::pbf_field_selector(const Options* msg) {
  return *msg->_impl_.pbf_field_selector_;
}
void Options::clear_locations() {
  _impl_.locations_.Clear();
}
void Options::clear_exclude_locations() {
  _impl_.exclude_locations_.Clear();
}
void Options::clear_sources() {
  _impl_.sources_.Clear();
}
void Options::clear_targets() {
  _impl_.targets_.Clear();
}
void Options::clear_shape() {
  _impl_.shape_.Clear();
}
void Options::clear_trace() {
  _impl_.trace_.Clear();
}
Options::Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Options)
}
Options::Options(const Options& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Options* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.costings_)*/{}
    , decltype(_impl_.locations_){from._impl_.locations_}
    , decltype(_impl_.exclude_locations_){from._impl_.exclude_locations_}
    , decltype(_impl_.sources_){from._impl_.sources_}
    , decltype(_impl_.targets_){from._impl_.targets_}
    , decltype(_impl_.shape_){from._impl_.shape_}
    , decltype(_impl_.contours_){from._impl_.contours_}
    , decltype(_impl_.trace_){from._impl_.trace_}
    , decltype(_impl_.filter_attributes_){from._impl_.filter_attributes_}
    , decltype(_impl_.recostings_){from._impl_.recostings_}
    , decltype(_impl_.exclude_polygons_){from._impl_.exclude_polygons_}
    , decltype(_impl_.expansion_properties_){from._impl_.expansion_properties_}
    , /*decltype(_impl_._expansion_properties_cached_byte_size_)*/{0}
    , decltype(_impl_.pbf_field_selector_){nullptr}
    , decltype(_impl_.units_){}
    , decltype(_impl_.directions_type_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.costing_type_){}
    , decltype(_impl_.date_time_type_){}
    , decltype(_impl_.shape_match_){}
    , decltype(_impl_.filter_action_){}
    , decltype(_impl_.shape_format_){}
    , decltype(_impl_.reverse_){}
    , decltype(_impl_.matrix_locations_){}
    , decltype(_impl_.has_language_){}
    , decltype(_impl_.has_id_){}
    , decltype(_impl_.has_jsonp_){}
    , decltype(_impl_.has_encoded_polyline_){}
    , decltype(_impl_.has_range_){}
    , decltype(_impl_.has_verbose_){}
    , decltype(_impl_.has_date_time_){}
    , decltype(_impl_.has_resample_distance_){}
    , decltype(_impl_.has_polygons_){}
    , decltype(_impl_.has_denoise_){}
    , decltype(_impl_.has_generalize_){}
    , decltype(_impl_.has_show_locations_){}
    , decltype(_impl_.has_gps_accuracy_){}
    , decltype(_impl_.has_search_radius_){}
    , decltype(_impl_.has_turn_penalty_factor_){}
    , decltype(_impl_.has_breakage_distance_){}
    , decltype(_impl_.has_use_timestamps_){}
    , decltype(_impl_.has_alternates_){}
    , decltype(_impl_.has_interpolation_distance_){}
    , decltype(_impl_.has_guidance_views_){}
    , decltype(_impl_.has_height_precision_){}
    , decltype(_impl_.has_roundabout_exits_){}
    , decltype(_impl_.has_linear_references_){}
    , decltype(_impl_.has_prioritize_bidirectional_){}
    , decltype(_impl_.has_expansion_action_){}
    , decltype(_impl_.has_skip_opposites_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.costings_.MergeFrom(from._impl_.costings_);
  if (from._internal_has_pbf_field_selector()) {
    _this->_impl_.pbf_field_selector_ = new ::valhalla::PbfFieldSelector(*from._impl_.pbf_field_selector_);
  }
  ::memcpy(&_impl_.units_, &from._impl_.units_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.matrix_locations_) -
    reinterpret_cast<char*>(&_impl_.units_)) + sizeof(_impl_.matrix_locations_));
  clear_has_has_language();
  switch (from.has_language_case()) {
    case kLanguage: {
      _this->_internal_set_language(from._internal_language());
      break;
    }
    case HAS_LANGUAGE_NOT_SET: {
      break;
    }
  }
  clear_has_has_id();
  switch (from.has_id_case()) {
    case kId: {
      _this->_internal_set_id(from._internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_jsonp();
  switch (from.has_jsonp_case()) {
    case kJsonp: {
      _this->_internal_set_jsonp(from._internal_jsonp());
      break;
    }
    case HAS_JSONP_NOT_SET: {
      break;
    }
  }
  clear_has_has_encoded_polyline();
  switch (from.has_encoded_polyline_case()) {
    case kEncodedPolyline: {
      _this->_internal_set_encoded_polyline(from._internal_encoded_polyline());
      break;
    }
    case HAS_ENCODED_POLYLINE_NOT_SET: {
      break;
    }
  }
  clear_has_has_range();
  switch (from.has_range_case()) {
    case kRange: {
      _this->_internal_set_range(from._internal_range());
      break;
    }
    case HAS_RANGE_NOT_SET: {
      break;
    }
  }
  clear_has_has_verbose();
  switch (from.has_verbose_case()) {
    case kVerbose: {
      _this->_internal_set_verbose(from._internal_verbose());
      break;
    }
    case HAS_VERBOSE_NOT_SET: {
      break;
    }
  }
  clear_has_has_date_time();
  switch (from.has_date_time_case()) {
    case kDateTime: {
      _this->_internal_set_date_time(from._internal_date_time());
      break;
    }
    case HAS_DATE_TIME_NOT_SET: {
      break;
    }
  }
  clear_has_has_resample_distance();
  switch (from.has_resample_distance_case()) {
    case kResampleDistance: {
      _this->_internal_set_resample_distance(from._internal_resample_distance());
      break;
    }
    case HAS_RESAMPLE_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_polygons();
  switch (from.has_polygons_case()) {
    case kPolygons: {
      _this->_internal_set_polygons(from._internal_polygons());
      break;
    }
    case HAS_POLYGONS_NOT_SET: {
      break;
    }
  }
  clear_has_has_denoise();
  switch (from.has_denoise_case()) {
    case kDenoise: {
      _this->_internal_set_denoise(from._internal_denoise());
      break;
    }
    case HAS_DENOISE_NOT_SET: {
      break;
    }
  }
  clear_has_has_generalize();
  switch (from.has_generalize_case()) {
    case kGeneralize: {
      _this->_internal_set_generalize(from._internal_generalize());
      break;
    }
    case HAS_GENERALIZE_NOT_SET: {
      break;
    }
  }
  clear_has_has_show_locations();
  switch (from.has_show_locations_case()) {
    case kShowLocations: {
      _this->_internal_set_show_locations(from._internal_show_locations());
      break;
    }
    case HAS_SHOW_LOCATIONS_NOT_SET: {
      break;
    }
  }
  clear_has_has_gps_accuracy();
  switch (from.has_gps_accuracy_case()) {
    case kGpsAccuracy: {
      _this->_internal_set_gps_accuracy(from._internal_gps_accuracy());
      break;
    }
    case HAS_GPS_ACCURACY_NOT_SET: {
      break;
    }
  }
  clear_has_has_search_radius();
  switch (from.has_search_radius_case()) {
    case kSearchRadius: {
      _this->_internal_set_search_radius(from._internal_search_radius());
      break;
    }
    case HAS_SEARCH_RADIUS_NOT_SET: {
      break;
    }
  }
  clear_has_has_turn_penalty_factor();
  switch (from.has_turn_penalty_factor_case()) {
    case kTurnPenaltyFactor: {
      _this->_internal_set_turn_penalty_factor(from._internal_turn_penalty_factor());
      break;
    }
    case HAS_TURN_PENALTY_FACTOR_NOT_SET: {
      break;
    }
  }
  clear_has_has_breakage_distance();
  switch (from.has_breakage_distance_case()) {
    case kBreakageDistance: {
      _this->_internal_set_breakage_distance(from._internal_breakage_distance());
      break;
    }
    case HAS_BREAKAGE_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_use_timestamps();
  switch (from.has_use_timestamps_case()) {
    case kUseTimestamps: {
      _this->_internal_set_use_timestamps(from._internal_use_timestamps());
      break;
    }
    case HAS_USE_TIMESTAMPS_NOT_SET: {
      break;
    }
  }
  clear_has_has_alternates();
  switch (from.has_alternates_case()) {
    case kAlternates: {
      _this->_internal_set_alternates(from._internal_alternates());
      break;
    }
    case HAS_ALTERNATES_NOT_SET: {
      break;
    }
  }
  clear_has_has_interpolation_distance();
  switch (from.has_interpolation_distance_case()) {
    case kInterpolationDistance: {
      _this->_internal_set_interpolation_distance(from._internal_interpolation_distance());
      break;
    }
    case HAS_INTERPOLATION_DISTANCE_NOT_SET: {
      break;
    }
  }
  clear_has_has_guidance_views();
  switch (from.has_guidance_views_case()) {
    case kGuidanceViews: {
      _this->_internal_set_guidance_views(from._internal_guidance_views());
      break;
    }
    case HAS_GUIDANCE_VIEWS_NOT_SET: {
      break;
    }
  }
  clear_has_has_height_precision();
  switch (from.has_height_precision_case()) {
    case kHeightPrecision: {
      _this->_internal_set_height_precision(from._internal_height_precision());
      break;
    }
    case HAS_HEIGHT_PRECISION_NOT_SET: {
      break;
    }
  }
  clear_has_has_roundabout_exits();
  switch (from.has_roundabout_exits_case()) {
    case kRoundaboutExits: {
      _this->_internal_set_roundabout_exits(from._internal_roundabout_exits());
      break;
    }
    case HAS_ROUNDABOUT_EXITS_NOT_SET: {
      break;
    }
  }
  clear_has_has_linear_references();
  switch (from.has_linear_references_case()) {
    case kLinearReferences: {
      _this->_internal_set_linear_references(from._internal_linear_references());
      break;
    }
    case HAS_LINEAR_REFERENCES_NOT_SET: {
      break;
    }
  }
  clear_has_has_prioritize_bidirectional();
  switch (from.has_prioritize_bidirectional_case()) {
    case kPrioritizeBidirectional: {
      _this->_internal_set_prioritize_bidirectional(from._internal_prioritize_bidirectional());
      break;
    }
    case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET: {
      break;
    }
  }
  clear_has_has_expansion_action();
  switch (from.has_expansion_action_case()) {
    case kExpansionAction: {
      _this->_internal_set_expansion_action(from._internal_expansion_action());
      break;
    }
    case HAS_EXPANSION_ACTION_NOT_SET: {
      break;
    }
  }
  clear_has_has_skip_opposites();
  switch (from.has_skip_opposites_case()) {
    case kSkipOpposites: {
      _this->_internal_set_skip_opposites(from._internal_skip_opposites());
      break;
    }
    case HAS_SKIP_OPPOSITES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.Options)
}

inline void Options::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.costings_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.locations_){arena}
    , decltype(_impl_.exclude_locations_){arena}
    , decltype(_impl_.sources_){arena}
    , decltype(_impl_.targets_){arena}
    , decltype(_impl_.shape_){arena}
    , decltype(_impl_.contours_){arena}
    , decltype(_impl_.trace_){arena}
    , decltype(_impl_.filter_attributes_){arena}
    , decltype(_impl_.recostings_){arena}
    , decltype(_impl_.exclude_polygons_){arena}
    , decltype(_impl_.expansion_properties_){arena}
    , /*decltype(_impl_._expansion_properties_cached_byte_size_)*/{0}
    , decltype(_impl_.pbf_field_selector_){nullptr}
    , decltype(_impl_.units_){0}
    , decltype(_impl_.directions_type_){0}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.action_){0}
    , decltype(_impl_.costing_type_){0}
    , decltype(_impl_.date_time_type_){0}
    , decltype(_impl_.shape_match_){0}
    , decltype(_impl_.filter_action_){0}
    , decltype(_impl_.shape_format_){0}
    , decltype(_impl_.reverse_){false}
    , decltype(_impl_.matrix_locations_){0u}
    , decltype(_impl_.has_language_){}
    , decltype(_impl_.has_id_){}
    , decltype(_impl_.has_jsonp_){}
    , decltype(_impl_.has_encoded_polyline_){}
    , decltype(_impl_.has_range_){}
    , decltype(_impl_.has_verbose_){}
    , decltype(_impl_.has_date_time_){}
    , decltype(_impl_.has_resample_distance_){}
    , decltype(_impl_.has_polygons_){}
    , decltype(_impl_.has_denoise_){}
    , decltype(_impl_.has_generalize_){}
    , decltype(_impl_.has_show_locations_){}
    , decltype(_impl_.has_gps_accuracy_){}
    , decltype(_impl_.has_search_radius_){}
    , decltype(_impl_.has_turn_penalty_factor_){}
    , decltype(_impl_.has_breakage_distance_){}
    , decltype(_impl_.has_use_timestamps_){}
    , decltype(_impl_.has_alternates_){}
    , decltype(_impl_.has_interpolation_distance_){}
    , decltype(_impl_.has_guidance_views_){}
    , decltype(_impl_.has_height_precision_){}
    , decltype(_impl_.has_roundabout_exits_){}
    , decltype(_impl_.has_linear_references_){}
    , decltype(_impl_.has_prioritize_bidirectional_){}
    , decltype(_impl_.has_expansion_action_){}
    , decltype(_impl_.has_skip_opposites_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_language();
  clear_has_has_id();
  clear_has_has_jsonp();
  clear_has_has_encoded_polyline();
  clear_has_has_range();
  clear_has_has_verbose();
  clear_has_has_date_time();
  clear_has_has_resample_distance();
  clear_has_has_polygons();
  clear_has_has_denoise();
  clear_has_has_generalize();
  clear_has_has_show_locations();
  clear_has_has_gps_accuracy();
  clear_has_has_search_radius();
  clear_has_has_turn_penalty_factor();
  clear_has_has_breakage_distance();
  clear_has_has_use_timestamps();
  clear_has_has_alternates();
  clear_has_has_interpolation_distance();
  clear_has_has_guidance_views();
  clear_has_has_height_precision();
  clear_has_has_roundabout_exits();
  clear_has_has_linear_references();
  clear_has_has_prioritize_bidirectional();
  clear_has_has_expansion_action();
  clear_has_has_skip_opposites();
}

Options::~Options() {
  // @@protoc_insertion_point(destructor:valhalla.Options)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Options::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.costings_.Destruct();
  _impl_.costings_.~MapFieldLite();
  _impl_.locations_.~RepeatedPtrField();
  _impl_.exclude_locations_.~RepeatedPtrField();
  _impl_.sources_.~RepeatedPtrField();
  _impl_.targets_.~RepeatedPtrField();
  _impl_.shape_.~RepeatedPtrField();
  _impl_.contours_.~RepeatedPtrField();
  _impl_.trace_.~RepeatedPtrField();
  _impl_.filter_attributes_.~RepeatedPtrField();
  _impl_.recostings_.~RepeatedPtrField();
  _impl_.exclude_polygons_.~RepeatedPtrField();
  _impl_.expansion_properties_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.pbf_field_selector_;
  if (has_has_language()) {
    clear_has_language();
  }
  if (has_has_id()) {
    clear_has_id();
  }
  if (has_has_jsonp()) {
    clear_has_jsonp();
  }
  if (has_has_encoded_polyline()) {
    clear_has_encoded_polyline();
  }
  if (has_has_range()) {
    clear_has_range();
  }
  if (has_has_verbose()) {
    clear_has_verbose();
  }
  if (has_has_date_time()) {
    clear_has_date_time();
  }
  if (has_has_resample_distance()) {
    clear_has_resample_distance();
  }
  if (has_has_polygons()) {
    clear_has_polygons();
  }
  if (has_has_denoise()) {
    clear_has_denoise();
  }
  if (has_has_generalize()) {
    clear_has_generalize();
  }
  if (has_has_show_locations()) {
    clear_has_show_locations();
  }
  if (has_has_gps_accuracy()) {
    clear_has_gps_accuracy();
  }
  if (has_has_search_radius()) {
    clear_has_search_radius();
  }
  if (has_has_turn_penalty_factor()) {
    clear_has_turn_penalty_factor();
  }
  if (has_has_breakage_distance()) {
    clear_has_breakage_distance();
  }
  if (has_has_use_timestamps()) {
    clear_has_use_timestamps();
  }
  if (has_has_alternates()) {
    clear_has_alternates();
  }
  if (has_has_interpolation_distance()) {
    clear_has_interpolation_distance();
  }
  if (has_has_guidance_views()) {
    clear_has_guidance_views();
  }
  if (has_has_height_precision()) {
    clear_has_height_precision();
  }
  if (has_has_roundabout_exits()) {
    clear_has_roundabout_exits();
  }
  if (has_has_linear_references()) {
    clear_has_linear_references();
  }
  if (has_has_prioritize_bidirectional()) {
    clear_has_prioritize_bidirectional();
  }
  if (has_has_expansion_action()) {
    clear_has_expansion_action();
  }
  if (has_has_skip_opposites()) {
    clear_has_skip_opposites();
  }
}

void Options::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Options::clear_has_language() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_language_case()) {
    case kLanguage: {
      _impl_.has_language_.language_.Destroy();
      break;
    }
    case HAS_LANGUAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_LANGUAGE_NOT_SET;
}

void Options::clear_has_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_id_case()) {
    case kId: {
      _impl_.has_id_.id_.Destroy();
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_ID_NOT_SET;
}

void Options::clear_has_jsonp() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_jsonp_case()) {
    case kJsonp: {
      _impl_.has_jsonp_.jsonp_.Destroy();
      break;
    }
    case HAS_JSONP_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_JSONP_NOT_SET;
}

void Options::clear_has_encoded_polyline() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_encoded_polyline_case()) {
    case kEncodedPolyline: {
      _impl_.has_encoded_polyline_.encoded_polyline_.Destroy();
      break;
    }
    case HAS_ENCODED_POLYLINE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_ENCODED_POLYLINE_NOT_SET;
}

void Options::clear_has_range() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_range_case()) {
    case kRange: {
      // No need to clear
      break;
    }
    case HAS_RANGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_RANGE_NOT_SET;
}

void Options::clear_has_verbose() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_verbose_case()) {
    case kVerbose: {
      // No need to clear
      break;
    }
    case HAS_VERBOSE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_VERBOSE_NOT_SET;
}

void Options::clear_has_date_time() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_date_time_case()) {
    case kDateTime: {
      _impl_.has_date_time_.date_time_.Destroy();
      break;
    }
    case HAS_DATE_TIME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_DATE_TIME_NOT_SET;
}

void Options::clear_has_resample_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_resample_distance_case()) {
    case kResampleDistance: {
      // No need to clear
      break;
    }
    case HAS_RESAMPLE_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_RESAMPLE_DISTANCE_NOT_SET;
}

void Options::clear_has_polygons() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_polygons_case()) {
    case kPolygons: {
      // No need to clear
      break;
    }
    case HAS_POLYGONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_POLYGONS_NOT_SET;
}

void Options::clear_has_denoise() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_denoise_case()) {
    case kDenoise: {
      // No need to clear
      break;
    }
    case HAS_DENOISE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = HAS_DENOISE_NOT_SET;
}

void Options::clear_has_generalize() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_generalize_case()) {
    case kGeneralize: {
      // No need to clear
      break;
    }
    case HAS_GENERALIZE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = HAS_GENERALIZE_NOT_SET;
}

void Options::clear_has_show_locations() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_show_locations_case()) {
    case kShowLocations: {
      // No need to clear
      break;
    }
    case HAS_SHOW_LOCATIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = HAS_SHOW_LOCATIONS_NOT_SET;
}

void Options::clear_has_gps_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_gps_accuracy_case()) {
    case kGpsAccuracy: {
      // No need to clear
      break;
    }
    case HAS_GPS_ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[12] = HAS_GPS_ACCURACY_NOT_SET;
}

void Options::clear_has_search_radius() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_search_radius_case()) {
    case kSearchRadius: {
      // No need to clear
      break;
    }
    case HAS_SEARCH_RADIUS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[13] = HAS_SEARCH_RADIUS_NOT_SET;
}

void Options::clear_has_turn_penalty_factor() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_turn_penalty_factor_case()) {
    case kTurnPenaltyFactor: {
      // No need to clear
      break;
    }
    case HAS_TURN_PENALTY_FACTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[14] = HAS_TURN_PENALTY_FACTOR_NOT_SET;
}

void Options::clear_has_breakage_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_breakage_distance_case()) {
    case kBreakageDistance: {
      // No need to clear
      break;
    }
    case HAS_BREAKAGE_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[15] = HAS_BREAKAGE_DISTANCE_NOT_SET;
}

void Options::clear_has_use_timestamps() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_use_timestamps_case()) {
    case kUseTimestamps: {
      // No need to clear
      break;
    }
    case HAS_USE_TIMESTAMPS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[16] = HAS_USE_TIMESTAMPS_NOT_SET;
}

void Options::clear_has_alternates() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_alternates_case()) {
    case kAlternates: {
      // No need to clear
      break;
    }
    case HAS_ALTERNATES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[17] = HAS_ALTERNATES_NOT_SET;
}

void Options::clear_has_interpolation_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_interpolation_distance_case()) {
    case kInterpolationDistance: {
      // No need to clear
      break;
    }
    case HAS_INTERPOLATION_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[18] = HAS_INTERPOLATION_DISTANCE_NOT_SET;
}

void Options::clear_has_guidance_views() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_guidance_views_case()) {
    case kGuidanceViews: {
      // No need to clear
      break;
    }
    case HAS_GUIDANCE_VIEWS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[19] = HAS_GUIDANCE_VIEWS_NOT_SET;
}

void Options::clear_has_height_precision() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_height_precision_case()) {
    case kHeightPrecision: {
      // No need to clear
      break;
    }
    case HAS_HEIGHT_PRECISION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[20] = HAS_HEIGHT_PRECISION_NOT_SET;
}

void Options::clear_has_roundabout_exits() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_roundabout_exits_case()) {
    case kRoundaboutExits: {
      // No need to clear
      break;
    }
    case HAS_ROUNDABOUT_EXITS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[21] = HAS_ROUNDABOUT_EXITS_NOT_SET;
}

void Options::clear_has_linear_references() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_linear_references_case()) {
    case kLinearReferences: {
      // No need to clear
      break;
    }
    case HAS_LINEAR_REFERENCES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[22] = HAS_LINEAR_REFERENCES_NOT_SET;
}

void Options::clear_has_prioritize_bidirectional() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_prioritize_bidirectional_case()) {
    case kPrioritizeBidirectional: {
      // No need to clear
      break;
    }
    case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[23] = HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}

void Options::clear_has_expansion_action() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_expansion_action_case()) {
    case kExpansionAction: {
      // No need to clear
      break;
    }
    case HAS_EXPANSION_ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[24] = HAS_EXPANSION_ACTION_NOT_SET;
}

void Options::clear_has_skip_opposites() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Options)
  switch (has_skip_opposites_case()) {
    case kSkipOpposites: {
      // No need to clear
      break;
    }
    case HAS_SKIP_OPPOSITES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[25] = HAS_SKIP_OPPOSITES_NOT_SET;
}


void Options::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Options)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.costings_.Clear();
  _impl_.locations_.Clear();
  _impl_.exclude_locations_.Clear();
  _impl_.sources_.Clear();
  _impl_.targets_.Clear();
  _impl_.shape_.Clear();
  _impl_.contours_.Clear();
  _impl_.trace_.Clear();
  _impl_.filter_attributes_.Clear();
  _impl_.recostings_.Clear();
  _impl_.exclude_polygons_.Clear();
  _impl_.expansion_properties_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.pbf_field_selector_ != nullptr) {
    delete _impl_.pbf_field_selector_;
  }
  _impl_.pbf_field_selector_ = nullptr;
  ::memset(&_impl_.units_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.matrix_locations_) -
      reinterpret_cast<char*>(&_impl_.units_)) + sizeof(_impl_.matrix_locations_));
  clear_has_language();
  clear_has_id();
  clear_has_jsonp();
  clear_has_encoded_polyline();
  clear_has_range();
  clear_has_verbose();
  clear_has_date_time();
  clear_has_resample_distance();
  clear_has_polygons();
  clear_has_denoise();
  clear_has_generalize();
  clear_has_show_locations();
  clear_has_gps_accuracy();
  clear_has_search_radius();
  clear_has_turn_penalty_factor();
  clear_has_breakage_distance();
  clear_has_use_timestamps();
  clear_has_alternates();
  clear_has_interpolation_distance();
  clear_has_guidance_views();
  clear_has_height_precision();
  clear_has_roundabout_exits();
  clear_has_linear_references();
  clear_has_prioritize_bidirectional();
  clear_has_expansion_action();
  clear_has_skip_opposites();
  _internal_metadata_.Clear<std::string>();
}

const char* Options::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.Options.Units units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_units(static_cast<::valhalla::Options_Units>(val));
        } else
          goto handle_unusual;
        continue;
      // string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.DirectionsType directions_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_directions_type(static_cast<::valhalla::DirectionsType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.Options.Format format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_format(static_cast<::valhalla::Options_Format>(val));
        } else
          goto handle_unusual;
        continue;
      // string id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string jsonp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_jsonp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string encoded_polyline = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_encoded_polyline();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.Options.Action action = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_action(static_cast<::valhalla::Options_Action>(val));
        } else
          goto handle_unusual;
        continue;
      // bool range = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _internal_set_range(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool verbose = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_verbose(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.Costing.Type costing_type = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_costing_type(static_cast<::valhalla::Costing_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // map<int32, .valhalla.Costing> costings = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.costings_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location locations = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location exclude_locations = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exclude_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location sources = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location targets = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.Options.DateTimeType date_time_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_date_time_type(static_cast<::valhalla::Options_DateTimeType>(val));
        } else
          goto handle_unusual;
        continue;
      // string date_time = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_date_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location shape = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_shape(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double resample_distance = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _internal_set_resample_distance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Contour contours = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_contours(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool polygons = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _internal_set_polygons(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float denoise = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _internal_set_denoise(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float generalize = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _internal_set_generalize(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool show_locations = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _internal_set_show_locations(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location trace = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_trace(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.ShapeMatch shape_match = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_shape_match(static_cast<::valhalla::ShapeMatch>(val));
        } else
          goto handle_unusual;
        continue;
      // float gps_accuracy = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 245)) {
          _internal_set_gps_accuracy(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float search_radius = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          _internal_set_search_radius(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float turn_penalty_factor = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          _internal_set_turn_penalty_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.FilterAction filter_action = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_filter_action(static_cast<::valhalla::FilterAction>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string filter_attributes = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_attributes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float breakage_distance = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _internal_set_breakage_distance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool use_timestamps = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_use_timestamps(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.ShapeFormat shape_format = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_shape_format(static_cast<::valhalla::ShapeFormat>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 alternates = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _internal_set_alternates(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float interpolation_distance = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _internal_set_interpolation_distance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool guidance_views = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _internal_set_guidance_views(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height_precision = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_height_precision(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool roundabout_exits = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_roundabout_exits(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool linear_references = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _internal_set_linear_references(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Costing recostings = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_recostings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<370>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Ring exclude_polygons = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_exclude_polygons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<378>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool prioritize_bidirectional = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _internal_set_prioritize_bidirectional(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.Options.Action expansion_action = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_expansion_action(static_cast<::valhalla::Options_Action>(val));
        } else
          goto handle_unusual;
        continue;
      // bool skip_opposites = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _internal_set_skip_opposites(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_expansion_properties(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 152) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_expansion_properties(static_cast<::valhalla::Options_ExpansionProperties>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.PbfFieldSelector pbf_field_selector = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_pbf_field_selector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reverse = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 matrix_locations = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.matrix_locations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Options::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Options)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.Options.Units units = 1;
  if (this->_internal_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_units(), target);
  }

  // string language = 2;
  if (_internal_has_language()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Options.language");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  // .valhalla.DirectionsType directions_type = 3;
  if (this->_internal_directions_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_directions_type(), target);
  }

  // .valhalla.Options.Format format = 4;
  if (this->_internal_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_format(), target);
  }

  // string id = 5;
  if (_internal_has_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Options.id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_id(), target);
  }

  // string jsonp = 6;
  if (_internal_has_jsonp()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_jsonp().data(), static_cast<int>(this->_internal_jsonp().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Options.jsonp");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_jsonp(), target);
  }

  // string encoded_polyline = 7;
  if (_internal_has_encoded_polyline()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_encoded_polyline().data(), static_cast<int>(this->_internal_encoded_polyline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Options.encoded_polyline");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_encoded_polyline(), target);
  }

  // .valhalla.Options.Action action = 8;
  if (this->_internal_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_action(), target);
  }

  // bool range = 10;
  if (_internal_has_range()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_range(), target);
  }

  // bool verbose = 11;
  if (_internal_has_verbose()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_verbose(), target);
  }

  // .valhalla.Costing.Type costing_type = 12;
  if (this->_internal_costing_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_costing_type(), target);
  }

  // map<int32, .valhalla.Costing> costings = 13;
  if (!this->_internal_costings().empty()) {
    using MapType = ::_pb::Map<int32_t, ::valhalla::Costing>;
    using WireHelper = Options_CostingsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_costings();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(13, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(13, entry.first, entry.second, target, stream);
      }
    }
  }

  // repeated .valhalla.Location locations = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locations_size()); i < n; i++) {
    const auto& repfield = this->_internal_locations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.Location exclude_locations = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exclude_locations_size()); i < n; i++) {
    const auto& repfield = this->_internal_exclude_locations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.Location sources = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sources_size()); i < n; i++) {
    const auto& repfield = this->_internal_sources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.Location targets = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_targets_size()); i < n; i++) {
    const auto& repfield = this->_internal_targets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .valhalla.Options.DateTimeType date_time_type = 18;
  if (this->_internal_date_time_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_date_time_type(), target);
  }

  // string date_time = 19;
  if (_internal_has_date_time()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_date_time().data(), static_cast<int>(this->_internal_date_time().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Options.date_time");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_date_time(), target);
  }

  // repeated .valhalla.Location shape = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shape_size()); i < n; i++) {
    const auto& repfield = this->_internal_shape(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // double resample_distance = 21;
  if (_internal_has_resample_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(21, this->_internal_resample_distance(), target);
  }

  // repeated .valhalla.Contour contours = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contours_size()); i < n; i++) {
    const auto& repfield = this->_internal_contours(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool polygons = 23;
  if (_internal_has_polygons()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_polygons(), target);
  }

  // float denoise = 24;
  if (_internal_has_denoise()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_denoise(), target);
  }

  // float generalize = 25;
  if (_internal_has_generalize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_generalize(), target);
  }

  // bool show_locations = 26;
  if (_internal_has_show_locations()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_show_locations(), target);
  }

  // repeated .valhalla.Location trace = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trace_size()); i < n; i++) {
    const auto& repfield = this->_internal_trace(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .valhalla.ShapeMatch shape_match = 28;
  if (this->_internal_shape_match() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      28, this->_internal_shape_match(), target);
  }

  // float gps_accuracy = 30;
  if (_internal_has_gps_accuracy()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(30, this->_internal_gps_accuracy(), target);
  }

  // float search_radius = 31;
  if (_internal_has_search_radius()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(31, this->_internal_search_radius(), target);
  }

  // float turn_penalty_factor = 32;
  if (_internal_has_turn_penalty_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(32, this->_internal_turn_penalty_factor(), target);
  }

  // .valhalla.FilterAction filter_action = 33;
  if (this->_internal_filter_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      33, this->_internal_filter_action(), target);
  }

  // repeated string filter_attributes = 34;
  for (int i = 0, n = this->_internal_filter_attributes_size(); i < n; i++) {
    const auto& s = this->_internal_filter_attributes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.Options.filter_attributes");
    target = stream->WriteString(34, s, target);
  }

  // float breakage_distance = 36;
  if (_internal_has_breakage_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(36, this->_internal_breakage_distance(), target);
  }

  // bool use_timestamps = 37;
  if (_internal_has_use_timestamps()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_use_timestamps(), target);
  }

  // .valhalla.ShapeFormat shape_format = 38;
  if (this->_internal_shape_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      38, this->_internal_shape_format(), target);
  }

  // uint32 alternates = 39;
  if (_internal_has_alternates()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_alternates(), target);
  }

  // float interpolation_distance = 40;
  if (_internal_has_interpolation_distance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(40, this->_internal_interpolation_distance(), target);
  }

  // bool guidance_views = 41;
  if (_internal_has_guidance_views()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(41, this->_internal_guidance_views(), target);
  }

  // uint32 height_precision = 43;
  if (_internal_has_height_precision()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(43, this->_internal_height_precision(), target);
  }

  // bool roundabout_exits = 44;
  if (_internal_has_roundabout_exits()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(44, this->_internal_roundabout_exits(), target);
  }

  // bool linear_references = 45;
  if (_internal_has_linear_references()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(45, this->_internal_linear_references(), target);
  }

  // repeated .valhalla.Costing recostings = 46;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_recostings_size()); i < n; i++) {
    const auto& repfield = this->_internal_recostings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(46, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.Ring exclude_polygons = 47;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exclude_polygons_size()); i < n; i++) {
    const auto& repfield = this->_internal_exclude_polygons(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(47, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool prioritize_bidirectional = 48;
  if (_internal_has_prioritize_bidirectional()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(48, this->_internal_prioritize_bidirectional(), target);
  }

  // .valhalla.Options.Action expansion_action = 49;
  if (_internal_has_expansion_action()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      49, this->_internal_expansion_action(), target);
  }

  // bool skip_opposites = 50;
  if (_internal_has_skip_opposites()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(50, this->_internal_skip_opposites(), target);
  }

  // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
  {
    int byte_size = _impl_._expansion_properties_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          51, _impl_.expansion_properties_, byte_size, target);
    }
  }

  // .valhalla.PbfFieldSelector pbf_field_selector = 52;
  if (this->_internal_has_pbf_field_selector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(52, _Internal::pbf_field_selector(this),
        _Internal::pbf_field_selector(this).GetCachedSize(), target, stream);
  }

  // bool reverse = 53;
  if (this->_internal_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(53, this->_internal_reverse(), target);
  }

  // uint32 matrix_locations = 54;
  if (this->_internal_matrix_locations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(54, this->_internal_matrix_locations(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Options)
  return target;
}

size_t Options::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Options)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .valhalla.Costing> costings = 13;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_costings_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >::const_iterator
      it = this->_internal_costings().begin();
      it != this->_internal_costings().end(); ++it) {
    total_size += Options_CostingsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .valhalla.Location locations = 14;
  total_size += 1UL * this->_internal_locations_size();
  for (const auto& msg : this->_impl_.locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location exclude_locations = 15;
  total_size += 1UL * this->_internal_exclude_locations_size();
  for (const auto& msg : this->_impl_.exclude_locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location sources = 16;
  total_size += 2UL * this->_internal_sources_size();
  for (const auto& msg : this->_impl_.sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location targets = 17;
  total_size += 2UL * this->_internal_targets_size();
  for (const auto& msg : this->_impl_.targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location shape = 20;
  total_size += 2UL * this->_internal_shape_size();
  for (const auto& msg : this->_impl_.shape_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Contour contours = 22;
  total_size += 2UL * this->_internal_contours_size();
  for (const auto& msg : this->_impl_.contours_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location trace = 27;
  total_size += 2UL * this->_internal_trace_size();
  for (const auto& msg : this->_impl_.trace_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string filter_attributes = 34;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.filter_attributes_.size());
  for (int i = 0, n = _impl_.filter_attributes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.filter_attributes_.Get(i));
  }

  // repeated .valhalla.Costing recostings = 46;
  total_size += 2UL * this->_internal_recostings_size();
  for (const auto& msg : this->_impl_.recostings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Ring exclude_polygons = 47;
  total_size += 2UL * this->_internal_exclude_polygons_size();
  for (const auto& msg : this->_impl_.exclude_polygons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_expansion_properties_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_expansion_properties(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._expansion_properties_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .valhalla.PbfFieldSelector pbf_field_selector = 52;
  if (this->_internal_has_pbf_field_selector()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pbf_field_selector_);
  }

  // .valhalla.Options.Units units = 1;
  if (this->_internal_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_units());
  }

  // .valhalla.DirectionsType directions_type = 3;
  if (this->_internal_directions_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_directions_type());
  }

  // .valhalla.Options.Format format = 4;
  if (this->_internal_format() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
  }

  // .valhalla.Options.Action action = 8;
  if (this->_internal_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  // .valhalla.Costing.Type costing_type = 12;
  if (this->_internal_costing_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_costing_type());
  }

  // .valhalla.Options.DateTimeType date_time_type = 18;
  if (this->_internal_date_time_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_date_time_type());
  }

  // .valhalla.ShapeMatch shape_match = 28;
  if (this->_internal_shape_match() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_shape_match());
  }

  // .valhalla.FilterAction filter_action = 33;
  if (this->_internal_filter_action() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filter_action());
  }

  // .valhalla.ShapeFormat shape_format = 38;
  if (this->_internal_shape_format() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_shape_format());
  }

  // bool reverse = 53;
  if (this->_internal_reverse() != 0) {
    total_size += 2 + 1;
  }

  // uint32 matrix_locations = 54;
  if (this->_internal_matrix_locations() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_matrix_locations());
  }

  switch (has_language_case()) {
    // string language = 2;
    case kLanguage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
      break;
    }
    case HAS_LANGUAGE_NOT_SET: {
      break;
    }
  }
  switch (has_id_case()) {
    // string id = 5;
    case kId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (has_jsonp_case()) {
    // string jsonp = 6;
    case kJsonp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_jsonp());
      break;
    }
    case HAS_JSONP_NOT_SET: {
      break;
    }
  }
  switch (has_encoded_polyline_case()) {
    // string encoded_polyline = 7;
    case kEncodedPolyline: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_encoded_polyline());
      break;
    }
    case HAS_ENCODED_POLYLINE_NOT_SET: {
      break;
    }
  }
  switch (has_range_case()) {
    // bool range = 10;
    case kRange: {
      total_size += 1 + 1;
      break;
    }
    case HAS_RANGE_NOT_SET: {
      break;
    }
  }
  switch (has_verbose_case()) {
    // bool verbose = 11;
    case kVerbose: {
      total_size += 1 + 1;
      break;
    }
    case HAS_VERBOSE_NOT_SET: {
      break;
    }
  }
  switch (has_date_time_case()) {
    // string date_time = 19;
    case kDateTime: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_date_time());
      break;
    }
    case HAS_DATE_TIME_NOT_SET: {
      break;
    }
  }
  switch (has_resample_distance_case()) {
    // double resample_distance = 21;
    case kResampleDistance: {
      total_size += 2 + 8;
      break;
    }
    case HAS_RESAMPLE_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_polygons_case()) {
    // bool polygons = 23;
    case kPolygons: {
      total_size += 2 + 1;
      break;
    }
    case HAS_POLYGONS_NOT_SET: {
      break;
    }
  }
  switch (has_denoise_case()) {
    // float denoise = 24;
    case kDenoise: {
      total_size += 2 + 4;
      break;
    }
    case HAS_DENOISE_NOT_SET: {
      break;
    }
  }
  switch (has_generalize_case()) {
    // float generalize = 25;
    case kGeneralize: {
      total_size += 2 + 4;
      break;
    }
    case HAS_GENERALIZE_NOT_SET: {
      break;
    }
  }
  switch (has_show_locations_case()) {
    // bool show_locations = 26;
    case kShowLocations: {
      total_size += 2 + 1;
      break;
    }
    case HAS_SHOW_LOCATIONS_NOT_SET: {
      break;
    }
  }
  switch (has_gps_accuracy_case()) {
    // float gps_accuracy = 30;
    case kGpsAccuracy: {
      total_size += 2 + 4;
      break;
    }
    case HAS_GPS_ACCURACY_NOT_SET: {
      break;
    }
  }
  switch (has_search_radius_case()) {
    // float search_radius = 31;
    case kSearchRadius: {
      total_size += 2 + 4;
      break;
    }
    case HAS_SEARCH_RADIUS_NOT_SET: {
      break;
    }
  }
  switch (has_turn_penalty_factor_case()) {
    // float turn_penalty_factor = 32;
    case kTurnPenaltyFactor: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TURN_PENALTY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (has_breakage_distance_case()) {
    // float breakage_distance = 36;
    case kBreakageDistance: {
      total_size += 2 + 4;
      break;
    }
    case HAS_BREAKAGE_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_use_timestamps_case()) {
    // bool use_timestamps = 37;
    case kUseTimestamps: {
      total_size += 2 + 1;
      break;
    }
    case HAS_USE_TIMESTAMPS_NOT_SET: {
      break;
    }
  }
  switch (has_alternates_case()) {
    // uint32 alternates = 39;
    case kAlternates: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_alternates());
      break;
    }
    case HAS_ALTERNATES_NOT_SET: {
      break;
    }
  }
  switch (has_interpolation_distance_case()) {
    // float interpolation_distance = 40;
    case kInterpolationDistance: {
      total_size += 2 + 4;
      break;
    }
    case HAS_INTERPOLATION_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (has_guidance_views_case()) {
    // bool guidance_views = 41;
    case kGuidanceViews: {
      total_size += 2 + 1;
      break;
    }
    case HAS_GUIDANCE_VIEWS_NOT_SET: {
      break;
    }
  }
  switch (has_height_precision_case()) {
    // uint32 height_precision = 43;
    case kHeightPrecision: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_height_precision());
      break;
    }
    case HAS_HEIGHT_PRECISION_NOT_SET: {
      break;
    }
  }
  switch (has_roundabout_exits_case()) {
    // bool roundabout_exits = 44;
    case kRoundaboutExits: {
      total_size += 2 + 1;
      break;
    }
    case HAS_ROUNDABOUT_EXITS_NOT_SET: {
      break;
    }
  }
  switch (has_linear_references_case()) {
    // bool linear_references = 45;
    case kLinearReferences: {
      total_size += 2 + 1;
      break;
    }
    case HAS_LINEAR_REFERENCES_NOT_SET: {
      break;
    }
  }
  switch (has_prioritize_bidirectional_case()) {
    // bool prioritize_bidirectional = 48;
    case kPrioritizeBidirectional: {
      total_size += 2 + 1;
      break;
    }
    case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET: {
      break;
    }
  }
  switch (has_expansion_action_case()) {
    // .valhalla.Options.Action expansion_action = 49;
    case kExpansionAction: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_expansion_action());
      break;
    }
    case HAS_EXPANSION_ACTION_NOT_SET: {
      break;
    }
  }
  switch (has_skip_opposites_case()) {
    // bool skip_opposites = 50;
    case kSkipOpposites: {
      total_size += 2 + 1;
      break;
    }
    case HAS_SKIP_OPPOSITES_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Options::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Options*>(
      &from));
}

void Options::MergeFrom(const Options& from) {
  Options* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Options)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.costings_.MergeFrom(from._impl_.costings_);
  _this->_impl_.locations_.MergeFrom(from._impl_.locations_);
  _this->_impl_.exclude_locations_.MergeFrom(from._impl_.exclude_locations_);
  _this->_impl_.sources_.MergeFrom(from._impl_.sources_);
  _this->_impl_.targets_.MergeFrom(from._impl_.targets_);
  _this->_impl_.shape_.MergeFrom(from._impl_.shape_);
  _this->_impl_.contours_.MergeFrom(from._impl_.contours_);
  _this->_impl_.trace_.MergeFrom(from._impl_.trace_);
  _this->_impl_.filter_attributes_.MergeFrom(from._impl_.filter_attributes_);
  _this->_impl_.recostings_.MergeFrom(from._impl_.recostings_);
  _this->_impl_.exclude_polygons_.MergeFrom(from._impl_.exclude_polygons_);
  _this->_impl_.expansion_properties_.MergeFrom(from._impl_.expansion_properties_);
  if (from._internal_has_pbf_field_selector()) {
    _this->_internal_mutable_pbf_field_selector()->::valhalla::PbfFieldSelector::MergeFrom(
        from._internal_pbf_field_selector());
  }
  if (from._internal_units() != 0) {
    _this->_internal_set_units(from._internal_units());
  }
  if (from._internal_directions_type() != 0) {
    _this->_internal_set_directions_type(from._internal_directions_type());
  }
  if (from._internal_format() != 0) {
    _this->_internal_set_format(from._internal_format());
  }
  if (from._internal_action() != 0) {
    _this->_internal_set_action(from._internal_action());
  }
  if (from._internal_costing_type() != 0) {
    _this->_internal_set_costing_type(from._internal_costing_type());
  }
  if (from._internal_date_time_type() != 0) {
    _this->_internal_set_date_time_type(from._internal_date_time_type());
  }
  if (from._internal_shape_match() != 0) {
    _this->_internal_set_shape_match(from._internal_shape_match());
  }
  if (from._internal_filter_action() != 0) {
    _this->_internal_set_filter_action(from._internal_filter_action());
  }
  if (from._internal_shape_format() != 0) {
    _this->_internal_set_shape_format(from._internal_shape_format());
  }
  if (from._internal_reverse() != 0) {
    _this->_internal_set_reverse(from._internal_reverse());
  }
  if (from._internal_matrix_locations() != 0) {
    _this->_internal_set_matrix_locations(from._internal_matrix_locations());
  }
  switch (from.has_language_case()) {
    case kLanguage: {
      _this->_internal_set_language(from._internal_language());
      break;
    }
    case HAS_LANGUAGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_id_case()) {
    case kId: {
      _this->_internal_set_id(from._internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_jsonp_case()) {
    case kJsonp: {
      _this->_internal_set_jsonp(from._internal_jsonp());
      break;
    }
    case HAS_JSONP_NOT_SET: {
      break;
    }
  }
  switch (from.has_encoded_polyline_case()) {
    case kEncodedPolyline: {
      _this->_internal_set_encoded_polyline(from._internal_encoded_polyline());
      break;
    }
    case HAS_ENCODED_POLYLINE_NOT_SET: {
      break;
    }
  }
  switch (from.has_range_case()) {
    case kRange: {
      _this->_internal_set_range(from._internal_range());
      break;
    }
    case HAS_RANGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_verbose_case()) {
    case kVerbose: {
      _this->_internal_set_verbose(from._internal_verbose());
      break;
    }
    case HAS_VERBOSE_NOT_SET: {
      break;
    }
  }
  switch (from.has_date_time_case()) {
    case kDateTime: {
      _this->_internal_set_date_time(from._internal_date_time());
      break;
    }
    case HAS_DATE_TIME_NOT_SET: {
      break;
    }
  }
  switch (from.has_resample_distance_case()) {
    case kResampleDistance: {
      _this->_internal_set_resample_distance(from._internal_resample_distance());
      break;
    }
    case HAS_RESAMPLE_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_polygons_case()) {
    case kPolygons: {
      _this->_internal_set_polygons(from._internal_polygons());
      break;
    }
    case HAS_POLYGONS_NOT_SET: {
      break;
    }
  }
  switch (from.has_denoise_case()) {
    case kDenoise: {
      _this->_internal_set_denoise(from._internal_denoise());
      break;
    }
    case HAS_DENOISE_NOT_SET: {
      break;
    }
  }
  switch (from.has_generalize_case()) {
    case kGeneralize: {
      _this->_internal_set_generalize(from._internal_generalize());
      break;
    }
    case HAS_GENERALIZE_NOT_SET: {
      break;
    }
  }
  switch (from.has_show_locations_case()) {
    case kShowLocations: {
      _this->_internal_set_show_locations(from._internal_show_locations());
      break;
    }
    case HAS_SHOW_LOCATIONS_NOT_SET: {
      break;
    }
  }
  switch (from.has_gps_accuracy_case()) {
    case kGpsAccuracy: {
      _this->_internal_set_gps_accuracy(from._internal_gps_accuracy());
      break;
    }
    case HAS_GPS_ACCURACY_NOT_SET: {
      break;
    }
  }
  switch (from.has_search_radius_case()) {
    case kSearchRadius: {
      _this->_internal_set_search_radius(from._internal_search_radius());
      break;
    }
    case HAS_SEARCH_RADIUS_NOT_SET: {
      break;
    }
  }
  switch (from.has_turn_penalty_factor_case()) {
    case kTurnPenaltyFactor: {
      _this->_internal_set_turn_penalty_factor(from._internal_turn_penalty_factor());
      break;
    }
    case HAS_TURN_PENALTY_FACTOR_NOT_SET: {
      break;
    }
  }
  switch (from.has_breakage_distance_case()) {
    case kBreakageDistance: {
      _this->_internal_set_breakage_distance(from._internal_breakage_distance());
      break;
    }
    case HAS_BREAKAGE_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_timestamps_case()) {
    case kUseTimestamps: {
      _this->_internal_set_use_timestamps(from._internal_use_timestamps());
      break;
    }
    case HAS_USE_TIMESTAMPS_NOT_SET: {
      break;
    }
  }
  switch (from.has_alternates_case()) {
    case kAlternates: {
      _this->_internal_set_alternates(from._internal_alternates());
      break;
    }
    case HAS_ALTERNATES_NOT_SET: {
      break;
    }
  }
  switch (from.has_interpolation_distance_case()) {
    case kInterpolationDistance: {
      _this->_internal_set_interpolation_distance(from._internal_interpolation_distance());
      break;
    }
    case HAS_INTERPOLATION_DISTANCE_NOT_SET: {
      break;
    }
  }
  switch (from.has_guidance_views_case()) {
    case kGuidanceViews: {
      _this->_internal_set_guidance_views(from._internal_guidance_views());
      break;
    }
    case HAS_GUIDANCE_VIEWS_NOT_SET: {
      break;
    }
  }
  switch (from.has_height_precision_case()) {
    case kHeightPrecision: {
      _this->_internal_set_height_precision(from._internal_height_precision());
      break;
    }
    case HAS_HEIGHT_PRECISION_NOT_SET: {
      break;
    }
  }
  switch (from.has_roundabout_exits_case()) {
    case kRoundaboutExits: {
      _this->_internal_set_roundabout_exits(from._internal_roundabout_exits());
      break;
    }
    case HAS_ROUNDABOUT_EXITS_NOT_SET: {
      break;
    }
  }
  switch (from.has_linear_references_case()) {
    case kLinearReferences: {
      _this->_internal_set_linear_references(from._internal_linear_references());
      break;
    }
    case HAS_LINEAR_REFERENCES_NOT_SET: {
      break;
    }
  }
  switch (from.has_prioritize_bidirectional_case()) {
    case kPrioritizeBidirectional: {
      _this->_internal_set_prioritize_bidirectional(from._internal_prioritize_bidirectional());
      break;
    }
    case HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET: {
      break;
    }
  }
  switch (from.has_expansion_action_case()) {
    case kExpansionAction: {
      _this->_internal_set_expansion_action(from._internal_expansion_action());
      break;
    }
    case HAS_EXPANSION_ACTION_NOT_SET: {
      break;
    }
  }
  switch (from.has_skip_opposites_case()) {
    case kSkipOpposites: {
      _this->_internal_set_skip_opposites(from._internal_skip_opposites());
      break;
    }
    case HAS_SKIP_OPPOSITES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Options::CopyFrom(const Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options::IsInitialized() const {
  return true;
}

void Options::InternalSwap(Options* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.costings_.InternalSwap(&other->_impl_.costings_);
  _impl_.locations_.InternalSwap(&other->_impl_.locations_);
  _impl_.exclude_locations_.InternalSwap(&other->_impl_.exclude_locations_);
  _impl_.sources_.InternalSwap(&other->_impl_.sources_);
  _impl_.targets_.InternalSwap(&other->_impl_.targets_);
  _impl_.shape_.InternalSwap(&other->_impl_.shape_);
  _impl_.contours_.InternalSwap(&other->_impl_.contours_);
  _impl_.trace_.InternalSwap(&other->_impl_.trace_);
  _impl_.filter_attributes_.InternalSwap(&other->_impl_.filter_attributes_);
  _impl_.recostings_.InternalSwap(&other->_impl_.recostings_);
  _impl_.exclude_polygons_.InternalSwap(&other->_impl_.exclude_polygons_);
  _impl_.expansion_properties_.InternalSwap(&other->_impl_.expansion_properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Options, _impl_.matrix_locations_)
      + sizeof(Options::_impl_.matrix_locations_)
      - PROTOBUF_FIELD_OFFSET(Options, _impl_.pbf_field_selector_)>(
          reinterpret_cast<char*>(&_impl_.pbf_field_selector_),
          reinterpret_cast<char*>(&other->_impl_.pbf_field_selector_));
  swap(_impl_.has_language_, other->_impl_.has_language_);
  swap(_impl_.has_id_, other->_impl_.has_id_);
  swap(_impl_.has_jsonp_, other->_impl_.has_jsonp_);
  swap(_impl_.has_encoded_polyline_, other->_impl_.has_encoded_polyline_);
  swap(_impl_.has_range_, other->_impl_.has_range_);
  swap(_impl_.has_verbose_, other->_impl_.has_verbose_);
  swap(_impl_.has_date_time_, other->_impl_.has_date_time_);
  swap(_impl_.has_resample_distance_, other->_impl_.has_resample_distance_);
  swap(_impl_.has_polygons_, other->_impl_.has_polygons_);
  swap(_impl_.has_denoise_, other->_impl_.has_denoise_);
  swap(_impl_.has_generalize_, other->_impl_.has_generalize_);
  swap(_impl_.has_show_locations_, other->_impl_.has_show_locations_);
  swap(_impl_.has_gps_accuracy_, other->_impl_.has_gps_accuracy_);
  swap(_impl_.has_search_radius_, other->_impl_.has_search_radius_);
  swap(_impl_.has_turn_penalty_factor_, other->_impl_.has_turn_penalty_factor_);
  swap(_impl_.has_breakage_distance_, other->_impl_.has_breakage_distance_);
  swap(_impl_.has_use_timestamps_, other->_impl_.has_use_timestamps_);
  swap(_impl_.has_alternates_, other->_impl_.has_alternates_);
  swap(_impl_.has_interpolation_distance_, other->_impl_.has_interpolation_distance_);
  swap(_impl_.has_guidance_views_, other->_impl_.has_guidance_views_);
  swap(_impl_.has_height_precision_, other->_impl_.has_height_precision_);
  swap(_impl_.has_roundabout_exits_, other->_impl_.has_roundabout_exits_);
  swap(_impl_.has_linear_references_, other->_impl_.has_linear_references_);
  swap(_impl_.has_prioritize_bidirectional_, other->_impl_.has_prioritize_bidirectional_);
  swap(_impl_.has_expansion_action_, other->_impl_.has_expansion_action_);
  swap(_impl_.has_skip_opposites_, other->_impl_.has_skip_opposites_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
  swap(_impl_._oneof_case_[12], other->_impl_._oneof_case_[12]);
  swap(_impl_._oneof_case_[13], other->_impl_._oneof_case_[13]);
  swap(_impl_._oneof_case_[14], other->_impl_._oneof_case_[14]);
  swap(_impl_._oneof_case_[15], other->_impl_._oneof_case_[15]);
  swap(_impl_._oneof_case_[16], other->_impl_._oneof_case_[16]);
  swap(_impl_._oneof_case_[17], other->_impl_._oneof_case_[17]);
  swap(_impl_._oneof_case_[18], other->_impl_._oneof_case_[18]);
  swap(_impl_._oneof_case_[19], other->_impl_._oneof_case_[19]);
  swap(_impl_._oneof_case_[20], other->_impl_._oneof_case_[20]);
  swap(_impl_._oneof_case_[21], other->_impl_._oneof_case_[21]);
  swap(_impl_._oneof_case_[22], other->_impl_._oneof_case_[22]);
  swap(_impl_._oneof_case_[23], other->_impl_._oneof_case_[23]);
  swap(_impl_._oneof_case_[24], other->_impl_._oneof_case_[24]);
  swap(_impl_._oneof_case_[25], other->_impl_._oneof_case_[25]);
}

std::string Options::GetTypeName() const {
  return "valhalla.Options";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::valhalla::Contour*
Arena::CreateMaybeMessage< ::valhalla::Contour >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Contour >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Ring*
Arena::CreateMaybeMessage< ::valhalla::Ring >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Ring >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::PbfFieldSelector*
Arena::CreateMaybeMessage< ::valhalla::PbfFieldSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::PbfFieldSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::AvoidEdge*
Arena::CreateMaybeMessage< ::valhalla::AvoidEdge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::AvoidEdge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Costing_Options*
Arena::CreateMaybeMessage< ::valhalla::Costing_Options >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Costing_Options >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Costing*
Arena::CreateMaybeMessage< ::valhalla::Costing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Costing >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Options_CostingsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::valhalla::Options_CostingsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Options_CostingsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Options*
Arena::CreateMaybeMessage< ::valhalla::Options >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Options >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
