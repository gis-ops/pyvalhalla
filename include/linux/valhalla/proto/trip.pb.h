// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_trip_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_trip_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
#include "sign.pb.h"
#include "incidents.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_trip_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_trip_2eproto {
  static const uint32_t offsets[];
};
namespace valhalla {
class Trip;
struct TripDefaultTypeInternal;
extern TripDefaultTypeInternal _Trip_default_instance_;
class TripLeg;
struct TripLegDefaultTypeInternal;
extern TripLegDefaultTypeInternal _TripLeg_default_instance_;
class TripLeg_Admin;
struct TripLeg_AdminDefaultTypeInternal;
extern TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
class TripLeg_Closure;
struct TripLeg_ClosureDefaultTypeInternal;
extern TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
class TripLeg_Cost;
struct TripLeg_CostDefaultTypeInternal;
extern TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
class TripLeg_Edge;
struct TripLeg_EdgeDefaultTypeInternal;
extern TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
class TripLeg_Incident;
struct TripLeg_IncidentDefaultTypeInternal;
extern TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
class TripLeg_IntersectingEdge;
struct TripLeg_IntersectingEdgeDefaultTypeInternal;
extern TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
class TripLeg_LaneConnectivity;
struct TripLeg_LaneConnectivityDefaultTypeInternal;
extern TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
class TripLeg_Node;
struct TripLeg_NodeDefaultTypeInternal;
extern TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
class TripLeg_PathCost;
struct TripLeg_PathCostDefaultTypeInternal;
extern TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
class TripLeg_Restriction;
struct TripLeg_RestrictionDefaultTypeInternal;
extern TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
class TripLeg_ShapeAttributes;
struct TripLeg_ShapeAttributesDefaultTypeInternal;
extern TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
class TripLeg_TrafficSegment;
struct TripLeg_TrafficSegmentDefaultTypeInternal;
extern TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
class TripRoute;
struct TripRouteDefaultTypeInternal;
extern TripRouteDefaultTypeInternal _TripRoute_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::Trip* Arena::CreateMaybeMessage<::valhalla::Trip>(Arena*);
template<> ::valhalla::TripLeg* Arena::CreateMaybeMessage<::valhalla::TripLeg>(Arena*);
template<> ::valhalla::TripLeg_Admin* Arena::CreateMaybeMessage<::valhalla::TripLeg_Admin>(Arena*);
template<> ::valhalla::TripLeg_Closure* Arena::CreateMaybeMessage<::valhalla::TripLeg_Closure>(Arena*);
template<> ::valhalla::TripLeg_Cost* Arena::CreateMaybeMessage<::valhalla::TripLeg_Cost>(Arena*);
template<> ::valhalla::TripLeg_Edge* Arena::CreateMaybeMessage<::valhalla::TripLeg_Edge>(Arena*);
template<> ::valhalla::TripLeg_Incident* Arena::CreateMaybeMessage<::valhalla::TripLeg_Incident>(Arena*);
template<> ::valhalla::TripLeg_IntersectingEdge* Arena::CreateMaybeMessage<::valhalla::TripLeg_IntersectingEdge>(Arena*);
template<> ::valhalla::TripLeg_LaneConnectivity* Arena::CreateMaybeMessage<::valhalla::TripLeg_LaneConnectivity>(Arena*);
template<> ::valhalla::TripLeg_Node* Arena::CreateMaybeMessage<::valhalla::TripLeg_Node>(Arena*);
template<> ::valhalla::TripLeg_PathCost* Arena::CreateMaybeMessage<::valhalla::TripLeg_PathCost>(Arena*);
template<> ::valhalla::TripLeg_Restriction* Arena::CreateMaybeMessage<::valhalla::TripLeg_Restriction>(Arena*);
template<> ::valhalla::TripLeg_ShapeAttributes* Arena::CreateMaybeMessage<::valhalla::TripLeg_ShapeAttributes>(Arena*);
template<> ::valhalla::TripLeg_TrafficSegment* Arena::CreateMaybeMessage<::valhalla::TripLeg_TrafficSegment>(Arena*);
template<> ::valhalla::TripRoute* Arena::CreateMaybeMessage<::valhalla::TripRoute>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum TripLeg_Node_Type : int {
  TripLeg_Node_Type_kStreetIntersection = 0,
  TripLeg_Node_Type_kGate = 1,
  TripLeg_Node_Type_kBollard = 2,
  TripLeg_Node_Type_kTollBooth = 3,
  TripLeg_Node_Type_kTransitEgress = 4,
  TripLeg_Node_Type_kTransitStation = 5,
  TripLeg_Node_Type_kTransitPlatform = 6,
  TripLeg_Node_Type_kBikeShare = 7,
  TripLeg_Node_Type_kParking = 8,
  TripLeg_Node_Type_kMotorwayJunction = 9,
  TripLeg_Node_Type_kBorderControl = 10,
  TripLeg_Node_Type_kTollGantry = 11,
  TripLeg_Node_Type_kSumpBuster = 12,
  TripLeg_Node_Type_kBuildingEntrance = 13,
  TripLeg_Node_Type_kElevator = 14,
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Node_Type_IsValid(int value);
constexpr TripLeg_Node_Type TripLeg_Node_Type_Type_MIN = TripLeg_Node_Type_kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node_Type_Type_MAX = TripLeg_Node_Type_kElevator;
constexpr int TripLeg_Node_Type_Type_ARRAYSIZE = TripLeg_Node_Type_Type_MAX + 1;

const std::string& TripLeg_Node_Type_Name(TripLeg_Node_Type value);
template<typename T>
inline const std::string& TripLeg_Node_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Node_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Node_Type_Name.");
  return TripLeg_Node_Type_Name(static_cast<TripLeg_Node_Type>(enum_t_value));
}
bool TripLeg_Node_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Node_Type* value);
enum TripLeg_Traversability : int {
  TripLeg_Traversability_kNone = 0,
  TripLeg_Traversability_kForward = 1,
  TripLeg_Traversability_kBackward = 2,
  TripLeg_Traversability_kBoth = 3,
  TripLeg_Traversability_TripLeg_Traversability_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Traversability_TripLeg_Traversability_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Traversability_IsValid(int value);
constexpr TripLeg_Traversability TripLeg_Traversability_Traversability_MIN = TripLeg_Traversability_kNone;
constexpr TripLeg_Traversability TripLeg_Traversability_Traversability_MAX = TripLeg_Traversability_kBoth;
constexpr int TripLeg_Traversability_Traversability_ARRAYSIZE = TripLeg_Traversability_Traversability_MAX + 1;

const std::string& TripLeg_Traversability_Name(TripLeg_Traversability value);
template<typename T>
inline const std::string& TripLeg_Traversability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Traversability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Traversability_Name.");
  return TripLeg_Traversability_Name(static_cast<TripLeg_Traversability>(enum_t_value));
}
bool TripLeg_Traversability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Traversability* value);
enum TripLeg_Use : int {
  TripLeg_Use_kRoadUse = 0,
  TripLeg_Use_kRampUse = 1,
  TripLeg_Use_kTurnChannelUse = 2,
  TripLeg_Use_kTrackUse = 3,
  TripLeg_Use_kDrivewayUse = 4,
  TripLeg_Use_kAlleyUse = 5,
  TripLeg_Use_kParkingAisleUse = 6,
  TripLeg_Use_kEmergencyAccessUse = 7,
  TripLeg_Use_kDriveThruUse = 8,
  TripLeg_Use_kCuldesacUse = 9,
  TripLeg_Use_kLivingStreetUse = 10,
  TripLeg_Use_kServiceRoadUse = 11,
  TripLeg_Use_kCyclewayUse = 20,
  TripLeg_Use_kMountainBikeUse = 21,
  TripLeg_Use_kSidewalkUse = 24,
  TripLeg_Use_kFootwayUse = 25,
  TripLeg_Use_kStepsUse = 26,
  TripLeg_Use_kPathUse = 27,
  TripLeg_Use_kPedestrianUse = 28,
  TripLeg_Use_kBridlewayUse = 29,
  TripLeg_Use_kPedestrianCrossingUse = 32,
  TripLeg_Use_kElevatorUse = 33,
  TripLeg_Use_kEscalatorUse = 34,
  TripLeg_Use_kRestAreaUse = 30,
  TripLeg_Use_kServiceAreaUse = 31,
  TripLeg_Use_kOtherUse = 40,
  TripLeg_Use_kFerryUse = 41,
  TripLeg_Use_kRailFerryUse = 42,
  TripLeg_Use_kConstructionUse = 43,
  TripLeg_Use_kRailUse = 50,
  TripLeg_Use_kBusUse = 51,
  TripLeg_Use_kEgressConnectionUse = 52,
  TripLeg_Use_kPlatformConnectionUse = 53,
  TripLeg_Use_kTransitConnectionUse = 54,
  TripLeg_Use_TripLeg_Use_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Use_TripLeg_Use_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Use_IsValid(int value);
constexpr TripLeg_Use TripLeg_Use_Use_MIN = TripLeg_Use_kRoadUse;
constexpr TripLeg_Use TripLeg_Use_Use_MAX = TripLeg_Use_kTransitConnectionUse;
constexpr int TripLeg_Use_Use_ARRAYSIZE = TripLeg_Use_Use_MAX + 1;

const std::string& TripLeg_Use_Name(TripLeg_Use value);
template<typename T>
inline const std::string& TripLeg_Use_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Use>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Use_Name.");
  return TripLeg_Use_Name(static_cast<TripLeg_Use>(enum_t_value));
}
bool TripLeg_Use_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Use* value);
enum TripLeg_Surface : int {
  TripLeg_Surface_kPavedSmooth = 0,
  TripLeg_Surface_kPaved = 1,
  TripLeg_Surface_kPavedRough = 2,
  TripLeg_Surface_kCompacted = 3,
  TripLeg_Surface_kDirt = 4,
  TripLeg_Surface_kGravel = 5,
  TripLeg_Surface_kPath = 6,
  TripLeg_Surface_kImpassable = 7,
  TripLeg_Surface_TripLeg_Surface_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Surface_TripLeg_Surface_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Surface_IsValid(int value);
constexpr TripLeg_Surface TripLeg_Surface_Surface_MIN = TripLeg_Surface_kPavedSmooth;
constexpr TripLeg_Surface TripLeg_Surface_Surface_MAX = TripLeg_Surface_kImpassable;
constexpr int TripLeg_Surface_Surface_ARRAYSIZE = TripLeg_Surface_Surface_MAX + 1;

const std::string& TripLeg_Surface_Name(TripLeg_Surface value);
template<typename T>
inline const std::string& TripLeg_Surface_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Surface>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Surface_Name.");
  return TripLeg_Surface_Name(static_cast<TripLeg_Surface>(enum_t_value));
}
bool TripLeg_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Surface* value);
enum TripLeg_CycleLane : int {
  TripLeg_CycleLane_kNoCycleLane = 0,
  TripLeg_CycleLane_kShared = 1,
  TripLeg_CycleLane_kDedicated = 2,
  TripLeg_CycleLane_kSeparated = 3,
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_CycleLane_IsValid(int value);
constexpr TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MIN = TripLeg_CycleLane_kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MAX = TripLeg_CycleLane_kSeparated;
constexpr int TripLeg_CycleLane_CycleLane_ARRAYSIZE = TripLeg_CycleLane_CycleLane_MAX + 1;

const std::string& TripLeg_CycleLane_Name(TripLeg_CycleLane value);
template<typename T>
inline const std::string& TripLeg_CycleLane_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_CycleLane>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_CycleLane_Name.");
  return TripLeg_CycleLane_Name(static_cast<TripLeg_CycleLane>(enum_t_value));
}
bool TripLeg_CycleLane_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_CycleLane* value);
enum TripLeg_SacScale : int {
  TripLeg_SacScale_kNoSacScale = 0,
  TripLeg_SacScale_kHiking = 1,
  TripLeg_SacScale_kMountainHiking = 2,
  TripLeg_SacScale_kDemandingMountainHiking = 3,
  TripLeg_SacScale_kAlpineHiking = 4,
  TripLeg_SacScale_kDemandingAlpineHiking = 5,
  TripLeg_SacScale_kDifficultAlpineHiking = 6,
  TripLeg_SacScale_TripLeg_SacScale_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_SacScale_TripLeg_SacScale_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_SacScale_IsValid(int value);
constexpr TripLeg_SacScale TripLeg_SacScale_SacScale_MIN = TripLeg_SacScale_kNoSacScale;
constexpr TripLeg_SacScale TripLeg_SacScale_SacScale_MAX = TripLeg_SacScale_kDifficultAlpineHiking;
constexpr int TripLeg_SacScale_SacScale_ARRAYSIZE = TripLeg_SacScale_SacScale_MAX + 1;

const std::string& TripLeg_SacScale_Name(TripLeg_SacScale value);
template<typename T>
inline const std::string& TripLeg_SacScale_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_SacScale>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_SacScale_Name.");
  return TripLeg_SacScale_Name(static_cast<TripLeg_SacScale>(enum_t_value));
}
bool TripLeg_SacScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_SacScale* value);
enum TripLeg_Sidewalk : int {
  TripLeg_Sidewalk_kNoSidewalk = 0,
  TripLeg_Sidewalk_kLeft = 1,
  TripLeg_Sidewalk_kRight = 2,
  TripLeg_Sidewalk_kBothSides = 3,
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Sidewalk_IsValid(int value);
constexpr TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MIN = TripLeg_Sidewalk_kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MAX = TripLeg_Sidewalk_kBothSides;
constexpr int TripLeg_Sidewalk_Sidewalk_ARRAYSIZE = TripLeg_Sidewalk_Sidewalk_MAX + 1;

const std::string& TripLeg_Sidewalk_Name(TripLeg_Sidewalk value);
template<typename T>
inline const std::string& TripLeg_Sidewalk_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Sidewalk>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Sidewalk_Name.");
  return TripLeg_Sidewalk_Name(static_cast<TripLeg_Sidewalk>(enum_t_value));
}
bool TripLeg_Sidewalk_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Sidewalk* value);
// ===================================================================

class TripLeg_LaneConnectivity final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.LaneConnectivity) */ {
 public:
  inline TripLeg_LaneConnectivity() : TripLeg_LaneConnectivity(nullptr) {}
  ~TripLeg_LaneConnectivity() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from);
  TripLeg_LaneConnectivity(TripLeg_LaneConnectivity&& from) noexcept
    : TripLeg_LaneConnectivity() {
    *this = ::std::move(from);
  }

  inline TripLeg_LaneConnectivity& operator=(const TripLeg_LaneConnectivity& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_LaneConnectivity& operator=(TripLeg_LaneConnectivity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_LaneConnectivity& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_LaneConnectivity* internal_default_instance() {
    return reinterpret_cast<const TripLeg_LaneConnectivity*>(
               &_TripLeg_LaneConnectivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TripLeg_LaneConnectivity& a, TripLeg_LaneConnectivity& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_LaneConnectivity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_LaneConnectivity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_LaneConnectivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_LaneConnectivity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_LaneConnectivity& from);
  void MergeFrom(const TripLeg_LaneConnectivity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_LaneConnectivity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.LaneConnectivity";
  }
  protected:
  explicit TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromLanesFieldNumber = 2,
    kToLanesFieldNumber = 3,
    kFromWayIdFieldNumber = 1,
  };
  // string from_lanes = 2;
  void clear_from_lanes();
  const std::string& from_lanes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_lanes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_lanes();
  PROTOBUF_NODISCARD std::string* release_from_lanes();
  void set_allocated_from_lanes(std::string* from_lanes);
  private:
  const std::string& _internal_from_lanes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_lanes(const std::string& value);
  std::string* _internal_mutable_from_lanes();
  public:

  // string to_lanes = 3;
  void clear_to_lanes();
  const std::string& to_lanes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_lanes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_lanes();
  PROTOBUF_NODISCARD std::string* release_to_lanes();
  void set_allocated_to_lanes(std::string* to_lanes);
  private:
  const std::string& _internal_to_lanes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_lanes(const std::string& value);
  std::string* _internal_mutable_to_lanes();
  public:

  // uint64 from_way_id = 1;
  void clear_from_way_id();
  uint64_t from_way_id() const;
  void set_from_way_id(uint64_t value);
  private:
  uint64_t _internal_from_way_id() const;
  void _internal_set_from_way_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.LaneConnectivity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_lanes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_lanes_;
    uint64_t from_way_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_TrafficSegment final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.TrafficSegment) */ {
 public:
  inline TripLeg_TrafficSegment() : TripLeg_TrafficSegment(nullptr) {}
  ~TripLeg_TrafficSegment() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from);
  TripLeg_TrafficSegment(TripLeg_TrafficSegment&& from) noexcept
    : TripLeg_TrafficSegment() {
    *this = ::std::move(from);
  }

  inline TripLeg_TrafficSegment& operator=(const TripLeg_TrafficSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_TrafficSegment& operator=(TripLeg_TrafficSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_TrafficSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_TrafficSegment* internal_default_instance() {
    return reinterpret_cast<const TripLeg_TrafficSegment*>(
               &_TripLeg_TrafficSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TripLeg_TrafficSegment& a, TripLeg_TrafficSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_TrafficSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_TrafficSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_TrafficSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_TrafficSegment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_TrafficSegment& from);
  void MergeFrom(const TripLeg_TrafficSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_TrafficSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.TrafficSegment";
  }
  protected:
  explicit TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentIdFieldNumber = 1,
    kBeginPercentFieldNumber = 2,
    kEndPercentFieldNumber = 3,
    kStartsSegmentFieldNumber = 4,
    kEndsSegmentFieldNumber = 5,
  };
  // uint64 segment_id = 1;
  void clear_segment_id();
  uint64_t segment_id() const;
  void set_segment_id(uint64_t value);
  private:
  uint64_t _internal_segment_id() const;
  void _internal_set_segment_id(uint64_t value);
  public:

  // float begin_percent = 2;
  void clear_begin_percent();
  float begin_percent() const;
  void set_begin_percent(float value);
  private:
  float _internal_begin_percent() const;
  void _internal_set_begin_percent(float value);
  public:

  // float end_percent = 3;
  void clear_end_percent();
  float end_percent() const;
  void set_end_percent(float value);
  private:
  float _internal_end_percent() const;
  void _internal_set_end_percent(float value);
  public:

  // bool starts_segment = 4;
  void clear_starts_segment();
  bool starts_segment() const;
  void set_starts_segment(bool value);
  private:
  bool _internal_starts_segment() const;
  void _internal_set_starts_segment(bool value);
  public:

  // bool ends_segment = 5;
  void clear_ends_segment();
  bool ends_segment() const;
  void set_ends_segment(bool value);
  private:
  bool _internal_ends_segment() const;
  void _internal_set_ends_segment(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TrafficSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t segment_id_;
    float begin_percent_;
    float end_percent_;
    bool starts_segment_;
    bool ends_segment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Restriction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Restriction) */ {
 public:
  inline TripLeg_Restriction() : TripLeg_Restriction(nullptr) {}
  ~TripLeg_Restriction() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Restriction(const TripLeg_Restriction& from);
  TripLeg_Restriction(TripLeg_Restriction&& from) noexcept
    : TripLeg_Restriction() {
    *this = ::std::move(from);
  }

  inline TripLeg_Restriction& operator=(const TripLeg_Restriction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Restriction& operator=(TripLeg_Restriction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Restriction& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Restriction* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Restriction*>(
               &_TripLeg_Restriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TripLeg_Restriction& a, TripLeg_Restriction& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Restriction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Restriction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Restriction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Restriction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Restriction& from);
  void MergeFrom(const TripLeg_Restriction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Restriction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Restriction";
  }
  protected:
  explicit TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Restriction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Edge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Edge) */ {
 public:
  inline TripLeg_Edge() : TripLeg_Edge(nullptr) {}
  ~TripLeg_Edge() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Edge(const TripLeg_Edge& from);
  TripLeg_Edge(TripLeg_Edge&& from) noexcept
    : TripLeg_Edge() {
    *this = ::std::move(from);
  }

  inline TripLeg_Edge& operator=(const TripLeg_Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Edge& operator=(TripLeg_Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Edge& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Edge* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Edge*>(
               &_TripLeg_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TripLeg_Edge& a, TripLeg_Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Edge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Edge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Edge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Edge& from);
  void MergeFrom(const TripLeg_Edge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Edge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Edge";
  }
  protected:
  explicit TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLaneConnectivityFieldNumber = 39,
    kTrafficSegmentFieldNumber = 41,
    kTurnLanesFieldNumber = 42,
    kTaggedValueFieldNumber = 48,
    kSignFieldNumber = 19,
    kTransitRouteInfoFieldNumber = 25,
    kRestrictionFieldNumber = 45,
    kLengthKmFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kRoadClassFieldNumber = 4,
    kBeginHeadingFieldNumber = 5,
    kEndHeadingFieldNumber = 6,
    kBeginShapeIndexFieldNumber = 7,
    kEndShapeIndexFieldNumber = 8,
    kTraversabilityFieldNumber = 9,
    kUseFieldNumber = 10,
    kTollFieldNumber = 11,
    kUnpavedFieldNumber = 12,
    kTunnelFieldNumber = 13,
    kBridgeFieldNumber = 14,
    kSurfaceFieldNumber = 18,
    kTravelModeFieldNumber = 20,
    kRoundaboutFieldNumber = 15,
    kInternalIntersectionFieldNumber = 16,
    kDriveOnLeftFieldNumber = 17,
    kBicycleNetworkFieldNumber = 33,
    kVehicleTypeFieldNumber = 21,
    kPedestrianTypeFieldNumber = 22,
    kBicycleTypeFieldNumber = 23,
    kIdFieldNumber = 26,
    kTransitTypeFieldNumber = 24,
    kWeightedGradeFieldNumber = 28,
    kWayIdFieldNumber = 27,
    kMaxUpwardGradeFieldNumber = 29,
    kMaxDownwardGradeFieldNumber = 30,
    kLaneCountFieldNumber = 31,
    kCycleLaneFieldNumber = 32,
    kSidewalkFieldNumber = 34,
    kDensityFieldNumber = 35,
    kSpeedLimitFieldNumber = 36,
    kTruckSpeedFieldNumber = 37,
    kMeanElevationFieldNumber = 40,
    kTruckRouteFieldNumber = 38,
    kHasTimeRestrictionsFieldNumber = 43,
    kDestinationOnlyFieldNumber = 46,
    kIsUrbanFieldNumber = 47,
    kDefaultSpeedFieldNumber = 44,
    kSourceAlongEdgeFieldNumber = 49,
    kTargetAlongEdgeFieldNumber = 50,
    kSacScaleFieldNumber = 51,
    kShoulderFieldNumber = 52,
    kIndoorFieldNumber = 53,
  };
  // repeated .valhalla.StreetName name = 1;
  int name_size() const;
  private:
  int _internal_name_size() const;
  public:
  void clear_name();
  ::valhalla::StreetName* mutable_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_name();
  private:
  const ::valhalla::StreetName& _internal_name(int index) const;
  ::valhalla::StreetName* _internal_add_name();
  public:
  const ::valhalla::StreetName& name(int index) const;
  ::valhalla::StreetName* add_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      name() const;

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  int lane_connectivity_size() const;
  private:
  int _internal_lane_connectivity_size() const;
  public:
  void clear_lane_connectivity();
  ::valhalla::TripLeg_LaneConnectivity* mutable_lane_connectivity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
      mutable_lane_connectivity();
  private:
  const ::valhalla::TripLeg_LaneConnectivity& _internal_lane_connectivity(int index) const;
  ::valhalla::TripLeg_LaneConnectivity* _internal_add_lane_connectivity();
  public:
  const ::valhalla::TripLeg_LaneConnectivity& lane_connectivity(int index) const;
  ::valhalla::TripLeg_LaneConnectivity* add_lane_connectivity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
      lane_connectivity() const;

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  int traffic_segment_size() const;
  private:
  int _internal_traffic_segment_size() const;
  public:
  void clear_traffic_segment();
  ::valhalla::TripLeg_TrafficSegment* mutable_traffic_segment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
      mutable_traffic_segment();
  private:
  const ::valhalla::TripLeg_TrafficSegment& _internal_traffic_segment(int index) const;
  ::valhalla::TripLeg_TrafficSegment* _internal_add_traffic_segment();
  public:
  const ::valhalla::TripLeg_TrafficSegment& traffic_segment(int index) const;
  ::valhalla::TripLeg_TrafficSegment* add_traffic_segment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
      traffic_segment() const;

  // repeated .valhalla.TurnLane turn_lanes = 42;
  int turn_lanes_size() const;
  private:
  int _internal_turn_lanes_size() const;
  public:
  void clear_turn_lanes();
  ::valhalla::TurnLane* mutable_turn_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >*
      mutable_turn_lanes();
  private:
  const ::valhalla::TurnLane& _internal_turn_lanes(int index) const;
  ::valhalla::TurnLane* _internal_add_turn_lanes();
  public:
  const ::valhalla::TurnLane& turn_lanes(int index) const;
  ::valhalla::TurnLane* add_turn_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >&
      turn_lanes() const;

  // repeated .valhalla.TaggedValue tagged_value = 48;
  int tagged_value_size() const;
  private:
  int _internal_tagged_value_size() const;
  public:
  void clear_tagged_value();
  ::valhalla::TaggedValue* mutable_tagged_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >*
      mutable_tagged_value();
  private:
  const ::valhalla::TaggedValue& _internal_tagged_value(int index) const;
  ::valhalla::TaggedValue* _internal_add_tagged_value();
  public:
  const ::valhalla::TaggedValue& tagged_value(int index) const;
  ::valhalla::TaggedValue* add_tagged_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >&
      tagged_value() const;

  // .valhalla.TripSign sign = 19;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);
  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::TripSign* sign);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  bool has_transit_route_info() const;
  private:
  bool _internal_has_transit_route_info() const;
  public:
  void clear_transit_route_info();
  const ::valhalla::TransitRouteInfo& transit_route_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitRouteInfo* release_transit_route_info();
  ::valhalla::TransitRouteInfo* mutable_transit_route_info();
  void set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info);
  private:
  const ::valhalla::TransitRouteInfo& _internal_transit_route_info() const;
  ::valhalla::TransitRouteInfo* _internal_mutable_transit_route_info();
  public:
  void unsafe_arena_set_allocated_transit_route_info(
      ::valhalla::TransitRouteInfo* transit_route_info);
  ::valhalla::TransitRouteInfo* unsafe_arena_release_transit_route_info();

  // .valhalla.TripLeg.Restriction restriction = 45;
  bool has_restriction() const;
  private:
  bool _internal_has_restriction() const;
  public:
  void clear_restriction();
  const ::valhalla::TripLeg_Restriction& restriction() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Restriction* release_restriction();
  ::valhalla::TripLeg_Restriction* mutable_restriction();
  void set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction);
  private:
  const ::valhalla::TripLeg_Restriction& _internal_restriction() const;
  ::valhalla::TripLeg_Restriction* _internal_mutable_restriction();
  public:
  void unsafe_arena_set_allocated_restriction(
      ::valhalla::TripLeg_Restriction* restriction);
  ::valhalla::TripLeg_Restriction* unsafe_arena_release_restriction();

  // float length_km = 2;
  void clear_length_km();
  float length_km() const;
  void set_length_km(float value);
  private:
  float _internal_length_km() const;
  void _internal_set_length_km(float value);
  public:

  // float speed = 3;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // .valhalla.RoadClass road_class = 4;
  void clear_road_class();
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);
  private:
  ::valhalla::RoadClass _internal_road_class() const;
  void _internal_set_road_class(::valhalla::RoadClass value);
  public:

  // uint32 begin_heading = 5;
  void clear_begin_heading();
  uint32_t begin_heading() const;
  void set_begin_heading(uint32_t value);
  private:
  uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(uint32_t value);
  public:

  // uint32 end_heading = 6;
  void clear_end_heading();
  uint32_t end_heading() const;
  void set_end_heading(uint32_t value);
  private:
  uint32_t _internal_end_heading() const;
  void _internal_set_end_heading(uint32_t value);
  public:

  // uint32 begin_shape_index = 7;
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 8;
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  // .valhalla.TripLeg.Traversability traversability = 9;
  void clear_traversability();
  ::valhalla::TripLeg_Traversability traversability() const;
  void set_traversability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_traversability() const;
  void _internal_set_traversability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Use use = 10;
  void clear_use();
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);
  private:
  ::valhalla::TripLeg_Use _internal_use() const;
  void _internal_set_use(::valhalla::TripLeg_Use value);
  public:

  // bool toll = 11;
  void clear_toll();
  bool toll() const;
  void set_toll(bool value);
  private:
  bool _internal_toll() const;
  void _internal_set_toll(bool value);
  public:

  // bool unpaved = 12;
  void clear_unpaved();
  bool unpaved() const;
  void set_unpaved(bool value);
  private:
  bool _internal_unpaved() const;
  void _internal_set_unpaved(bool value);
  public:

  // bool tunnel = 13;
  void clear_tunnel();
  bool tunnel() const;
  void set_tunnel(bool value);
  private:
  bool _internal_tunnel() const;
  void _internal_set_tunnel(bool value);
  public:

  // bool bridge = 14;
  void clear_bridge();
  bool bridge() const;
  void set_bridge(bool value);
  private:
  bool _internal_bridge() const;
  void _internal_set_bridge(bool value);
  public:

  // .valhalla.TripLeg.Surface surface = 18;
  void clear_surface();
  ::valhalla::TripLeg_Surface surface() const;
  void set_surface(::valhalla::TripLeg_Surface value);
  private:
  ::valhalla::TripLeg_Surface _internal_surface() const;
  void _internal_set_surface(::valhalla::TripLeg_Surface value);
  public:

  // .valhalla.TravelMode travel_mode = 20;
  void clear_travel_mode();
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);
  private:
  ::valhalla::TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::TravelMode value);
  public:

  // bool roundabout = 15;
  void clear_roundabout();
  bool roundabout() const;
  void set_roundabout(bool value);
  private:
  bool _internal_roundabout() const;
  void _internal_set_roundabout(bool value);
  public:

  // bool internal_intersection = 16;
  void clear_internal_intersection();
  bool internal_intersection() const;
  void set_internal_intersection(bool value);
  private:
  bool _internal_internal_intersection() const;
  void _internal_set_internal_intersection(bool value);
  public:

  // bool drive_on_left = 17;
  void clear_drive_on_left();
  bool drive_on_left() const;
  void set_drive_on_left(bool value);
  private:
  bool _internal_drive_on_left() const;
  void _internal_set_drive_on_left(bool value);
  public:

  // bool bicycle_network = 33;
  void clear_bicycle_network();
  bool bicycle_network() const;
  void set_bicycle_network(bool value);
  private:
  bool _internal_bicycle_network() const;
  void _internal_set_bicycle_network(bool value);
  public:

  // .valhalla.VehicleType vehicle_type = 21;
  void clear_vehicle_type();
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);
  private:
  ::valhalla::VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::VehicleType value);
  public:

  // .valhalla.PedestrianType pedestrian_type = 22;
  void clear_pedestrian_type();
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);
  private:
  ::valhalla::PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::PedestrianType value);
  public:

  // .valhalla.BicycleType bicycle_type = 23;
  void clear_bicycle_type();
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);
  private:
  ::valhalla::BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::BicycleType value);
  public:

  // uint64 id = 26;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // .valhalla.TransitType transit_type = 24;
  void clear_transit_type();
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);
  private:
  ::valhalla::TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::TransitType value);
  public:

  // float weighted_grade = 28;
  void clear_weighted_grade();
  float weighted_grade() const;
  void set_weighted_grade(float value);
  private:
  float _internal_weighted_grade() const;
  void _internal_set_weighted_grade(float value);
  public:

  // uint64 way_id = 27;
  void clear_way_id();
  uint64_t way_id() const;
  void set_way_id(uint64_t value);
  private:
  uint64_t _internal_way_id() const;
  void _internal_set_way_id(uint64_t value);
  public:

  // int32 max_upward_grade = 29;
  void clear_max_upward_grade();
  int32_t max_upward_grade() const;
  void set_max_upward_grade(int32_t value);
  private:
  int32_t _internal_max_upward_grade() const;
  void _internal_set_max_upward_grade(int32_t value);
  public:

  // int32 max_downward_grade = 30;
  void clear_max_downward_grade();
  int32_t max_downward_grade() const;
  void set_max_downward_grade(int32_t value);
  private:
  int32_t _internal_max_downward_grade() const;
  void _internal_set_max_downward_grade(int32_t value);
  public:

  // uint32 lane_count = 31;
  void clear_lane_count();
  uint32_t lane_count() const;
  void set_lane_count(uint32_t value);
  private:
  uint32_t _internal_lane_count() const;
  void _internal_set_lane_count(uint32_t value);
  public:

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  void clear_cycle_lane();
  ::valhalla::TripLeg_CycleLane cycle_lane() const;
  void set_cycle_lane(::valhalla::TripLeg_CycleLane value);
  private:
  ::valhalla::TripLeg_CycleLane _internal_cycle_lane() const;
  void _internal_set_cycle_lane(::valhalla::TripLeg_CycleLane value);
  public:

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  void clear_sidewalk();
  ::valhalla::TripLeg_Sidewalk sidewalk() const;
  void set_sidewalk(::valhalla::TripLeg_Sidewalk value);
  private:
  ::valhalla::TripLeg_Sidewalk _internal_sidewalk() const;
  void _internal_set_sidewalk(::valhalla::TripLeg_Sidewalk value);
  public:

  // uint32 density = 35;
  void clear_density();
  uint32_t density() const;
  void set_density(uint32_t value);
  private:
  uint32_t _internal_density() const;
  void _internal_set_density(uint32_t value);
  public:

  // uint32 speed_limit = 36;
  void clear_speed_limit();
  uint32_t speed_limit() const;
  void set_speed_limit(uint32_t value);
  private:
  uint32_t _internal_speed_limit() const;
  void _internal_set_speed_limit(uint32_t value);
  public:

  // float truck_speed = 37;
  void clear_truck_speed();
  float truck_speed() const;
  void set_truck_speed(float value);
  private:
  float _internal_truck_speed() const;
  void _internal_set_truck_speed(float value);
  public:

  // int32 mean_elevation = 40;
  void clear_mean_elevation();
  int32_t mean_elevation() const;
  void set_mean_elevation(int32_t value);
  private:
  int32_t _internal_mean_elevation() const;
  void _internal_set_mean_elevation(int32_t value);
  public:

  // bool truck_route = 38;
  void clear_truck_route();
  bool truck_route() const;
  void set_truck_route(bool value);
  private:
  bool _internal_truck_route() const;
  void _internal_set_truck_route(bool value);
  public:

  // bool has_time_restrictions = 43;
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // bool destination_only = 46;
  void clear_destination_only();
  bool destination_only() const;
  void set_destination_only(bool value);
  private:
  bool _internal_destination_only() const;
  void _internal_set_destination_only(bool value);
  public:

  // bool is_urban = 47;
  void clear_is_urban();
  bool is_urban() const;
  void set_is_urban(bool value);
  private:
  bool _internal_is_urban() const;
  void _internal_set_is_urban(bool value);
  public:

  // float default_speed = 44;
  void clear_default_speed();
  float default_speed() const;
  void set_default_speed(float value);
  private:
  float _internal_default_speed() const;
  void _internal_set_default_speed(float value);
  public:

  // float source_along_edge = 49;
  void clear_source_along_edge();
  float source_along_edge() const;
  void set_source_along_edge(float value);
  private:
  float _internal_source_along_edge() const;
  void _internal_set_source_along_edge(float value);
  public:

  // float target_along_edge = 50;
  void clear_target_along_edge();
  float target_along_edge() const;
  void set_target_along_edge(float value);
  private:
  float _internal_target_along_edge() const;
  void _internal_set_target_along_edge(float value);
  public:

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  void clear_sac_scale();
  ::valhalla::TripLeg_SacScale sac_scale() const;
  void set_sac_scale(::valhalla::TripLeg_SacScale value);
  private:
  ::valhalla::TripLeg_SacScale _internal_sac_scale() const;
  void _internal_set_sac_scale(::valhalla::TripLeg_SacScale value);
  public:

  // bool shoulder = 52;
  void clear_shoulder();
  bool shoulder() const;
  void set_shoulder(bool value);
  private:
  bool _internal_shoulder() const;
  void _internal_set_shoulder(bool value);
  public:

  // bool indoor = 53;
  void clear_indoor();
  bool indoor() const;
  void set_indoor(bool value);
  private:
  bool _internal_indoor() const;
  void _internal_set_indoor(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Edge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity > lane_connectivity_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment > traffic_segment_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane > turn_lanes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue > tagged_value_;
    ::valhalla::TripSign* sign_;
    ::valhalla::TransitRouteInfo* transit_route_info_;
    ::valhalla::TripLeg_Restriction* restriction_;
    float length_km_;
    float speed_;
    int road_class_;
    uint32_t begin_heading_;
    uint32_t end_heading_;
    uint32_t begin_shape_index_;
    uint32_t end_shape_index_;
    int traversability_;
    int use_;
    bool toll_;
    bool unpaved_;
    bool tunnel_;
    bool bridge_;
    int surface_;
    int travel_mode_;
    bool roundabout_;
    bool internal_intersection_;
    bool drive_on_left_;
    bool bicycle_network_;
    int vehicle_type_;
    int pedestrian_type_;
    int bicycle_type_;
    uint64_t id_;
    int transit_type_;
    float weighted_grade_;
    uint64_t way_id_;
    int32_t max_upward_grade_;
    int32_t max_downward_grade_;
    uint32_t lane_count_;
    int cycle_lane_;
    int sidewalk_;
    uint32_t density_;
    uint32_t speed_limit_;
    float truck_speed_;
    int32_t mean_elevation_;
    bool truck_route_;
    bool has_time_restrictions_;
    bool destination_only_;
    bool is_urban_;
    float default_speed_;
    float source_along_edge_;
    float target_along_edge_;
    int sac_scale_;
    bool shoulder_;
    bool indoor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_IntersectingEdge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.IntersectingEdge) */ {
 public:
  inline TripLeg_IntersectingEdge() : TripLeg_IntersectingEdge(nullptr) {}
  ~TripLeg_IntersectingEdge() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from);
  TripLeg_IntersectingEdge(TripLeg_IntersectingEdge&& from) noexcept
    : TripLeg_IntersectingEdge() {
    *this = ::std::move(from);
  }

  inline TripLeg_IntersectingEdge& operator=(const TripLeg_IntersectingEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_IntersectingEdge& operator=(TripLeg_IntersectingEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_IntersectingEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_IntersectingEdge* internal_default_instance() {
    return reinterpret_cast<const TripLeg_IntersectingEdge*>(
               &_TripLeg_IntersectingEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TripLeg_IntersectingEdge& a, TripLeg_IntersectingEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_IntersectingEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_IntersectingEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_IntersectingEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_IntersectingEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_IntersectingEdge& from);
  void MergeFrom(const TripLeg_IntersectingEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_IntersectingEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.IntersectingEdge";
  }
  protected:
  explicit TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignFieldNumber = 10,
    kBeginHeadingFieldNumber = 1,
    kPrevNameConsistencyFieldNumber = 2,
    kCurrNameConsistencyFieldNumber = 3,
    kDriveabilityFieldNumber = 4,
    kCyclabilityFieldNumber = 5,
    kWalkabilityFieldNumber = 6,
    kUseFieldNumber = 7,
    kRoadClassFieldNumber = 8,
    kLaneCountFieldNumber = 9,
  };
  // .valhalla.TripSign sign = 10;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);
  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::TripSign* sign);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  // uint32 begin_heading = 1;
  void clear_begin_heading();
  uint32_t begin_heading() const;
  void set_begin_heading(uint32_t value);
  private:
  uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(uint32_t value);
  public:

  // bool prev_name_consistency = 2;
  void clear_prev_name_consistency();
  bool prev_name_consistency() const;
  void set_prev_name_consistency(bool value);
  private:
  bool _internal_prev_name_consistency() const;
  void _internal_set_prev_name_consistency(bool value);
  public:

  // bool curr_name_consistency = 3;
  void clear_curr_name_consistency();
  bool curr_name_consistency() const;
  void set_curr_name_consistency(bool value);
  private:
  bool _internal_curr_name_consistency() const;
  void _internal_set_curr_name_consistency(bool value);
  public:

  // .valhalla.TripLeg.Traversability driveability = 4;
  void clear_driveability();
  ::valhalla::TripLeg_Traversability driveability() const;
  void set_driveability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_driveability() const;
  void _internal_set_driveability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Traversability cyclability = 5;
  void clear_cyclability();
  ::valhalla::TripLeg_Traversability cyclability() const;
  void set_cyclability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_cyclability() const;
  void _internal_set_cyclability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Traversability walkability = 6;
  void clear_walkability();
  ::valhalla::TripLeg_Traversability walkability() const;
  void set_walkability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_walkability() const;
  void _internal_set_walkability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Use use = 7;
  void clear_use();
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);
  private:
  ::valhalla::TripLeg_Use _internal_use() const;
  void _internal_set_use(::valhalla::TripLeg_Use value);
  public:

  // .valhalla.RoadClass road_class = 8;
  void clear_road_class();
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);
  private:
  ::valhalla::RoadClass _internal_road_class() const;
  void _internal_set_road_class(::valhalla::RoadClass value);
  public:

  // uint32 lane_count = 9;
  void clear_lane_count();
  uint32_t lane_count() const;
  void set_lane_count(uint32_t value);
  private:
  uint32_t _internal_lane_count() const;
  void _internal_set_lane_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.IntersectingEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::TripSign* sign_;
    uint32_t begin_heading_;
    bool prev_name_consistency_;
    bool curr_name_consistency_;
    int driveability_;
    int cyclability_;
    int walkability_;
    int use_;
    int road_class_;
    uint32_t lane_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Cost final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Cost) */ {
 public:
  inline TripLeg_Cost() : TripLeg_Cost(nullptr) {}
  ~TripLeg_Cost() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Cost(const TripLeg_Cost& from);
  TripLeg_Cost(TripLeg_Cost&& from) noexcept
    : TripLeg_Cost() {
    *this = ::std::move(from);
  }

  inline TripLeg_Cost& operator=(const TripLeg_Cost& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Cost& operator=(TripLeg_Cost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Cost& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Cost* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Cost*>(
               &_TripLeg_Cost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TripLeg_Cost& a, TripLeg_Cost& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Cost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Cost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Cost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Cost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Cost& from);
  void MergeFrom(const TripLeg_Cost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Cost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Cost";
  }
  protected:
  explicit TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // double seconds = 1;
  void clear_seconds();
  double seconds() const;
  void set_seconds(double value);
  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);
  public:

  // double cost = 2;
  void clear_cost();
  double cost() const;
  void set_cost(double value);
  private:
  double _internal_cost() const;
  void _internal_set_cost(double value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Cost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double seconds_;
    double cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_PathCost final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.PathCost) */ {
 public:
  inline TripLeg_PathCost() : TripLeg_PathCost(nullptr) {}
  ~TripLeg_PathCost() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_PathCost(const TripLeg_PathCost& from);
  TripLeg_PathCost(TripLeg_PathCost&& from) noexcept
    : TripLeg_PathCost() {
    *this = ::std::move(from);
  }

  inline TripLeg_PathCost& operator=(const TripLeg_PathCost& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_PathCost& operator=(TripLeg_PathCost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_PathCost& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_PathCost* internal_default_instance() {
    return reinterpret_cast<const TripLeg_PathCost*>(
               &_TripLeg_PathCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TripLeg_PathCost& a, TripLeg_PathCost& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_PathCost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_PathCost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_PathCost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_PathCost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_PathCost& from);
  void MergeFrom(const TripLeg_PathCost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_PathCost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.PathCost";
  }
  protected:
  explicit TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElapsedCostFieldNumber = 1,
    kTransitionCostFieldNumber = 2,
  };
  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  bool has_elapsed_cost() const;
  private:
  bool _internal_has_elapsed_cost() const;
  public:
  void clear_elapsed_cost();
  const ::valhalla::TripLeg_Cost& elapsed_cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Cost* release_elapsed_cost();
  ::valhalla::TripLeg_Cost* mutable_elapsed_cost();
  void set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost);
  private:
  const ::valhalla::TripLeg_Cost& _internal_elapsed_cost() const;
  ::valhalla::TripLeg_Cost* _internal_mutable_elapsed_cost();
  public:
  void unsafe_arena_set_allocated_elapsed_cost(
      ::valhalla::TripLeg_Cost* elapsed_cost);
  ::valhalla::TripLeg_Cost* unsafe_arena_release_elapsed_cost();

  // .valhalla.TripLeg.Cost transition_cost = 2;
  bool has_transition_cost() const;
  private:
  bool _internal_has_transition_cost() const;
  public:
  void clear_transition_cost();
  const ::valhalla::TripLeg_Cost& transition_cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Cost* release_transition_cost();
  ::valhalla::TripLeg_Cost* mutable_transition_cost();
  void set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost);
  private:
  const ::valhalla::TripLeg_Cost& _internal_transition_cost() const;
  ::valhalla::TripLeg_Cost* _internal_mutable_transition_cost();
  public:
  void unsafe_arena_set_allocated_transition_cost(
      ::valhalla::TripLeg_Cost* transition_cost);
  ::valhalla::TripLeg_Cost* unsafe_arena_release_transition_cost();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.PathCost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::TripLeg_Cost* elapsed_cost_;
    ::valhalla::TripLeg_Cost* transition_cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Node final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Node) */ {
 public:
  inline TripLeg_Node() : TripLeg_Node(nullptr) {}
  ~TripLeg_Node() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Node(const TripLeg_Node& from);
  TripLeg_Node(TripLeg_Node&& from) noexcept
    : TripLeg_Node() {
    *this = ::std::move(from);
  }

  inline TripLeg_Node& operator=(const TripLeg_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Node& operator=(TripLeg_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Node* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Node*>(
               &_TripLeg_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TripLeg_Node& a, TripLeg_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Node>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Node& from);
  void MergeFrom(const TripLeg_Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Node";
  }
  protected:
  explicit TripLeg_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TripLeg_Node_Type Type;
  static constexpr Type kStreetIntersection =
    TripLeg_Node_Type_kStreetIntersection;
  static constexpr Type kGate =
    TripLeg_Node_Type_kGate;
  static constexpr Type kBollard =
    TripLeg_Node_Type_kBollard;
  static constexpr Type kTollBooth =
    TripLeg_Node_Type_kTollBooth;
  static constexpr Type kTransitEgress =
    TripLeg_Node_Type_kTransitEgress;
  static constexpr Type kTransitStation =
    TripLeg_Node_Type_kTransitStation;
  static constexpr Type kTransitPlatform =
    TripLeg_Node_Type_kTransitPlatform;
  static constexpr Type kBikeShare =
    TripLeg_Node_Type_kBikeShare;
  static constexpr Type kParking =
    TripLeg_Node_Type_kParking;
  static constexpr Type kMotorwayJunction =
    TripLeg_Node_Type_kMotorwayJunction;
  static constexpr Type kBorderControl =
    TripLeg_Node_Type_kBorderControl;
  static constexpr Type kTollGantry =
    TripLeg_Node_Type_kTollGantry;
  static constexpr Type kSumpBuster =
    TripLeg_Node_Type_kSumpBuster;
  static constexpr Type kBuildingEntrance =
    TripLeg_Node_Type_kBuildingEntrance;
  static constexpr Type kElevator =
    TripLeg_Node_Type_kElevator;
  static inline bool Type_IsValid(int value) {
    return TripLeg_Node_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TripLeg_Node_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TripLeg_Node_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TripLeg_Node_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TripLeg_Node_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TripLeg_Node_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectingEdgeFieldNumber = 2,
    kRecostsFieldNumber = 13,
    kTimeZoneFieldNumber = 11,
    kEdgeFieldNumber = 1,
    kTransitPlatformInfoFieldNumber = 6,
    kTransitStationInfoFieldNumber = 7,
    kTransitEgressInfoFieldNumber = 10,
    kCostFieldNumber = 12,
    kBssInfoFieldNumber = 14,
    kAdminIndexFieldNumber = 3,
    kTypeFieldNumber = 4,
    kForkFieldNumber = 5,
  };
  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  int intersecting_edge_size() const;
  private:
  int _internal_intersecting_edge_size() const;
  public:
  void clear_intersecting_edge();
  ::valhalla::TripLeg_IntersectingEdge* mutable_intersecting_edge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
      mutable_intersecting_edge();
  private:
  const ::valhalla::TripLeg_IntersectingEdge& _internal_intersecting_edge(int index) const;
  ::valhalla::TripLeg_IntersectingEdge* _internal_add_intersecting_edge();
  public:
  const ::valhalla::TripLeg_IntersectingEdge& intersecting_edge(int index) const;
  ::valhalla::TripLeg_IntersectingEdge* add_intersecting_edge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
      intersecting_edge() const;

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  int recosts_size() const;
  private:
  int _internal_recosts_size() const;
  public:
  void clear_recosts();
  ::valhalla::TripLeg_PathCost* mutable_recosts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
      mutable_recosts();
  private:
  const ::valhalla::TripLeg_PathCost& _internal_recosts(int index) const;
  ::valhalla::TripLeg_PathCost* _internal_add_recosts();
  public:
  const ::valhalla::TripLeg_PathCost& recosts(int index) const;
  ::valhalla::TripLeg_PathCost* add_recosts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
      recosts() const;

  // string time_zone = 11;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // .valhalla.TripLeg.Edge edge = 1;
  bool has_edge() const;
  private:
  bool _internal_has_edge() const;
  public:
  void clear_edge();
  const ::valhalla::TripLeg_Edge& edge() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Edge* release_edge();
  ::valhalla::TripLeg_Edge* mutable_edge();
  void set_allocated_edge(::valhalla::TripLeg_Edge* edge);
  private:
  const ::valhalla::TripLeg_Edge& _internal_edge() const;
  ::valhalla::TripLeg_Edge* _internal_mutable_edge();
  public:
  void unsafe_arena_set_allocated_edge(
      ::valhalla::TripLeg_Edge* edge);
  ::valhalla::TripLeg_Edge* unsafe_arena_release_edge();

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  bool has_transit_platform_info() const;
  private:
  bool _internal_has_transit_platform_info() const;
  public:
  void clear_transit_platform_info();
  const ::valhalla::TransitPlatformInfo& transit_platform_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitPlatformInfo* release_transit_platform_info();
  ::valhalla::TransitPlatformInfo* mutable_transit_platform_info();
  void set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info);
  private:
  const ::valhalla::TransitPlatformInfo& _internal_transit_platform_info() const;
  ::valhalla::TransitPlatformInfo* _internal_mutable_transit_platform_info();
  public:
  void unsafe_arena_set_allocated_transit_platform_info(
      ::valhalla::TransitPlatformInfo* transit_platform_info);
  ::valhalla::TransitPlatformInfo* unsafe_arena_release_transit_platform_info();

  // .valhalla.TransitStationInfo transit_station_info = 7;
  bool has_transit_station_info() const;
  private:
  bool _internal_has_transit_station_info() const;
  public:
  void clear_transit_station_info();
  const ::valhalla::TransitStationInfo& transit_station_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitStationInfo* release_transit_station_info();
  ::valhalla::TransitStationInfo* mutable_transit_station_info();
  void set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info);
  private:
  const ::valhalla::TransitStationInfo& _internal_transit_station_info() const;
  ::valhalla::TransitStationInfo* _internal_mutable_transit_station_info();
  public:
  void unsafe_arena_set_allocated_transit_station_info(
      ::valhalla::TransitStationInfo* transit_station_info);
  ::valhalla::TransitStationInfo* unsafe_arena_release_transit_station_info();

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  bool has_transit_egress_info() const;
  private:
  bool _internal_has_transit_egress_info() const;
  public:
  void clear_transit_egress_info();
  const ::valhalla::TransitEgressInfo& transit_egress_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitEgressInfo* release_transit_egress_info();
  ::valhalla::TransitEgressInfo* mutable_transit_egress_info();
  void set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info);
  private:
  const ::valhalla::TransitEgressInfo& _internal_transit_egress_info() const;
  ::valhalla::TransitEgressInfo* _internal_mutable_transit_egress_info();
  public:
  void unsafe_arena_set_allocated_transit_egress_info(
      ::valhalla::TransitEgressInfo* transit_egress_info);
  ::valhalla::TransitEgressInfo* unsafe_arena_release_transit_egress_info();

  // .valhalla.TripLeg.PathCost cost = 12;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  const ::valhalla::TripLeg_PathCost& cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_PathCost* release_cost();
  ::valhalla::TripLeg_PathCost* mutable_cost();
  void set_allocated_cost(::valhalla::TripLeg_PathCost* cost);
  private:
  const ::valhalla::TripLeg_PathCost& _internal_cost() const;
  ::valhalla::TripLeg_PathCost* _internal_mutable_cost();
  public:
  void unsafe_arena_set_allocated_cost(
      ::valhalla::TripLeg_PathCost* cost);
  ::valhalla::TripLeg_PathCost* unsafe_arena_release_cost();

  // .valhalla.BikeShareStationInfo bss_info = 14;
  bool has_bss_info() const;
  private:
  bool _internal_has_bss_info() const;
  public:
  void clear_bss_info();
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  PROTOBUF_NODISCARD ::valhalla::BikeShareStationInfo* release_bss_info();
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info);
  private:
  const ::valhalla::BikeShareStationInfo& _internal_bss_info() const;
  ::valhalla::BikeShareStationInfo* _internal_mutable_bss_info();
  public:
  void unsafe_arena_set_allocated_bss_info(
      ::valhalla::BikeShareStationInfo* bss_info);
  ::valhalla::BikeShareStationInfo* unsafe_arena_release_bss_info();

  // uint32 admin_index = 3;
  void clear_admin_index();
  uint32_t admin_index() const;
  void set_admin_index(uint32_t value);
  private:
  uint32_t _internal_admin_index() const;
  void _internal_set_admin_index(uint32_t value);
  public:

  // .valhalla.TripLeg.Node.Type type = 4;
  void clear_type();
  ::valhalla::TripLeg_Node_Type type() const;
  void set_type(::valhalla::TripLeg_Node_Type value);
  private:
  ::valhalla::TripLeg_Node_Type _internal_type() const;
  void _internal_set_type(::valhalla::TripLeg_Node_Type value);
  public:

  // bool fork = 5;
  void clear_fork();
  bool fork() const;
  void set_fork(bool value);
  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge > intersecting_edge_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost > recosts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::valhalla::TripLeg_Edge* edge_;
    ::valhalla::TransitPlatformInfo* transit_platform_info_;
    ::valhalla::TransitStationInfo* transit_station_info_;
    ::valhalla::TransitEgressInfo* transit_egress_info_;
    ::valhalla::TripLeg_PathCost* cost_;
    ::valhalla::BikeShareStationInfo* bss_info_;
    uint32_t admin_index_;
    int type_;
    bool fork_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Admin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Admin) */ {
 public:
  inline TripLeg_Admin() : TripLeg_Admin(nullptr) {}
  ~TripLeg_Admin() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Admin(const TripLeg_Admin& from);
  TripLeg_Admin(TripLeg_Admin&& from) noexcept
    : TripLeg_Admin() {
    *this = ::std::move(from);
  }

  inline TripLeg_Admin& operator=(const TripLeg_Admin& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Admin& operator=(TripLeg_Admin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Admin& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Admin* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Admin*>(
               &_TripLeg_Admin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TripLeg_Admin& a, TripLeg_Admin& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Admin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Admin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Admin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Admin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Admin& from);
  void MergeFrom(const TripLeg_Admin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Admin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Admin";
  }
  protected:
  explicit TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryCodeFieldNumber = 1,
    kCountryTextFieldNumber = 2,
    kStateCodeFieldNumber = 3,
    kStateTextFieldNumber = 4,
  };
  // string country_code = 1;
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // string country_text = 2;
  void clear_country_text();
  const std::string& country_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_text();
  PROTOBUF_NODISCARD std::string* release_country_text();
  void set_allocated_country_text(std::string* country_text);
  private:
  const std::string& _internal_country_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_text(const std::string& value);
  std::string* _internal_mutable_country_text();
  public:

  // string state_code = 3;
  void clear_state_code();
  const std::string& state_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_code();
  PROTOBUF_NODISCARD std::string* release_state_code();
  void set_allocated_state_code(std::string* state_code);
  private:
  const std::string& _internal_state_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_code(const std::string& value);
  std::string* _internal_mutable_state_code();
  public:

  // string state_text = 4;
  void clear_state_text();
  const std::string& state_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_text();
  PROTOBUF_NODISCARD std::string* release_state_text();
  void set_allocated_state_text(std::string* state_text);
  private:
  const std::string& _internal_state_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_text(const std::string& value);
  std::string* _internal_mutable_state_text();
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Admin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_ShapeAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.ShapeAttributes) */ {
 public:
  inline TripLeg_ShapeAttributes() : TripLeg_ShapeAttributes(nullptr) {}
  ~TripLeg_ShapeAttributes() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from);
  TripLeg_ShapeAttributes(TripLeg_ShapeAttributes&& from) noexcept
    : TripLeg_ShapeAttributes() {
    *this = ::std::move(from);
  }

  inline TripLeg_ShapeAttributes& operator=(const TripLeg_ShapeAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_ShapeAttributes& operator=(TripLeg_ShapeAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_ShapeAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_ShapeAttributes* internal_default_instance() {
    return reinterpret_cast<const TripLeg_ShapeAttributes*>(
               &_TripLeg_ShapeAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TripLeg_ShapeAttributes& a, TripLeg_ShapeAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_ShapeAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_ShapeAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_ShapeAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_ShapeAttributes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_ShapeAttributes& from);
  void MergeFrom(const TripLeg_ShapeAttributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_ShapeAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.ShapeAttributes";
  }
  protected:
  explicit TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kLengthFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kSpeedLimitFieldNumber = 5,
  };
  // repeated uint32 time = 1 [packed = true];
  int time_size() const;
  private:
  int _internal_time_size() const;
  public:
  void clear_time();
  private:
  uint32_t _internal_time(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_time() const;
  void _internal_add_time(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_time();
  public:
  uint32_t time(int index) const;
  void set_time(int index, uint32_t value);
  void add_time(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_time();

  // repeated uint32 length = 2 [packed = true];
  int length_size() const;
  private:
  int _internal_length_size() const;
  public:
  void clear_length();
  private:
  uint32_t _internal_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_length() const;
  void _internal_add_length(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_length();
  public:
  uint32_t length(int index) const;
  void set_length(int index, uint32_t value);
  void add_length(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_length();

  // repeated uint32 speed = 3 [packed = true];
  int speed_size() const;
  private:
  int _internal_speed_size() const;
  public:
  void clear_speed();
  private:
  uint32_t _internal_speed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_speed() const;
  void _internal_add_speed(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_speed();
  public:
  uint32_t speed(int index) const;
  void set_speed(int index, uint32_t value);
  void add_speed(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      speed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_speed();

  // repeated uint32 speed_limit = 5 [packed = true];
  int speed_limit_size() const;
  private:
  int _internal_speed_limit_size() const;
  public:
  void clear_speed_limit();
  private:
  uint32_t _internal_speed_limit(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_speed_limit() const;
  void _internal_add_speed_limit(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_speed_limit();
  public:
  uint32_t speed_limit(int index) const;
  void set_speed_limit(int index, uint32_t value);
  void add_speed_limit(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      speed_limit() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_speed_limit();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.ShapeAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > time_;
    mutable std::atomic<int> _time_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > length_;
    mutable std::atomic<int> _length_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > speed_;
    mutable std::atomic<int> _speed_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > speed_limit_;
    mutable std::atomic<int> _speed_limit_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Incident final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Incident) */ {
 public:
  inline TripLeg_Incident() : TripLeg_Incident(nullptr) {}
  ~TripLeg_Incident() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Incident(const TripLeg_Incident& from);
  TripLeg_Incident(TripLeg_Incident&& from) noexcept
    : TripLeg_Incident() {
    *this = ::std::move(from);
  }

  inline TripLeg_Incident& operator=(const TripLeg_Incident& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Incident& operator=(TripLeg_Incident&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Incident& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Incident* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Incident*>(
               &_TripLeg_Incident_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TripLeg_Incident& a, TripLeg_Incident& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Incident* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Incident* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Incident* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Incident>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Incident& from);
  void MergeFrom(const TripLeg_Incident& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Incident* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Incident";
  }
  protected:
  explicit TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kBeginShapeIndexFieldNumber = 3,
    kEndShapeIndexFieldNumber = 4,
  };
  // .valhalla.IncidentsTile.Metadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::valhalla::IncidentsTile_Metadata& metadata() const;
  PROTOBUF_NODISCARD ::valhalla::IncidentsTile_Metadata* release_metadata();
  ::valhalla::IncidentsTile_Metadata* mutable_metadata();
  void set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata);
  private:
  const ::valhalla::IncidentsTile_Metadata& _internal_metadata() const;
  ::valhalla::IncidentsTile_Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::valhalla::IncidentsTile_Metadata* metadata);
  ::valhalla::IncidentsTile_Metadata* unsafe_arena_release_metadata();

  // uint32 begin_shape_index = 3;
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 4;
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Incident)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::IncidentsTile_Metadata* metadata_;
    uint32_t begin_shape_index_;
    uint32_t end_shape_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Closure final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Closure) */ {
 public:
  inline TripLeg_Closure() : TripLeg_Closure(nullptr) {}
  ~TripLeg_Closure() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Closure(const TripLeg_Closure& from);
  TripLeg_Closure(TripLeg_Closure&& from) noexcept
    : TripLeg_Closure() {
    *this = ::std::move(from);
  }

  inline TripLeg_Closure& operator=(const TripLeg_Closure& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Closure& operator=(TripLeg_Closure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Closure& default_instance() {
    return *internal_default_instance();
  }
  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 1,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 2,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  static inline const TripLeg_Closure* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Closure*>(
               &_TripLeg_Closure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TripLeg_Closure& a, TripLeg_Closure& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Closure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Closure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Closure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Closure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Closure& from);
  void MergeFrom(const TripLeg_Closure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Closure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Closure";
  }
  protected:
  explicit TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginShapeIndexFieldNumber = 1,
    kEndShapeIndexFieldNumber = 2,
  };
  // uint32 begin_shape_index = 1;
  bool has_begin_shape_index() const;
  private:
  bool _internal_has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 2;
  bool has_end_shape_index() const;
  private:
  bool _internal_has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  void clear_has_begin_shape_index();
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  void clear_has_end_shape_index();
  HasEndShapeIndexCase has_end_shape_index_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Closure)
 private:
  class _Internal;
  void set_has_begin_shape_index();
  void set_has_end_shape_index();

  inline bool has_has_begin_shape_index() const;
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  inline void clear_has_has_end_shape_index();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasBeginShapeIndexUnion {
      constexpr HasBeginShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t begin_shape_index_;
    } has_begin_shape_index_;
    union HasEndShapeIndexUnion {
      constexpr HasEndShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t end_shape_index_;
    } has_end_shape_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg) */ {
 public:
  inline TripLeg() : TripLeg(nullptr) {}
  ~TripLeg() override;
  explicit PROTOBUF_CONSTEXPR TripLeg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg(const TripLeg& from);
  TripLeg(TripLeg&& from) noexcept
    : TripLeg() {
    *this = ::std::move(from);
  }

  inline TripLeg& operator=(const TripLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg& operator=(TripLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg* internal_default_instance() {
    return reinterpret_cast<const TripLeg*>(
               &_TripLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TripLeg& a, TripLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg& from);
  void MergeFrom(const TripLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg";
  }
  protected:
  explicit TripLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TripLeg_LaneConnectivity LaneConnectivity;
  typedef TripLeg_TrafficSegment TrafficSegment;
  typedef TripLeg_Restriction Restriction;
  typedef TripLeg_Edge Edge;
  typedef TripLeg_IntersectingEdge IntersectingEdge;
  typedef TripLeg_Cost Cost;
  typedef TripLeg_PathCost PathCost;
  typedef TripLeg_Node Node;
  typedef TripLeg_Admin Admin;
  typedef TripLeg_ShapeAttributes ShapeAttributes;
  typedef TripLeg_Incident Incident;
  typedef TripLeg_Closure Closure;

  typedef TripLeg_Traversability Traversability;
  static constexpr Traversability kNone =
    TripLeg_Traversability_kNone;
  static constexpr Traversability kForward =
    TripLeg_Traversability_kForward;
  static constexpr Traversability kBackward =
    TripLeg_Traversability_kBackward;
  static constexpr Traversability kBoth =
    TripLeg_Traversability_kBoth;
  static inline bool Traversability_IsValid(int value) {
    return TripLeg_Traversability_IsValid(value);
  }
  static constexpr Traversability Traversability_MIN =
    TripLeg_Traversability_Traversability_MIN;
  static constexpr Traversability Traversability_MAX =
    TripLeg_Traversability_Traversability_MAX;
  static constexpr int Traversability_ARRAYSIZE =
    TripLeg_Traversability_Traversability_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Traversability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Traversability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Traversability_Name.");
    return TripLeg_Traversability_Name(enum_t_value);
  }
  static inline bool Traversability_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Traversability* value) {
    return TripLeg_Traversability_Parse(name, value);
  }

  typedef TripLeg_Use Use;
  static constexpr Use kRoadUse =
    TripLeg_Use_kRoadUse;
  static constexpr Use kRampUse =
    TripLeg_Use_kRampUse;
  static constexpr Use kTurnChannelUse =
    TripLeg_Use_kTurnChannelUse;
  static constexpr Use kTrackUse =
    TripLeg_Use_kTrackUse;
  static constexpr Use kDrivewayUse =
    TripLeg_Use_kDrivewayUse;
  static constexpr Use kAlleyUse =
    TripLeg_Use_kAlleyUse;
  static constexpr Use kParkingAisleUse =
    TripLeg_Use_kParkingAisleUse;
  static constexpr Use kEmergencyAccessUse =
    TripLeg_Use_kEmergencyAccessUse;
  static constexpr Use kDriveThruUse =
    TripLeg_Use_kDriveThruUse;
  static constexpr Use kCuldesacUse =
    TripLeg_Use_kCuldesacUse;
  static constexpr Use kLivingStreetUse =
    TripLeg_Use_kLivingStreetUse;
  static constexpr Use kServiceRoadUse =
    TripLeg_Use_kServiceRoadUse;
  static constexpr Use kCyclewayUse =
    TripLeg_Use_kCyclewayUse;
  static constexpr Use kMountainBikeUse =
    TripLeg_Use_kMountainBikeUse;
  static constexpr Use kSidewalkUse =
    TripLeg_Use_kSidewalkUse;
  static constexpr Use kFootwayUse =
    TripLeg_Use_kFootwayUse;
  static constexpr Use kStepsUse =
    TripLeg_Use_kStepsUse;
  static constexpr Use kPathUse =
    TripLeg_Use_kPathUse;
  static constexpr Use kPedestrianUse =
    TripLeg_Use_kPedestrianUse;
  static constexpr Use kBridlewayUse =
    TripLeg_Use_kBridlewayUse;
  static constexpr Use kPedestrianCrossingUse =
    TripLeg_Use_kPedestrianCrossingUse;
  static constexpr Use kElevatorUse =
    TripLeg_Use_kElevatorUse;
  static constexpr Use kEscalatorUse =
    TripLeg_Use_kEscalatorUse;
  static constexpr Use kRestAreaUse =
    TripLeg_Use_kRestAreaUse;
  static constexpr Use kServiceAreaUse =
    TripLeg_Use_kServiceAreaUse;
  static constexpr Use kOtherUse =
    TripLeg_Use_kOtherUse;
  static constexpr Use kFerryUse =
    TripLeg_Use_kFerryUse;
  static constexpr Use kRailFerryUse =
    TripLeg_Use_kRailFerryUse;
  static constexpr Use kConstructionUse =
    TripLeg_Use_kConstructionUse;
  static constexpr Use kRailUse =
    TripLeg_Use_kRailUse;
  static constexpr Use kBusUse =
    TripLeg_Use_kBusUse;
  static constexpr Use kEgressConnectionUse =
    TripLeg_Use_kEgressConnectionUse;
  static constexpr Use kPlatformConnectionUse =
    TripLeg_Use_kPlatformConnectionUse;
  static constexpr Use kTransitConnectionUse =
    TripLeg_Use_kTransitConnectionUse;
  static inline bool Use_IsValid(int value) {
    return TripLeg_Use_IsValid(value);
  }
  static constexpr Use Use_MIN =
    TripLeg_Use_Use_MIN;
  static constexpr Use Use_MAX =
    TripLeg_Use_Use_MAX;
  static constexpr int Use_ARRAYSIZE =
    TripLeg_Use_Use_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Use_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Use>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Use_Name.");
    return TripLeg_Use_Name(enum_t_value);
  }
  static inline bool Use_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Use* value) {
    return TripLeg_Use_Parse(name, value);
  }

  typedef TripLeg_Surface Surface;
  static constexpr Surface kPavedSmooth =
    TripLeg_Surface_kPavedSmooth;
  static constexpr Surface kPaved =
    TripLeg_Surface_kPaved;
  static constexpr Surface kPavedRough =
    TripLeg_Surface_kPavedRough;
  static constexpr Surface kCompacted =
    TripLeg_Surface_kCompacted;
  static constexpr Surface kDirt =
    TripLeg_Surface_kDirt;
  static constexpr Surface kGravel =
    TripLeg_Surface_kGravel;
  static constexpr Surface kPath =
    TripLeg_Surface_kPath;
  static constexpr Surface kImpassable =
    TripLeg_Surface_kImpassable;
  static inline bool Surface_IsValid(int value) {
    return TripLeg_Surface_IsValid(value);
  }
  static constexpr Surface Surface_MIN =
    TripLeg_Surface_Surface_MIN;
  static constexpr Surface Surface_MAX =
    TripLeg_Surface_Surface_MAX;
  static constexpr int Surface_ARRAYSIZE =
    TripLeg_Surface_Surface_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Surface_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Surface>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Surface_Name.");
    return TripLeg_Surface_Name(enum_t_value);
  }
  static inline bool Surface_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Surface* value) {
    return TripLeg_Surface_Parse(name, value);
  }

  typedef TripLeg_CycleLane CycleLane;
  static constexpr CycleLane kNoCycleLane =
    TripLeg_CycleLane_kNoCycleLane;
  static constexpr CycleLane kShared =
    TripLeg_CycleLane_kShared;
  static constexpr CycleLane kDedicated =
    TripLeg_CycleLane_kDedicated;
  static constexpr CycleLane kSeparated =
    TripLeg_CycleLane_kSeparated;
  static inline bool CycleLane_IsValid(int value) {
    return TripLeg_CycleLane_IsValid(value);
  }
  static constexpr CycleLane CycleLane_MIN =
    TripLeg_CycleLane_CycleLane_MIN;
  static constexpr CycleLane CycleLane_MAX =
    TripLeg_CycleLane_CycleLane_MAX;
  static constexpr int CycleLane_ARRAYSIZE =
    TripLeg_CycleLane_CycleLane_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CycleLane_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CycleLane>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CycleLane_Name.");
    return TripLeg_CycleLane_Name(enum_t_value);
  }
  static inline bool CycleLane_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CycleLane* value) {
    return TripLeg_CycleLane_Parse(name, value);
  }

  typedef TripLeg_SacScale SacScale;
  static constexpr SacScale kNoSacScale =
    TripLeg_SacScale_kNoSacScale;
  static constexpr SacScale kHiking =
    TripLeg_SacScale_kHiking;
  static constexpr SacScale kMountainHiking =
    TripLeg_SacScale_kMountainHiking;
  static constexpr SacScale kDemandingMountainHiking =
    TripLeg_SacScale_kDemandingMountainHiking;
  static constexpr SacScale kAlpineHiking =
    TripLeg_SacScale_kAlpineHiking;
  static constexpr SacScale kDemandingAlpineHiking =
    TripLeg_SacScale_kDemandingAlpineHiking;
  static constexpr SacScale kDifficultAlpineHiking =
    TripLeg_SacScale_kDifficultAlpineHiking;
  static inline bool SacScale_IsValid(int value) {
    return TripLeg_SacScale_IsValid(value);
  }
  static constexpr SacScale SacScale_MIN =
    TripLeg_SacScale_SacScale_MIN;
  static constexpr SacScale SacScale_MAX =
    TripLeg_SacScale_SacScale_MAX;
  static constexpr int SacScale_ARRAYSIZE =
    TripLeg_SacScale_SacScale_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SacScale_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SacScale>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SacScale_Name.");
    return TripLeg_SacScale_Name(enum_t_value);
  }
  static inline bool SacScale_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SacScale* value) {
    return TripLeg_SacScale_Parse(name, value);
  }

  typedef TripLeg_Sidewalk Sidewalk;
  static constexpr Sidewalk kNoSidewalk =
    TripLeg_Sidewalk_kNoSidewalk;
  static constexpr Sidewalk kLeft =
    TripLeg_Sidewalk_kLeft;
  static constexpr Sidewalk kRight =
    TripLeg_Sidewalk_kRight;
  static constexpr Sidewalk kBothSides =
    TripLeg_Sidewalk_kBothSides;
  static inline bool Sidewalk_IsValid(int value) {
    return TripLeg_Sidewalk_IsValid(value);
  }
  static constexpr Sidewalk Sidewalk_MIN =
    TripLeg_Sidewalk_Sidewalk_MIN;
  static constexpr Sidewalk Sidewalk_MAX =
    TripLeg_Sidewalk_Sidewalk_MAX;
  static constexpr int Sidewalk_ARRAYSIZE =
    TripLeg_Sidewalk_Sidewalk_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Sidewalk_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Sidewalk>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Sidewalk_Name.");
    return TripLeg_Sidewalk_Name(enum_t_value);
  }
  static inline bool Sidewalk_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Sidewalk* value) {
    return TripLeg_Sidewalk_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 5,
    kNodeFieldNumber = 6,
    kAdminFieldNumber = 7,
    kIncidentsFieldNumber = 11,
    kAlgorithmsFieldNumber = 12,
    kClosuresFieldNumber = 13,
    kShapeFieldNumber = 8,
    kBboxFieldNumber = 9,
    kShapeAttributesFieldNumber = 10,
    kOsmChangesetFieldNumber = 1,
    kTripIdFieldNumber = 2,
    kLegIdFieldNumber = 3,
    kLegCountFieldNumber = 4,
  };
  // repeated .valhalla.Location location = 5;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::valhalla::Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::valhalla::Location& _internal_location(int index) const;
  ::valhalla::Location* _internal_add_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // repeated .valhalla.TripLeg.Node node = 6;
  int node_size() const;
  private:
  int _internal_node_size() const;
  public:
  void clear_node();
  ::valhalla::TripLeg_Node* mutable_node(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >*
      mutable_node();
  private:
  const ::valhalla::TripLeg_Node& _internal_node(int index) const;
  ::valhalla::TripLeg_Node* _internal_add_node();
  public:
  const ::valhalla::TripLeg_Node& node(int index) const;
  ::valhalla::TripLeg_Node* add_node();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >&
      node() const;

  // repeated .valhalla.TripLeg.Admin admin = 7;
  int admin_size() const;
  private:
  int _internal_admin_size() const;
  public:
  void clear_admin();
  ::valhalla::TripLeg_Admin* mutable_admin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
      mutable_admin();
  private:
  const ::valhalla::TripLeg_Admin& _internal_admin(int index) const;
  ::valhalla::TripLeg_Admin* _internal_add_admin();
  public:
  const ::valhalla::TripLeg_Admin& admin(int index) const;
  ::valhalla::TripLeg_Admin* add_admin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
      admin() const;

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  int incidents_size() const;
  private:
  int _internal_incidents_size() const;
  public:
  void clear_incidents();
  ::valhalla::TripLeg_Incident* mutable_incidents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
      mutable_incidents();
  private:
  const ::valhalla::TripLeg_Incident& _internal_incidents(int index) const;
  ::valhalla::TripLeg_Incident* _internal_add_incidents();
  public:
  const ::valhalla::TripLeg_Incident& incidents(int index) const;
  ::valhalla::TripLeg_Incident* add_incidents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
      incidents() const;

  // repeated string algorithms = 12;
  int algorithms_size() const;
  private:
  int _internal_algorithms_size() const;
  public:
  void clear_algorithms();
  const std::string& algorithms(int index) const;
  std::string* mutable_algorithms(int index);
  void set_algorithms(int index, const std::string& value);
  void set_algorithms(int index, std::string&& value);
  void set_algorithms(int index, const char* value);
  void set_algorithms(int index, const char* value, size_t size);
  std::string* add_algorithms();
  void add_algorithms(const std::string& value);
  void add_algorithms(std::string&& value);
  void add_algorithms(const char* value);
  void add_algorithms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& algorithms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_algorithms();
  private:
  const std::string& _internal_algorithms(int index) const;
  std::string* _internal_add_algorithms();
  public:

  // repeated .valhalla.TripLeg.Closure closures = 13;
  int closures_size() const;
  private:
  int _internal_closures_size() const;
  public:
  void clear_closures();
  ::valhalla::TripLeg_Closure* mutable_closures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
      mutable_closures();
  private:
  const ::valhalla::TripLeg_Closure& _internal_closures(int index) const;
  ::valhalla::TripLeg_Closure* _internal_add_closures();
  public:
  const ::valhalla::TripLeg_Closure& closures(int index) const;
  ::valhalla::TripLeg_Closure* add_closures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
      closures() const;

  // string shape = 8;
  void clear_shape();
  const std::string& shape() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* shape);
  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(const std::string& value);
  std::string* _internal_mutable_shape();
  public:

  // .valhalla.BoundingBox bbox = 9;
  bool has_bbox() const;
  private:
  bool _internal_has_bbox() const;
  public:
  void clear_bbox();
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_NODISCARD ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);
  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();
  public:
  void unsafe_arena_set_allocated_bbox(
      ::valhalla::BoundingBox* bbox);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  bool has_shape_attributes() const;
  private:
  bool _internal_has_shape_attributes() const;
  public:
  void clear_shape_attributes();
  const ::valhalla::TripLeg_ShapeAttributes& shape_attributes() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_ShapeAttributes* release_shape_attributes();
  ::valhalla::TripLeg_ShapeAttributes* mutable_shape_attributes();
  void set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes);
  private:
  const ::valhalla::TripLeg_ShapeAttributes& _internal_shape_attributes() const;
  ::valhalla::TripLeg_ShapeAttributes* _internal_mutable_shape_attributes();
  public:
  void unsafe_arena_set_allocated_shape_attributes(
      ::valhalla::TripLeg_ShapeAttributes* shape_attributes);
  ::valhalla::TripLeg_ShapeAttributes* unsafe_arena_release_shape_attributes();

  // uint64 osm_changeset = 1;
  void clear_osm_changeset();
  uint64_t osm_changeset() const;
  void set_osm_changeset(uint64_t value);
  private:
  uint64_t _internal_osm_changeset() const;
  void _internal_set_osm_changeset(uint64_t value);
  public:

  // uint64 trip_id = 2;
  void clear_trip_id();
  uint64_t trip_id() const;
  void set_trip_id(uint64_t value);
  private:
  uint64_t _internal_trip_id() const;
  void _internal_set_trip_id(uint64_t value);
  public:

  // uint32 leg_id = 3;
  void clear_leg_id();
  uint32_t leg_id() const;
  void set_leg_id(uint32_t value);
  private:
  uint32_t _internal_leg_id() const;
  void _internal_set_leg_id(uint32_t value);
  public:

  // uint32 leg_count = 4;
  void clear_leg_count();
  uint32_t leg_count() const;
  void set_leg_count(uint32_t value);
  private:
  uint32_t _internal_leg_count() const;
  void _internal_set_leg_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > location_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node > node_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin > admin_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident > incidents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> algorithms_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure > closures_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_;
    ::valhalla::BoundingBox* bbox_;
    ::valhalla::TripLeg_ShapeAttributes* shape_attributes_;
    uint64_t osm_changeset_;
    uint64_t trip_id_;
    uint32_t leg_id_;
    uint32_t leg_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripRoute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripRoute) */ {
 public:
  inline TripRoute() : TripRoute(nullptr) {}
  ~TripRoute() override;
  explicit PROTOBUF_CONSTEXPR TripRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripRoute(const TripRoute& from);
  TripRoute(TripRoute&& from) noexcept
    : TripRoute() {
    *this = ::std::move(from);
  }

  inline TripRoute& operator=(const TripRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripRoute& operator=(TripRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripRoute* internal_default_instance() {
    return reinterpret_cast<const TripRoute*>(
               &_TripRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TripRoute& a, TripRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(TripRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripRoute& from);
  void MergeFrom(const TripRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripRoute";
  }
  protected:
  explicit TripRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.TripLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;
  public:
  void clear_legs();
  ::valhalla::TripLeg* mutable_legs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >*
      mutable_legs();
  private:
  const ::valhalla::TripLeg& _internal_legs(int index) const;
  ::valhalla::TripLeg* _internal_add_legs();
  public:
  const ::valhalla::TripLeg& legs(int index) const;
  ::valhalla::TripLeg* add_legs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.TripRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg > legs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class Trip final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Trip) */ {
 public:
  inline Trip() : Trip(nullptr) {}
  ~Trip() override;
  explicit PROTOBUF_CONSTEXPR Trip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trip(const Trip& from);
  Trip(Trip&& from) noexcept
    : Trip() {
    *this = ::std::move(from);
  }

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trip& operator=(Trip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Trip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trip* internal_default_instance() {
    return reinterpret_cast<const Trip*>(
               &_Trip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Trip& a, Trip& b) {
    a.Swap(&b);
  }
  inline void Swap(Trip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trip>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Trip& from);
  void MergeFrom(const Trip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Trip";
  }
  protected:
  explicit Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.TripRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::valhalla::TripRoute* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >*
      mutable_routes();
  private:
  const ::valhalla::TripRoute& _internal_routes(int index) const;
  ::valhalla::TripRoute* _internal_add_routes();
  public:
  const ::valhalla::TripRoute& routes(int index) const;
  ::valhalla::TripRoute* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Trip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute > routes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TripLeg_LaneConnectivity

// uint64 from_way_id = 1;
inline void TripLeg_LaneConnectivity::clear_from_way_id() {
  _impl_.from_way_id_ = uint64_t{0u};
}
inline uint64_t TripLeg_LaneConnectivity::_internal_from_way_id() const {
  return _impl_.from_way_id_;
}
inline uint64_t TripLeg_LaneConnectivity::from_way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_way_id)
  return _internal_from_way_id();
}
inline void TripLeg_LaneConnectivity::_internal_set_from_way_id(uint64_t value) {
  
  _impl_.from_way_id_ = value;
}
inline void TripLeg_LaneConnectivity::set_from_way_id(uint64_t value) {
  _internal_set_from_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_way_id)
}

// string from_lanes = 2;
inline void TripLeg_LaneConnectivity::clear_from_lanes() {
  _impl_.from_lanes_.ClearToEmpty();
}
inline const std::string& TripLeg_LaneConnectivity::from_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _internal_from_lanes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_LaneConnectivity::set_from_lanes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_lanes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
inline std::string* TripLeg_LaneConnectivity::mutable_from_lanes() {
  std::string* _s = _internal_mutable_from_lanes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _s;
}
inline const std::string& TripLeg_LaneConnectivity::_internal_from_lanes() const {
  return _impl_.from_lanes_.Get();
}
inline void TripLeg_LaneConnectivity::_internal_set_from_lanes(const std::string& value) {
  
  _impl_.from_lanes_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::_internal_mutable_from_lanes() {
  
  return _impl_.from_lanes_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::release_from_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _impl_.from_lanes_.Release();
}
inline void TripLeg_LaneConnectivity::set_allocated_from_lanes(std::string* from_lanes) {
  if (from_lanes != nullptr) {
    
  } else {
    
  }
  _impl_.from_lanes_.SetAllocated(from_lanes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_lanes_.IsDefault()) {
    _impl_.from_lanes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.from_lanes)
}

// string to_lanes = 3;
inline void TripLeg_LaneConnectivity::clear_to_lanes() {
  _impl_.to_lanes_.ClearToEmpty();
}
inline const std::string& TripLeg_LaneConnectivity::to_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _internal_to_lanes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_LaneConnectivity::set_to_lanes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_lanes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
inline std::string* TripLeg_LaneConnectivity::mutable_to_lanes() {
  std::string* _s = _internal_mutable_to_lanes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _s;
}
inline const std::string& TripLeg_LaneConnectivity::_internal_to_lanes() const {
  return _impl_.to_lanes_.Get();
}
inline void TripLeg_LaneConnectivity::_internal_set_to_lanes(const std::string& value) {
  
  _impl_.to_lanes_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::_internal_mutable_to_lanes() {
  
  return _impl_.to_lanes_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::release_to_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _impl_.to_lanes_.Release();
}
inline void TripLeg_LaneConnectivity::set_allocated_to_lanes(std::string* to_lanes) {
  if (to_lanes != nullptr) {
    
  } else {
    
  }
  _impl_.to_lanes_.SetAllocated(to_lanes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_lanes_.IsDefault()) {
    _impl_.to_lanes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.to_lanes)
}

// -------------------------------------------------------------------

// TripLeg_TrafficSegment

// uint64 segment_id = 1;
inline void TripLeg_TrafficSegment::clear_segment_id() {
  _impl_.segment_id_ = uint64_t{0u};
}
inline uint64_t TripLeg_TrafficSegment::_internal_segment_id() const {
  return _impl_.segment_id_;
}
inline uint64_t TripLeg_TrafficSegment::segment_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.segment_id)
  return _internal_segment_id();
}
inline void TripLeg_TrafficSegment::_internal_set_segment_id(uint64_t value) {
  
  _impl_.segment_id_ = value;
}
inline void TripLeg_TrafficSegment::set_segment_id(uint64_t value) {
  _internal_set_segment_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.segment_id)
}

// float begin_percent = 2;
inline void TripLeg_TrafficSegment::clear_begin_percent() {
  _impl_.begin_percent_ = 0;
}
inline float TripLeg_TrafficSegment::_internal_begin_percent() const {
  return _impl_.begin_percent_;
}
inline float TripLeg_TrafficSegment::begin_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.begin_percent)
  return _internal_begin_percent();
}
inline void TripLeg_TrafficSegment::_internal_set_begin_percent(float value) {
  
  _impl_.begin_percent_ = value;
}
inline void TripLeg_TrafficSegment::set_begin_percent(float value) {
  _internal_set_begin_percent(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.begin_percent)
}

// float end_percent = 3;
inline void TripLeg_TrafficSegment::clear_end_percent() {
  _impl_.end_percent_ = 0;
}
inline float TripLeg_TrafficSegment::_internal_end_percent() const {
  return _impl_.end_percent_;
}
inline float TripLeg_TrafficSegment::end_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.end_percent)
  return _internal_end_percent();
}
inline void TripLeg_TrafficSegment::_internal_set_end_percent(float value) {
  
  _impl_.end_percent_ = value;
}
inline void TripLeg_TrafficSegment::set_end_percent(float value) {
  _internal_set_end_percent(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.end_percent)
}

// bool starts_segment = 4;
inline void TripLeg_TrafficSegment::clear_starts_segment() {
  _impl_.starts_segment_ = false;
}
inline bool TripLeg_TrafficSegment::_internal_starts_segment() const {
  return _impl_.starts_segment_;
}
inline bool TripLeg_TrafficSegment::starts_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.starts_segment)
  return _internal_starts_segment();
}
inline void TripLeg_TrafficSegment::_internal_set_starts_segment(bool value) {
  
  _impl_.starts_segment_ = value;
}
inline void TripLeg_TrafficSegment::set_starts_segment(bool value) {
  _internal_set_starts_segment(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.starts_segment)
}

// bool ends_segment = 5;
inline void TripLeg_TrafficSegment::clear_ends_segment() {
  _impl_.ends_segment_ = false;
}
inline bool TripLeg_TrafficSegment::_internal_ends_segment() const {
  return _impl_.ends_segment_;
}
inline bool TripLeg_TrafficSegment::ends_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.ends_segment)
  return _internal_ends_segment();
}
inline void TripLeg_TrafficSegment::_internal_set_ends_segment(bool value) {
  
  _impl_.ends_segment_ = value;
}
inline void TripLeg_TrafficSegment::set_ends_segment(bool value) {
  _internal_set_ends_segment(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.ends_segment)
}

// -------------------------------------------------------------------

// TripLeg_Restriction

// uint32 type = 1;
inline void TripLeg_Restriction::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TripLeg_Restriction::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TripLeg_Restriction::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Restriction.type)
  return _internal_type();
}
inline void TripLeg_Restriction::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TripLeg_Restriction::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Restriction.type)
}

// -------------------------------------------------------------------

// TripLeg_Edge

// repeated .valhalla.StreetName name = 1;
inline int TripLeg_Edge::_internal_name_size() const {
  return _impl_.name_.size();
}
inline int TripLeg_Edge::name_size() const {
  return _internal_name_size();
}
inline ::valhalla::StreetName* TripLeg_Edge::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.name)
  return _impl_.name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
TripLeg_Edge::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.name)
  return &_impl_.name_;
}
inline const ::valhalla::StreetName& TripLeg_Edge::_internal_name(int index) const {
  return _impl_.name_.Get(index);
}
inline const ::valhalla::StreetName& TripLeg_Edge::name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.name)
  return _internal_name(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::_internal_add_name() {
  return _impl_.name_.Add();
}
inline ::valhalla::StreetName* TripLeg_Edge::add_name() {
  ::valhalla::StreetName* _add = _internal_add_name();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
TripLeg_Edge::name() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.name)
  return _impl_.name_;
}

// float length_km = 2;
inline void TripLeg_Edge::clear_length_km() {
  _impl_.length_km_ = 0;
}
inline float TripLeg_Edge::_internal_length_km() const {
  return _impl_.length_km_;
}
inline float TripLeg_Edge::length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.length_km)
  return _internal_length_km();
}
inline void TripLeg_Edge::_internal_set_length_km(float value) {
  
  _impl_.length_km_ = value;
}
inline void TripLeg_Edge::set_length_km(float value) {
  _internal_set_length_km(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.length_km)
}

// float speed = 3;
inline void TripLeg_Edge::clear_speed() {
  _impl_.speed_ = 0;
}
inline float TripLeg_Edge::_internal_speed() const {
  return _impl_.speed_;
}
inline float TripLeg_Edge::speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed)
  return _internal_speed();
}
inline void TripLeg_Edge::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void TripLeg_Edge::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed)
}

// .valhalla.RoadClass road_class = 4;
inline void TripLeg_Edge::clear_road_class() {
  _impl_.road_class_ = 0;
}
inline ::valhalla::RoadClass TripLeg_Edge::_internal_road_class() const {
  return static_cast< ::valhalla::RoadClass >(_impl_.road_class_);
}
inline ::valhalla::RoadClass TripLeg_Edge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.road_class)
  return _internal_road_class();
}
inline void TripLeg_Edge::_internal_set_road_class(::valhalla::RoadClass value) {
  
  _impl_.road_class_ = value;
}
inline void TripLeg_Edge::set_road_class(::valhalla::RoadClass value) {
  _internal_set_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.road_class)
}

// uint32 begin_heading = 5;
inline void TripLeg_Edge::clear_begin_heading() {
  _impl_.begin_heading_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_begin_heading() const {
  return _impl_.begin_heading_;
}
inline uint32_t TripLeg_Edge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_heading)
  return _internal_begin_heading();
}
inline void TripLeg_Edge::_internal_set_begin_heading(uint32_t value) {
  
  _impl_.begin_heading_ = value;
}
inline void TripLeg_Edge::set_begin_heading(uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_heading)
}

// uint32 end_heading = 6;
inline void TripLeg_Edge::clear_end_heading() {
  _impl_.end_heading_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_end_heading() const {
  return _impl_.end_heading_;
}
inline uint32_t TripLeg_Edge::end_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_heading)
  return _internal_end_heading();
}
inline void TripLeg_Edge::_internal_set_end_heading(uint32_t value) {
  
  _impl_.end_heading_ = value;
}
inline void TripLeg_Edge::set_end_heading(uint32_t value) {
  _internal_set_end_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_heading)
}

// uint32 begin_shape_index = 7;
inline void TripLeg_Edge::clear_begin_shape_index() {
  _impl_.begin_shape_index_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_begin_shape_index() const {
  return _impl_.begin_shape_index_;
}
inline uint32_t TripLeg_Edge::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Edge::_internal_set_begin_shape_index(uint32_t value) {
  
  _impl_.begin_shape_index_ = value;
}
inline void TripLeg_Edge::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_shape_index)
}

// uint32 end_shape_index = 8;
inline void TripLeg_Edge::clear_end_shape_index() {
  _impl_.end_shape_index_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_end_shape_index() const {
  return _impl_.end_shape_index_;
}
inline uint32_t TripLeg_Edge::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Edge::_internal_set_end_shape_index(uint32_t value) {
  
  _impl_.end_shape_index_ = value;
}
inline void TripLeg_Edge::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_shape_index)
}

// .valhalla.TripLeg.Traversability traversability = 9;
inline void TripLeg_Edge::clear_traversability() {
  _impl_.traversability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::_internal_traversability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.traversability_);
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::traversability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traversability)
  return _internal_traversability();
}
inline void TripLeg_Edge::_internal_set_traversability(::valhalla::TripLeg_Traversability value) {
  
  _impl_.traversability_ = value;
}
inline void TripLeg_Edge::set_traversability(::valhalla::TripLeg_Traversability value) {
  _internal_set_traversability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.traversability)
}

// .valhalla.TripLeg.Use use = 10;
inline void TripLeg_Edge::clear_use() {
  _impl_.use_ = 0;
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::_internal_use() const {
  return static_cast< ::valhalla::TripLeg_Use >(_impl_.use_);
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.use)
  return _internal_use();
}
inline void TripLeg_Edge::_internal_set_use(::valhalla::TripLeg_Use value) {
  
  _impl_.use_ = value;
}
inline void TripLeg_Edge::set_use(::valhalla::TripLeg_Use value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.use)
}

// bool toll = 11;
inline void TripLeg_Edge::clear_toll() {
  _impl_.toll_ = false;
}
inline bool TripLeg_Edge::_internal_toll() const {
  return _impl_.toll_;
}
inline bool TripLeg_Edge::toll() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.toll)
  return _internal_toll();
}
inline void TripLeg_Edge::_internal_set_toll(bool value) {
  
  _impl_.toll_ = value;
}
inline void TripLeg_Edge::set_toll(bool value) {
  _internal_set_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.toll)
}

// bool unpaved = 12;
inline void TripLeg_Edge::clear_unpaved() {
  _impl_.unpaved_ = false;
}
inline bool TripLeg_Edge::_internal_unpaved() const {
  return _impl_.unpaved_;
}
inline bool TripLeg_Edge::unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.unpaved)
  return _internal_unpaved();
}
inline void TripLeg_Edge::_internal_set_unpaved(bool value) {
  
  _impl_.unpaved_ = value;
}
inline void TripLeg_Edge::set_unpaved(bool value) {
  _internal_set_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.unpaved)
}

// bool tunnel = 13;
inline void TripLeg_Edge::clear_tunnel() {
  _impl_.tunnel_ = false;
}
inline bool TripLeg_Edge::_internal_tunnel() const {
  return _impl_.tunnel_;
}
inline bool TripLeg_Edge::tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tunnel)
  return _internal_tunnel();
}
inline void TripLeg_Edge::_internal_set_tunnel(bool value) {
  
  _impl_.tunnel_ = value;
}
inline void TripLeg_Edge::set_tunnel(bool value) {
  _internal_set_tunnel(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.tunnel)
}

// bool bridge = 14;
inline void TripLeg_Edge::clear_bridge() {
  _impl_.bridge_ = false;
}
inline bool TripLeg_Edge::_internal_bridge() const {
  return _impl_.bridge_;
}
inline bool TripLeg_Edge::bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bridge)
  return _internal_bridge();
}
inline void TripLeg_Edge::_internal_set_bridge(bool value) {
  
  _impl_.bridge_ = value;
}
inline void TripLeg_Edge::set_bridge(bool value) {
  _internal_set_bridge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bridge)
}

// bool roundabout = 15;
inline void TripLeg_Edge::clear_roundabout() {
  _impl_.roundabout_ = false;
}
inline bool TripLeg_Edge::_internal_roundabout() const {
  return _impl_.roundabout_;
}
inline bool TripLeg_Edge::roundabout() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.roundabout)
  return _internal_roundabout();
}
inline void TripLeg_Edge::_internal_set_roundabout(bool value) {
  
  _impl_.roundabout_ = value;
}
inline void TripLeg_Edge::set_roundabout(bool value) {
  _internal_set_roundabout(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.roundabout)
}

// bool internal_intersection = 16;
inline void TripLeg_Edge::clear_internal_intersection() {
  _impl_.internal_intersection_ = false;
}
inline bool TripLeg_Edge::_internal_internal_intersection() const {
  return _impl_.internal_intersection_;
}
inline bool TripLeg_Edge::internal_intersection() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.internal_intersection)
  return _internal_internal_intersection();
}
inline void TripLeg_Edge::_internal_set_internal_intersection(bool value) {
  
  _impl_.internal_intersection_ = value;
}
inline void TripLeg_Edge::set_internal_intersection(bool value) {
  _internal_set_internal_intersection(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.internal_intersection)
}

// bool drive_on_left = 17;
inline void TripLeg_Edge::clear_drive_on_left() {
  _impl_.drive_on_left_ = false;
}
inline bool TripLeg_Edge::_internal_drive_on_left() const {
  return _impl_.drive_on_left_;
}
inline bool TripLeg_Edge::drive_on_left() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.drive_on_left)
  return _internal_drive_on_left();
}
inline void TripLeg_Edge::_internal_set_drive_on_left(bool value) {
  
  _impl_.drive_on_left_ = value;
}
inline void TripLeg_Edge::set_drive_on_left(bool value) {
  _internal_set_drive_on_left(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.drive_on_left)
}

// .valhalla.TripLeg.Surface surface = 18;
inline void TripLeg_Edge::clear_surface() {
  _impl_.surface_ = 0;
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::_internal_surface() const {
  return static_cast< ::valhalla::TripLeg_Surface >(_impl_.surface_);
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::surface() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.surface)
  return _internal_surface();
}
inline void TripLeg_Edge::_internal_set_surface(::valhalla::TripLeg_Surface value) {
  
  _impl_.surface_ = value;
}
inline void TripLeg_Edge::set_surface(::valhalla::TripLeg_Surface value) {
  _internal_set_surface(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.surface)
}

// .valhalla.TripSign sign = 19;
inline bool TripLeg_Edge::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool TripLeg_Edge::has_sign() const {
  return _internal_has_sign();
}
inline const ::valhalla::TripSign& TripLeg_Edge::_internal_sign() const {
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(
      ::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& TripLeg_Edge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sign)
  return _internal_sign();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_sign(
    ::valhalla::TripSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.sign)
}
inline ::valhalla::TripSign* TripLeg_Edge::release_sign() {
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripSign* TripLeg_Edge::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.sign)
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* TripLeg_Edge::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* TripLeg_Edge::mutable_sign() {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.sign)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_sign(::valhalla::TripSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.sign)
}

// .valhalla.TravelMode travel_mode = 20;
inline void TripLeg_Edge::clear_travel_mode() {
  _impl_.travel_mode_ = 0;
}
inline ::valhalla::TravelMode TripLeg_Edge::_internal_travel_mode() const {
  return static_cast< ::valhalla::TravelMode >(_impl_.travel_mode_);
}
inline ::valhalla::TravelMode TripLeg_Edge::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.travel_mode)
  return _internal_travel_mode();
}
inline void TripLeg_Edge::_internal_set_travel_mode(::valhalla::TravelMode value) {
  
  _impl_.travel_mode_ = value;
}
inline void TripLeg_Edge::set_travel_mode(::valhalla::TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.travel_mode)
}

// .valhalla.VehicleType vehicle_type = 21;
inline void TripLeg_Edge::clear_vehicle_type() {
  _impl_.vehicle_type_ = 0;
}
inline ::valhalla::VehicleType TripLeg_Edge::_internal_vehicle_type() const {
  return static_cast< ::valhalla::VehicleType >(_impl_.vehicle_type_);
}
inline ::valhalla::VehicleType TripLeg_Edge::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.vehicle_type)
  return _internal_vehicle_type();
}
inline void TripLeg_Edge::_internal_set_vehicle_type(::valhalla::VehicleType value) {
  
  _impl_.vehicle_type_ = value;
}
inline void TripLeg_Edge::set_vehicle_type(::valhalla::VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.vehicle_type)
}

// .valhalla.PedestrianType pedestrian_type = 22;
inline void TripLeg_Edge::clear_pedestrian_type() {
  _impl_.pedestrian_type_ = 0;
}
inline ::valhalla::PedestrianType TripLeg_Edge::_internal_pedestrian_type() const {
  return static_cast< ::valhalla::PedestrianType >(_impl_.pedestrian_type_);
}
inline ::valhalla::PedestrianType TripLeg_Edge::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void TripLeg_Edge::_internal_set_pedestrian_type(::valhalla::PedestrianType value) {
  
  _impl_.pedestrian_type_ = value;
}
inline void TripLeg_Edge::set_pedestrian_type(::valhalla::PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.pedestrian_type)
}

// .valhalla.BicycleType bicycle_type = 23;
inline void TripLeg_Edge::clear_bicycle_type() {
  _impl_.bicycle_type_ = 0;
}
inline ::valhalla::BicycleType TripLeg_Edge::_internal_bicycle_type() const {
  return static_cast< ::valhalla::BicycleType >(_impl_.bicycle_type_);
}
inline ::valhalla::BicycleType TripLeg_Edge::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_type)
  return _internal_bicycle_type();
}
inline void TripLeg_Edge::_internal_set_bicycle_type(::valhalla::BicycleType value) {
  
  _impl_.bicycle_type_ = value;
}
inline void TripLeg_Edge::set_bicycle_type(::valhalla::BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_type)
}

// .valhalla.TransitType transit_type = 24;
inline void TripLeg_Edge::clear_transit_type() {
  _impl_.transit_type_ = 0;
}
inline ::valhalla::TransitType TripLeg_Edge::_internal_transit_type() const {
  return static_cast< ::valhalla::TransitType >(_impl_.transit_type_);
}
inline ::valhalla::TransitType TripLeg_Edge::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_type)
  return _internal_transit_type();
}
inline void TripLeg_Edge::_internal_set_transit_type(::valhalla::TransitType value) {
  
  _impl_.transit_type_ = value;
}
inline void TripLeg_Edge::set_transit_type(::valhalla::TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.transit_type)
}

// .valhalla.TransitRouteInfo transit_route_info = 25;
inline bool TripLeg_Edge::_internal_has_transit_route_info() const {
  return this != internal_default_instance() && _impl_.transit_route_info_ != nullptr;
}
inline bool TripLeg_Edge::has_transit_route_info() const {
  return _internal_has_transit_route_info();
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::_internal_transit_route_info() const {
  const ::valhalla::TransitRouteInfo* p = _impl_.transit_route_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitRouteInfo&>(
      ::valhalla::_TransitRouteInfo_default_instance_);
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::transit_route_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_route_info)
  return _internal_transit_route_info();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_transit_route_info(
    ::valhalla::TransitRouteInfo* transit_route_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_route_info_);
  }
  _impl_.transit_route_info_ = transit_route_info;
  if (transit_route_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::release_transit_route_info() {
  
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_route_info_;
  _impl_.transit_route_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::unsafe_arena_release_transit_route_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.transit_route_info)
  
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_route_info_;
  _impl_.transit_route_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::_internal_mutable_transit_route_info() {
  
  if (_impl_.transit_route_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitRouteInfo>(GetArenaForAllocation());
    _impl_.transit_route_info_ = p;
  }
  return _impl_.transit_route_info_;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::mutable_transit_route_info() {
  ::valhalla::TransitRouteInfo* _msg = _internal_mutable_transit_route_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.transit_route_info)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_route_info_);
  }
  if (transit_route_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_route_info));
    if (message_arena != submessage_arena) {
      transit_route_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_route_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_route_info_ = transit_route_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}

// uint64 id = 26;
inline void TripLeg_Edge::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t TripLeg_Edge::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t TripLeg_Edge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.id)
  return _internal_id();
}
inline void TripLeg_Edge::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void TripLeg_Edge::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.id)
}

// uint64 way_id = 27;
inline void TripLeg_Edge::clear_way_id() {
  _impl_.way_id_ = uint64_t{0u};
}
inline uint64_t TripLeg_Edge::_internal_way_id() const {
  return _impl_.way_id_;
}
inline uint64_t TripLeg_Edge::way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.way_id)
  return _internal_way_id();
}
inline void TripLeg_Edge::_internal_set_way_id(uint64_t value) {
  
  _impl_.way_id_ = value;
}
inline void TripLeg_Edge::set_way_id(uint64_t value) {
  _internal_set_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.way_id)
}

// float weighted_grade = 28;
inline void TripLeg_Edge::clear_weighted_grade() {
  _impl_.weighted_grade_ = 0;
}
inline float TripLeg_Edge::_internal_weighted_grade() const {
  return _impl_.weighted_grade_;
}
inline float TripLeg_Edge::weighted_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.weighted_grade)
  return _internal_weighted_grade();
}
inline void TripLeg_Edge::_internal_set_weighted_grade(float value) {
  
  _impl_.weighted_grade_ = value;
}
inline void TripLeg_Edge::set_weighted_grade(float value) {
  _internal_set_weighted_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.weighted_grade)
}

// int32 max_upward_grade = 29;
inline void TripLeg_Edge::clear_max_upward_grade() {
  _impl_.max_upward_grade_ = 0;
}
inline int32_t TripLeg_Edge::_internal_max_upward_grade() const {
  return _impl_.max_upward_grade_;
}
inline int32_t TripLeg_Edge::max_upward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_upward_grade)
  return _internal_max_upward_grade();
}
inline void TripLeg_Edge::_internal_set_max_upward_grade(int32_t value) {
  
  _impl_.max_upward_grade_ = value;
}
inline void TripLeg_Edge::set_max_upward_grade(int32_t value) {
  _internal_set_max_upward_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_upward_grade)
}

// int32 max_downward_grade = 30;
inline void TripLeg_Edge::clear_max_downward_grade() {
  _impl_.max_downward_grade_ = 0;
}
inline int32_t TripLeg_Edge::_internal_max_downward_grade() const {
  return _impl_.max_downward_grade_;
}
inline int32_t TripLeg_Edge::max_downward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_downward_grade)
  return _internal_max_downward_grade();
}
inline void TripLeg_Edge::_internal_set_max_downward_grade(int32_t value) {
  
  _impl_.max_downward_grade_ = value;
}
inline void TripLeg_Edge::set_max_downward_grade(int32_t value) {
  _internal_set_max_downward_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_downward_grade)
}

// uint32 lane_count = 31;
inline void TripLeg_Edge::clear_lane_count() {
  _impl_.lane_count_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_lane_count() const {
  return _impl_.lane_count_;
}
inline uint32_t TripLeg_Edge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_count)
  return _internal_lane_count();
}
inline void TripLeg_Edge::_internal_set_lane_count(uint32_t value) {
  
  _impl_.lane_count_ = value;
}
inline void TripLeg_Edge::set_lane_count(uint32_t value) {
  _internal_set_lane_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.lane_count)
}

// .valhalla.TripLeg.CycleLane cycle_lane = 32;
inline void TripLeg_Edge::clear_cycle_lane() {
  _impl_.cycle_lane_ = 0;
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::_internal_cycle_lane() const {
  return static_cast< ::valhalla::TripLeg_CycleLane >(_impl_.cycle_lane_);
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::cycle_lane() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.cycle_lane)
  return _internal_cycle_lane();
}
inline void TripLeg_Edge::_internal_set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  
  _impl_.cycle_lane_ = value;
}
inline void TripLeg_Edge::set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  _internal_set_cycle_lane(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.cycle_lane)
}

// bool bicycle_network = 33;
inline void TripLeg_Edge::clear_bicycle_network() {
  _impl_.bicycle_network_ = false;
}
inline bool TripLeg_Edge::_internal_bicycle_network() const {
  return _impl_.bicycle_network_;
}
inline bool TripLeg_Edge::bicycle_network() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_network)
  return _internal_bicycle_network();
}
inline void TripLeg_Edge::_internal_set_bicycle_network(bool value) {
  
  _impl_.bicycle_network_ = value;
}
inline void TripLeg_Edge::set_bicycle_network(bool value) {
  _internal_set_bicycle_network(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_network)
}

// .valhalla.TripLeg.Sidewalk sidewalk = 34;
inline void TripLeg_Edge::clear_sidewalk() {
  _impl_.sidewalk_ = 0;
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::_internal_sidewalk() const {
  return static_cast< ::valhalla::TripLeg_Sidewalk >(_impl_.sidewalk_);
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::sidewalk() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sidewalk)
  return _internal_sidewalk();
}
inline void TripLeg_Edge::_internal_set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  
  _impl_.sidewalk_ = value;
}
inline void TripLeg_Edge::set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  _internal_set_sidewalk(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sidewalk)
}

// uint32 density = 35;
inline void TripLeg_Edge::clear_density() {
  _impl_.density_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_density() const {
  return _impl_.density_;
}
inline uint32_t TripLeg_Edge::density() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.density)
  return _internal_density();
}
inline void TripLeg_Edge::_internal_set_density(uint32_t value) {
  
  _impl_.density_ = value;
}
inline void TripLeg_Edge::set_density(uint32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.density)
}

// uint32 speed_limit = 36;
inline void TripLeg_Edge::clear_speed_limit() {
  _impl_.speed_limit_ = 0u;
}
inline uint32_t TripLeg_Edge::_internal_speed_limit() const {
  return _impl_.speed_limit_;
}
inline uint32_t TripLeg_Edge::speed_limit() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed_limit)
  return _internal_speed_limit();
}
inline void TripLeg_Edge::_internal_set_speed_limit(uint32_t value) {
  
  _impl_.speed_limit_ = value;
}
inline void TripLeg_Edge::set_speed_limit(uint32_t value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed_limit)
}

// float truck_speed = 37;
inline void TripLeg_Edge::clear_truck_speed() {
  _impl_.truck_speed_ = 0;
}
inline float TripLeg_Edge::_internal_truck_speed() const {
  return _impl_.truck_speed_;
}
inline float TripLeg_Edge::truck_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_speed)
  return _internal_truck_speed();
}
inline void TripLeg_Edge::_internal_set_truck_speed(float value) {
  
  _impl_.truck_speed_ = value;
}
inline void TripLeg_Edge::set_truck_speed(float value) {
  _internal_set_truck_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_speed)
}

// bool truck_route = 38;
inline void TripLeg_Edge::clear_truck_route() {
  _impl_.truck_route_ = false;
}
inline bool TripLeg_Edge::_internal_truck_route() const {
  return _impl_.truck_route_;
}
inline bool TripLeg_Edge::truck_route() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_route)
  return _internal_truck_route();
}
inline void TripLeg_Edge::_internal_set_truck_route(bool value) {
  
  _impl_.truck_route_ = value;
}
inline void TripLeg_Edge::set_truck_route(bool value) {
  _internal_set_truck_route(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_route)
}

// repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
inline int TripLeg_Edge::_internal_lane_connectivity_size() const {
  return _impl_.lane_connectivity_.size();
}
inline int TripLeg_Edge::lane_connectivity_size() const {
  return _internal_lane_connectivity_size();
}
inline void TripLeg_Edge::clear_lane_connectivity() {
  _impl_.lane_connectivity_.Clear();
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::mutable_lane_connectivity(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.lane_connectivity)
  return _impl_.lane_connectivity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
TripLeg_Edge::mutable_lane_connectivity() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.lane_connectivity)
  return &_impl_.lane_connectivity_;
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::_internal_lane_connectivity(int index) const {
  return _impl_.lane_connectivity_.Get(index);
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::lane_connectivity(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_connectivity)
  return _internal_lane_connectivity(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::_internal_add_lane_connectivity() {
  return _impl_.lane_connectivity_.Add();
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::add_lane_connectivity() {
  ::valhalla::TripLeg_LaneConnectivity* _add = _internal_add_lane_connectivity();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.lane_connectivity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
TripLeg_Edge::lane_connectivity() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.lane_connectivity)
  return _impl_.lane_connectivity_;
}

// int32 mean_elevation = 40;
inline void TripLeg_Edge::clear_mean_elevation() {
  _impl_.mean_elevation_ = 0;
}
inline int32_t TripLeg_Edge::_internal_mean_elevation() const {
  return _impl_.mean_elevation_;
}
inline int32_t TripLeg_Edge::mean_elevation() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.mean_elevation)
  return _internal_mean_elevation();
}
inline void TripLeg_Edge::_internal_set_mean_elevation(int32_t value) {
  
  _impl_.mean_elevation_ = value;
}
inline void TripLeg_Edge::set_mean_elevation(int32_t value) {
  _internal_set_mean_elevation(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.mean_elevation)
}

// repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
inline int TripLeg_Edge::_internal_traffic_segment_size() const {
  return _impl_.traffic_segment_.size();
}
inline int TripLeg_Edge::traffic_segment_size() const {
  return _internal_traffic_segment_size();
}
inline void TripLeg_Edge::clear_traffic_segment() {
  _impl_.traffic_segment_.Clear();
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::mutable_traffic_segment(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.traffic_segment)
  return _impl_.traffic_segment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
TripLeg_Edge::mutable_traffic_segment() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.traffic_segment)
  return &_impl_.traffic_segment_;
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::_internal_traffic_segment(int index) const {
  return _impl_.traffic_segment_.Get(index);
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::traffic_segment(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traffic_segment)
  return _internal_traffic_segment(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::_internal_add_traffic_segment() {
  return _impl_.traffic_segment_.Add();
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::add_traffic_segment() {
  ::valhalla::TripLeg_TrafficSegment* _add = _internal_add_traffic_segment();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.traffic_segment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
TripLeg_Edge::traffic_segment() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.traffic_segment)
  return _impl_.traffic_segment_;
}

// repeated .valhalla.TurnLane turn_lanes = 42;
inline int TripLeg_Edge::_internal_turn_lanes_size() const {
  return _impl_.turn_lanes_.size();
}
inline int TripLeg_Edge::turn_lanes_size() const {
  return _internal_turn_lanes_size();
}
inline ::valhalla::TurnLane* TripLeg_Edge::mutable_turn_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.turn_lanes)
  return _impl_.turn_lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >*
TripLeg_Edge::mutable_turn_lanes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.turn_lanes)
  return &_impl_.turn_lanes_;
}
inline const ::valhalla::TurnLane& TripLeg_Edge::_internal_turn_lanes(int index) const {
  return _impl_.turn_lanes_.Get(index);
}
inline const ::valhalla::TurnLane& TripLeg_Edge::turn_lanes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.turn_lanes)
  return _internal_turn_lanes(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::_internal_add_turn_lanes() {
  return _impl_.turn_lanes_.Add();
}
inline ::valhalla::TurnLane* TripLeg_Edge::add_turn_lanes() {
  ::valhalla::TurnLane* _add = _internal_add_turn_lanes();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.turn_lanes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >&
TripLeg_Edge::turn_lanes() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.turn_lanes)
  return _impl_.turn_lanes_;
}

// bool has_time_restrictions = 43;
inline void TripLeg_Edge::clear_has_time_restrictions() {
  _impl_.has_time_restrictions_ = false;
}
inline bool TripLeg_Edge::_internal_has_time_restrictions() const {
  return _impl_.has_time_restrictions_;
}
inline bool TripLeg_Edge::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void TripLeg_Edge::_internal_set_has_time_restrictions(bool value) {
  
  _impl_.has_time_restrictions_ = value;
}
inline void TripLeg_Edge::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.has_time_restrictions)
}

// float default_speed = 44;
inline void TripLeg_Edge::clear_default_speed() {
  _impl_.default_speed_ = 0;
}
inline float TripLeg_Edge::_internal_default_speed() const {
  return _impl_.default_speed_;
}
inline float TripLeg_Edge::default_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.default_speed)
  return _internal_default_speed();
}
inline void TripLeg_Edge::_internal_set_default_speed(float value) {
  
  _impl_.default_speed_ = value;
}
inline void TripLeg_Edge::set_default_speed(float value) {
  _internal_set_default_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.default_speed)
}

// .valhalla.TripLeg.Restriction restriction = 45;
inline bool TripLeg_Edge::_internal_has_restriction() const {
  return this != internal_default_instance() && _impl_.restriction_ != nullptr;
}
inline bool TripLeg_Edge::has_restriction() const {
  return _internal_has_restriction();
}
inline void TripLeg_Edge::clear_restriction() {
  if (GetArenaForAllocation() == nullptr && _impl_.restriction_ != nullptr) {
    delete _impl_.restriction_;
  }
  _impl_.restriction_ = nullptr;
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::_internal_restriction() const {
  const ::valhalla::TripLeg_Restriction* p = _impl_.restriction_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Restriction&>(
      ::valhalla::_TripLeg_Restriction_default_instance_);
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::restriction() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.restriction)
  return _internal_restriction();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_restriction(
    ::valhalla::TripLeg_Restriction* restriction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.restriction_);
  }
  _impl_.restriction_ = restriction;
  if (restriction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.restriction)
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::release_restriction() {
  
  ::valhalla::TripLeg_Restriction* temp = _impl_.restriction_;
  _impl_.restriction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::unsafe_arena_release_restriction() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.restriction)
  
  ::valhalla::TripLeg_Restriction* temp = _impl_.restriction_;
  _impl_.restriction_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::_internal_mutable_restriction() {
  
  if (_impl_.restriction_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Restriction>(GetArenaForAllocation());
    _impl_.restriction_ = p;
  }
  return _impl_.restriction_;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::mutable_restriction() {
  ::valhalla::TripLeg_Restriction* _msg = _internal_mutable_restriction();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.restriction)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.restriction_;
  }
  if (restriction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(restriction);
    if (message_arena != submessage_arena) {
      restriction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restriction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.restriction_ = restriction;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.restriction)
}

// bool destination_only = 46;
inline void TripLeg_Edge::clear_destination_only() {
  _impl_.destination_only_ = false;
}
inline bool TripLeg_Edge::_internal_destination_only() const {
  return _impl_.destination_only_;
}
inline bool TripLeg_Edge::destination_only() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.destination_only)
  return _internal_destination_only();
}
inline void TripLeg_Edge::_internal_set_destination_only(bool value) {
  
  _impl_.destination_only_ = value;
}
inline void TripLeg_Edge::set_destination_only(bool value) {
  _internal_set_destination_only(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.destination_only)
}

// bool is_urban = 47;
inline void TripLeg_Edge::clear_is_urban() {
  _impl_.is_urban_ = false;
}
inline bool TripLeg_Edge::_internal_is_urban() const {
  return _impl_.is_urban_;
}
inline bool TripLeg_Edge::is_urban() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.is_urban)
  return _internal_is_urban();
}
inline void TripLeg_Edge::_internal_set_is_urban(bool value) {
  
  _impl_.is_urban_ = value;
}
inline void TripLeg_Edge::set_is_urban(bool value) {
  _internal_set_is_urban(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.is_urban)
}

// repeated .valhalla.TaggedValue tagged_value = 48;
inline int TripLeg_Edge::_internal_tagged_value_size() const {
  return _impl_.tagged_value_.size();
}
inline int TripLeg_Edge::tagged_value_size() const {
  return _internal_tagged_value_size();
}
inline ::valhalla::TaggedValue* TripLeg_Edge::mutable_tagged_value(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.tagged_value)
  return _impl_.tagged_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >*
TripLeg_Edge::mutable_tagged_value() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.tagged_value)
  return &_impl_.tagged_value_;
}
inline const ::valhalla::TaggedValue& TripLeg_Edge::_internal_tagged_value(int index) const {
  return _impl_.tagged_value_.Get(index);
}
inline const ::valhalla::TaggedValue& TripLeg_Edge::tagged_value(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tagged_value)
  return _internal_tagged_value(index);
}
inline ::valhalla::TaggedValue* TripLeg_Edge::_internal_add_tagged_value() {
  return _impl_.tagged_value_.Add();
}
inline ::valhalla::TaggedValue* TripLeg_Edge::add_tagged_value() {
  ::valhalla::TaggedValue* _add = _internal_add_tagged_value();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.tagged_value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >&
TripLeg_Edge::tagged_value() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.tagged_value)
  return _impl_.tagged_value_;
}

// float source_along_edge = 49;
inline void TripLeg_Edge::clear_source_along_edge() {
  _impl_.source_along_edge_ = 0;
}
inline float TripLeg_Edge::_internal_source_along_edge() const {
  return _impl_.source_along_edge_;
}
inline float TripLeg_Edge::source_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.source_along_edge)
  return _internal_source_along_edge();
}
inline void TripLeg_Edge::_internal_set_source_along_edge(float value) {
  
  _impl_.source_along_edge_ = value;
}
inline void TripLeg_Edge::set_source_along_edge(float value) {
  _internal_set_source_along_edge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.source_along_edge)
}

// float target_along_edge = 50;
inline void TripLeg_Edge::clear_target_along_edge() {
  _impl_.target_along_edge_ = 0;
}
inline float TripLeg_Edge::_internal_target_along_edge() const {
  return _impl_.target_along_edge_;
}
inline float TripLeg_Edge::target_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.target_along_edge)
  return _internal_target_along_edge();
}
inline void TripLeg_Edge::_internal_set_target_along_edge(float value) {
  
  _impl_.target_along_edge_ = value;
}
inline void TripLeg_Edge::set_target_along_edge(float value) {
  _internal_set_target_along_edge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.target_along_edge)
}

// .valhalla.TripLeg.SacScale sac_scale = 51;
inline void TripLeg_Edge::clear_sac_scale() {
  _impl_.sac_scale_ = 0;
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::_internal_sac_scale() const {
  return static_cast< ::valhalla::TripLeg_SacScale >(_impl_.sac_scale_);
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::sac_scale() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sac_scale)
  return _internal_sac_scale();
}
inline void TripLeg_Edge::_internal_set_sac_scale(::valhalla::TripLeg_SacScale value) {
  
  _impl_.sac_scale_ = value;
}
inline void TripLeg_Edge::set_sac_scale(::valhalla::TripLeg_SacScale value) {
  _internal_set_sac_scale(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sac_scale)
}

// bool shoulder = 52;
inline void TripLeg_Edge::clear_shoulder() {
  _impl_.shoulder_ = false;
}
inline bool TripLeg_Edge::_internal_shoulder() const {
  return _impl_.shoulder_;
}
inline bool TripLeg_Edge::shoulder() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.shoulder)
  return _internal_shoulder();
}
inline void TripLeg_Edge::_internal_set_shoulder(bool value) {
  
  _impl_.shoulder_ = value;
}
inline void TripLeg_Edge::set_shoulder(bool value) {
  _internal_set_shoulder(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.shoulder)
}

// bool indoor = 53;
inline void TripLeg_Edge::clear_indoor() {
  _impl_.indoor_ = false;
}
inline bool TripLeg_Edge::_internal_indoor() const {
  return _impl_.indoor_;
}
inline bool TripLeg_Edge::indoor() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.indoor)
  return _internal_indoor();
}
inline void TripLeg_Edge::_internal_set_indoor(bool value) {
  
  _impl_.indoor_ = value;
}
inline void TripLeg_Edge::set_indoor(bool value) {
  _internal_set_indoor(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.indoor)
}

// -------------------------------------------------------------------

// TripLeg_IntersectingEdge

// uint32 begin_heading = 1;
inline void TripLeg_IntersectingEdge::clear_begin_heading() {
  _impl_.begin_heading_ = 0u;
}
inline uint32_t TripLeg_IntersectingEdge::_internal_begin_heading() const {
  return _impl_.begin_heading_;
}
inline uint32_t TripLeg_IntersectingEdge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.begin_heading)
  return _internal_begin_heading();
}
inline void TripLeg_IntersectingEdge::_internal_set_begin_heading(uint32_t value) {
  
  _impl_.begin_heading_ = value;
}
inline void TripLeg_IntersectingEdge::set_begin_heading(uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.begin_heading)
}

// bool prev_name_consistency = 2;
inline void TripLeg_IntersectingEdge::clear_prev_name_consistency() {
  _impl_.prev_name_consistency_ = false;
}
inline bool TripLeg_IntersectingEdge::_internal_prev_name_consistency() const {
  return _impl_.prev_name_consistency_;
}
inline bool TripLeg_IntersectingEdge::prev_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
  return _internal_prev_name_consistency();
}
inline void TripLeg_IntersectingEdge::_internal_set_prev_name_consistency(bool value) {
  
  _impl_.prev_name_consistency_ = value;
}
inline void TripLeg_IntersectingEdge::set_prev_name_consistency(bool value) {
  _internal_set_prev_name_consistency(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
}

// bool curr_name_consistency = 3;
inline void TripLeg_IntersectingEdge::clear_curr_name_consistency() {
  _impl_.curr_name_consistency_ = false;
}
inline bool TripLeg_IntersectingEdge::_internal_curr_name_consistency() const {
  return _impl_.curr_name_consistency_;
}
inline bool TripLeg_IntersectingEdge::curr_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
  return _internal_curr_name_consistency();
}
inline void TripLeg_IntersectingEdge::_internal_set_curr_name_consistency(bool value) {
  
  _impl_.curr_name_consistency_ = value;
}
inline void TripLeg_IntersectingEdge::set_curr_name_consistency(bool value) {
  _internal_set_curr_name_consistency(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
}

// .valhalla.TripLeg.Traversability driveability = 4;
inline void TripLeg_IntersectingEdge::clear_driveability() {
  _impl_.driveability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_driveability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.driveability_);
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::driveability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.driveability)
  return _internal_driveability();
}
inline void TripLeg_IntersectingEdge::_internal_set_driveability(::valhalla::TripLeg_Traversability value) {
  
  _impl_.driveability_ = value;
}
inline void TripLeg_IntersectingEdge::set_driveability(::valhalla::TripLeg_Traversability value) {
  _internal_set_driveability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.driveability)
}

// .valhalla.TripLeg.Traversability cyclability = 5;
inline void TripLeg_IntersectingEdge::clear_cyclability() {
  _impl_.cyclability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_cyclability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.cyclability_);
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::cyclability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.cyclability)
  return _internal_cyclability();
}
inline void TripLeg_IntersectingEdge::_internal_set_cyclability(::valhalla::TripLeg_Traversability value) {
  
  _impl_.cyclability_ = value;
}
inline void TripLeg_IntersectingEdge::set_cyclability(::valhalla::TripLeg_Traversability value) {
  _internal_set_cyclability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.cyclability)
}

// .valhalla.TripLeg.Traversability walkability = 6;
inline void TripLeg_IntersectingEdge::clear_walkability() {
  _impl_.walkability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_walkability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.walkability_);
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::walkability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.walkability)
  return _internal_walkability();
}
inline void TripLeg_IntersectingEdge::_internal_set_walkability(::valhalla::TripLeg_Traversability value) {
  
  _impl_.walkability_ = value;
}
inline void TripLeg_IntersectingEdge::set_walkability(::valhalla::TripLeg_Traversability value) {
  _internal_set_walkability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.walkability)
}

// .valhalla.TripLeg.Use use = 7;
inline void TripLeg_IntersectingEdge::clear_use() {
  _impl_.use_ = 0;
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::_internal_use() const {
  return static_cast< ::valhalla::TripLeg_Use >(_impl_.use_);
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.use)
  return _internal_use();
}
inline void TripLeg_IntersectingEdge::_internal_set_use(::valhalla::TripLeg_Use value) {
  
  _impl_.use_ = value;
}
inline void TripLeg_IntersectingEdge::set_use(::valhalla::TripLeg_Use value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.use)
}

// .valhalla.RoadClass road_class = 8;
inline void TripLeg_IntersectingEdge::clear_road_class() {
  _impl_.road_class_ = 0;
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::_internal_road_class() const {
  return static_cast< ::valhalla::RoadClass >(_impl_.road_class_);
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.road_class)
  return _internal_road_class();
}
inline void TripLeg_IntersectingEdge::_internal_set_road_class(::valhalla::RoadClass value) {
  
  _impl_.road_class_ = value;
}
inline void TripLeg_IntersectingEdge::set_road_class(::valhalla::RoadClass value) {
  _internal_set_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.road_class)
}

// uint32 lane_count = 9;
inline void TripLeg_IntersectingEdge::clear_lane_count() {
  _impl_.lane_count_ = 0u;
}
inline uint32_t TripLeg_IntersectingEdge::_internal_lane_count() const {
  return _impl_.lane_count_;
}
inline uint32_t TripLeg_IntersectingEdge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.lane_count)
  return _internal_lane_count();
}
inline void TripLeg_IntersectingEdge::_internal_set_lane_count(uint32_t value) {
  
  _impl_.lane_count_ = value;
}
inline void TripLeg_IntersectingEdge::set_lane_count(uint32_t value) {
  _internal_set_lane_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.lane_count)
}

// .valhalla.TripSign sign = 10;
inline bool TripLeg_IntersectingEdge::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool TripLeg_IntersectingEdge::has_sign() const {
  return _internal_has_sign();
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::_internal_sign() const {
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(
      ::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.sign)
  return _internal_sign();
}
inline void TripLeg_IntersectingEdge::unsafe_arena_set_allocated_sign(
    ::valhalla::TripSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::release_sign() {
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.IntersectingEdge.sign)
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::mutable_sign() {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.IntersectingEdge.sign)
  return _msg;
}
inline void TripLeg_IntersectingEdge::set_allocated_sign(::valhalla::TripSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}

// -------------------------------------------------------------------

// TripLeg_Cost

// double seconds = 1;
inline void TripLeg_Cost::clear_seconds() {
  _impl_.seconds_ = 0;
}
inline double TripLeg_Cost::_internal_seconds() const {
  return _impl_.seconds_;
}
inline double TripLeg_Cost::seconds() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.seconds)
  return _internal_seconds();
}
inline void TripLeg_Cost::_internal_set_seconds(double value) {
  
  _impl_.seconds_ = value;
}
inline void TripLeg_Cost::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.seconds)
}

// double cost = 2;
inline void TripLeg_Cost::clear_cost() {
  _impl_.cost_ = 0;
}
inline double TripLeg_Cost::_internal_cost() const {
  return _impl_.cost_;
}
inline double TripLeg_Cost::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.cost)
  return _internal_cost();
}
inline void TripLeg_Cost::_internal_set_cost(double value) {
  
  _impl_.cost_ = value;
}
inline void TripLeg_Cost::set_cost(double value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.cost)
}

// -------------------------------------------------------------------

// TripLeg_PathCost

// .valhalla.TripLeg.Cost elapsed_cost = 1;
inline bool TripLeg_PathCost::_internal_has_elapsed_cost() const {
  return this != internal_default_instance() && _impl_.elapsed_cost_ != nullptr;
}
inline bool TripLeg_PathCost::has_elapsed_cost() const {
  return _internal_has_elapsed_cost();
}
inline void TripLeg_PathCost::clear_elapsed_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.elapsed_cost_ != nullptr) {
    delete _impl_.elapsed_cost_;
  }
  _impl_.elapsed_cost_ = nullptr;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_internal_elapsed_cost() const {
  const ::valhalla::TripLeg_Cost* p = _impl_.elapsed_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Cost&>(
      ::valhalla::_TripLeg_Cost_default_instance_);
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::elapsed_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.elapsed_cost)
  return _internal_elapsed_cost();
}
inline void TripLeg_PathCost::unsafe_arena_set_allocated_elapsed_cost(
    ::valhalla::TripLeg_Cost* elapsed_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elapsed_cost_);
  }
  _impl_.elapsed_cost_ = elapsed_cost;
  if (elapsed_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_elapsed_cost() {
  
  ::valhalla::TripLeg_Cost* temp = _impl_.elapsed_cost_;
  _impl_.elapsed_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::unsafe_arena_release_elapsed_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.elapsed_cost)
  
  ::valhalla::TripLeg_Cost* temp = _impl_.elapsed_cost_;
  _impl_.elapsed_cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::_internal_mutable_elapsed_cost() {
  
  if (_impl_.elapsed_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Cost>(GetArenaForAllocation());
    _impl_.elapsed_cost_ = p;
  }
  return _impl_.elapsed_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_elapsed_cost() {
  ::valhalla::TripLeg_Cost* _msg = _internal_mutable_elapsed_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.elapsed_cost)
  return _msg;
}
inline void TripLeg_PathCost::set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.elapsed_cost_;
  }
  if (elapsed_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(elapsed_cost);
    if (message_arena != submessage_arena) {
      elapsed_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, elapsed_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.elapsed_cost_ = elapsed_cost;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}

// .valhalla.TripLeg.Cost transition_cost = 2;
inline bool TripLeg_PathCost::_internal_has_transition_cost() const {
  return this != internal_default_instance() && _impl_.transition_cost_ != nullptr;
}
inline bool TripLeg_PathCost::has_transition_cost() const {
  return _internal_has_transition_cost();
}
inline void TripLeg_PathCost::clear_transition_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.transition_cost_ != nullptr) {
    delete _impl_.transition_cost_;
  }
  _impl_.transition_cost_ = nullptr;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_internal_transition_cost() const {
  const ::valhalla::TripLeg_Cost* p = _impl_.transition_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Cost&>(
      ::valhalla::_TripLeg_Cost_default_instance_);
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::transition_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.transition_cost)
  return _internal_transition_cost();
}
inline void TripLeg_PathCost::unsafe_arena_set_allocated_transition_cost(
    ::valhalla::TripLeg_Cost* transition_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transition_cost_);
  }
  _impl_.transition_cost_ = transition_cost;
  if (transition_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_transition_cost() {
  
  ::valhalla::TripLeg_Cost* temp = _impl_.transition_cost_;
  _impl_.transition_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::unsafe_arena_release_transition_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.transition_cost)
  
  ::valhalla::TripLeg_Cost* temp = _impl_.transition_cost_;
  _impl_.transition_cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::_internal_mutable_transition_cost() {
  
  if (_impl_.transition_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Cost>(GetArenaForAllocation());
    _impl_.transition_cost_ = p;
  }
  return _impl_.transition_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_transition_cost() {
  ::valhalla::TripLeg_Cost* _msg = _internal_mutable_transition_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.transition_cost)
  return _msg;
}
inline void TripLeg_PathCost::set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transition_cost_;
  }
  if (transition_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transition_cost);
    if (message_arena != submessage_arena) {
      transition_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transition_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transition_cost_ = transition_cost;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}

// -------------------------------------------------------------------

// TripLeg_Node

// .valhalla.TripLeg.Edge edge = 1;
inline bool TripLeg_Node::_internal_has_edge() const {
  return this != internal_default_instance() && _impl_.edge_ != nullptr;
}
inline bool TripLeg_Node::has_edge() const {
  return _internal_has_edge();
}
inline void TripLeg_Node::clear_edge() {
  if (GetArenaForAllocation() == nullptr && _impl_.edge_ != nullptr) {
    delete _impl_.edge_;
  }
  _impl_.edge_ = nullptr;
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::_internal_edge() const {
  const ::valhalla::TripLeg_Edge* p = _impl_.edge_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Edge&>(
      ::valhalla::_TripLeg_Edge_default_instance_);
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.edge)
  return _internal_edge();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_edge(
    ::valhalla::TripLeg_Edge* edge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.edge_);
  }
  _impl_.edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.edge)
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::release_edge() {
  
  ::valhalla::TripLeg_Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::unsafe_arena_release_edge() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.edge)
  
  ::valhalla::TripLeg_Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::_internal_mutable_edge() {
  
  if (_impl_.edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Edge>(GetArenaForAllocation());
    _impl_.edge_ = p;
  }
  return _impl_.edge_;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::mutable_edge() {
  ::valhalla::TripLeg_Edge* _msg = _internal_mutable_edge();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.edge)
  return _msg;
}
inline void TripLeg_Node::set_allocated_edge(::valhalla::TripLeg_Edge* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.edge_;
  }
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.edge_ = edge;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.edge)
}

// repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
inline int TripLeg_Node::_internal_intersecting_edge_size() const {
  return _impl_.intersecting_edge_.size();
}
inline int TripLeg_Node::intersecting_edge_size() const {
  return _internal_intersecting_edge_size();
}
inline void TripLeg_Node::clear_intersecting_edge() {
  _impl_.intersecting_edge_.Clear();
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::mutable_intersecting_edge(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.intersecting_edge)
  return _impl_.intersecting_edge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
TripLeg_Node::mutable_intersecting_edge() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.intersecting_edge)
  return &_impl_.intersecting_edge_;
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::_internal_intersecting_edge(int index) const {
  return _impl_.intersecting_edge_.Get(index);
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::intersecting_edge(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.intersecting_edge)
  return _internal_intersecting_edge(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::_internal_add_intersecting_edge() {
  return _impl_.intersecting_edge_.Add();
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::add_intersecting_edge() {
  ::valhalla::TripLeg_IntersectingEdge* _add = _internal_add_intersecting_edge();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.intersecting_edge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
TripLeg_Node::intersecting_edge() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.intersecting_edge)
  return _impl_.intersecting_edge_;
}

// uint32 admin_index = 3;
inline void TripLeg_Node::clear_admin_index() {
  _impl_.admin_index_ = 0u;
}
inline uint32_t TripLeg_Node::_internal_admin_index() const {
  return _impl_.admin_index_;
}
inline uint32_t TripLeg_Node::admin_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.admin_index)
  return _internal_admin_index();
}
inline void TripLeg_Node::_internal_set_admin_index(uint32_t value) {
  
  _impl_.admin_index_ = value;
}
inline void TripLeg_Node::set_admin_index(uint32_t value) {
  _internal_set_admin_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.admin_index)
}

// .valhalla.TripLeg.Node.Type type = 4;
inline void TripLeg_Node::clear_type() {
  _impl_.type_ = 0;
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::_internal_type() const {
  return static_cast< ::valhalla::TripLeg_Node_Type >(_impl_.type_);
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.type)
  return _internal_type();
}
inline void TripLeg_Node::_internal_set_type(::valhalla::TripLeg_Node_Type value) {
  
  _impl_.type_ = value;
}
inline void TripLeg_Node::set_type(::valhalla::TripLeg_Node_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.type)
}

// bool fork = 5;
inline void TripLeg_Node::clear_fork() {
  _impl_.fork_ = false;
}
inline bool TripLeg_Node::_internal_fork() const {
  return _impl_.fork_;
}
inline bool TripLeg_Node::fork() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.fork)
  return _internal_fork();
}
inline void TripLeg_Node::_internal_set_fork(bool value) {
  
  _impl_.fork_ = value;
}
inline void TripLeg_Node::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.fork)
}

// .valhalla.TransitPlatformInfo transit_platform_info = 6;
inline bool TripLeg_Node::_internal_has_transit_platform_info() const {
  return this != internal_default_instance() && _impl_.transit_platform_info_ != nullptr;
}
inline bool TripLeg_Node::has_transit_platform_info() const {
  return _internal_has_transit_platform_info();
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::_internal_transit_platform_info() const {
  const ::valhalla::TransitPlatformInfo* p = _impl_.transit_platform_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitPlatformInfo&>(
      ::valhalla::_TransitPlatformInfo_default_instance_);
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::transit_platform_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_platform_info)
  return _internal_transit_platform_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_platform_info(
    ::valhalla::TransitPlatformInfo* transit_platform_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_platform_info_);
  }
  _impl_.transit_platform_info_ = transit_platform_info;
  if (transit_platform_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::release_transit_platform_info() {
  
  ::valhalla::TransitPlatformInfo* temp = _impl_.transit_platform_info_;
  _impl_.transit_platform_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::unsafe_arena_release_transit_platform_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_platform_info)
  
  ::valhalla::TransitPlatformInfo* temp = _impl_.transit_platform_info_;
  _impl_.transit_platform_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::_internal_mutable_transit_platform_info() {
  
  if (_impl_.transit_platform_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitPlatformInfo>(GetArenaForAllocation());
    _impl_.transit_platform_info_ = p;
  }
  return _impl_.transit_platform_info_;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::mutable_transit_platform_info() {
  ::valhalla::TransitPlatformInfo* _msg = _internal_mutable_transit_platform_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_platform_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_platform_info_);
  }
  if (transit_platform_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_platform_info));
    if (message_arena != submessage_arena) {
      transit_platform_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_platform_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_platform_info_ = transit_platform_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}

// .valhalla.TransitStationInfo transit_station_info = 7;
inline bool TripLeg_Node::_internal_has_transit_station_info() const {
  return this != internal_default_instance() && _impl_.transit_station_info_ != nullptr;
}
inline bool TripLeg_Node::has_transit_station_info() const {
  return _internal_has_transit_station_info();
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::_internal_transit_station_info() const {
  const ::valhalla::TransitStationInfo* p = _impl_.transit_station_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitStationInfo&>(
      ::valhalla::_TransitStationInfo_default_instance_);
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::transit_station_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_station_info)
  return _internal_transit_station_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_station_info(
    ::valhalla::TransitStationInfo* transit_station_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_station_info_);
  }
  _impl_.transit_station_info_ = transit_station_info;
  if (transit_station_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::release_transit_station_info() {
  
  ::valhalla::TransitStationInfo* temp = _impl_.transit_station_info_;
  _impl_.transit_station_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::unsafe_arena_release_transit_station_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_station_info)
  
  ::valhalla::TransitStationInfo* temp = _impl_.transit_station_info_;
  _impl_.transit_station_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::_internal_mutable_transit_station_info() {
  
  if (_impl_.transit_station_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitStationInfo>(GetArenaForAllocation());
    _impl_.transit_station_info_ = p;
  }
  return _impl_.transit_station_info_;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::mutable_transit_station_info() {
  ::valhalla::TransitStationInfo* _msg = _internal_mutable_transit_station_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_station_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_station_info_);
  }
  if (transit_station_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_station_info));
    if (message_arena != submessage_arena) {
      transit_station_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_station_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_station_info_ = transit_station_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}

// .valhalla.TransitEgressInfo transit_egress_info = 10;
inline bool TripLeg_Node::_internal_has_transit_egress_info() const {
  return this != internal_default_instance() && _impl_.transit_egress_info_ != nullptr;
}
inline bool TripLeg_Node::has_transit_egress_info() const {
  return _internal_has_transit_egress_info();
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::_internal_transit_egress_info() const {
  const ::valhalla::TransitEgressInfo* p = _impl_.transit_egress_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitEgressInfo&>(
      ::valhalla::_TransitEgressInfo_default_instance_);
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::transit_egress_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_egress_info)
  return _internal_transit_egress_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_egress_info(
    ::valhalla::TransitEgressInfo* transit_egress_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_egress_info_);
  }
  _impl_.transit_egress_info_ = transit_egress_info;
  if (transit_egress_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::release_transit_egress_info() {
  
  ::valhalla::TransitEgressInfo* temp = _impl_.transit_egress_info_;
  _impl_.transit_egress_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::unsafe_arena_release_transit_egress_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_egress_info)
  
  ::valhalla::TransitEgressInfo* temp = _impl_.transit_egress_info_;
  _impl_.transit_egress_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::_internal_mutable_transit_egress_info() {
  
  if (_impl_.transit_egress_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitEgressInfo>(GetArenaForAllocation());
    _impl_.transit_egress_info_ = p;
  }
  return _impl_.transit_egress_info_;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::mutable_transit_egress_info() {
  ::valhalla::TransitEgressInfo* _msg = _internal_mutable_transit_egress_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_egress_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_egress_info_);
  }
  if (transit_egress_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_egress_info));
    if (message_arena != submessage_arena) {
      transit_egress_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_egress_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_egress_info_ = transit_egress_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}

// string time_zone = 11;
inline void TripLeg_Node::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& TripLeg_Node::time_zone() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_Node::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
}
inline std::string* TripLeg_Node::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.time_zone)
  return _s;
}
inline const std::string& TripLeg_Node::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void TripLeg_Node::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Node::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_Node::release_time_zone() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.time_zone)
  return _impl_.time_zone_.Release();
}
inline void TripLeg_Node::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.time_zone)
}

// .valhalla.TripLeg.PathCost cost = 12;
inline bool TripLeg_Node::_internal_has_cost() const {
  return this != internal_default_instance() && _impl_.cost_ != nullptr;
}
inline bool TripLeg_Node::has_cost() const {
  return _internal_has_cost();
}
inline void TripLeg_Node::clear_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.cost_ != nullptr) {
    delete _impl_.cost_;
  }
  _impl_.cost_ = nullptr;
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::_internal_cost() const {
  const ::valhalla::TripLeg_PathCost* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_PathCost&>(
      ::valhalla::_TripLeg_PathCost_default_instance_);
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.cost)
  return _internal_cost();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_cost(
    ::valhalla::TripLeg_PathCost* cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.cost)
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::release_cost() {
  
  ::valhalla::TripLeg_PathCost* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::unsafe_arena_release_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.cost)
  
  ::valhalla::TripLeg_PathCost* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::_internal_mutable_cost() {
  
  if (_impl_.cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_PathCost>(GetArenaForAllocation());
    _impl_.cost_ = p;
  }
  return _impl_.cost_;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_cost() {
  ::valhalla::TripLeg_PathCost* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.cost)
  return _msg;
}
inline void TripLeg_Node::set_allocated_cost(::valhalla::TripLeg_PathCost* cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cost_;
  }
  if (cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cost);
    if (message_arena != submessage_arena) {
      cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cost_ = cost;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.cost)
}

// repeated .valhalla.TripLeg.PathCost recosts = 13;
inline int TripLeg_Node::_internal_recosts_size() const {
  return _impl_.recosts_.size();
}
inline int TripLeg_Node::recosts_size() const {
  return _internal_recosts_size();
}
inline void TripLeg_Node::clear_recosts() {
  _impl_.recosts_.Clear();
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_recosts(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.recosts)
  return _impl_.recosts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
TripLeg_Node::mutable_recosts() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.recosts)
  return &_impl_.recosts_;
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::_internal_recosts(int index) const {
  return _impl_.recosts_.Get(index);
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::recosts(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.recosts)
  return _internal_recosts(index);
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::_internal_add_recosts() {
  return _impl_.recosts_.Add();
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::add_recosts() {
  ::valhalla::TripLeg_PathCost* _add = _internal_add_recosts();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.recosts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
TripLeg_Node::recosts() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.recosts)
  return _impl_.recosts_;
}

// .valhalla.BikeShareStationInfo bss_info = 14;
inline bool TripLeg_Node::_internal_has_bss_info() const {
  return this != internal_default_instance() && _impl_.bss_info_ != nullptr;
}
inline bool TripLeg_Node::has_bss_info() const {
  return _internal_has_bss_info();
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::_internal_bss_info() const {
  const ::valhalla::BikeShareStationInfo* p = _impl_.bss_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BikeShareStationInfo&>(
      ::valhalla::_BikeShareStationInfo_default_instance_);
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.bss_info)
  return _internal_bss_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_bss_info(
    ::valhalla::BikeShareStationInfo* bss_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bss_info_);
  }
  _impl_.bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.bss_info)
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::release_bss_info() {
  
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::unsafe_arena_release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
  return temp;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::_internal_mutable_bss_info() {
  
  if (_impl_.bss_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BikeShareStationInfo>(GetArenaForAllocation());
    _impl_.bss_info_ = p;
  }
  return _impl_.bss_info_;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::mutable_bss_info() {
  ::valhalla::BikeShareStationInfo* _msg = _internal_mutable_bss_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.bss_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bss_info_);
  }
  if (bss_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bss_info));
    if (message_arena != submessage_arena) {
      bss_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bss_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bss_info_ = bss_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.bss_info)
}

// -------------------------------------------------------------------

// TripLeg_Admin

// string country_code = 1;
inline void TripLeg_Admin::clear_country_code() {
  _impl_.country_code_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::country_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_Admin::set_country_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
}
inline std::string* TripLeg_Admin::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_code)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_country_code() const {
  return _impl_.country_code_.Get();
}
inline void TripLeg_Admin::_internal_set_country_code(const std::string& value) {
  
  _impl_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_country_code() {
  
  return _impl_.country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_country_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_code)
  return _impl_.country_code_.Release();
}
inline void TripLeg_Admin::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    
  } else {
    
  }
  _impl_.country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_code)
}

// string country_text = 2;
inline void TripLeg_Admin::clear_country_text() {
  _impl_.country_text_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::country_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_text)
  return _internal_country_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_Admin::set_country_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.country_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
}
inline std::string* TripLeg_Admin::mutable_country_text() {
  std::string* _s = _internal_mutable_country_text();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_text)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_country_text() const {
  return _impl_.country_text_.Get();
}
inline void TripLeg_Admin::_internal_set_country_text(const std::string& value) {
  
  _impl_.country_text_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_country_text() {
  
  return _impl_.country_text_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_country_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_text)
  return _impl_.country_text_.Release();
}
inline void TripLeg_Admin::set_allocated_country_text(std::string* country_text) {
  if (country_text != nullptr) {
    
  } else {
    
  }
  _impl_.country_text_.SetAllocated(country_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_text_.IsDefault()) {
    _impl_.country_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_text)
}

// string state_code = 3;
inline void TripLeg_Admin::clear_state_code() {
  _impl_.state_code_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::state_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_code)
  return _internal_state_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_Admin::set_state_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
}
inline std::string* TripLeg_Admin::mutable_state_code() {
  std::string* _s = _internal_mutable_state_code();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_code)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_state_code() const {
  return _impl_.state_code_.Get();
}
inline void TripLeg_Admin::_internal_set_state_code(const std::string& value) {
  
  _impl_.state_code_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_state_code() {
  
  return _impl_.state_code_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_state_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_code)
  return _impl_.state_code_.Release();
}
inline void TripLeg_Admin::set_allocated_state_code(std::string* state_code) {
  if (state_code != nullptr) {
    
  } else {
    
  }
  _impl_.state_code_.SetAllocated(state_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_code_.IsDefault()) {
    _impl_.state_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_code)
}

// string state_text = 4;
inline void TripLeg_Admin::clear_state_text() {
  _impl_.state_text_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::state_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_text)
  return _internal_state_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg_Admin::set_state_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
}
inline std::string* TripLeg_Admin::mutable_state_text() {
  std::string* _s = _internal_mutable_state_text();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_text)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_state_text() const {
  return _impl_.state_text_.Get();
}
inline void TripLeg_Admin::_internal_set_state_text(const std::string& value) {
  
  _impl_.state_text_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_state_text() {
  
  return _impl_.state_text_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_state_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_text)
  return _impl_.state_text_.Release();
}
inline void TripLeg_Admin::set_allocated_state_text(std::string* state_text) {
  if (state_text != nullptr) {
    
  } else {
    
  }
  _impl_.state_text_.SetAllocated(state_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_text_.IsDefault()) {
    _impl_.state_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_text)
}

// -------------------------------------------------------------------

// TripLeg_ShapeAttributes

// repeated uint32 time = 1 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_time_size() const {
  return _impl_.time_.size();
}
inline int TripLeg_ShapeAttributes::time_size() const {
  return _internal_time_size();
}
inline void TripLeg_ShapeAttributes::clear_time() {
  _impl_.time_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_time(int index) const {
  return _impl_.time_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::time(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_time(index);
}
inline void TripLeg_ShapeAttributes::set_time(int index, uint32_t value) {
  _impl_.time_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.time)
}
inline void TripLeg_ShapeAttributes::_internal_add_time(uint32_t value) {
  _impl_.time_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_time(uint32_t value) {
  _internal_add_time(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.time)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_time() const {
  return _impl_.time_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::time() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_time();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_time() {
  return &_impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_time() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_mutable_time();
}

// repeated uint32 length = 2 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_length_size() const {
  return _impl_.length_.size();
}
inline int TripLeg_ShapeAttributes::length_size() const {
  return _internal_length_size();
}
inline void TripLeg_ShapeAttributes::clear_length() {
  _impl_.length_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_length(int index) const {
  return _impl_.length_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::length(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_length(index);
}
inline void TripLeg_ShapeAttributes::set_length(int index, uint32_t value) {
  _impl_.length_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.length)
}
inline void TripLeg_ShapeAttributes::_internal_add_length(uint32_t value) {
  _impl_.length_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_length(uint32_t value) {
  _internal_add_length(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_length() const {
  return _impl_.length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::length() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_length() {
  return &_impl_.length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_length() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_mutable_length();
}

// repeated uint32 speed = 3 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_speed_size() const {
  return _impl_.speed_.size();
}
inline int TripLeg_ShapeAttributes::speed_size() const {
  return _internal_speed_size();
}
inline void TripLeg_ShapeAttributes::clear_speed() {
  _impl_.speed_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_speed(int index) const {
  return _impl_.speed_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::speed(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_speed(index);
}
inline void TripLeg_ShapeAttributes::set_speed(int index, uint32_t value) {
  _impl_.speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed)
}
inline void TripLeg_ShapeAttributes::_internal_add_speed(uint32_t value) {
  _impl_.speed_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_speed(uint32_t value) {
  _internal_add_speed(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_speed() const {
  return _impl_.speed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::speed() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_speed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_speed() {
  return &_impl_.speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_speed() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_mutable_speed();
}

// repeated uint32 speed_limit = 5 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_speed_limit_size() const {
  return _impl_.speed_limit_.size();
}
inline int TripLeg_ShapeAttributes::speed_limit_size() const {
  return _internal_speed_limit_size();
}
inline void TripLeg_ShapeAttributes::clear_speed_limit() {
  _impl_.speed_limit_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_speed_limit(int index) const {
  return _impl_.speed_limit_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::speed_limit(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_speed_limit(index);
}
inline void TripLeg_ShapeAttributes::set_speed_limit(int index, uint32_t value) {
  _impl_.speed_limit_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline void TripLeg_ShapeAttributes::_internal_add_speed_limit(uint32_t value) {
  _impl_.speed_limit_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_speed_limit(uint32_t value) {
  _internal_add_speed_limit(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_speed_limit() const {
  return _impl_.speed_limit_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::speed_limit() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_speed_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_speed_limit() {
  return &_impl_.speed_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_speed_limit() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_mutable_speed_limit();
}

// -------------------------------------------------------------------

// TripLeg_Incident

// .valhalla.IncidentsTile.Metadata metadata = 1;
inline bool TripLeg_Incident::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool TripLeg_Incident::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::_internal_metadata() const {
  const ::valhalla::IncidentsTile_Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::IncidentsTile_Metadata&>(
      ::valhalla::_IncidentsTile_Metadata_default_instance_);
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::metadata() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.metadata)
  return _internal_metadata();
}
inline void TripLeg_Incident::unsafe_arena_set_allocated_metadata(
    ::valhalla::IncidentsTile_Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Incident.metadata)
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::release_metadata() {
  
  ::valhalla::IncidentsTile_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Incident.metadata)
  
  ::valhalla::IncidentsTile_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::IncidentsTile_Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::mutable_metadata() {
  ::valhalla::IncidentsTile_Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Incident.metadata)
  return _msg;
}
inline void TripLeg_Incident::set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Incident.metadata)
}

// uint32 begin_shape_index = 3;
inline void TripLeg_Incident::clear_begin_shape_index() {
  _impl_.begin_shape_index_ = 0u;
}
inline uint32_t TripLeg_Incident::_internal_begin_shape_index() const {
  return _impl_.begin_shape_index_;
}
inline uint32_t TripLeg_Incident::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Incident::_internal_set_begin_shape_index(uint32_t value) {
  
  _impl_.begin_shape_index_ = value;
}
inline void TripLeg_Incident::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.begin_shape_index)
}

// uint32 end_shape_index = 4;
inline void TripLeg_Incident::clear_end_shape_index() {
  _impl_.end_shape_index_ = 0u;
}
inline uint32_t TripLeg_Incident::_internal_end_shape_index() const {
  return _impl_.end_shape_index_;
}
inline uint32_t TripLeg_Incident::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Incident::_internal_set_end_shape_index(uint32_t value) {
  
  _impl_.end_shape_index_ = value;
}
inline void TripLeg_Incident::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.end_shape_index)
}

// -------------------------------------------------------------------

// TripLeg_Closure

// uint32 begin_shape_index = 1;
inline bool TripLeg_Closure::_internal_has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline bool TripLeg_Closure::has_begin_shape_index() const {
  return _internal_has_begin_shape_index();
}
inline void TripLeg_Closure::set_has_begin_shape_index() {
  _impl_._oneof_case_[0] = kBeginShapeIndex;
}
inline void TripLeg_Closure::clear_begin_shape_index() {
  if (_internal_has_begin_shape_index()) {
    _impl_.has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline uint32_t TripLeg_Closure::_internal_begin_shape_index() const {
  if (_internal_has_begin_shape_index()) {
    return _impl_.has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::_internal_set_begin_shape_index(uint32_t value) {
  if (!_internal_has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  _impl_.has_begin_shape_index_.begin_shape_index_ = value;
}
inline uint32_t TripLeg_Closure::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Closure::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.begin_shape_index)
}

// uint32 end_shape_index = 2;
inline bool TripLeg_Closure::_internal_has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline bool TripLeg_Closure::has_end_shape_index() const {
  return _internal_has_end_shape_index();
}
inline void TripLeg_Closure::set_has_end_shape_index() {
  _impl_._oneof_case_[1] = kEndShapeIndex;
}
inline void TripLeg_Closure::clear_end_shape_index() {
  if (_internal_has_end_shape_index()) {
    _impl_.has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline uint32_t TripLeg_Closure::_internal_end_shape_index() const {
  if (_internal_has_end_shape_index()) {
    return _impl_.has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::_internal_set_end_shape_index(uint32_t value) {
  if (!_internal_has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  _impl_.has_end_shape_index_.end_shape_index_ = value;
}
inline uint32_t TripLeg_Closure::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Closure::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.end_shape_index)
}

inline bool TripLeg_Closure::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_begin_shape_index() {
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Closure::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_end_shape_index() {
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline TripLeg_Closure::HasBeginShapeIndexCase TripLeg_Closure::has_begin_shape_index_case() const {
  return TripLeg_Closure::HasBeginShapeIndexCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Closure::HasEndShapeIndexCase TripLeg_Closure::has_end_shape_index_case() const {
  return TripLeg_Closure::HasEndShapeIndexCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg

// uint64 osm_changeset = 1;
inline void TripLeg::clear_osm_changeset() {
  _impl_.osm_changeset_ = uint64_t{0u};
}
inline uint64_t TripLeg::_internal_osm_changeset() const {
  return _impl_.osm_changeset_;
}
inline uint64_t TripLeg::osm_changeset() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.osm_changeset)
  return _internal_osm_changeset();
}
inline void TripLeg::_internal_set_osm_changeset(uint64_t value) {
  
  _impl_.osm_changeset_ = value;
}
inline void TripLeg::set_osm_changeset(uint64_t value) {
  _internal_set_osm_changeset(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.osm_changeset)
}

// uint64 trip_id = 2;
inline void TripLeg::clear_trip_id() {
  _impl_.trip_id_ = uint64_t{0u};
}
inline uint64_t TripLeg::_internal_trip_id() const {
  return _impl_.trip_id_;
}
inline uint64_t TripLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.trip_id)
  return _internal_trip_id();
}
inline void TripLeg::_internal_set_trip_id(uint64_t value) {
  
  _impl_.trip_id_ = value;
}
inline void TripLeg::set_trip_id(uint64_t value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.trip_id)
}

// uint32 leg_id = 3;
inline void TripLeg::clear_leg_id() {
  _impl_.leg_id_ = 0u;
}
inline uint32_t TripLeg::_internal_leg_id() const {
  return _impl_.leg_id_;
}
inline uint32_t TripLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_id)
  return _internal_leg_id();
}
inline void TripLeg::_internal_set_leg_id(uint32_t value) {
  
  _impl_.leg_id_ = value;
}
inline void TripLeg::set_leg_id(uint32_t value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_id)
}

// uint32 leg_count = 4;
inline void TripLeg::clear_leg_count() {
  _impl_.leg_count_ = 0u;
}
inline uint32_t TripLeg::_internal_leg_count() const {
  return _impl_.leg_count_;
}
inline uint32_t TripLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_count)
  return _internal_leg_count();
}
inline void TripLeg::_internal_set_leg_count(uint32_t value) {
  
  _impl_.leg_count_ = value;
}
inline void TripLeg::set_leg_count(uint32_t value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_count)
}

// repeated .valhalla.Location location = 5;
inline int TripLeg::_internal_location_size() const {
  return _impl_.location_.size();
}
inline int TripLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* TripLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.location)
  return _impl_.location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
TripLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.location)
  return &_impl_.location_;
}
inline const ::valhalla::Location& TripLeg::_internal_location(int index) const {
  return _impl_.location_.Get(index);
}
inline const ::valhalla::Location& TripLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.location)
  return _internal_location(index);
}
inline ::valhalla::Location* TripLeg::_internal_add_location() {
  return _impl_.location_.Add();
}
inline ::valhalla::Location* TripLeg::add_location() {
  ::valhalla::Location* _add = _internal_add_location();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.location)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
TripLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.location)
  return _impl_.location_;
}

// repeated .valhalla.TripLeg.Node node = 6;
inline int TripLeg::_internal_node_size() const {
  return _impl_.node_.size();
}
inline int TripLeg::node_size() const {
  return _internal_node_size();
}
inline void TripLeg::clear_node() {
  _impl_.node_.Clear();
}
inline ::valhalla::TripLeg_Node* TripLeg::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.node)
  return _impl_.node_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >*
TripLeg::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.node)
  return &_impl_.node_;
}
inline const ::valhalla::TripLeg_Node& TripLeg::_internal_node(int index) const {
  return _impl_.node_.Get(index);
}
inline const ::valhalla::TripLeg_Node& TripLeg::node(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.node)
  return _internal_node(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::_internal_add_node() {
  return _impl_.node_.Add();
}
inline ::valhalla::TripLeg_Node* TripLeg::add_node() {
  ::valhalla::TripLeg_Node* _add = _internal_add_node();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.node)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >&
TripLeg::node() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.node)
  return _impl_.node_;
}

// repeated .valhalla.TripLeg.Admin admin = 7;
inline int TripLeg::_internal_admin_size() const {
  return _impl_.admin_.size();
}
inline int TripLeg::admin_size() const {
  return _internal_admin_size();
}
inline void TripLeg::clear_admin() {
  _impl_.admin_.Clear();
}
inline ::valhalla::TripLeg_Admin* TripLeg::mutable_admin(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.admin)
  return _impl_.admin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
TripLeg::mutable_admin() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.admin)
  return &_impl_.admin_;
}
inline const ::valhalla::TripLeg_Admin& TripLeg::_internal_admin(int index) const {
  return _impl_.admin_.Get(index);
}
inline const ::valhalla::TripLeg_Admin& TripLeg::admin(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.admin)
  return _internal_admin(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::_internal_add_admin() {
  return _impl_.admin_.Add();
}
inline ::valhalla::TripLeg_Admin* TripLeg::add_admin() {
  ::valhalla::TripLeg_Admin* _add = _internal_add_admin();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.admin)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
TripLeg::admin() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.admin)
  return _impl_.admin_;
}

// string shape = 8;
inline void TripLeg::clear_shape() {
  _impl_.shape_.ClearToEmpty();
}
inline const std::string& TripLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape)
  return _internal_shape();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripLeg::set_shape(ArgT0&& arg0, ArgT... args) {
 
 _impl_.shape_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
}
inline std::string* TripLeg::mutable_shape() {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape)
  return _s;
}
inline const std::string& TripLeg::_internal_shape() const {
  return _impl_.shape_.Get();
}
inline void TripLeg::_internal_set_shape(const std::string& value) {
  
  _impl_.shape_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg::_internal_mutable_shape() {
  
  return _impl_.shape_.Mutable(GetArenaForAllocation());
}
inline std::string* TripLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape)
  return _impl_.shape_.Release();
}
inline void TripLeg::set_allocated_shape(std::string* shape) {
  if (shape != nullptr) {
    
  } else {
    
  }
  _impl_.shape_.SetAllocated(shape, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shape_.IsDefault()) {
    _impl_.shape_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape)
}

// .valhalla.BoundingBox bbox = 9;
inline bool TripLeg::_internal_has_bbox() const {
  return this != internal_default_instance() && _impl_.bbox_ != nullptr;
}
inline bool TripLeg::has_bbox() const {
  return _internal_has_bbox();
}
inline const ::valhalla::BoundingBox& TripLeg::_internal_bbox() const {
  const ::valhalla::BoundingBox* p = _impl_.bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(
      ::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& TripLeg::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.bbox)
  return _internal_bbox();
}
inline void TripLeg::unsafe_arena_set_allocated_bbox(
    ::valhalla::BoundingBox* bbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  _impl_.bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.bbox)
}
inline ::valhalla::BoundingBox* TripLeg::release_bbox() {
  
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BoundingBox* TripLeg::unsafe_arena_release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.bbox)
  
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* TripLeg::_internal_mutable_bbox() {
  
  if (_impl_.bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArenaForAllocation());
    _impl_.bbox_ = p;
  }
  return _impl_.bbox_;
}
inline ::valhalla::BoundingBox* TripLeg::mutable_bbox() {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.bbox)
  return _msg;
}
inline void TripLeg::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  if (bbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox));
    if (message_arena != submessage_arena) {
      bbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.bbox)
}

// .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
inline bool TripLeg::_internal_has_shape_attributes() const {
  return this != internal_default_instance() && _impl_.shape_attributes_ != nullptr;
}
inline bool TripLeg::has_shape_attributes() const {
  return _internal_has_shape_attributes();
}
inline void TripLeg::clear_shape_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.shape_attributes_ != nullptr) {
    delete _impl_.shape_attributes_;
  }
  _impl_.shape_attributes_ = nullptr;
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::_internal_shape_attributes() const {
  const ::valhalla::TripLeg_ShapeAttributes* p = _impl_.shape_attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_ShapeAttributes&>(
      ::valhalla::_TripLeg_ShapeAttributes_default_instance_);
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::shape_attributes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape_attributes)
  return _internal_shape_attributes();
}
inline void TripLeg::unsafe_arena_set_allocated_shape_attributes(
    ::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shape_attributes_);
  }
  _impl_.shape_attributes_ = shape_attributes;
  if (shape_attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.shape_attributes)
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::release_shape_attributes() {
  
  ::valhalla::TripLeg_ShapeAttributes* temp = _impl_.shape_attributes_;
  _impl_.shape_attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::unsafe_arena_release_shape_attributes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape_attributes)
  
  ::valhalla::TripLeg_ShapeAttributes* temp = _impl_.shape_attributes_;
  _impl_.shape_attributes_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::_internal_mutable_shape_attributes() {
  
  if (_impl_.shape_attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_ShapeAttributes>(GetArenaForAllocation());
    _impl_.shape_attributes_ = p;
  }
  return _impl_.shape_attributes_;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::mutable_shape_attributes() {
  ::valhalla::TripLeg_ShapeAttributes* _msg = _internal_mutable_shape_attributes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape_attributes)
  return _msg;
}
inline void TripLeg::set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shape_attributes_;
  }
  if (shape_attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape_attributes);
    if (message_arena != submessage_arena) {
      shape_attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape_attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shape_attributes_ = shape_attributes;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape_attributes)
}

// repeated .valhalla.TripLeg.Incident incidents = 11;
inline int TripLeg::_internal_incidents_size() const {
  return _impl_.incidents_.size();
}
inline int TripLeg::incidents_size() const {
  return _internal_incidents_size();
}
inline void TripLeg::clear_incidents() {
  _impl_.incidents_.Clear();
}
inline ::valhalla::TripLeg_Incident* TripLeg::mutable_incidents(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.incidents)
  return _impl_.incidents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
TripLeg::mutable_incidents() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.incidents)
  return &_impl_.incidents_;
}
inline const ::valhalla::TripLeg_Incident& TripLeg::_internal_incidents(int index) const {
  return _impl_.incidents_.Get(index);
}
inline const ::valhalla::TripLeg_Incident& TripLeg::incidents(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.incidents)
  return _internal_incidents(index);
}
inline ::valhalla::TripLeg_Incident* TripLeg::_internal_add_incidents() {
  return _impl_.incidents_.Add();
}
inline ::valhalla::TripLeg_Incident* TripLeg::add_incidents() {
  ::valhalla::TripLeg_Incident* _add = _internal_add_incidents();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.incidents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
TripLeg::incidents() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.incidents)
  return _impl_.incidents_;
}

// repeated string algorithms = 12;
inline int TripLeg::_internal_algorithms_size() const {
  return _impl_.algorithms_.size();
}
inline int TripLeg::algorithms_size() const {
  return _internal_algorithms_size();
}
inline void TripLeg::clear_algorithms() {
  _impl_.algorithms_.Clear();
}
inline std::string* TripLeg::add_algorithms() {
  std::string* _s = _internal_add_algorithms();
  // @@protoc_insertion_point(field_add_mutable:valhalla.TripLeg.algorithms)
  return _s;
}
inline const std::string& TripLeg::_internal_algorithms(int index) const {
  return _impl_.algorithms_.Get(index);
}
inline const std::string& TripLeg::algorithms(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.algorithms)
  return _internal_algorithms(index);
}
inline std::string* TripLeg::mutable_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.algorithms)
  return _impl_.algorithms_.Mutable(index);
}
inline void TripLeg::set_algorithms(int index, const std::string& value) {
  _impl_.algorithms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, std::string&& value) {
  _impl_.algorithms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.algorithms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value, size_t size) {
  _impl_.algorithms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.algorithms)
}
inline std::string* TripLeg::_internal_add_algorithms() {
  return _impl_.algorithms_.Add();
}
inline void TripLeg::add_algorithms(const std::string& value) {
  _impl_.algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(std::string&& value) {
  _impl_.algorithms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value, size_t size) {
  _impl_.algorithms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.TripLeg.algorithms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TripLeg::algorithms() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.algorithms)
  return _impl_.algorithms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TripLeg::mutable_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.algorithms)
  return &_impl_.algorithms_;
}

// repeated .valhalla.TripLeg.Closure closures = 13;
inline int TripLeg::_internal_closures_size() const {
  return _impl_.closures_.size();
}
inline int TripLeg::closures_size() const {
  return _internal_closures_size();
}
inline void TripLeg::clear_closures() {
  _impl_.closures_.Clear();
}
inline ::valhalla::TripLeg_Closure* TripLeg::mutable_closures(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.closures)
  return _impl_.closures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
TripLeg::mutable_closures() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.closures)
  return &_impl_.closures_;
}
inline const ::valhalla::TripLeg_Closure& TripLeg::_internal_closures(int index) const {
  return _impl_.closures_.Get(index);
}
inline const ::valhalla::TripLeg_Closure& TripLeg::closures(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.closures)
  return _internal_closures(index);
}
inline ::valhalla::TripLeg_Closure* TripLeg::_internal_add_closures() {
  return _impl_.closures_.Add();
}
inline ::valhalla::TripLeg_Closure* TripLeg::add_closures() {
  ::valhalla::TripLeg_Closure* _add = _internal_add_closures();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.closures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
TripLeg::closures() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.closures)
  return _impl_.closures_;
}

// -------------------------------------------------------------------

// TripRoute

// repeated .valhalla.TripLeg legs = 1;
inline int TripRoute::_internal_legs_size() const {
  return _impl_.legs_.size();
}
inline int TripRoute::legs_size() const {
  return _internal_legs_size();
}
inline void TripRoute::clear_legs() {
  _impl_.legs_.Clear();
}
inline ::valhalla::TripLeg* TripRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripRoute.legs)
  return _impl_.legs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >*
TripRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripRoute.legs)
  return &_impl_.legs_;
}
inline const ::valhalla::TripLeg& TripRoute::_internal_legs(int index) const {
  return _impl_.legs_.Get(index);
}
inline const ::valhalla::TripLeg& TripRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripRoute.legs)
  return _internal_legs(index);
}
inline ::valhalla::TripLeg* TripRoute::_internal_add_legs() {
  return _impl_.legs_.Add();
}
inline ::valhalla::TripLeg* TripRoute::add_legs() {
  ::valhalla::TripLeg* _add = _internal_add_legs();
  // @@protoc_insertion_point(field_add:valhalla.TripRoute.legs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >&
TripRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.TripRoute.legs)
  return _impl_.legs_;
}

// -------------------------------------------------------------------

// Trip

// repeated .valhalla.TripRoute routes = 1;
inline int Trip::_internal_routes_size() const {
  return _impl_.routes_.size();
}
inline int Trip::routes_size() const {
  return _internal_routes_size();
}
inline void Trip::clear_routes() {
  _impl_.routes_.Clear();
}
inline ::valhalla::TripRoute* Trip::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Trip.routes)
  return _impl_.routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >*
Trip::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Trip.routes)
  return &_impl_.routes_;
}
inline const ::valhalla::TripRoute& Trip::_internal_routes(int index) const {
  return _impl_.routes_.Get(index);
}
inline const ::valhalla::TripRoute& Trip::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Trip.routes)
  return _internal_routes(index);
}
inline ::valhalla::TripRoute* Trip::_internal_add_routes() {
  return _impl_.routes_.Add();
}
inline ::valhalla::TripRoute* Trip::add_routes() {
  ::valhalla::TripRoute* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:valhalla.Trip.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >&
Trip::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Trip.routes)
  return _impl_.routes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::TripLeg_Node_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Traversability> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Use> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Surface> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_CycleLane> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_SacScale> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Sidewalk> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_trip_2eproto
