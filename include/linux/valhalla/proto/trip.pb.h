// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#ifndef PROTOBUF_trip_2eproto__INCLUDED
#define PROTOBUF_trip_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"  // IWYU pragma: export
#include "sign.pb.h"  // IWYU pragma: export
#include "incidents.pb.h"
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_trip_2eproto();
void protobuf_AssignDesc_trip_2eproto();
void protobuf_ShutdownFile_trip_2eproto();

class Trip;
class TripLeg;
class TripLeg_Admin;
class TripLeg_Closure;
class TripLeg_Cost;
class TripLeg_Edge;
class TripLeg_Incident;
class TripLeg_IntersectingEdge;
class TripLeg_LaneConnectivity;
class TripLeg_Node;
class TripLeg_PathCost;
class TripLeg_Restriction;
class TripLeg_ShapeAttributes;
class TripLeg_TrafficSegment;
class TripRoute;

enum TripLeg_Node_Type {
  TripLeg_Node_Type_kStreetIntersection = 0,
  TripLeg_Node_Type_kGate = 1,
  TripLeg_Node_Type_kBollard = 2,
  TripLeg_Node_Type_kTollBooth = 3,
  TripLeg_Node_Type_kTransitEgress = 4,
  TripLeg_Node_Type_kTransitStation = 5,
  TripLeg_Node_Type_kTransitPlatform = 6,
  TripLeg_Node_Type_kBikeShare = 7,
  TripLeg_Node_Type_kParking = 8,
  TripLeg_Node_Type_kMotorwayJunction = 9,
  TripLeg_Node_Type_kBorderControl = 10,
  TripLeg_Node_Type_kTollGantry = 11,
  TripLeg_Node_Type_kSumpBuster = 12,
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_Node_Type_IsValid(int value);
const TripLeg_Node_Type TripLeg_Node_Type_Type_MIN = TripLeg_Node_Type_kStreetIntersection;
const TripLeg_Node_Type TripLeg_Node_Type_Type_MAX = TripLeg_Node_Type_kSumpBuster;
const int TripLeg_Node_Type_Type_ARRAYSIZE = TripLeg_Node_Type_Type_MAX + 1;

enum TripLeg_Traversability {
  TripLeg_Traversability_kNone = 0,
  TripLeg_Traversability_kForward = 1,
  TripLeg_Traversability_kBackward = 2,
  TripLeg_Traversability_kBoth = 3,
  TripLeg_Traversability_TripLeg_Traversability_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_Traversability_TripLeg_Traversability_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_Traversability_IsValid(int value);
const TripLeg_Traversability TripLeg_Traversability_Traversability_MIN = TripLeg_Traversability_kNone;
const TripLeg_Traversability TripLeg_Traversability_Traversability_MAX = TripLeg_Traversability_kBoth;
const int TripLeg_Traversability_Traversability_ARRAYSIZE = TripLeg_Traversability_Traversability_MAX + 1;

enum TripLeg_Use {
  TripLeg_Use_kRoadUse = 0,
  TripLeg_Use_kRampUse = 1,
  TripLeg_Use_kTurnChannelUse = 2,
  TripLeg_Use_kTrackUse = 3,
  TripLeg_Use_kDrivewayUse = 4,
  TripLeg_Use_kAlleyUse = 5,
  TripLeg_Use_kParkingAisleUse = 6,
  TripLeg_Use_kEmergencyAccessUse = 7,
  TripLeg_Use_kDriveThruUse = 8,
  TripLeg_Use_kCuldesacUse = 9,
  TripLeg_Use_kLivingStreetUse = 10,
  TripLeg_Use_kServiceRoadUse = 11,
  TripLeg_Use_kCyclewayUse = 20,
  TripLeg_Use_kMountainBikeUse = 21,
  TripLeg_Use_kSidewalkUse = 24,
  TripLeg_Use_kFootwayUse = 25,
  TripLeg_Use_kStepsUse = 26,
  TripLeg_Use_kPathUse = 27,
  TripLeg_Use_kPedestrianUse = 28,
  TripLeg_Use_kBridlewayUse = 29,
  TripLeg_Use_kPedestrianCrossingUse = 32,
  TripLeg_Use_kRestAreaUse = 30,
  TripLeg_Use_kServiceAreaUse = 31,
  TripLeg_Use_kOtherUse = 40,
  TripLeg_Use_kFerryUse = 41,
  TripLeg_Use_kRailFerryUse = 42,
  TripLeg_Use_kRailUse = 50,
  TripLeg_Use_kBusUse = 51,
  TripLeg_Use_kEgressConnectionUse = 52,
  TripLeg_Use_kPlatformConnectionUse = 53,
  TripLeg_Use_kTransitConnectionUse = 54,
  TripLeg_Use_TripLeg_Use_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_Use_TripLeg_Use_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_Use_IsValid(int value);
const TripLeg_Use TripLeg_Use_Use_MIN = TripLeg_Use_kRoadUse;
const TripLeg_Use TripLeg_Use_Use_MAX = TripLeg_Use_kTransitConnectionUse;
const int TripLeg_Use_Use_ARRAYSIZE = TripLeg_Use_Use_MAX + 1;

enum TripLeg_Surface {
  TripLeg_Surface_kPavedSmooth = 0,
  TripLeg_Surface_kPaved = 1,
  TripLeg_Surface_kPavedRough = 2,
  TripLeg_Surface_kCompacted = 3,
  TripLeg_Surface_kDirt = 4,
  TripLeg_Surface_kGravel = 5,
  TripLeg_Surface_kPath = 6,
  TripLeg_Surface_kImpassable = 7,
  TripLeg_Surface_TripLeg_Surface_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_Surface_TripLeg_Surface_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_Surface_IsValid(int value);
const TripLeg_Surface TripLeg_Surface_Surface_MIN = TripLeg_Surface_kPavedSmooth;
const TripLeg_Surface TripLeg_Surface_Surface_MAX = TripLeg_Surface_kImpassable;
const int TripLeg_Surface_Surface_ARRAYSIZE = TripLeg_Surface_Surface_MAX + 1;

enum TripLeg_CycleLane {
  TripLeg_CycleLane_kNoCycleLane = 0,
  TripLeg_CycleLane_kShared = 1,
  TripLeg_CycleLane_kDedicated = 2,
  TripLeg_CycleLane_kSeparated = 3,
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_CycleLane_IsValid(int value);
const TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MIN = TripLeg_CycleLane_kNoCycleLane;
const TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MAX = TripLeg_CycleLane_kSeparated;
const int TripLeg_CycleLane_CycleLane_ARRAYSIZE = TripLeg_CycleLane_CycleLane_MAX + 1;

enum TripLeg_SacScale {
  TripLeg_SacScale_kNoSacScale = 0,
  TripLeg_SacScale_kHiking = 1,
  TripLeg_SacScale_kMountainHiking = 2,
  TripLeg_SacScale_kDemandingMountainHiking = 3,
  TripLeg_SacScale_kAlpineHiking = 4,
  TripLeg_SacScale_kDemandingAlpineHiking = 5,
  TripLeg_SacScale_kDifficultAlpineHiking = 6,
  TripLeg_SacScale_TripLeg_SacScale_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_SacScale_TripLeg_SacScale_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_SacScale_IsValid(int value);
const TripLeg_SacScale TripLeg_SacScale_SacScale_MIN = TripLeg_SacScale_kNoSacScale;
const TripLeg_SacScale TripLeg_SacScale_SacScale_MAX = TripLeg_SacScale_kDifficultAlpineHiking;
const int TripLeg_SacScale_SacScale_ARRAYSIZE = TripLeg_SacScale_SacScale_MAX + 1;

enum TripLeg_Sidewalk {
  TripLeg_Sidewalk_kNoSidewalk = 0,
  TripLeg_Sidewalk_kLeft = 1,
  TripLeg_Sidewalk_kRight = 2,
  TripLeg_Sidewalk_kBothSides = 3,
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TripLeg_Sidewalk_IsValid(int value);
const TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MIN = TripLeg_Sidewalk_kNoSidewalk;
const TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MAX = TripLeg_Sidewalk_kBothSides;
const int TripLeg_Sidewalk_Sidewalk_ARRAYSIZE = TripLeg_Sidewalk_Sidewalk_MAX + 1;

// ===================================================================

class TripLeg_LaneConnectivity : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.LaneConnectivity) */ {
 public:
  TripLeg_LaneConnectivity();
  virtual ~TripLeg_LaneConnectivity();

  TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from);

  inline TripLeg_LaneConnectivity& operator=(const TripLeg_LaneConnectivity& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_LaneConnectivity& default_instance();

  enum HasFromWayIdCase {
    kFromWayId = 1,
    HAS_FROM_WAY_ID_NOT_SET = 0,
  };

  enum HasFromLanesCase {
    kFromLanes = 2,
    HAS_FROM_LANES_NOT_SET = 0,
  };

  enum HasToLanesCase {
    kToLanes = 3,
    HAS_TO_LANES_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_LaneConnectivity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_LaneConnectivity* other);

  // implements Message ----------------------------------------------

  inline TripLeg_LaneConnectivity* New() const { return New(NULL); }

  TripLeg_LaneConnectivity* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_LaneConnectivity& from);
  void MergeFrom(const TripLeg_LaneConnectivity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_LaneConnectivity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 from_way_id = 1;
  private:
  bool has_from_way_id() const;
  public:
  void clear_from_way_id();
  static const int kFromWayIdFieldNumber = 1;
  ::google::protobuf::uint64 from_way_id() const;
  void set_from_way_id(::google::protobuf::uint64 value);

  // optional string from_lanes = 2;
  private:
  bool has_from_lanes() const;
  public:
  void clear_from_lanes();
  static const int kFromLanesFieldNumber = 2;
  const ::std::string& from_lanes() const;
  void set_from_lanes(const ::std::string& value);
  void set_from_lanes(const char* value);
  void set_from_lanes(const char* value, size_t size);
  ::std::string* mutable_from_lanes();
  ::std::string* release_from_lanes();
  void set_allocated_from_lanes(::std::string* from_lanes);

  // optional string to_lanes = 3;
  private:
  bool has_to_lanes() const;
  public:
  void clear_to_lanes();
  static const int kToLanesFieldNumber = 3;
  const ::std::string& to_lanes() const;
  void set_to_lanes(const ::std::string& value);
  void set_to_lanes(const char* value);
  void set_to_lanes(const char* value, size_t size);
  ::std::string* mutable_to_lanes();
  ::std::string* release_to_lanes();
  void set_allocated_to_lanes(::std::string* to_lanes);

  HasFromWayIdCase has_from_way_id_case() const;
  HasFromLanesCase has_from_lanes_case() const;
  HasToLanesCase has_to_lanes_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.LaneConnectivity)
 private:
  inline void set_has_from_way_id();
  inline void set_has_from_lanes();
  inline void set_has_to_lanes();

  inline bool has_has_from_way_id() const;
  void clear_has_from_way_id();
  inline void clear_has_has_from_way_id();

  inline bool has_has_from_lanes() const;
  void clear_has_from_lanes();
  inline void clear_has_has_from_lanes();

  inline bool has_has_to_lanes() const;
  void clear_has_to_lanes();
  inline void clear_has_has_to_lanes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasFromWayIdUnion {
    HasFromWayIdUnion() {}
    ::google::protobuf::uint64 from_way_id_;
  } has_from_way_id_;
  union HasFromLanesUnion {
    HasFromLanesUnion() {}
    ::google::protobuf::internal::ArenaStringPtr from_lanes_;
  } has_from_lanes_;
  union HasToLanesUnion {
    HasToLanesUnion() {}
    ::google::protobuf::internal::ArenaStringPtr to_lanes_;
  } has_to_lanes_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_LaneConnectivity* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_TrafficSegment : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.TrafficSegment) */ {
 public:
  TripLeg_TrafficSegment();
  virtual ~TripLeg_TrafficSegment();

  TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from);

  inline TripLeg_TrafficSegment& operator=(const TripLeg_TrafficSegment& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_TrafficSegment& default_instance();

  enum HasSegmentIdCase {
    kSegmentId = 1,
    HAS_SEGMENT_ID_NOT_SET = 0,
  };

  enum HasBeginPercentCase {
    kBeginPercent = 2,
    HAS_BEGIN_PERCENT_NOT_SET = 0,
  };

  enum HasEndPercentCase {
    kEndPercent = 3,
    HAS_END_PERCENT_NOT_SET = 0,
  };

  enum HasStartsSegmentCase {
    kStartsSegment = 4,
    HAS_STARTS_SEGMENT_NOT_SET = 0,
  };

  enum HasEndsSegmentCase {
    kEndsSegment = 5,
    HAS_ENDS_SEGMENT_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_TrafficSegment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_TrafficSegment* other);

  // implements Message ----------------------------------------------

  inline TripLeg_TrafficSegment* New() const { return New(NULL); }

  TripLeg_TrafficSegment* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_TrafficSegment& from);
  void MergeFrom(const TripLeg_TrafficSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_TrafficSegment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 segment_id = 1;
  private:
  bool has_segment_id() const;
  public:
  void clear_segment_id();
  static const int kSegmentIdFieldNumber = 1;
  ::google::protobuf::uint64 segment_id() const;
  void set_segment_id(::google::protobuf::uint64 value);

  // optional float begin_percent = 2;
  private:
  bool has_begin_percent() const;
  public:
  void clear_begin_percent();
  static const int kBeginPercentFieldNumber = 2;
  float begin_percent() const;
  void set_begin_percent(float value);

  // optional float end_percent = 3;
  private:
  bool has_end_percent() const;
  public:
  void clear_end_percent();
  static const int kEndPercentFieldNumber = 3;
  float end_percent() const;
  void set_end_percent(float value);

  // optional bool starts_segment = 4;
  private:
  bool has_starts_segment() const;
  public:
  void clear_starts_segment();
  static const int kStartsSegmentFieldNumber = 4;
  bool starts_segment() const;
  void set_starts_segment(bool value);

  // optional bool ends_segment = 5;
  private:
  bool has_ends_segment() const;
  public:
  void clear_ends_segment();
  static const int kEndsSegmentFieldNumber = 5;
  bool ends_segment() const;
  void set_ends_segment(bool value);

  HasSegmentIdCase has_segment_id_case() const;
  HasBeginPercentCase has_begin_percent_case() const;
  HasEndPercentCase has_end_percent_case() const;
  HasStartsSegmentCase has_starts_segment_case() const;
  HasEndsSegmentCase has_ends_segment_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TrafficSegment)
 private:
  inline void set_has_segment_id();
  inline void set_has_begin_percent();
  inline void set_has_end_percent();
  inline void set_has_starts_segment();
  inline void set_has_ends_segment();

  inline bool has_has_segment_id() const;
  void clear_has_segment_id();
  inline void clear_has_has_segment_id();

  inline bool has_has_begin_percent() const;
  void clear_has_begin_percent();
  inline void clear_has_has_begin_percent();

  inline bool has_has_end_percent() const;
  void clear_has_end_percent();
  inline void clear_has_has_end_percent();

  inline bool has_has_starts_segment() const;
  void clear_has_starts_segment();
  inline void clear_has_has_starts_segment();

  inline bool has_has_ends_segment() const;
  void clear_has_ends_segment();
  inline void clear_has_has_ends_segment();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasSegmentIdUnion {
    HasSegmentIdUnion() {}
    ::google::protobuf::uint64 segment_id_;
  } has_segment_id_;
  union HasBeginPercentUnion {
    HasBeginPercentUnion() {}
    float begin_percent_;
  } has_begin_percent_;
  union HasEndPercentUnion {
    HasEndPercentUnion() {}
    float end_percent_;
  } has_end_percent_;
  union HasStartsSegmentUnion {
    HasStartsSegmentUnion() {}
    bool starts_segment_;
  } has_starts_segment_;
  union HasEndsSegmentUnion {
    HasEndsSegmentUnion() {}
    bool ends_segment_;
  } has_ends_segment_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[5];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_TrafficSegment* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Restriction : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Restriction) */ {
 public:
  TripLeg_Restriction();
  virtual ~TripLeg_Restriction();

  TripLeg_Restriction(const TripLeg_Restriction& from);

  inline TripLeg_Restriction& operator=(const TripLeg_Restriction& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Restriction& default_instance();

  enum HasTypeCase {
    kType = 1,
    HAS_TYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Restriction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Restriction* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Restriction* New() const { return New(NULL); }

  TripLeg_Restriction* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Restriction& from);
  void MergeFrom(const TripLeg_Restriction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Restriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  HasTypeCase has_type_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Restriction)
 private:
  inline void set_has_type();

  inline bool has_has_type() const;
  void clear_has_type();
  inline void clear_has_has_type();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasTypeUnion {
    HasTypeUnion() {}
    ::google::protobuf::uint32 type_;
  } has_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Restriction* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Edge : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Edge) */ {
 public:
  TripLeg_Edge();
  virtual ~TripLeg_Edge();

  TripLeg_Edge(const TripLeg_Edge& from);

  inline TripLeg_Edge& operator=(const TripLeg_Edge& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Edge& default_instance();

  enum HasLengthKmCase {
    kLengthKm = 2,
    HAS_LENGTH_KM_NOT_SET = 0,
  };

  enum HasSpeedCase {
    kSpeed = 3,
    HAS_SPEED_NOT_SET = 0,
  };

  enum HasRoadClassCase {
    kRoadClass = 4,
    HAS_ROAD_CLASS_NOT_SET = 0,
  };

  enum HasBeginHeadingCase {
    kBeginHeading = 5,
    HAS_BEGIN_HEADING_NOT_SET = 0,
  };

  enum HasEndHeadingCase {
    kEndHeading = 6,
    HAS_END_HEADING_NOT_SET = 0,
  };

  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 7,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 8,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasTraversabilityCase {
    kTraversability = 9,
    HAS_TRAVERSABILITY_NOT_SET = 0,
  };

  enum HasUseCase {
    kUse = 10,
    HAS_USE_NOT_SET = 0,
  };

  enum HasTollCase {
    kToll = 11,
    HAS_TOLL_NOT_SET = 0,
  };

  enum HasUnpavedCase {
    kUnpaved = 12,
    HAS_UNPAVED_NOT_SET = 0,
  };

  enum HasTunnelCase {
    kTunnel = 13,
    HAS_TUNNEL_NOT_SET = 0,
  };

  enum HasBridgeCase {
    kBridge = 14,
    HAS_BRIDGE_NOT_SET = 0,
  };

  enum HasRoundaboutCase {
    kRoundabout = 15,
    HAS_ROUNDABOUT_NOT_SET = 0,
  };

  enum HasInternalIntersectionCase {
    kInternalIntersection = 16,
    HAS_INTERNAL_INTERSECTION_NOT_SET = 0,
  };

  enum HasDriveOnLeftCase {
    kDriveOnLeft = 17,
    HAS_DRIVE_ON_LEFT_NOT_SET = 0,
  };

  enum HasSurfaceCase {
    kSurface = 18,
    HAS_SURFACE_NOT_SET = 0,
  };

  enum HasTravelModeCase {
    kTravelMode = 20,
    HAS_TRAVEL_MODE_NOT_SET = 0,
  };

  enum HasVehicleTypeCase {
    kVehicleType = 21,
    HAS_VEHICLE_TYPE_NOT_SET = 0,
  };

  enum HasPedestrianTypeCase {
    kPedestrianType = 22,
    HAS_PEDESTRIAN_TYPE_NOT_SET = 0,
  };

  enum HasBicycleTypeCase {
    kBicycleType = 23,
    HAS_BICYCLE_TYPE_NOT_SET = 0,
  };

  enum HasTransitTypeCase {
    kTransitType = 24,
    HAS_TRANSIT_TYPE_NOT_SET = 0,
  };

  enum HasIdCase {
    kId = 26,
    HAS_ID_NOT_SET = 0,
  };

  enum HasWayIdCase {
    kWayId = 27,
    HAS_WAY_ID_NOT_SET = 0,
  };

  enum HasWeightedGradeCase {
    kWeightedGrade = 28,
    HAS_WEIGHTED_GRADE_NOT_SET = 0,
  };

  enum HasMaxUpwardGradeCase {
    kMaxUpwardGrade = 29,
    HAS_MAX_UPWARD_GRADE_NOT_SET = 0,
  };

  enum HasMaxDownwardGradeCase {
    kMaxDownwardGrade = 30,
    HAS_MAX_DOWNWARD_GRADE_NOT_SET = 0,
  };

  enum HasLaneCountCase {
    kLaneCount = 31,
    HAS_LANE_COUNT_NOT_SET = 0,
  };

  enum HasCycleLaneCase {
    kCycleLane = 32,
    HAS_CYCLE_LANE_NOT_SET = 0,
  };

  enum HasBicycleNetworkCase {
    kBicycleNetwork = 33,
    HAS_BICYCLE_NETWORK_NOT_SET = 0,
  };

  enum HasSidewalkCase {
    kSidewalk = 34,
    HAS_SIDEWALK_NOT_SET = 0,
  };

  enum HasDensityCase {
    kDensity = 35,
    HAS_DENSITY_NOT_SET = 0,
  };

  enum HasSpeedLimitCase {
    kSpeedLimit = 36,
    HAS_SPEED_LIMIT_NOT_SET = 0,
  };

  enum HasTruckSpeedCase {
    kTruckSpeed = 37,
    HAS_TRUCK_SPEED_NOT_SET = 0,
  };

  enum HasTruckRouteCase {
    kTruckRoute = 38,
    HAS_TRUCK_ROUTE_NOT_SET = 0,
  };

  enum HasMeanElevationCase {
    kMeanElevation = 40,
    HAS_MEAN_ELEVATION_NOT_SET = 0,
  };

  enum HasHasTimeRestrictionsCase {
    kHasTimeRestrictions = 43,
    HAS_HAS_TIME_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasDefaultSpeedCase {
    kDefaultSpeed = 44,
    HAS_DEFAULT_SPEED_NOT_SET = 0,
  };

  enum HasDestinationOnlyCase {
    kDestinationOnly = 46,
    HAS_DESTINATION_ONLY_NOT_SET = 0,
  };

  enum HasIsUrbanCase {
    kIsUrban = 47,
    HAS_IS_URBAN_NOT_SET = 0,
  };

  enum HasSourceAlongEdgeCase {
    kSourceAlongEdge = 49,
    HAS_SOURCE_ALONG_EDGE_NOT_SET = 0,
  };

  enum HasTargetAlongEdgeCase {
    kTargetAlongEdge = 50,
    HAS_TARGET_ALONG_EDGE_NOT_SET = 0,
  };

  enum HasSacScaleCase {
    kSacScale = 51,
    HAS_SAC_SCALE_NOT_SET = 0,
  };

  enum HasShoulderCase {
    kShoulder = 52,
    HAS_SHOULDER_NOT_SET = 0,
  };

  enum HasTotalLengthKmCase {
    kTotalLengthKm = 53,
    HAS_TOTAL_LENGTH_KM_NOT_SET = 0,
  };

  enum HasShortcutIdCase {
    kShortcutId = 54,
    HAS_SHORTCUT_ID_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Edge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Edge* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Edge* New() const { return New(NULL); }

  TripLeg_Edge* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Edge& from);
  void MergeFrom(const TripLeg_Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.StreetName name = 1;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::valhalla::StreetName& name(int index) const;
  ::valhalla::StreetName* mutable_name(int index);
  ::valhalla::StreetName* add_name();
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      name() const;

  // optional float length_km = 2;
  private:
  bool has_length_km() const;
  public:
  void clear_length_km();
  static const int kLengthKmFieldNumber = 2;
  float length_km() const;
  void set_length_km(float value);

  // optional float speed = 3;
  private:
  bool has_speed() const;
  public:
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // optional .valhalla.RoadClass road_class = 4;
  private:
  bool has_road_class() const;
  public:
  void clear_road_class();
  static const int kRoadClassFieldNumber = 4;
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);

  // optional uint32 begin_heading = 5;
  private:
  bool has_begin_heading() const;
  public:
  void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 5;
  ::google::protobuf::uint32 begin_heading() const;
  void set_begin_heading(::google::protobuf::uint32 value);

  // optional uint32 end_heading = 6;
  private:
  bool has_end_heading() const;
  public:
  void clear_end_heading();
  static const int kEndHeadingFieldNumber = 6;
  ::google::protobuf::uint32 end_heading() const;
  void set_end_heading(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 7;
  private:
  bool has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 7;
  ::google::protobuf::uint32 begin_shape_index() const;
  void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 8;
  private:
  bool has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 8;
  ::google::protobuf::uint32 end_shape_index() const;
  void set_end_shape_index(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.Traversability traversability = 9;
  private:
  bool has_traversability() const;
  public:
  void clear_traversability();
  static const int kTraversabilityFieldNumber = 9;
  ::valhalla::TripLeg_Traversability traversability() const;
  void set_traversability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Use use = 10;
  private:
  bool has_use() const;
  public:
  void clear_use();
  static const int kUseFieldNumber = 10;
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);

  // optional bool toll = 11;
  private:
  bool has_toll() const;
  public:
  void clear_toll();
  static const int kTollFieldNumber = 11;
  bool toll() const;
  void set_toll(bool value);

  // optional bool unpaved = 12;
  private:
  bool has_unpaved() const;
  public:
  void clear_unpaved();
  static const int kUnpavedFieldNumber = 12;
  bool unpaved() const;
  void set_unpaved(bool value);

  // optional bool tunnel = 13;
  private:
  bool has_tunnel() const;
  public:
  void clear_tunnel();
  static const int kTunnelFieldNumber = 13;
  bool tunnel() const;
  void set_tunnel(bool value);

  // optional bool bridge = 14;
  private:
  bool has_bridge() const;
  public:
  void clear_bridge();
  static const int kBridgeFieldNumber = 14;
  bool bridge() const;
  void set_bridge(bool value);

  // optional bool roundabout = 15;
  private:
  bool has_roundabout() const;
  public:
  void clear_roundabout();
  static const int kRoundaboutFieldNumber = 15;
  bool roundabout() const;
  void set_roundabout(bool value);

  // optional bool internal_intersection = 16;
  private:
  bool has_internal_intersection() const;
  public:
  void clear_internal_intersection();
  static const int kInternalIntersectionFieldNumber = 16;
  bool internal_intersection() const;
  void set_internal_intersection(bool value);

  // optional bool drive_on_left = 17;
  private:
  bool has_drive_on_left() const;
  public:
  void clear_drive_on_left();
  static const int kDriveOnLeftFieldNumber = 17;
  bool drive_on_left() const;
  void set_drive_on_left(bool value);

  // optional .valhalla.TripLeg.Surface surface = 18;
  private:
  bool has_surface() const;
  public:
  void clear_surface();
  static const int kSurfaceFieldNumber = 18;
  ::valhalla::TripLeg_Surface surface() const;
  void set_surface(::valhalla::TripLeg_Surface value);

  // optional .valhalla.TripSign sign = 19;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 19;
  const ::valhalla::TripSign& sign() const;
  ::valhalla::TripSign* mutable_sign();
  ::valhalla::TripSign* release_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);

  // optional .valhalla.TravelMode travel_mode = 20;
  private:
  bool has_travel_mode() const;
  public:
  void clear_travel_mode();
  static const int kTravelModeFieldNumber = 20;
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);

  // optional .valhalla.VehicleType vehicle_type = 21;
  private:
  bool has_vehicle_type() const;
  public:
  void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 21;
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);

  // optional .valhalla.PedestrianType pedestrian_type = 22;
  private:
  bool has_pedestrian_type() const;
  public:
  void clear_pedestrian_type();
  static const int kPedestrianTypeFieldNumber = 22;
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);

  // optional .valhalla.BicycleType bicycle_type = 23;
  private:
  bool has_bicycle_type() const;
  public:
  void clear_bicycle_type();
  static const int kBicycleTypeFieldNumber = 23;
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);

  // optional .valhalla.TransitType transit_type = 24;
  private:
  bool has_transit_type() const;
  public:
  void clear_transit_type();
  static const int kTransitTypeFieldNumber = 24;
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);

  // optional .valhalla.TransitRouteInfo transit_route_info = 25;
  bool has_transit_route_info() const;
  void clear_transit_route_info();
  static const int kTransitRouteInfoFieldNumber = 25;
  const ::valhalla::TransitRouteInfo& transit_route_info() const;
  ::valhalla::TransitRouteInfo* mutable_transit_route_info();
  ::valhalla::TransitRouteInfo* release_transit_route_info();
  void set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info);

  // optional uint64 id = 26;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 26;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional uint64 way_id = 27;
  private:
  bool has_way_id() const;
  public:
  void clear_way_id();
  static const int kWayIdFieldNumber = 27;
  ::google::protobuf::uint64 way_id() const;
  void set_way_id(::google::protobuf::uint64 value);

  // optional float weighted_grade = 28;
  private:
  bool has_weighted_grade() const;
  public:
  void clear_weighted_grade();
  static const int kWeightedGradeFieldNumber = 28;
  float weighted_grade() const;
  void set_weighted_grade(float value);

  // optional int32 max_upward_grade = 29;
  private:
  bool has_max_upward_grade() const;
  public:
  void clear_max_upward_grade();
  static const int kMaxUpwardGradeFieldNumber = 29;
  ::google::protobuf::int32 max_upward_grade() const;
  void set_max_upward_grade(::google::protobuf::int32 value);

  // optional int32 max_downward_grade = 30;
  private:
  bool has_max_downward_grade() const;
  public:
  void clear_max_downward_grade();
  static const int kMaxDownwardGradeFieldNumber = 30;
  ::google::protobuf::int32 max_downward_grade() const;
  void set_max_downward_grade(::google::protobuf::int32 value);

  // optional uint32 lane_count = 31;
  private:
  bool has_lane_count() const;
  public:
  void clear_lane_count();
  static const int kLaneCountFieldNumber = 31;
  ::google::protobuf::uint32 lane_count() const;
  void set_lane_count(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
  private:
  bool has_cycle_lane() const;
  public:
  void clear_cycle_lane();
  static const int kCycleLaneFieldNumber = 32;
  ::valhalla::TripLeg_CycleLane cycle_lane() const;
  void set_cycle_lane(::valhalla::TripLeg_CycleLane value);

  // optional uint32 bicycle_network = 33;
  private:
  bool has_bicycle_network() const;
  public:
  void clear_bicycle_network();
  static const int kBicycleNetworkFieldNumber = 33;
  ::google::protobuf::uint32 bicycle_network() const;
  void set_bicycle_network(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
  private:
  bool has_sidewalk() const;
  public:
  void clear_sidewalk();
  static const int kSidewalkFieldNumber = 34;
  ::valhalla::TripLeg_Sidewalk sidewalk() const;
  void set_sidewalk(::valhalla::TripLeg_Sidewalk value);

  // optional uint32 density = 35;
  private:
  bool has_density() const;
  public:
  void clear_density();
  static const int kDensityFieldNumber = 35;
  ::google::protobuf::uint32 density() const;
  void set_density(::google::protobuf::uint32 value);

  // optional uint32 speed_limit = 36;
  private:
  bool has_speed_limit() const;
  public:
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 36;
  ::google::protobuf::uint32 speed_limit() const;
  void set_speed_limit(::google::protobuf::uint32 value);

  // optional float truck_speed = 37;
  private:
  bool has_truck_speed() const;
  public:
  void clear_truck_speed();
  static const int kTruckSpeedFieldNumber = 37;
  float truck_speed() const;
  void set_truck_speed(float value);

  // optional bool truck_route = 38;
  private:
  bool has_truck_route() const;
  public:
  void clear_truck_route();
  static const int kTruckRouteFieldNumber = 38;
  bool truck_route() const;
  void set_truck_route(bool value);

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  int lane_connectivity_size() const;
  void clear_lane_connectivity();
  static const int kLaneConnectivityFieldNumber = 39;
  const ::valhalla::TripLeg_LaneConnectivity& lane_connectivity(int index) const;
  ::valhalla::TripLeg_LaneConnectivity* mutable_lane_connectivity(int index);
  ::valhalla::TripLeg_LaneConnectivity* add_lane_connectivity();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
      mutable_lane_connectivity();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
      lane_connectivity() const;

  // optional int32 mean_elevation = 40;
  private:
  bool has_mean_elevation() const;
  public:
  void clear_mean_elevation();
  static const int kMeanElevationFieldNumber = 40;
  ::google::protobuf::int32 mean_elevation() const;
  void set_mean_elevation(::google::protobuf::int32 value);

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  int traffic_segment_size() const;
  void clear_traffic_segment();
  static const int kTrafficSegmentFieldNumber = 41;
  const ::valhalla::TripLeg_TrafficSegment& traffic_segment(int index) const;
  ::valhalla::TripLeg_TrafficSegment* mutable_traffic_segment(int index);
  ::valhalla::TripLeg_TrafficSegment* add_traffic_segment();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
      mutable_traffic_segment();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
      traffic_segment() const;

  // repeated .valhalla.TurnLane turn_lanes = 42;
  int turn_lanes_size() const;
  void clear_turn_lanes();
  static const int kTurnLanesFieldNumber = 42;
  const ::valhalla::TurnLane& turn_lanes(int index) const;
  ::valhalla::TurnLane* mutable_turn_lanes(int index);
  ::valhalla::TurnLane* add_turn_lanes();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >*
      mutable_turn_lanes();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >&
      turn_lanes() const;

  // optional bool has_time_restrictions = 43;
  private:
  bool has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  static const int kHasTimeRestrictionsFieldNumber = 43;
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);

  // optional float default_speed = 44;
  private:
  bool has_default_speed() const;
  public:
  void clear_default_speed();
  static const int kDefaultSpeedFieldNumber = 44;
  float default_speed() const;
  void set_default_speed(float value);

  // optional .valhalla.TripLeg.Restriction restriction = 45;
  bool has_restriction() const;
  void clear_restriction();
  static const int kRestrictionFieldNumber = 45;
  const ::valhalla::TripLeg_Restriction& restriction() const;
  ::valhalla::TripLeg_Restriction* mutable_restriction();
  ::valhalla::TripLeg_Restriction* release_restriction();
  void set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction);

  // optional bool destination_only = 46;
  private:
  bool has_destination_only() const;
  public:
  void clear_destination_only();
  static const int kDestinationOnlyFieldNumber = 46;
  bool destination_only() const;
  void set_destination_only(bool value);

  // optional bool is_urban = 47;
  private:
  bool has_is_urban() const;
  public:
  void clear_is_urban();
  static const int kIsUrbanFieldNumber = 47;
  bool is_urban() const;
  void set_is_urban(bool value);

  // repeated .valhalla.TaggedValue tagged_value = 48;
  int tagged_value_size() const;
  void clear_tagged_value();
  static const int kTaggedValueFieldNumber = 48;
  const ::valhalla::TaggedValue& tagged_value(int index) const;
  ::valhalla::TaggedValue* mutable_tagged_value(int index);
  ::valhalla::TaggedValue* add_tagged_value();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >*
      mutable_tagged_value();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >&
      tagged_value() const;

  // optional float source_along_edge = 49;
  private:
  bool has_source_along_edge() const;
  public:
  void clear_source_along_edge();
  static const int kSourceAlongEdgeFieldNumber = 49;
  float source_along_edge() const;
  void set_source_along_edge(float value);

  // optional float target_along_edge = 50;
  private:
  bool has_target_along_edge() const;
  public:
  void clear_target_along_edge();
  static const int kTargetAlongEdgeFieldNumber = 50;
  float target_along_edge() const;
  void set_target_along_edge(float value);

  // optional .valhalla.TripLeg.SacScale sac_scale = 51;
  private:
  bool has_sac_scale() const;
  public:
  void clear_sac_scale();
  static const int kSacScaleFieldNumber = 51;
  ::valhalla::TripLeg_SacScale sac_scale() const;
  void set_sac_scale(::valhalla::TripLeg_SacScale value);

  // optional bool shoulder = 52;
  private:
  bool has_shoulder() const;
  public:
  void clear_shoulder();
  static const int kShoulderFieldNumber = 52;
  bool shoulder() const;
  void set_shoulder(bool value);

  // optional float total_length_km = 53;
  private:
  bool has_total_length_km() const;
  public:
  void clear_total_length_km();
  static const int kTotalLengthKmFieldNumber = 53;
  float total_length_km() const;
  void set_total_length_km(float value);

  // optional int64 shortcut_id = 54;
  private:
  bool has_shortcut_id() const;
  public:
  void clear_shortcut_id();
  static const int kShortcutIdFieldNumber = 54;
  ::google::protobuf::int64 shortcut_id() const;
  void set_shortcut_id(::google::protobuf::int64 value);

  HasLengthKmCase has_length_km_case() const;
  HasSpeedCase has_speed_case() const;
  HasRoadClassCase has_road_class_case() const;
  HasBeginHeadingCase has_begin_heading_case() const;
  HasEndHeadingCase has_end_heading_case() const;
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  HasEndShapeIndexCase has_end_shape_index_case() const;
  HasTraversabilityCase has_traversability_case() const;
  HasUseCase has_use_case() const;
  HasTollCase has_toll_case() const;
  HasUnpavedCase has_unpaved_case() const;
  HasTunnelCase has_tunnel_case() const;
  HasBridgeCase has_bridge_case() const;
  HasRoundaboutCase has_roundabout_case() const;
  HasInternalIntersectionCase has_internal_intersection_case() const;
  HasDriveOnLeftCase has_drive_on_left_case() const;
  HasSurfaceCase has_surface_case() const;
  HasTravelModeCase has_travel_mode_case() const;
  HasVehicleTypeCase has_vehicle_type_case() const;
  HasPedestrianTypeCase has_pedestrian_type_case() const;
  HasBicycleTypeCase has_bicycle_type_case() const;
  HasTransitTypeCase has_transit_type_case() const;
  HasIdCase has_id_case() const;
  HasWayIdCase has_way_id_case() const;
  HasWeightedGradeCase has_weighted_grade_case() const;
  HasMaxUpwardGradeCase has_max_upward_grade_case() const;
  HasMaxDownwardGradeCase has_max_downward_grade_case() const;
  HasLaneCountCase has_lane_count_case() const;
  HasCycleLaneCase has_cycle_lane_case() const;
  HasBicycleNetworkCase has_bicycle_network_case() const;
  HasSidewalkCase has_sidewalk_case() const;
  HasDensityCase has_density_case() const;
  HasSpeedLimitCase has_speed_limit_case() const;
  HasTruckSpeedCase has_truck_speed_case() const;
  HasTruckRouteCase has_truck_route_case() const;
  HasMeanElevationCase has_mean_elevation_case() const;
  HasHasTimeRestrictionsCase has_has_time_restrictions_case() const;
  HasDefaultSpeedCase has_default_speed_case() const;
  HasDestinationOnlyCase has_destination_only_case() const;
  HasIsUrbanCase has_is_urban_case() const;
  HasSourceAlongEdgeCase has_source_along_edge_case() const;
  HasTargetAlongEdgeCase has_target_along_edge_case() const;
  HasSacScaleCase has_sac_scale_case() const;
  HasShoulderCase has_shoulder_case() const;
  HasTotalLengthKmCase has_total_length_km_case() const;
  HasShortcutIdCase has_shortcut_id_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Edge)
 private:
  inline void set_has_length_km();
  inline void set_has_speed();
  inline void set_has_road_class();
  inline void set_has_begin_heading();
  inline void set_has_end_heading();
  inline void set_has_begin_shape_index();
  inline void set_has_end_shape_index();
  inline void set_has_traversability();
  inline void set_has_use();
  inline void set_has_toll();
  inline void set_has_unpaved();
  inline void set_has_tunnel();
  inline void set_has_bridge();
  inline void set_has_roundabout();
  inline void set_has_internal_intersection();
  inline void set_has_drive_on_left();
  inline void set_has_surface();
  inline void set_has_travel_mode();
  inline void set_has_vehicle_type();
  inline void set_has_pedestrian_type();
  inline void set_has_bicycle_type();
  inline void set_has_transit_type();
  inline void set_has_id();
  inline void set_has_way_id();
  inline void set_has_weighted_grade();
  inline void set_has_max_upward_grade();
  inline void set_has_max_downward_grade();
  inline void set_has_lane_count();
  inline void set_has_cycle_lane();
  inline void set_has_bicycle_network();
  inline void set_has_sidewalk();
  inline void set_has_density();
  inline void set_has_speed_limit();
  inline void set_has_truck_speed();
  inline void set_has_truck_route();
  inline void set_has_mean_elevation();
  inline void set_has_has_time_restrictions();
  inline void set_has_default_speed();
  inline void set_has_destination_only();
  inline void set_has_is_urban();
  inline void set_has_source_along_edge();
  inline void set_has_target_along_edge();
  inline void set_has_sac_scale();
  inline void set_has_shoulder();
  inline void set_has_total_length_km();
  inline void set_has_shortcut_id();

  inline bool has_has_length_km() const;
  void clear_has_length_km();
  inline void clear_has_has_length_km();

  inline bool has_has_speed() const;
  void clear_has_speed();
  inline void clear_has_has_speed();

  inline bool has_has_road_class() const;
  void clear_has_road_class();
  inline void clear_has_has_road_class();

  inline bool has_has_begin_heading() const;
  void clear_has_begin_heading();
  inline void clear_has_has_begin_heading();

  inline bool has_has_end_heading() const;
  void clear_has_end_heading();
  inline void clear_has_has_end_heading();

  inline bool has_has_begin_shape_index() const;
  void clear_has_begin_shape_index();
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  void clear_has_end_shape_index();
  inline void clear_has_has_end_shape_index();

  inline bool has_has_traversability() const;
  void clear_has_traversability();
  inline void clear_has_has_traversability();

  inline bool has_has_use() const;
  void clear_has_use();
  inline void clear_has_has_use();

  inline bool has_has_toll() const;
  void clear_has_toll();
  inline void clear_has_has_toll();

  inline bool has_has_unpaved() const;
  void clear_has_unpaved();
  inline void clear_has_has_unpaved();

  inline bool has_has_tunnel() const;
  void clear_has_tunnel();
  inline void clear_has_has_tunnel();

  inline bool has_has_bridge() const;
  void clear_has_bridge();
  inline void clear_has_has_bridge();

  inline bool has_has_roundabout() const;
  void clear_has_roundabout();
  inline void clear_has_has_roundabout();

  inline bool has_has_internal_intersection() const;
  void clear_has_internal_intersection();
  inline void clear_has_has_internal_intersection();

  inline bool has_has_drive_on_left() const;
  void clear_has_drive_on_left();
  inline void clear_has_has_drive_on_left();

  inline bool has_has_surface() const;
  void clear_has_surface();
  inline void clear_has_has_surface();

  inline bool has_has_travel_mode() const;
  void clear_has_travel_mode();
  inline void clear_has_has_travel_mode();

  inline bool has_has_vehicle_type() const;
  void clear_has_vehicle_type();
  inline void clear_has_has_vehicle_type();

  inline bool has_has_pedestrian_type() const;
  void clear_has_pedestrian_type();
  inline void clear_has_has_pedestrian_type();

  inline bool has_has_bicycle_type() const;
  void clear_has_bicycle_type();
  inline void clear_has_has_bicycle_type();

  inline bool has_has_transit_type() const;
  void clear_has_transit_type();
  inline void clear_has_has_transit_type();

  inline bool has_has_id() const;
  void clear_has_id();
  inline void clear_has_has_id();

  inline bool has_has_way_id() const;
  void clear_has_way_id();
  inline void clear_has_has_way_id();

  inline bool has_has_weighted_grade() const;
  void clear_has_weighted_grade();
  inline void clear_has_has_weighted_grade();

  inline bool has_has_max_upward_grade() const;
  void clear_has_max_upward_grade();
  inline void clear_has_has_max_upward_grade();

  inline bool has_has_max_downward_grade() const;
  void clear_has_max_downward_grade();
  inline void clear_has_has_max_downward_grade();

  inline bool has_has_lane_count() const;
  void clear_has_lane_count();
  inline void clear_has_has_lane_count();

  inline bool has_has_cycle_lane() const;
  void clear_has_cycle_lane();
  inline void clear_has_has_cycle_lane();

  inline bool has_has_bicycle_network() const;
  void clear_has_bicycle_network();
  inline void clear_has_has_bicycle_network();

  inline bool has_has_sidewalk() const;
  void clear_has_sidewalk();
  inline void clear_has_has_sidewalk();

  inline bool has_has_density() const;
  void clear_has_density();
  inline void clear_has_has_density();

  inline bool has_has_speed_limit() const;
  void clear_has_speed_limit();
  inline void clear_has_has_speed_limit();

  inline bool has_has_truck_speed() const;
  void clear_has_truck_speed();
  inline void clear_has_has_truck_speed();

  inline bool has_has_truck_route() const;
  void clear_has_truck_route();
  inline void clear_has_has_truck_route();

  inline bool has_has_mean_elevation() const;
  void clear_has_mean_elevation();
  inline void clear_has_has_mean_elevation();

  inline bool has_has_has_time_restrictions() const;
  void clear_has_has_time_restrictions();
  inline void clear_has_has_has_time_restrictions();

  inline bool has_has_default_speed() const;
  void clear_has_default_speed();
  inline void clear_has_has_default_speed();

  inline bool has_has_destination_only() const;
  void clear_has_destination_only();
  inline void clear_has_has_destination_only();

  inline bool has_has_is_urban() const;
  void clear_has_is_urban();
  inline void clear_has_has_is_urban();

  inline bool has_has_source_along_edge() const;
  void clear_has_source_along_edge();
  inline void clear_has_has_source_along_edge();

  inline bool has_has_target_along_edge() const;
  void clear_has_target_along_edge();
  inline void clear_has_has_target_along_edge();

  inline bool has_has_sac_scale() const;
  void clear_has_sac_scale();
  inline void clear_has_has_sac_scale();

  inline bool has_has_shoulder() const;
  void clear_has_shoulder();
  inline void clear_has_has_shoulder();

  inline bool has_has_total_length_km() const;
  void clear_has_total_length_km();
  inline void clear_has_has_total_length_km();

  inline bool has_has_shortcut_id() const;
  void clear_has_shortcut_id();
  inline void clear_has_has_shortcut_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > name_;
  ::valhalla::TripSign* sign_;
  ::valhalla::TransitRouteInfo* transit_route_info_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity > lane_connectivity_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment > traffic_segment_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane > turn_lanes_;
  ::valhalla::TripLeg_Restriction* restriction_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue > tagged_value_;
  union HasLengthKmUnion {
    HasLengthKmUnion() {}
    float length_km_;
  } has_length_km_;
  union HasSpeedUnion {
    HasSpeedUnion() {}
    float speed_;
  } has_speed_;
  union HasRoadClassUnion {
    HasRoadClassUnion() {}
    int road_class_;
  } has_road_class_;
  union HasBeginHeadingUnion {
    HasBeginHeadingUnion() {}
    ::google::protobuf::uint32 begin_heading_;
  } has_begin_heading_;
  union HasEndHeadingUnion {
    HasEndHeadingUnion() {}
    ::google::protobuf::uint32 end_heading_;
  } has_end_heading_;
  union HasBeginShapeIndexUnion {
    HasBeginShapeIndexUnion() {}
    ::google::protobuf::uint32 begin_shape_index_;
  } has_begin_shape_index_;
  union HasEndShapeIndexUnion {
    HasEndShapeIndexUnion() {}
    ::google::protobuf::uint32 end_shape_index_;
  } has_end_shape_index_;
  union HasTraversabilityUnion {
    HasTraversabilityUnion() {}
    int traversability_;
  } has_traversability_;
  union HasUseUnion {
    HasUseUnion() {}
    int use_;
  } has_use_;
  union HasTollUnion {
    HasTollUnion() {}
    bool toll_;
  } has_toll_;
  union HasUnpavedUnion {
    HasUnpavedUnion() {}
    bool unpaved_;
  } has_unpaved_;
  union HasTunnelUnion {
    HasTunnelUnion() {}
    bool tunnel_;
  } has_tunnel_;
  union HasBridgeUnion {
    HasBridgeUnion() {}
    bool bridge_;
  } has_bridge_;
  union HasRoundaboutUnion {
    HasRoundaboutUnion() {}
    bool roundabout_;
  } has_roundabout_;
  union HasInternalIntersectionUnion {
    HasInternalIntersectionUnion() {}
    bool internal_intersection_;
  } has_internal_intersection_;
  union HasDriveOnLeftUnion {
    HasDriveOnLeftUnion() {}
    bool drive_on_left_;
  } has_drive_on_left_;
  union HasSurfaceUnion {
    HasSurfaceUnion() {}
    int surface_;
  } has_surface_;
  union HasTravelModeUnion {
    HasTravelModeUnion() {}
    int travel_mode_;
  } has_travel_mode_;
  union HasVehicleTypeUnion {
    HasVehicleTypeUnion() {}
    int vehicle_type_;
  } has_vehicle_type_;
  union HasPedestrianTypeUnion {
    HasPedestrianTypeUnion() {}
    int pedestrian_type_;
  } has_pedestrian_type_;
  union HasBicycleTypeUnion {
    HasBicycleTypeUnion() {}
    int bicycle_type_;
  } has_bicycle_type_;
  union HasTransitTypeUnion {
    HasTransitTypeUnion() {}
    int transit_type_;
  } has_transit_type_;
  union HasIdUnion {
    HasIdUnion() {}
    ::google::protobuf::uint64 id_;
  } has_id_;
  union HasWayIdUnion {
    HasWayIdUnion() {}
    ::google::protobuf::uint64 way_id_;
  } has_way_id_;
  union HasWeightedGradeUnion {
    HasWeightedGradeUnion() {}
    float weighted_grade_;
  } has_weighted_grade_;
  union HasMaxUpwardGradeUnion {
    HasMaxUpwardGradeUnion() {}
    ::google::protobuf::int32 max_upward_grade_;
  } has_max_upward_grade_;
  union HasMaxDownwardGradeUnion {
    HasMaxDownwardGradeUnion() {}
    ::google::protobuf::int32 max_downward_grade_;
  } has_max_downward_grade_;
  union HasLaneCountUnion {
    HasLaneCountUnion() {}
    ::google::protobuf::uint32 lane_count_;
  } has_lane_count_;
  union HasCycleLaneUnion {
    HasCycleLaneUnion() {}
    int cycle_lane_;
  } has_cycle_lane_;
  union HasBicycleNetworkUnion {
    HasBicycleNetworkUnion() {}
    ::google::protobuf::uint32 bicycle_network_;
  } has_bicycle_network_;
  union HasSidewalkUnion {
    HasSidewalkUnion() {}
    int sidewalk_;
  } has_sidewalk_;
  union HasDensityUnion {
    HasDensityUnion() {}
    ::google::protobuf::uint32 density_;
  } has_density_;
  union HasSpeedLimitUnion {
    HasSpeedLimitUnion() {}
    ::google::protobuf::uint32 speed_limit_;
  } has_speed_limit_;
  union HasTruckSpeedUnion {
    HasTruckSpeedUnion() {}
    float truck_speed_;
  } has_truck_speed_;
  union HasTruckRouteUnion {
    HasTruckRouteUnion() {}
    bool truck_route_;
  } has_truck_route_;
  union HasMeanElevationUnion {
    HasMeanElevationUnion() {}
    ::google::protobuf::int32 mean_elevation_;
  } has_mean_elevation_;
  union HasHasTimeRestrictionsUnion {
    HasHasTimeRestrictionsUnion() {}
    bool has_time_restrictions_;
  } has_has_time_restrictions_;
  union HasDefaultSpeedUnion {
    HasDefaultSpeedUnion() {}
    float default_speed_;
  } has_default_speed_;
  union HasDestinationOnlyUnion {
    HasDestinationOnlyUnion() {}
    bool destination_only_;
  } has_destination_only_;
  union HasIsUrbanUnion {
    HasIsUrbanUnion() {}
    bool is_urban_;
  } has_is_urban_;
  union HasSourceAlongEdgeUnion {
    HasSourceAlongEdgeUnion() {}
    float source_along_edge_;
  } has_source_along_edge_;
  union HasTargetAlongEdgeUnion {
    HasTargetAlongEdgeUnion() {}
    float target_along_edge_;
  } has_target_along_edge_;
  union HasSacScaleUnion {
    HasSacScaleUnion() {}
    int sac_scale_;
  } has_sac_scale_;
  union HasShoulderUnion {
    HasShoulderUnion() {}
    bool shoulder_;
  } has_shoulder_;
  union HasTotalLengthKmUnion {
    HasTotalLengthKmUnion() {}
    float total_length_km_;
  } has_total_length_km_;
  union HasShortcutIdUnion {
    HasShortcutIdUnion() {}
    ::google::protobuf::int64 shortcut_id_;
  } has_shortcut_id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[46];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Edge* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_IntersectingEdge : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.IntersectingEdge) */ {
 public:
  TripLeg_IntersectingEdge();
  virtual ~TripLeg_IntersectingEdge();

  TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from);

  inline TripLeg_IntersectingEdge& operator=(const TripLeg_IntersectingEdge& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_IntersectingEdge& default_instance();

  enum HasBeginHeadingCase {
    kBeginHeading = 1,
    HAS_BEGIN_HEADING_NOT_SET = 0,
  };

  enum HasPrevNameConsistencyCase {
    kPrevNameConsistency = 2,
    HAS_PREV_NAME_CONSISTENCY_NOT_SET = 0,
  };

  enum HasCurrNameConsistencyCase {
    kCurrNameConsistency = 3,
    HAS_CURR_NAME_CONSISTENCY_NOT_SET = 0,
  };

  enum HasDriveabilityCase {
    kDriveability = 4,
    HAS_DRIVEABILITY_NOT_SET = 0,
  };

  enum HasCyclabilityCase {
    kCyclability = 5,
    HAS_CYCLABILITY_NOT_SET = 0,
  };

  enum HasWalkabilityCase {
    kWalkability = 6,
    HAS_WALKABILITY_NOT_SET = 0,
  };

  enum HasUseCase {
    kUse = 7,
    HAS_USE_NOT_SET = 0,
  };

  enum HasRoadClassCase {
    kRoadClass = 8,
    HAS_ROAD_CLASS_NOT_SET = 0,
  };

  enum HasLaneCountCase {
    kLaneCount = 9,
    HAS_LANE_COUNT_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_IntersectingEdge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_IntersectingEdge* other);

  // implements Message ----------------------------------------------

  inline TripLeg_IntersectingEdge* New() const { return New(NULL); }

  TripLeg_IntersectingEdge* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_IntersectingEdge& from);
  void MergeFrom(const TripLeg_IntersectingEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_IntersectingEdge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 begin_heading = 1;
  private:
  bool has_begin_heading() const;
  public:
  void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 1;
  ::google::protobuf::uint32 begin_heading() const;
  void set_begin_heading(::google::protobuf::uint32 value);

  // optional bool prev_name_consistency = 2;
  private:
  bool has_prev_name_consistency() const;
  public:
  void clear_prev_name_consistency();
  static const int kPrevNameConsistencyFieldNumber = 2;
  bool prev_name_consistency() const;
  void set_prev_name_consistency(bool value);

  // optional bool curr_name_consistency = 3;
  private:
  bool has_curr_name_consistency() const;
  public:
  void clear_curr_name_consistency();
  static const int kCurrNameConsistencyFieldNumber = 3;
  bool curr_name_consistency() const;
  void set_curr_name_consistency(bool value);

  // optional .valhalla.TripLeg.Traversability driveability = 4;
  private:
  bool has_driveability() const;
  public:
  void clear_driveability();
  static const int kDriveabilityFieldNumber = 4;
  ::valhalla::TripLeg_Traversability driveability() const;
  void set_driveability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Traversability cyclability = 5;
  private:
  bool has_cyclability() const;
  public:
  void clear_cyclability();
  static const int kCyclabilityFieldNumber = 5;
  ::valhalla::TripLeg_Traversability cyclability() const;
  void set_cyclability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Traversability walkability = 6;
  private:
  bool has_walkability() const;
  public:
  void clear_walkability();
  static const int kWalkabilityFieldNumber = 6;
  ::valhalla::TripLeg_Traversability walkability() const;
  void set_walkability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Use use = 7;
  private:
  bool has_use() const;
  public:
  void clear_use();
  static const int kUseFieldNumber = 7;
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);

  // optional .valhalla.RoadClass road_class = 8;
  private:
  bool has_road_class() const;
  public:
  void clear_road_class();
  static const int kRoadClassFieldNumber = 8;
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);

  // optional uint32 lane_count = 9;
  private:
  bool has_lane_count() const;
  public:
  void clear_lane_count();
  static const int kLaneCountFieldNumber = 9;
  ::google::protobuf::uint32 lane_count() const;
  void set_lane_count(::google::protobuf::uint32 value);

  // optional .valhalla.TripSign sign = 10;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 10;
  const ::valhalla::TripSign& sign() const;
  ::valhalla::TripSign* mutable_sign();
  ::valhalla::TripSign* release_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);

  HasBeginHeadingCase has_begin_heading_case() const;
  HasPrevNameConsistencyCase has_prev_name_consistency_case() const;
  HasCurrNameConsistencyCase has_curr_name_consistency_case() const;
  HasDriveabilityCase has_driveability_case() const;
  HasCyclabilityCase has_cyclability_case() const;
  HasWalkabilityCase has_walkability_case() const;
  HasUseCase has_use_case() const;
  HasRoadClassCase has_road_class_case() const;
  HasLaneCountCase has_lane_count_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.IntersectingEdge)
 private:
  inline void set_has_begin_heading();
  inline void set_has_prev_name_consistency();
  inline void set_has_curr_name_consistency();
  inline void set_has_driveability();
  inline void set_has_cyclability();
  inline void set_has_walkability();
  inline void set_has_use();
  inline void set_has_road_class();
  inline void set_has_lane_count();

  inline bool has_has_begin_heading() const;
  void clear_has_begin_heading();
  inline void clear_has_has_begin_heading();

  inline bool has_has_prev_name_consistency() const;
  void clear_has_prev_name_consistency();
  inline void clear_has_has_prev_name_consistency();

  inline bool has_has_curr_name_consistency() const;
  void clear_has_curr_name_consistency();
  inline void clear_has_has_curr_name_consistency();

  inline bool has_has_driveability() const;
  void clear_has_driveability();
  inline void clear_has_has_driveability();

  inline bool has_has_cyclability() const;
  void clear_has_cyclability();
  inline void clear_has_has_cyclability();

  inline bool has_has_walkability() const;
  void clear_has_walkability();
  inline void clear_has_has_walkability();

  inline bool has_has_use() const;
  void clear_has_use();
  inline void clear_has_has_use();

  inline bool has_has_road_class() const;
  void clear_has_road_class();
  inline void clear_has_has_road_class();

  inline bool has_has_lane_count() const;
  void clear_has_lane_count();
  inline void clear_has_has_lane_count();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::valhalla::TripSign* sign_;
  union HasBeginHeadingUnion {
    HasBeginHeadingUnion() {}
    ::google::protobuf::uint32 begin_heading_;
  } has_begin_heading_;
  union HasPrevNameConsistencyUnion {
    HasPrevNameConsistencyUnion() {}
    bool prev_name_consistency_;
  } has_prev_name_consistency_;
  union HasCurrNameConsistencyUnion {
    HasCurrNameConsistencyUnion() {}
    bool curr_name_consistency_;
  } has_curr_name_consistency_;
  union HasDriveabilityUnion {
    HasDriveabilityUnion() {}
    int driveability_;
  } has_driveability_;
  union HasCyclabilityUnion {
    HasCyclabilityUnion() {}
    int cyclability_;
  } has_cyclability_;
  union HasWalkabilityUnion {
    HasWalkabilityUnion() {}
    int walkability_;
  } has_walkability_;
  union HasUseUnion {
    HasUseUnion() {}
    int use_;
  } has_use_;
  union HasRoadClassUnion {
    HasRoadClassUnion() {}
    int road_class_;
  } has_road_class_;
  union HasLaneCountUnion {
    HasLaneCountUnion() {}
    ::google::protobuf::uint32 lane_count_;
  } has_lane_count_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[9];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_IntersectingEdge* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Cost : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Cost) */ {
 public:
  TripLeg_Cost();
  virtual ~TripLeg_Cost();

  TripLeg_Cost(const TripLeg_Cost& from);

  inline TripLeg_Cost& operator=(const TripLeg_Cost& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Cost& default_instance();

  enum HasSecondsCase {
    kSeconds = 1,
    HAS_SECONDS_NOT_SET = 0,
  };

  enum HasCostCase {
    kCost = 2,
    HAS_COST_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Cost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Cost* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Cost* New() const { return New(NULL); }

  TripLeg_Cost* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Cost& from);
  void MergeFrom(const TripLeg_Cost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Cost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double seconds = 1;
  private:
  bool has_seconds() const;
  public:
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  double seconds() const;
  void set_seconds(double value);

  // optional double cost = 2;
  private:
  bool has_cost() const;
  public:
  void clear_cost();
  static const int kCostFieldNumber = 2;
  double cost() const;
  void set_cost(double value);

  HasSecondsCase has_seconds_case() const;
  HasCostCase has_cost_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Cost)
 private:
  inline void set_has_seconds();
  inline void set_has_cost();

  inline bool has_has_seconds() const;
  void clear_has_seconds();
  inline void clear_has_has_seconds();

  inline bool has_has_cost() const;
  void clear_has_cost();
  inline void clear_has_has_cost();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasSecondsUnion {
    HasSecondsUnion() {}
    double seconds_;
  } has_seconds_;
  union HasCostUnion {
    HasCostUnion() {}
    double cost_;
  } has_cost_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Cost* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_PathCost : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.PathCost) */ {
 public:
  TripLeg_PathCost();
  virtual ~TripLeg_PathCost();

  TripLeg_PathCost(const TripLeg_PathCost& from);

  inline TripLeg_PathCost& operator=(const TripLeg_PathCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_PathCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_PathCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_PathCost* other);

  // implements Message ----------------------------------------------

  inline TripLeg_PathCost* New() const { return New(NULL); }

  TripLeg_PathCost* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_PathCost& from);
  void MergeFrom(const TripLeg_PathCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_PathCost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
  bool has_elapsed_cost() const;
  void clear_elapsed_cost();
  static const int kElapsedCostFieldNumber = 1;
  const ::valhalla::TripLeg_Cost& elapsed_cost() const;
  ::valhalla::TripLeg_Cost* mutable_elapsed_cost();
  ::valhalla::TripLeg_Cost* release_elapsed_cost();
  void set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost);

  // optional .valhalla.TripLeg.Cost transition_cost = 2;
  bool has_transition_cost() const;
  void clear_transition_cost();
  static const int kTransitionCostFieldNumber = 2;
  const ::valhalla::TripLeg_Cost& transition_cost() const;
  ::valhalla::TripLeg_Cost* mutable_transition_cost();
  ::valhalla::TripLeg_Cost* release_transition_cost();
  void set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.PathCost)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::valhalla::TripLeg_Cost* elapsed_cost_;
  ::valhalla::TripLeg_Cost* transition_cost_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_PathCost* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Node : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Node) */ {
 public:
  TripLeg_Node();
  virtual ~TripLeg_Node();

  TripLeg_Node(const TripLeg_Node& from);

  inline TripLeg_Node& operator=(const TripLeg_Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Node& default_instance();

  enum HasAdminIndexCase {
    kAdminIndex = 3,
    HAS_ADMIN_INDEX_NOT_SET = 0,
  };

  enum HasTypeCase {
    kType = 4,
    HAS_TYPE_NOT_SET = 0,
  };

  enum HasForkCase {
    kFork = 5,
    HAS_FORK_NOT_SET = 0,
  };

  enum HasTimeZoneCase {
    kTimeZone = 11,
    HAS_TIME_ZONE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Node* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Node* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Node* New() const { return New(NULL); }

  TripLeg_Node* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Node& from);
  void MergeFrom(const TripLeg_Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripLeg_Node_Type Type;
  static const Type kStreetIntersection =
    TripLeg_Node_Type_kStreetIntersection;
  static const Type kGate =
    TripLeg_Node_Type_kGate;
  static const Type kBollard =
    TripLeg_Node_Type_kBollard;
  static const Type kTollBooth =
    TripLeg_Node_Type_kTollBooth;
  static const Type kTransitEgress =
    TripLeg_Node_Type_kTransitEgress;
  static const Type kTransitStation =
    TripLeg_Node_Type_kTransitStation;
  static const Type kTransitPlatform =
    TripLeg_Node_Type_kTransitPlatform;
  static const Type kBikeShare =
    TripLeg_Node_Type_kBikeShare;
  static const Type kParking =
    TripLeg_Node_Type_kParking;
  static const Type kMotorwayJunction =
    TripLeg_Node_Type_kMotorwayJunction;
  static const Type kBorderControl =
    TripLeg_Node_Type_kBorderControl;
  static const Type kTollGantry =
    TripLeg_Node_Type_kTollGantry;
  static const Type kSumpBuster =
    TripLeg_Node_Type_kSumpBuster;
  static inline bool Type_IsValid(int value) {
    return TripLeg_Node_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripLeg_Node_Type_Type_MIN;
  static const Type Type_MAX =
    TripLeg_Node_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripLeg_Node_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.TripLeg.Edge edge = 1;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 1;
  const ::valhalla::TripLeg_Edge& edge() const;
  ::valhalla::TripLeg_Edge* mutable_edge();
  ::valhalla::TripLeg_Edge* release_edge();
  void set_allocated_edge(::valhalla::TripLeg_Edge* edge);

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  int intersecting_edge_size() const;
  void clear_intersecting_edge();
  static const int kIntersectingEdgeFieldNumber = 2;
  const ::valhalla::TripLeg_IntersectingEdge& intersecting_edge(int index) const;
  ::valhalla::TripLeg_IntersectingEdge* mutable_intersecting_edge(int index);
  ::valhalla::TripLeg_IntersectingEdge* add_intersecting_edge();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
      mutable_intersecting_edge();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
      intersecting_edge() const;

  // optional uint32 admin_index = 3;
  private:
  bool has_admin_index() const;
  public:
  void clear_admin_index();
  static const int kAdminIndexFieldNumber = 3;
  ::google::protobuf::uint32 admin_index() const;
  void set_admin_index(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.Node.Type type = 4;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::valhalla::TripLeg_Node_Type type() const;
  void set_type(::valhalla::TripLeg_Node_Type value);

  // optional bool fork = 5;
  private:
  bool has_fork() const;
  public:
  void clear_fork();
  static const int kForkFieldNumber = 5;
  bool fork() const;
  void set_fork(bool value);

  // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
  bool has_transit_platform_info() const;
  void clear_transit_platform_info();
  static const int kTransitPlatformInfoFieldNumber = 6;
  const ::valhalla::TransitPlatformInfo& transit_platform_info() const;
  ::valhalla::TransitPlatformInfo* mutable_transit_platform_info();
  ::valhalla::TransitPlatformInfo* release_transit_platform_info();
  void set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info);

  // optional .valhalla.TransitStationInfo transit_station_info = 7;
  bool has_transit_station_info() const;
  void clear_transit_station_info();
  static const int kTransitStationInfoFieldNumber = 7;
  const ::valhalla::TransitStationInfo& transit_station_info() const;
  ::valhalla::TransitStationInfo* mutable_transit_station_info();
  ::valhalla::TransitStationInfo* release_transit_station_info();
  void set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info);

  // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
  bool has_transit_egress_info() const;
  void clear_transit_egress_info();
  static const int kTransitEgressInfoFieldNumber = 10;
  const ::valhalla::TransitEgressInfo& transit_egress_info() const;
  ::valhalla::TransitEgressInfo* mutable_transit_egress_info();
  ::valhalla::TransitEgressInfo* release_transit_egress_info();
  void set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info);

  // optional string time_zone = 11;
  private:
  bool has_time_zone() const;
  public:
  void clear_time_zone();
  static const int kTimeZoneFieldNumber = 11;
  const ::std::string& time_zone() const;
  void set_time_zone(const ::std::string& value);
  void set_time_zone(const char* value);
  void set_time_zone(const char* value, size_t size);
  ::std::string* mutable_time_zone();
  ::std::string* release_time_zone();
  void set_allocated_time_zone(::std::string* time_zone);

  // optional .valhalla.TripLeg.PathCost cost = 12;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 12;
  const ::valhalla::TripLeg_PathCost& cost() const;
  ::valhalla::TripLeg_PathCost* mutable_cost();
  ::valhalla::TripLeg_PathCost* release_cost();
  void set_allocated_cost(::valhalla::TripLeg_PathCost* cost);

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  int recosts_size() const;
  void clear_recosts();
  static const int kRecostsFieldNumber = 13;
  const ::valhalla::TripLeg_PathCost& recosts(int index) const;
  ::valhalla::TripLeg_PathCost* mutable_recosts(int index);
  ::valhalla::TripLeg_PathCost* add_recosts();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
      mutable_recosts();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
      recosts() const;

  // optional .valhalla.BikeShareStationInfo bss_info = 14;
  bool has_bss_info() const;
  void clear_bss_info();
  static const int kBssInfoFieldNumber = 14;
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  ::valhalla::BikeShareStationInfo* release_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info);

  HasAdminIndexCase has_admin_index_case() const;
  HasTypeCase has_type_case() const;
  HasForkCase has_fork_case() const;
  HasTimeZoneCase has_time_zone_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Node)
 private:
  inline void set_has_admin_index();
  inline void set_has_type();
  inline void set_has_fork();
  inline void set_has_time_zone();

  inline bool has_has_admin_index() const;
  void clear_has_admin_index();
  inline void clear_has_has_admin_index();

  inline bool has_has_type() const;
  void clear_has_type();
  inline void clear_has_has_type();

  inline bool has_has_fork() const;
  void clear_has_fork();
  inline void clear_has_has_fork();

  inline bool has_has_time_zone() const;
  void clear_has_time_zone();
  inline void clear_has_has_time_zone();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::valhalla::TripLeg_Edge* edge_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge > intersecting_edge_;
  ::valhalla::TransitPlatformInfo* transit_platform_info_;
  ::valhalla::TransitStationInfo* transit_station_info_;
  ::valhalla::TransitEgressInfo* transit_egress_info_;
  ::valhalla::TripLeg_PathCost* cost_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost > recosts_;
  ::valhalla::BikeShareStationInfo* bss_info_;
  union HasAdminIndexUnion {
    HasAdminIndexUnion() {}
    ::google::protobuf::uint32 admin_index_;
  } has_admin_index_;
  union HasTypeUnion {
    HasTypeUnion() {}
    int type_;
  } has_type_;
  union HasForkUnion {
    HasForkUnion() {}
    bool fork_;
  } has_fork_;
  union HasTimeZoneUnion {
    HasTimeZoneUnion() {}
    ::google::protobuf::internal::ArenaStringPtr time_zone_;
  } has_time_zone_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Node* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Admin : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Admin) */ {
 public:
  TripLeg_Admin();
  virtual ~TripLeg_Admin();

  TripLeg_Admin(const TripLeg_Admin& from);

  inline TripLeg_Admin& operator=(const TripLeg_Admin& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Admin& default_instance();

  enum HasCountryCodeCase {
    kCountryCode = 1,
    HAS_COUNTRY_CODE_NOT_SET = 0,
  };

  enum HasCountryTextCase {
    kCountryText = 2,
    HAS_COUNTRY_TEXT_NOT_SET = 0,
  };

  enum HasStateCodeCase {
    kStateCode = 3,
    HAS_STATE_CODE_NOT_SET = 0,
  };

  enum HasStateTextCase {
    kStateText = 4,
    HAS_STATE_TEXT_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Admin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Admin* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Admin* New() const { return New(NULL); }

  TripLeg_Admin* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Admin& from);
  void MergeFrom(const TripLeg_Admin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Admin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string country_code = 1;
  private:
  bool has_country_code() const;
  public:
  void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  const ::std::string& country_code() const;
  void set_country_code(const ::std::string& value);
  void set_country_code(const char* value);
  void set_country_code(const char* value, size_t size);
  ::std::string* mutable_country_code();
  ::std::string* release_country_code();
  void set_allocated_country_code(::std::string* country_code);

  // optional string country_text = 2;
  private:
  bool has_country_text() const;
  public:
  void clear_country_text();
  static const int kCountryTextFieldNumber = 2;
  const ::std::string& country_text() const;
  void set_country_text(const ::std::string& value);
  void set_country_text(const char* value);
  void set_country_text(const char* value, size_t size);
  ::std::string* mutable_country_text();
  ::std::string* release_country_text();
  void set_allocated_country_text(::std::string* country_text);

  // optional string state_code = 3;
  private:
  bool has_state_code() const;
  public:
  void clear_state_code();
  static const int kStateCodeFieldNumber = 3;
  const ::std::string& state_code() const;
  void set_state_code(const ::std::string& value);
  void set_state_code(const char* value);
  void set_state_code(const char* value, size_t size);
  ::std::string* mutable_state_code();
  ::std::string* release_state_code();
  void set_allocated_state_code(::std::string* state_code);

  // optional string state_text = 4;
  private:
  bool has_state_text() const;
  public:
  void clear_state_text();
  static const int kStateTextFieldNumber = 4;
  const ::std::string& state_text() const;
  void set_state_text(const ::std::string& value);
  void set_state_text(const char* value);
  void set_state_text(const char* value, size_t size);
  ::std::string* mutable_state_text();
  ::std::string* release_state_text();
  void set_allocated_state_text(::std::string* state_text);

  HasCountryCodeCase has_country_code_case() const;
  HasCountryTextCase has_country_text_case() const;
  HasStateCodeCase has_state_code_case() const;
  HasStateTextCase has_state_text_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Admin)
 private:
  inline void set_has_country_code();
  inline void set_has_country_text();
  inline void set_has_state_code();
  inline void set_has_state_text();

  inline bool has_has_country_code() const;
  void clear_has_country_code();
  inline void clear_has_has_country_code();

  inline bool has_has_country_text() const;
  void clear_has_country_text();
  inline void clear_has_has_country_text();

  inline bool has_has_state_code() const;
  void clear_has_state_code();
  inline void clear_has_has_state_code();

  inline bool has_has_state_text() const;
  void clear_has_state_text();
  inline void clear_has_has_state_text();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasCountryCodeUnion {
    HasCountryCodeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr country_code_;
  } has_country_code_;
  union HasCountryTextUnion {
    HasCountryTextUnion() {}
    ::google::protobuf::internal::ArenaStringPtr country_text_;
  } has_country_text_;
  union HasStateCodeUnion {
    HasStateCodeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr state_code_;
  } has_state_code_;
  union HasStateTextUnion {
    HasStateTextUnion() {}
    ::google::protobuf::internal::ArenaStringPtr state_text_;
  } has_state_text_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Admin* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_ShapeAttributes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.ShapeAttributes) */ {
 public:
  TripLeg_ShapeAttributes();
  virtual ~TripLeg_ShapeAttributes();

  TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from);

  inline TripLeg_ShapeAttributes& operator=(const TripLeg_ShapeAttributes& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_ShapeAttributes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_ShapeAttributes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_ShapeAttributes* other);

  // implements Message ----------------------------------------------

  inline TripLeg_ShapeAttributes* New() const { return New(NULL); }

  TripLeg_ShapeAttributes* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_ShapeAttributes& from);
  void MergeFrom(const TripLeg_ShapeAttributes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_ShapeAttributes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 time = 1 [packed = true];
  int time_size() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint32 time(int index) const;
  void set_time(int index, ::google::protobuf::uint32 value);
  void add_time(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      time() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_time();

  // repeated uint32 length = 2 [packed = true];
  int length_size() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length(int index) const;
  void set_length(int index, ::google::protobuf::uint32 value);
  void add_length(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      length() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_length();

  // repeated uint32 speed = 3 [packed = true];
  int speed_size() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  ::google::protobuf::uint32 speed(int index) const;
  void set_speed(int index, ::google::protobuf::uint32 value);
  void add_speed(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      speed() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_speed();

  // repeated uint32 speed_limit = 5 [packed = true];
  int speed_limit_size() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 5;
  ::google::protobuf::uint32 speed_limit(int index) const;
  void set_speed_limit(int index, ::google::protobuf::uint32 value);
  void add_speed_limit(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      speed_limit() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_speed_limit();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.ShapeAttributes)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > time_;
  mutable int _time_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > length_;
  mutable int _length_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > speed_;
  mutable int _speed_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > speed_limit_;
  mutable int _speed_limit_cached_byte_size_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_ShapeAttributes* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Incident : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Incident) */ {
 public:
  TripLeg_Incident();
  virtual ~TripLeg_Incident();

  TripLeg_Incident(const TripLeg_Incident& from);

  inline TripLeg_Incident& operator=(const TripLeg_Incident& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Incident& default_instance();

  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 3,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 4,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Incident* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Incident* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Incident* New() const { return New(NULL); }

  TripLeg_Incident* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Incident& from);
  void MergeFrom(const TripLeg_Incident& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Incident* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.IncidentsTile.Metadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::valhalla::IncidentsTile_Metadata& metadata() const;
  ::valhalla::IncidentsTile_Metadata* mutable_metadata();
  ::valhalla::IncidentsTile_Metadata* release_metadata();
  void set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata);

  // optional uint32 begin_shape_index = 3;
  private:
  bool has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 3;
  ::google::protobuf::uint32 begin_shape_index() const;
  void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 4;
  private:
  bool has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 4;
  ::google::protobuf::uint32 end_shape_index() const;
  void set_end_shape_index(::google::protobuf::uint32 value);

  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  HasEndShapeIndexCase has_end_shape_index_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Incident)
 private:
  inline void set_has_begin_shape_index();
  inline void set_has_end_shape_index();

  inline bool has_has_begin_shape_index() const;
  void clear_has_begin_shape_index();
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  void clear_has_end_shape_index();
  inline void clear_has_has_end_shape_index();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::valhalla::IncidentsTile_Metadata* metadata_;
  union HasBeginShapeIndexUnion {
    HasBeginShapeIndexUnion() {}
    ::google::protobuf::uint32 begin_shape_index_;
  } has_begin_shape_index_;
  union HasEndShapeIndexUnion {
    HasEndShapeIndexUnion() {}
    ::google::protobuf::uint32 end_shape_index_;
  } has_end_shape_index_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Incident* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Closure : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Closure) */ {
 public:
  TripLeg_Closure();
  virtual ~TripLeg_Closure();

  TripLeg_Closure(const TripLeg_Closure& from);

  inline TripLeg_Closure& operator=(const TripLeg_Closure& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Closure& default_instance();

  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 1,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 2,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Closure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Closure* other);

  // implements Message ----------------------------------------------

  inline TripLeg_Closure* New() const { return New(NULL); }

  TripLeg_Closure* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Closure& from);
  void MergeFrom(const TripLeg_Closure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Closure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 begin_shape_index = 1;
  private:
  bool has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 1;
  ::google::protobuf::uint32 begin_shape_index() const;
  void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 2;
  private:
  bool has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 2;
  ::google::protobuf::uint32 end_shape_index() const;
  void set_end_shape_index(::google::protobuf::uint32 value);

  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  HasEndShapeIndexCase has_end_shape_index_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Closure)
 private:
  inline void set_has_begin_shape_index();
  inline void set_has_end_shape_index();

  inline bool has_has_begin_shape_index() const;
  void clear_has_begin_shape_index();
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  void clear_has_end_shape_index();
  inline void clear_has_has_end_shape_index();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasBeginShapeIndexUnion {
    HasBeginShapeIndexUnion() {}
    ::google::protobuf::uint32 begin_shape_index_;
  } has_begin_shape_index_;
  union HasEndShapeIndexUnion {
    HasEndShapeIndexUnion() {}
    ::google::protobuf::uint32 end_shape_index_;
  } has_end_shape_index_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Closure* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg) */ {
 public:
  TripLeg();
  virtual ~TripLeg();

  TripLeg(const TripLeg& from);

  inline TripLeg& operator=(const TripLeg& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg& default_instance();

  enum HasOsmChangesetCase {
    kOsmChangeset = 1,
    HAS_OSM_CHANGESET_NOT_SET = 0,
  };

  enum HasTripIdCase {
    kTripId = 2,
    HAS_TRIP_ID_NOT_SET = 0,
  };

  enum HasLegIdCase {
    kLegId = 3,
    HAS_LEG_ID_NOT_SET = 0,
  };

  enum HasLegCountCase {
    kLegCount = 4,
    HAS_LEG_COUNT_NOT_SET = 0,
  };

  enum HasShapeCase {
    kShape = 8,
    HAS_SHAPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg* other);

  // implements Message ----------------------------------------------

  inline TripLeg* New() const { return New(NULL); }

  TripLeg* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg& from);
  void MergeFrom(const TripLeg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripLeg_LaneConnectivity LaneConnectivity;
  typedef TripLeg_TrafficSegment TrafficSegment;
  typedef TripLeg_Restriction Restriction;
  typedef TripLeg_Edge Edge;
  typedef TripLeg_IntersectingEdge IntersectingEdge;
  typedef TripLeg_Cost Cost;
  typedef TripLeg_PathCost PathCost;
  typedef TripLeg_Node Node;
  typedef TripLeg_Admin Admin;
  typedef TripLeg_ShapeAttributes ShapeAttributes;
  typedef TripLeg_Incident Incident;
  typedef TripLeg_Closure Closure;

  typedef TripLeg_Traversability Traversability;
  static const Traversability kNone =
    TripLeg_Traversability_kNone;
  static const Traversability kForward =
    TripLeg_Traversability_kForward;
  static const Traversability kBackward =
    TripLeg_Traversability_kBackward;
  static const Traversability kBoth =
    TripLeg_Traversability_kBoth;
  static inline bool Traversability_IsValid(int value) {
    return TripLeg_Traversability_IsValid(value);
  }
  static const Traversability Traversability_MIN =
    TripLeg_Traversability_Traversability_MIN;
  static const Traversability Traversability_MAX =
    TripLeg_Traversability_Traversability_MAX;
  static const int Traversability_ARRAYSIZE =
    TripLeg_Traversability_Traversability_ARRAYSIZE;

  typedef TripLeg_Use Use;
  static const Use kRoadUse =
    TripLeg_Use_kRoadUse;
  static const Use kRampUse =
    TripLeg_Use_kRampUse;
  static const Use kTurnChannelUse =
    TripLeg_Use_kTurnChannelUse;
  static const Use kTrackUse =
    TripLeg_Use_kTrackUse;
  static const Use kDrivewayUse =
    TripLeg_Use_kDrivewayUse;
  static const Use kAlleyUse =
    TripLeg_Use_kAlleyUse;
  static const Use kParkingAisleUse =
    TripLeg_Use_kParkingAisleUse;
  static const Use kEmergencyAccessUse =
    TripLeg_Use_kEmergencyAccessUse;
  static const Use kDriveThruUse =
    TripLeg_Use_kDriveThruUse;
  static const Use kCuldesacUse =
    TripLeg_Use_kCuldesacUse;
  static const Use kLivingStreetUse =
    TripLeg_Use_kLivingStreetUse;
  static const Use kServiceRoadUse =
    TripLeg_Use_kServiceRoadUse;
  static const Use kCyclewayUse =
    TripLeg_Use_kCyclewayUse;
  static const Use kMountainBikeUse =
    TripLeg_Use_kMountainBikeUse;
  static const Use kSidewalkUse =
    TripLeg_Use_kSidewalkUse;
  static const Use kFootwayUse =
    TripLeg_Use_kFootwayUse;
  static const Use kStepsUse =
    TripLeg_Use_kStepsUse;
  static const Use kPathUse =
    TripLeg_Use_kPathUse;
  static const Use kPedestrianUse =
    TripLeg_Use_kPedestrianUse;
  static const Use kBridlewayUse =
    TripLeg_Use_kBridlewayUse;
  static const Use kPedestrianCrossingUse =
    TripLeg_Use_kPedestrianCrossingUse;
  static const Use kRestAreaUse =
    TripLeg_Use_kRestAreaUse;
  static const Use kServiceAreaUse =
    TripLeg_Use_kServiceAreaUse;
  static const Use kOtherUse =
    TripLeg_Use_kOtherUse;
  static const Use kFerryUse =
    TripLeg_Use_kFerryUse;
  static const Use kRailFerryUse =
    TripLeg_Use_kRailFerryUse;
  static const Use kRailUse =
    TripLeg_Use_kRailUse;
  static const Use kBusUse =
    TripLeg_Use_kBusUse;
  static const Use kEgressConnectionUse =
    TripLeg_Use_kEgressConnectionUse;
  static const Use kPlatformConnectionUse =
    TripLeg_Use_kPlatformConnectionUse;
  static const Use kTransitConnectionUse =
    TripLeg_Use_kTransitConnectionUse;
  static inline bool Use_IsValid(int value) {
    return TripLeg_Use_IsValid(value);
  }
  static const Use Use_MIN =
    TripLeg_Use_Use_MIN;
  static const Use Use_MAX =
    TripLeg_Use_Use_MAX;
  static const int Use_ARRAYSIZE =
    TripLeg_Use_Use_ARRAYSIZE;

  typedef TripLeg_Surface Surface;
  static const Surface kPavedSmooth =
    TripLeg_Surface_kPavedSmooth;
  static const Surface kPaved =
    TripLeg_Surface_kPaved;
  static const Surface kPavedRough =
    TripLeg_Surface_kPavedRough;
  static const Surface kCompacted =
    TripLeg_Surface_kCompacted;
  static const Surface kDirt =
    TripLeg_Surface_kDirt;
  static const Surface kGravel =
    TripLeg_Surface_kGravel;
  static const Surface kPath =
    TripLeg_Surface_kPath;
  static const Surface kImpassable =
    TripLeg_Surface_kImpassable;
  static inline bool Surface_IsValid(int value) {
    return TripLeg_Surface_IsValid(value);
  }
  static const Surface Surface_MIN =
    TripLeg_Surface_Surface_MIN;
  static const Surface Surface_MAX =
    TripLeg_Surface_Surface_MAX;
  static const int Surface_ARRAYSIZE =
    TripLeg_Surface_Surface_ARRAYSIZE;

  typedef TripLeg_CycleLane CycleLane;
  static const CycleLane kNoCycleLane =
    TripLeg_CycleLane_kNoCycleLane;
  static const CycleLane kShared =
    TripLeg_CycleLane_kShared;
  static const CycleLane kDedicated =
    TripLeg_CycleLane_kDedicated;
  static const CycleLane kSeparated =
    TripLeg_CycleLane_kSeparated;
  static inline bool CycleLane_IsValid(int value) {
    return TripLeg_CycleLane_IsValid(value);
  }
  static const CycleLane CycleLane_MIN =
    TripLeg_CycleLane_CycleLane_MIN;
  static const CycleLane CycleLane_MAX =
    TripLeg_CycleLane_CycleLane_MAX;
  static const int CycleLane_ARRAYSIZE =
    TripLeg_CycleLane_CycleLane_ARRAYSIZE;

  typedef TripLeg_SacScale SacScale;
  static const SacScale kNoSacScale =
    TripLeg_SacScale_kNoSacScale;
  static const SacScale kHiking =
    TripLeg_SacScale_kHiking;
  static const SacScale kMountainHiking =
    TripLeg_SacScale_kMountainHiking;
  static const SacScale kDemandingMountainHiking =
    TripLeg_SacScale_kDemandingMountainHiking;
  static const SacScale kAlpineHiking =
    TripLeg_SacScale_kAlpineHiking;
  static const SacScale kDemandingAlpineHiking =
    TripLeg_SacScale_kDemandingAlpineHiking;
  static const SacScale kDifficultAlpineHiking =
    TripLeg_SacScale_kDifficultAlpineHiking;
  static inline bool SacScale_IsValid(int value) {
    return TripLeg_SacScale_IsValid(value);
  }
  static const SacScale SacScale_MIN =
    TripLeg_SacScale_SacScale_MIN;
  static const SacScale SacScale_MAX =
    TripLeg_SacScale_SacScale_MAX;
  static const int SacScale_ARRAYSIZE =
    TripLeg_SacScale_SacScale_ARRAYSIZE;

  typedef TripLeg_Sidewalk Sidewalk;
  static const Sidewalk kNoSidewalk =
    TripLeg_Sidewalk_kNoSidewalk;
  static const Sidewalk kLeft =
    TripLeg_Sidewalk_kLeft;
  static const Sidewalk kRight =
    TripLeg_Sidewalk_kRight;
  static const Sidewalk kBothSides =
    TripLeg_Sidewalk_kBothSides;
  static inline bool Sidewalk_IsValid(int value) {
    return TripLeg_Sidewalk_IsValid(value);
  }
  static const Sidewalk Sidewalk_MIN =
    TripLeg_Sidewalk_Sidewalk_MIN;
  static const Sidewalk Sidewalk_MAX =
    TripLeg_Sidewalk_Sidewalk_MAX;
  static const int Sidewalk_ARRAYSIZE =
    TripLeg_Sidewalk_Sidewalk_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint64 osm_changeset = 1;
  private:
  bool has_osm_changeset() const;
  public:
  void clear_osm_changeset();
  static const int kOsmChangesetFieldNumber = 1;
  ::google::protobuf::uint64 osm_changeset() const;
  void set_osm_changeset(::google::protobuf::uint64 value);

  // optional uint64 trip_id = 2;
  private:
  bool has_trip_id() const;
  public:
  void clear_trip_id();
  static const int kTripIdFieldNumber = 2;
  ::google::protobuf::uint64 trip_id() const;
  void set_trip_id(::google::protobuf::uint64 value);

  // optional uint32 leg_id = 3;
  private:
  bool has_leg_id() const;
  public:
  void clear_leg_id();
  static const int kLegIdFieldNumber = 3;
  ::google::protobuf::uint32 leg_id() const;
  void set_leg_id(::google::protobuf::uint32 value);

  // optional uint32 leg_count = 4;
  private:
  bool has_leg_count() const;
  public:
  void clear_leg_count();
  static const int kLegCountFieldNumber = 4;
  ::google::protobuf::uint32 leg_count() const;
  void set_leg_count(::google::protobuf::uint32 value);

  // repeated .valhalla.Location location = 5;
  int location_size() const;
  void clear_location();
  static const int kLocationFieldNumber = 5;
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* mutable_location(int index);
  ::valhalla::Location* add_location();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // repeated .valhalla.TripLeg.Node node = 6;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 6;
  const ::valhalla::TripLeg_Node& node(int index) const;
  ::valhalla::TripLeg_Node* mutable_node(int index);
  ::valhalla::TripLeg_Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >&
      node() const;

  // repeated .valhalla.TripLeg.Admin admin = 7;
  int admin_size() const;
  void clear_admin();
  static const int kAdminFieldNumber = 7;
  const ::valhalla::TripLeg_Admin& admin(int index) const;
  ::valhalla::TripLeg_Admin* mutable_admin(int index);
  ::valhalla::TripLeg_Admin* add_admin();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
      mutable_admin();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
      admin() const;

  // optional string shape = 8;
  private:
  bool has_shape() const;
  public:
  void clear_shape();
  static const int kShapeFieldNumber = 8;
  const ::std::string& shape() const;
  void set_shape(const ::std::string& value);
  void set_shape(const char* value);
  void set_shape(const char* value, size_t size);
  ::std::string* mutable_shape();
  ::std::string* release_shape();
  void set_allocated_shape(::std::string* shape);

  // optional .valhalla.BoundingBox bbox = 9;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 9;
  const ::valhalla::BoundingBox& bbox() const;
  ::valhalla::BoundingBox* mutable_bbox();
  ::valhalla::BoundingBox* release_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);

  // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  bool has_shape_attributes() const;
  void clear_shape_attributes();
  static const int kShapeAttributesFieldNumber = 10;
  const ::valhalla::TripLeg_ShapeAttributes& shape_attributes() const;
  ::valhalla::TripLeg_ShapeAttributes* mutable_shape_attributes();
  ::valhalla::TripLeg_ShapeAttributes* release_shape_attributes();
  void set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes);

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  int incidents_size() const;
  void clear_incidents();
  static const int kIncidentsFieldNumber = 11;
  const ::valhalla::TripLeg_Incident& incidents(int index) const;
  ::valhalla::TripLeg_Incident* mutable_incidents(int index);
  ::valhalla::TripLeg_Incident* add_incidents();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
      mutable_incidents();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
      incidents() const;

  // repeated string algorithms = 12;
  int algorithms_size() const;
  void clear_algorithms();
  static const int kAlgorithmsFieldNumber = 12;
  const ::std::string& algorithms(int index) const;
  ::std::string* mutable_algorithms(int index);
  void set_algorithms(int index, const ::std::string& value);
  void set_algorithms(int index, const char* value);
  void set_algorithms(int index, const char* value, size_t size);
  ::std::string* add_algorithms();
  void add_algorithms(const ::std::string& value);
  void add_algorithms(const char* value);
  void add_algorithms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& algorithms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_algorithms();

  // repeated .valhalla.TripLeg.Closure closures = 13;
  int closures_size() const;
  void clear_closures();
  static const int kClosuresFieldNumber = 13;
  const ::valhalla::TripLeg_Closure& closures(int index) const;
  ::valhalla::TripLeg_Closure* mutable_closures(int index);
  ::valhalla::TripLeg_Closure* add_closures();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
      mutable_closures();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
      closures() const;

  HasOsmChangesetCase has_osm_changeset_case() const;
  HasTripIdCase has_trip_id_case() const;
  HasLegIdCase has_leg_id_case() const;
  HasLegCountCase has_leg_count_case() const;
  HasShapeCase has_shape_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg)
 private:
  inline void set_has_osm_changeset();
  inline void set_has_trip_id();
  inline void set_has_leg_id();
  inline void set_has_leg_count();
  inline void set_has_shape();

  inline bool has_has_osm_changeset() const;
  void clear_has_osm_changeset();
  inline void clear_has_has_osm_changeset();

  inline bool has_has_trip_id() const;
  void clear_has_trip_id();
  inline void clear_has_has_trip_id();

  inline bool has_has_leg_id() const;
  void clear_has_leg_id();
  inline void clear_has_has_leg_id();

  inline bool has_has_leg_count() const;
  void clear_has_leg_count();
  inline void clear_has_has_leg_count();

  inline bool has_has_shape() const;
  void clear_has_shape();
  inline void clear_has_has_shape();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > location_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node > node_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin > admin_;
  ::valhalla::BoundingBox* bbox_;
  ::valhalla::TripLeg_ShapeAttributes* shape_attributes_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident > incidents_;
  ::google::protobuf::RepeatedPtrField< ::std::string> algorithms_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure > closures_;
  union HasOsmChangesetUnion {
    HasOsmChangesetUnion() {}
    ::google::protobuf::uint64 osm_changeset_;
  } has_osm_changeset_;
  union HasTripIdUnion {
    HasTripIdUnion() {}
    ::google::protobuf::uint64 trip_id_;
  } has_trip_id_;
  union HasLegIdUnion {
    HasLegIdUnion() {}
    ::google::protobuf::uint32 leg_id_;
  } has_leg_id_;
  union HasLegCountUnion {
    HasLegCountUnion() {}
    ::google::protobuf::uint32 leg_count_;
  } has_leg_count_;
  union HasShapeUnion {
    HasShapeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr shape_;
  } has_shape_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[5];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg* default_instance_;
};
// -------------------------------------------------------------------

class TripRoute : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripRoute) */ {
 public:
  TripRoute();
  virtual ~TripRoute();

  TripRoute(const TripRoute& from);

  inline TripRoute& operator=(const TripRoute& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripRoute* other);

  // implements Message ----------------------------------------------

  inline TripRoute* New() const { return New(NULL); }

  TripRoute* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripRoute& from);
  void MergeFrom(const TripRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.TripLeg legs = 1;
  int legs_size() const;
  void clear_legs();
  static const int kLegsFieldNumber = 1;
  const ::valhalla::TripLeg& legs(int index) const;
  ::valhalla::TripLeg* mutable_legs(int index);
  ::valhalla::TripLeg* add_legs();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >*
      mutable_legs();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.TripRoute)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg > legs_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripRoute* default_instance_;
};
// -------------------------------------------------------------------

class Trip : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Trip) */ {
 public:
  Trip();
  virtual ~Trip();

  Trip(const Trip& from);

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }

  static const Trip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Trip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Trip* other);

  // implements Message ----------------------------------------------

  inline Trip* New() const { return New(NULL); }

  Trip* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Trip& from);
  void MergeFrom(const Trip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.TripRoute routes = 1;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 1;
  const ::valhalla::TripRoute& routes(int index) const;
  ::valhalla::TripRoute* mutable_routes(int index);
  ::valhalla::TripRoute* add_routes();
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Trip)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute > routes_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static Trip* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TripLeg_LaneConnectivity

// optional uint64 from_way_id = 1;
inline bool TripLeg_LaneConnectivity::has_from_way_id() const {
  return has_from_way_id_case() == kFromWayId;
}
inline void TripLeg_LaneConnectivity::set_has_from_way_id() {
  _oneof_case_[0] = kFromWayId;
}
inline void TripLeg_LaneConnectivity::clear_from_way_id() {
  if (has_from_way_id()) {
    has_from_way_id_.from_way_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_from_way_id();
  }
}
inline ::google::protobuf::uint64 TripLeg_LaneConnectivity::from_way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_way_id)
  if (has_from_way_id()) {
    return has_from_way_id_.from_way_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TripLeg_LaneConnectivity::set_from_way_id(::google::protobuf::uint64 value) {
  if (!has_from_way_id()) {
    clear_has_from_way_id();
    set_has_from_way_id();
  }
  has_from_way_id_.from_way_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_way_id)
}

// optional string from_lanes = 2;
inline bool TripLeg_LaneConnectivity::has_from_lanes() const {
  return has_from_lanes_case() == kFromLanes;
}
inline void TripLeg_LaneConnectivity::set_has_from_lanes() {
  _oneof_case_[1] = kFromLanes;
}
inline void TripLeg_LaneConnectivity::clear_from_lanes() {
  if (has_from_lanes()) {
    has_from_lanes_.from_lanes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_from_lanes();
  }
}
inline const ::std::string& TripLeg_LaneConnectivity::from_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (has_from_lanes()) {
    return has_from_lanes_.from_lanes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_LaneConnectivity::set_from_lanes(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_from_lanes_.from_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
inline void TripLeg_LaneConnectivity::set_from_lanes(const char* value) {
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_from_lanes_.from_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
inline void TripLeg_LaneConnectivity::set_from_lanes(const char* value, size_t size) {
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_from_lanes_.from_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
inline ::std::string* TripLeg_LaneConnectivity::mutable_from_lanes() {
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return has_from_lanes_.from_lanes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_LaneConnectivity::release_from_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (has_from_lanes()) {
    clear_has_has_from_lanes();
    return has_from_lanes_.from_lanes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_LaneConnectivity::set_allocated_from_lanes(::std::string* from_lanes) {
  if (!has_from_lanes()) {
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_from_lanes();
  if (from_lanes != NULL) {
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        from_lanes);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.from_lanes)
}

// optional string to_lanes = 3;
inline bool TripLeg_LaneConnectivity::has_to_lanes() const {
  return has_to_lanes_case() == kToLanes;
}
inline void TripLeg_LaneConnectivity::set_has_to_lanes() {
  _oneof_case_[2] = kToLanes;
}
inline void TripLeg_LaneConnectivity::clear_to_lanes() {
  if (has_to_lanes()) {
    has_to_lanes_.to_lanes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_to_lanes();
  }
}
inline const ::std::string& TripLeg_LaneConnectivity::to_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (has_to_lanes()) {
    return has_to_lanes_.to_lanes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_LaneConnectivity::set_to_lanes(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_to_lanes_.to_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
inline void TripLeg_LaneConnectivity::set_to_lanes(const char* value) {
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_to_lanes_.to_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
inline void TripLeg_LaneConnectivity::set_to_lanes(const char* value, size_t size) {
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_to_lanes_.to_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
inline ::std::string* TripLeg_LaneConnectivity::mutable_to_lanes() {
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return has_to_lanes_.to_lanes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_LaneConnectivity::release_to_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (has_to_lanes()) {
    clear_has_has_to_lanes();
    return has_to_lanes_.to_lanes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_LaneConnectivity::set_allocated_to_lanes(::std::string* to_lanes) {
  if (!has_to_lanes()) {
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_to_lanes();
  if (to_lanes != NULL) {
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        to_lanes);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.to_lanes)
}

inline bool TripLeg_LaneConnectivity::has_has_from_way_id() const {
  return has_from_way_id_case() != HAS_FROM_WAY_ID_NOT_SET;
}
inline void TripLeg_LaneConnectivity::clear_has_has_from_way_id() {
  _oneof_case_[0] = HAS_FROM_WAY_ID_NOT_SET;
}
inline bool TripLeg_LaneConnectivity::has_has_from_lanes() const {
  return has_from_lanes_case() != HAS_FROM_LANES_NOT_SET;
}
inline void TripLeg_LaneConnectivity::clear_has_has_from_lanes() {
  _oneof_case_[1] = HAS_FROM_LANES_NOT_SET;
}
inline bool TripLeg_LaneConnectivity::has_has_to_lanes() const {
  return has_to_lanes_case() != HAS_TO_LANES_NOT_SET;
}
inline void TripLeg_LaneConnectivity::clear_has_has_to_lanes() {
  _oneof_case_[2] = HAS_TO_LANES_NOT_SET;
}
inline TripLeg_LaneConnectivity::HasFromWayIdCase TripLeg_LaneConnectivity::has_from_way_id_case() const {
  return TripLeg_LaneConnectivity::HasFromWayIdCase(_oneof_case_[0]);
}
inline TripLeg_LaneConnectivity::HasFromLanesCase TripLeg_LaneConnectivity::has_from_lanes_case() const {
  return TripLeg_LaneConnectivity::HasFromLanesCase(_oneof_case_[1]);
}
inline TripLeg_LaneConnectivity::HasToLanesCase TripLeg_LaneConnectivity::has_to_lanes_case() const {
  return TripLeg_LaneConnectivity::HasToLanesCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// TripLeg_TrafficSegment

// optional uint64 segment_id = 1;
inline bool TripLeg_TrafficSegment::has_segment_id() const {
  return has_segment_id_case() == kSegmentId;
}
inline void TripLeg_TrafficSegment::set_has_segment_id() {
  _oneof_case_[0] = kSegmentId;
}
inline void TripLeg_TrafficSegment::clear_segment_id() {
  if (has_segment_id()) {
    has_segment_id_.segment_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_segment_id();
  }
}
inline ::google::protobuf::uint64 TripLeg_TrafficSegment::segment_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.segment_id)
  if (has_segment_id()) {
    return has_segment_id_.segment_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TripLeg_TrafficSegment::set_segment_id(::google::protobuf::uint64 value) {
  if (!has_segment_id()) {
    clear_has_segment_id();
    set_has_segment_id();
  }
  has_segment_id_.segment_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.segment_id)
}

// optional float begin_percent = 2;
inline bool TripLeg_TrafficSegment::has_begin_percent() const {
  return has_begin_percent_case() == kBeginPercent;
}
inline void TripLeg_TrafficSegment::set_has_begin_percent() {
  _oneof_case_[1] = kBeginPercent;
}
inline void TripLeg_TrafficSegment::clear_begin_percent() {
  if (has_begin_percent()) {
    has_begin_percent_.begin_percent_ = 0;
    clear_has_has_begin_percent();
  }
}
inline float TripLeg_TrafficSegment::begin_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.begin_percent)
  if (has_begin_percent()) {
    return has_begin_percent_.begin_percent_;
  }
  return 0;
}
inline void TripLeg_TrafficSegment::set_begin_percent(float value) {
  if (!has_begin_percent()) {
    clear_has_begin_percent();
    set_has_begin_percent();
  }
  has_begin_percent_.begin_percent_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.begin_percent)
}

// optional float end_percent = 3;
inline bool TripLeg_TrafficSegment::has_end_percent() const {
  return has_end_percent_case() == kEndPercent;
}
inline void TripLeg_TrafficSegment::set_has_end_percent() {
  _oneof_case_[2] = kEndPercent;
}
inline void TripLeg_TrafficSegment::clear_end_percent() {
  if (has_end_percent()) {
    has_end_percent_.end_percent_ = 0;
    clear_has_has_end_percent();
  }
}
inline float TripLeg_TrafficSegment::end_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.end_percent)
  if (has_end_percent()) {
    return has_end_percent_.end_percent_;
  }
  return 0;
}
inline void TripLeg_TrafficSegment::set_end_percent(float value) {
  if (!has_end_percent()) {
    clear_has_end_percent();
    set_has_end_percent();
  }
  has_end_percent_.end_percent_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.end_percent)
}

// optional bool starts_segment = 4;
inline bool TripLeg_TrafficSegment::has_starts_segment() const {
  return has_starts_segment_case() == kStartsSegment;
}
inline void TripLeg_TrafficSegment::set_has_starts_segment() {
  _oneof_case_[3] = kStartsSegment;
}
inline void TripLeg_TrafficSegment::clear_starts_segment() {
  if (has_starts_segment()) {
    has_starts_segment_.starts_segment_ = false;
    clear_has_has_starts_segment();
  }
}
inline bool TripLeg_TrafficSegment::starts_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.starts_segment)
  if (has_starts_segment()) {
    return has_starts_segment_.starts_segment_;
  }
  return false;
}
inline void TripLeg_TrafficSegment::set_starts_segment(bool value) {
  if (!has_starts_segment()) {
    clear_has_starts_segment();
    set_has_starts_segment();
  }
  has_starts_segment_.starts_segment_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.starts_segment)
}

// optional bool ends_segment = 5;
inline bool TripLeg_TrafficSegment::has_ends_segment() const {
  return has_ends_segment_case() == kEndsSegment;
}
inline void TripLeg_TrafficSegment::set_has_ends_segment() {
  _oneof_case_[4] = kEndsSegment;
}
inline void TripLeg_TrafficSegment::clear_ends_segment() {
  if (has_ends_segment()) {
    has_ends_segment_.ends_segment_ = false;
    clear_has_has_ends_segment();
  }
}
inline bool TripLeg_TrafficSegment::ends_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.ends_segment)
  if (has_ends_segment()) {
    return has_ends_segment_.ends_segment_;
  }
  return false;
}
inline void TripLeg_TrafficSegment::set_ends_segment(bool value) {
  if (!has_ends_segment()) {
    clear_has_ends_segment();
    set_has_ends_segment();
  }
  has_ends_segment_.ends_segment_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.ends_segment)
}

inline bool TripLeg_TrafficSegment::has_has_segment_id() const {
  return has_segment_id_case() != HAS_SEGMENT_ID_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_segment_id() {
  _oneof_case_[0] = HAS_SEGMENT_ID_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_begin_percent() const {
  return has_begin_percent_case() != HAS_BEGIN_PERCENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_begin_percent() {
  _oneof_case_[1] = HAS_BEGIN_PERCENT_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_end_percent() const {
  return has_end_percent_case() != HAS_END_PERCENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_end_percent() {
  _oneof_case_[2] = HAS_END_PERCENT_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_starts_segment() const {
  return has_starts_segment_case() != HAS_STARTS_SEGMENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_starts_segment() {
  _oneof_case_[3] = HAS_STARTS_SEGMENT_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_ends_segment() const {
  return has_ends_segment_case() != HAS_ENDS_SEGMENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_ends_segment() {
  _oneof_case_[4] = HAS_ENDS_SEGMENT_NOT_SET;
}
inline TripLeg_TrafficSegment::HasSegmentIdCase TripLeg_TrafficSegment::has_segment_id_case() const {
  return TripLeg_TrafficSegment::HasSegmentIdCase(_oneof_case_[0]);
}
inline TripLeg_TrafficSegment::HasBeginPercentCase TripLeg_TrafficSegment::has_begin_percent_case() const {
  return TripLeg_TrafficSegment::HasBeginPercentCase(_oneof_case_[1]);
}
inline TripLeg_TrafficSegment::HasEndPercentCase TripLeg_TrafficSegment::has_end_percent_case() const {
  return TripLeg_TrafficSegment::HasEndPercentCase(_oneof_case_[2]);
}
inline TripLeg_TrafficSegment::HasStartsSegmentCase TripLeg_TrafficSegment::has_starts_segment_case() const {
  return TripLeg_TrafficSegment::HasStartsSegmentCase(_oneof_case_[3]);
}
inline TripLeg_TrafficSegment::HasEndsSegmentCase TripLeg_TrafficSegment::has_ends_segment_case() const {
  return TripLeg_TrafficSegment::HasEndsSegmentCase(_oneof_case_[4]);
}
// -------------------------------------------------------------------

// TripLeg_Restriction

// optional uint32 type = 1;
inline bool TripLeg_Restriction::has_type() const {
  return has_type_case() == kType;
}
inline void TripLeg_Restriction::set_has_type() {
  _oneof_case_[0] = kType;
}
inline void TripLeg_Restriction::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0u;
    clear_has_has_type();
  }
}
inline ::google::protobuf::uint32 TripLeg_Restriction::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Restriction.type)
  if (has_type()) {
    return has_type_.type_;
  }
  return 0u;
}
inline void TripLeg_Restriction::set_type(::google::protobuf::uint32 value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Restriction.type)
}

inline bool TripLeg_Restriction::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void TripLeg_Restriction::clear_has_has_type() {
  _oneof_case_[0] = HAS_TYPE_NOT_SET;
}
inline TripLeg_Restriction::HasTypeCase TripLeg_Restriction::has_type_case() const {
  return TripLeg_Restriction::HasTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TripLeg_Edge

// repeated .valhalla.StreetName name = 1;
inline int TripLeg_Edge::name_size() const {
  return name_.size();
}
inline void TripLeg_Edge::clear_name() {
  name_.Clear();
}
inline const ::valhalla::StreetName& TripLeg_Edge::name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.name)
  return name_.Get(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.name)
  return name_.Mutable(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::add_name() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.name)
  return name_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
TripLeg_Edge::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.name)
  return &name_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
TripLeg_Edge::name() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.name)
  return name_;
}

// optional float length_km = 2;
inline bool TripLeg_Edge::has_length_km() const {
  return has_length_km_case() == kLengthKm;
}
inline void TripLeg_Edge::set_has_length_km() {
  _oneof_case_[0] = kLengthKm;
}
inline void TripLeg_Edge::clear_length_km() {
  if (has_length_km()) {
    has_length_km_.length_km_ = 0;
    clear_has_has_length_km();
  }
}
inline float TripLeg_Edge::length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.length_km)
  if (has_length_km()) {
    return has_length_km_.length_km_;
  }
  return 0;
}
inline void TripLeg_Edge::set_length_km(float value) {
  if (!has_length_km()) {
    clear_has_length_km();
    set_has_length_km();
  }
  has_length_km_.length_km_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.length_km)
}

// optional float speed = 3;
inline bool TripLeg_Edge::has_speed() const {
  return has_speed_case() == kSpeed;
}
inline void TripLeg_Edge::set_has_speed() {
  _oneof_case_[1] = kSpeed;
}
inline void TripLeg_Edge::clear_speed() {
  if (has_speed()) {
    has_speed_.speed_ = 0;
    clear_has_has_speed();
  }
}
inline float TripLeg_Edge::speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed)
  if (has_speed()) {
    return has_speed_.speed_;
  }
  return 0;
}
inline void TripLeg_Edge::set_speed(float value) {
  if (!has_speed()) {
    clear_has_speed();
    set_has_speed();
  }
  has_speed_.speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed)
}

// optional .valhalla.RoadClass road_class = 4;
inline bool TripLeg_Edge::has_road_class() const {
  return has_road_class_case() == kRoadClass;
}
inline void TripLeg_Edge::set_has_road_class() {
  _oneof_case_[2] = kRoadClass;
}
inline void TripLeg_Edge::clear_road_class() {
  if (has_road_class()) {
    has_road_class_.road_class_ = 0;
    clear_has_has_road_class();
  }
}
inline ::valhalla::RoadClass TripLeg_Edge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.road_class)
  if (has_road_class()) {
    return static_cast< ::valhalla::RoadClass >(has_road_class_.road_class_);
  }
  return static_cast< ::valhalla::RoadClass >(0);
}
inline void TripLeg_Edge::set_road_class(::valhalla::RoadClass value) {
  if (!has_road_class()) {
    clear_has_road_class();
    set_has_road_class();
  }
  has_road_class_.road_class_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.road_class)
}

// optional uint32 begin_heading = 5;
inline bool TripLeg_Edge::has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
inline void TripLeg_Edge::set_has_begin_heading() {
  _oneof_case_[3] = kBeginHeading;
}
inline void TripLeg_Edge::clear_begin_heading() {
  if (has_begin_heading()) {
    has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_heading)
  if (has_begin_heading()) {
    return has_begin_heading_.begin_heading_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_begin_heading(::google::protobuf::uint32 value) {
  if (!has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  has_begin_heading_.begin_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_heading)
}

// optional uint32 end_heading = 6;
inline bool TripLeg_Edge::has_end_heading() const {
  return has_end_heading_case() == kEndHeading;
}
inline void TripLeg_Edge::set_has_end_heading() {
  _oneof_case_[4] = kEndHeading;
}
inline void TripLeg_Edge::clear_end_heading() {
  if (has_end_heading()) {
    has_end_heading_.end_heading_ = 0u;
    clear_has_has_end_heading();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::end_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_heading)
  if (has_end_heading()) {
    return has_end_heading_.end_heading_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_end_heading(::google::protobuf::uint32 value) {
  if (!has_end_heading()) {
    clear_has_end_heading();
    set_has_end_heading();
  }
  has_end_heading_.end_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_heading)
}

// optional uint32 begin_shape_index = 7;
inline bool TripLeg_Edge::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline void TripLeg_Edge::set_has_begin_shape_index() {
  _oneof_case_[5] = kBeginShapeIndex;
}
inline void TripLeg_Edge::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_shape_index)
}

// optional uint32 end_shape_index = 8;
inline bool TripLeg_Edge::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline void TripLeg_Edge::set_has_end_shape_index() {
  _oneof_case_[6] = kEndShapeIndex;
}
inline void TripLeg_Edge::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_shape_index)
}

// optional .valhalla.TripLeg.Traversability traversability = 9;
inline bool TripLeg_Edge::has_traversability() const {
  return has_traversability_case() == kTraversability;
}
inline void TripLeg_Edge::set_has_traversability() {
  _oneof_case_[7] = kTraversability;
}
inline void TripLeg_Edge::clear_traversability() {
  if (has_traversability()) {
    has_traversability_.traversability_ = 0;
    clear_has_has_traversability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::traversability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traversability)
  if (has_traversability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_traversability_.traversability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline void TripLeg_Edge::set_traversability(::valhalla::TripLeg_Traversability value) {
  if (!has_traversability()) {
    clear_has_traversability();
    set_has_traversability();
  }
  has_traversability_.traversability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.traversability)
}

// optional .valhalla.TripLeg.Use use = 10;
inline bool TripLeg_Edge::has_use() const {
  return has_use_case() == kUse;
}
inline void TripLeg_Edge::set_has_use() {
  _oneof_case_[8] = kUse;
}
inline void TripLeg_Edge::clear_use() {
  if (has_use()) {
    has_use_.use_ = 0;
    clear_has_has_use();
  }
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.use)
  if (has_use()) {
    return static_cast< ::valhalla::TripLeg_Use >(has_use_.use_);
  }
  return static_cast< ::valhalla::TripLeg_Use >(0);
}
inline void TripLeg_Edge::set_use(::valhalla::TripLeg_Use value) {
  if (!has_use()) {
    clear_has_use();
    set_has_use();
  }
  has_use_.use_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.use)
}

// optional bool toll = 11;
inline bool TripLeg_Edge::has_toll() const {
  return has_toll_case() == kToll;
}
inline void TripLeg_Edge::set_has_toll() {
  _oneof_case_[9] = kToll;
}
inline void TripLeg_Edge::clear_toll() {
  if (has_toll()) {
    has_toll_.toll_ = false;
    clear_has_has_toll();
  }
}
inline bool TripLeg_Edge::toll() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.toll)
  if (has_toll()) {
    return has_toll_.toll_;
  }
  return false;
}
inline void TripLeg_Edge::set_toll(bool value) {
  if (!has_toll()) {
    clear_has_toll();
    set_has_toll();
  }
  has_toll_.toll_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.toll)
}

// optional bool unpaved = 12;
inline bool TripLeg_Edge::has_unpaved() const {
  return has_unpaved_case() == kUnpaved;
}
inline void TripLeg_Edge::set_has_unpaved() {
  _oneof_case_[10] = kUnpaved;
}
inline void TripLeg_Edge::clear_unpaved() {
  if (has_unpaved()) {
    has_unpaved_.unpaved_ = false;
    clear_has_has_unpaved();
  }
}
inline bool TripLeg_Edge::unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.unpaved)
  if (has_unpaved()) {
    return has_unpaved_.unpaved_;
  }
  return false;
}
inline void TripLeg_Edge::set_unpaved(bool value) {
  if (!has_unpaved()) {
    clear_has_unpaved();
    set_has_unpaved();
  }
  has_unpaved_.unpaved_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.unpaved)
}

// optional bool tunnel = 13;
inline bool TripLeg_Edge::has_tunnel() const {
  return has_tunnel_case() == kTunnel;
}
inline void TripLeg_Edge::set_has_tunnel() {
  _oneof_case_[11] = kTunnel;
}
inline void TripLeg_Edge::clear_tunnel() {
  if (has_tunnel()) {
    has_tunnel_.tunnel_ = false;
    clear_has_has_tunnel();
  }
}
inline bool TripLeg_Edge::tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tunnel)
  if (has_tunnel()) {
    return has_tunnel_.tunnel_;
  }
  return false;
}
inline void TripLeg_Edge::set_tunnel(bool value) {
  if (!has_tunnel()) {
    clear_has_tunnel();
    set_has_tunnel();
  }
  has_tunnel_.tunnel_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.tunnel)
}

// optional bool bridge = 14;
inline bool TripLeg_Edge::has_bridge() const {
  return has_bridge_case() == kBridge;
}
inline void TripLeg_Edge::set_has_bridge() {
  _oneof_case_[12] = kBridge;
}
inline void TripLeg_Edge::clear_bridge() {
  if (has_bridge()) {
    has_bridge_.bridge_ = false;
    clear_has_has_bridge();
  }
}
inline bool TripLeg_Edge::bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bridge)
  if (has_bridge()) {
    return has_bridge_.bridge_;
  }
  return false;
}
inline void TripLeg_Edge::set_bridge(bool value) {
  if (!has_bridge()) {
    clear_has_bridge();
    set_has_bridge();
  }
  has_bridge_.bridge_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bridge)
}

// optional bool roundabout = 15;
inline bool TripLeg_Edge::has_roundabout() const {
  return has_roundabout_case() == kRoundabout;
}
inline void TripLeg_Edge::set_has_roundabout() {
  _oneof_case_[13] = kRoundabout;
}
inline void TripLeg_Edge::clear_roundabout() {
  if (has_roundabout()) {
    has_roundabout_.roundabout_ = false;
    clear_has_has_roundabout();
  }
}
inline bool TripLeg_Edge::roundabout() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.roundabout)
  if (has_roundabout()) {
    return has_roundabout_.roundabout_;
  }
  return false;
}
inline void TripLeg_Edge::set_roundabout(bool value) {
  if (!has_roundabout()) {
    clear_has_roundabout();
    set_has_roundabout();
  }
  has_roundabout_.roundabout_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.roundabout)
}

// optional bool internal_intersection = 16;
inline bool TripLeg_Edge::has_internal_intersection() const {
  return has_internal_intersection_case() == kInternalIntersection;
}
inline void TripLeg_Edge::set_has_internal_intersection() {
  _oneof_case_[14] = kInternalIntersection;
}
inline void TripLeg_Edge::clear_internal_intersection() {
  if (has_internal_intersection()) {
    has_internal_intersection_.internal_intersection_ = false;
    clear_has_has_internal_intersection();
  }
}
inline bool TripLeg_Edge::internal_intersection() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.internal_intersection)
  if (has_internal_intersection()) {
    return has_internal_intersection_.internal_intersection_;
  }
  return false;
}
inline void TripLeg_Edge::set_internal_intersection(bool value) {
  if (!has_internal_intersection()) {
    clear_has_internal_intersection();
    set_has_internal_intersection();
  }
  has_internal_intersection_.internal_intersection_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.internal_intersection)
}

// optional bool drive_on_left = 17;
inline bool TripLeg_Edge::has_drive_on_left() const {
  return has_drive_on_left_case() == kDriveOnLeft;
}
inline void TripLeg_Edge::set_has_drive_on_left() {
  _oneof_case_[15] = kDriveOnLeft;
}
inline void TripLeg_Edge::clear_drive_on_left() {
  if (has_drive_on_left()) {
    has_drive_on_left_.drive_on_left_ = false;
    clear_has_has_drive_on_left();
  }
}
inline bool TripLeg_Edge::drive_on_left() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.drive_on_left)
  if (has_drive_on_left()) {
    return has_drive_on_left_.drive_on_left_;
  }
  return false;
}
inline void TripLeg_Edge::set_drive_on_left(bool value) {
  if (!has_drive_on_left()) {
    clear_has_drive_on_left();
    set_has_drive_on_left();
  }
  has_drive_on_left_.drive_on_left_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.drive_on_left)
}

// optional .valhalla.TripLeg.Surface surface = 18;
inline bool TripLeg_Edge::has_surface() const {
  return has_surface_case() == kSurface;
}
inline void TripLeg_Edge::set_has_surface() {
  _oneof_case_[16] = kSurface;
}
inline void TripLeg_Edge::clear_surface() {
  if (has_surface()) {
    has_surface_.surface_ = 0;
    clear_has_has_surface();
  }
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::surface() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.surface)
  if (has_surface()) {
    return static_cast< ::valhalla::TripLeg_Surface >(has_surface_.surface_);
  }
  return static_cast< ::valhalla::TripLeg_Surface >(0);
}
inline void TripLeg_Edge::set_surface(::valhalla::TripLeg_Surface value) {
  if (!has_surface()) {
    clear_has_surface();
    set_has_surface();
  }
  has_surface_.surface_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.surface)
}

// optional .valhalla.TripSign sign = 19;
inline bool TripLeg_Edge::has_sign() const {
  return !_is_default_instance_ && sign_ != NULL;
}
inline void TripLeg_Edge::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
}
inline const ::valhalla::TripSign& TripLeg_Edge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sign)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
inline ::valhalla::TripSign* TripLeg_Edge::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::valhalla::TripSign;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.sign)
  return sign_;
}
inline ::valhalla::TripSign* TripLeg_Edge::release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.sign)
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void TripLeg_Edge::set_allocated_sign(::valhalla::TripSign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.sign)
}

// optional .valhalla.TravelMode travel_mode = 20;
inline bool TripLeg_Edge::has_travel_mode() const {
  return has_travel_mode_case() == kTravelMode;
}
inline void TripLeg_Edge::set_has_travel_mode() {
  _oneof_case_[17] = kTravelMode;
}
inline void TripLeg_Edge::clear_travel_mode() {
  if (has_travel_mode()) {
    has_travel_mode_.travel_mode_ = 0;
    clear_has_has_travel_mode();
  }
}
inline ::valhalla::TravelMode TripLeg_Edge::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.travel_mode)
  if (has_travel_mode()) {
    return static_cast< ::valhalla::TravelMode >(has_travel_mode_.travel_mode_);
  }
  return static_cast< ::valhalla::TravelMode >(0);
}
inline void TripLeg_Edge::set_travel_mode(::valhalla::TravelMode value) {
  if (!has_travel_mode()) {
    clear_has_travel_mode();
    set_has_travel_mode();
  }
  has_travel_mode_.travel_mode_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.travel_mode)
}

// optional .valhalla.VehicleType vehicle_type = 21;
inline bool TripLeg_Edge::has_vehicle_type() const {
  return has_vehicle_type_case() == kVehicleType;
}
inline void TripLeg_Edge::set_has_vehicle_type() {
  _oneof_case_[18] = kVehicleType;
}
inline void TripLeg_Edge::clear_vehicle_type() {
  if (has_vehicle_type()) {
    has_vehicle_type_.vehicle_type_ = 0;
    clear_has_has_vehicle_type();
  }
}
inline ::valhalla::VehicleType TripLeg_Edge::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.vehicle_type)
  if (has_vehicle_type()) {
    return static_cast< ::valhalla::VehicleType >(has_vehicle_type_.vehicle_type_);
  }
  return static_cast< ::valhalla::VehicleType >(0);
}
inline void TripLeg_Edge::set_vehicle_type(::valhalla::VehicleType value) {
  if (!has_vehicle_type()) {
    clear_has_vehicle_type();
    set_has_vehicle_type();
  }
  has_vehicle_type_.vehicle_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.vehicle_type)
}

// optional .valhalla.PedestrianType pedestrian_type = 22;
inline bool TripLeg_Edge::has_pedestrian_type() const {
  return has_pedestrian_type_case() == kPedestrianType;
}
inline void TripLeg_Edge::set_has_pedestrian_type() {
  _oneof_case_[19] = kPedestrianType;
}
inline void TripLeg_Edge::clear_pedestrian_type() {
  if (has_pedestrian_type()) {
    has_pedestrian_type_.pedestrian_type_ = 0;
    clear_has_has_pedestrian_type();
  }
}
inline ::valhalla::PedestrianType TripLeg_Edge::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.pedestrian_type)
  if (has_pedestrian_type()) {
    return static_cast< ::valhalla::PedestrianType >(has_pedestrian_type_.pedestrian_type_);
  }
  return static_cast< ::valhalla::PedestrianType >(0);
}
inline void TripLeg_Edge::set_pedestrian_type(::valhalla::PedestrianType value) {
  if (!has_pedestrian_type()) {
    clear_has_pedestrian_type();
    set_has_pedestrian_type();
  }
  has_pedestrian_type_.pedestrian_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.pedestrian_type)
}

// optional .valhalla.BicycleType bicycle_type = 23;
inline bool TripLeg_Edge::has_bicycle_type() const {
  return has_bicycle_type_case() == kBicycleType;
}
inline void TripLeg_Edge::set_has_bicycle_type() {
  _oneof_case_[20] = kBicycleType;
}
inline void TripLeg_Edge::clear_bicycle_type() {
  if (has_bicycle_type()) {
    has_bicycle_type_.bicycle_type_ = 0;
    clear_has_has_bicycle_type();
  }
}
inline ::valhalla::BicycleType TripLeg_Edge::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_type)
  if (has_bicycle_type()) {
    return static_cast< ::valhalla::BicycleType >(has_bicycle_type_.bicycle_type_);
  }
  return static_cast< ::valhalla::BicycleType >(0);
}
inline void TripLeg_Edge::set_bicycle_type(::valhalla::BicycleType value) {
  if (!has_bicycle_type()) {
    clear_has_bicycle_type();
    set_has_bicycle_type();
  }
  has_bicycle_type_.bicycle_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_type)
}

// optional .valhalla.TransitType transit_type = 24;
inline bool TripLeg_Edge::has_transit_type() const {
  return has_transit_type_case() == kTransitType;
}
inline void TripLeg_Edge::set_has_transit_type() {
  _oneof_case_[21] = kTransitType;
}
inline void TripLeg_Edge::clear_transit_type() {
  if (has_transit_type()) {
    has_transit_type_.transit_type_ = 0;
    clear_has_has_transit_type();
  }
}
inline ::valhalla::TransitType TripLeg_Edge::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_type)
  if (has_transit_type()) {
    return static_cast< ::valhalla::TransitType >(has_transit_type_.transit_type_);
  }
  return static_cast< ::valhalla::TransitType >(0);
}
inline void TripLeg_Edge::set_transit_type(::valhalla::TransitType value) {
  if (!has_transit_type()) {
    clear_has_transit_type();
    set_has_transit_type();
  }
  has_transit_type_.transit_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.transit_type)
}

// optional .valhalla.TransitRouteInfo transit_route_info = 25;
inline bool TripLeg_Edge::has_transit_route_info() const {
  return !_is_default_instance_ && transit_route_info_ != NULL;
}
inline void TripLeg_Edge::clear_transit_route_info() {
  if (GetArenaNoVirtual() == NULL && transit_route_info_ != NULL) delete transit_route_info_;
  transit_route_info_ = NULL;
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::transit_route_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_route_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance().transit_route_info_;
#else
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance_->transit_route_info_;
#endif
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::mutable_transit_route_info() {
  
  if (transit_route_info_ == NULL) {
    transit_route_info_ = new ::valhalla::TransitRouteInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.transit_route_info)
  return transit_route_info_;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::release_transit_route_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.transit_route_info)
  
  ::valhalla::TransitRouteInfo* temp = transit_route_info_;
  transit_route_info_ = NULL;
  return temp;
}
inline void TripLeg_Edge::set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info) {
  delete transit_route_info_;
  transit_route_info_ = transit_route_info;
  if (transit_route_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}

// optional uint64 id = 26;
inline bool TripLeg_Edge::has_id() const {
  return has_id_case() == kId;
}
inline void TripLeg_Edge::set_has_id() {
  _oneof_case_[22] = kId;
}
inline void TripLeg_Edge::clear_id() {
  if (has_id()) {
    has_id_.id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_id();
  }
}
inline ::google::protobuf::uint64 TripLeg_Edge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.id)
  if (has_id()) {
    return has_id_.id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TripLeg_Edge::set_id(::google::protobuf::uint64 value) {
  if (!has_id()) {
    clear_has_id();
    set_has_id();
  }
  has_id_.id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.id)
}

// optional uint64 way_id = 27;
inline bool TripLeg_Edge::has_way_id() const {
  return has_way_id_case() == kWayId;
}
inline void TripLeg_Edge::set_has_way_id() {
  _oneof_case_[23] = kWayId;
}
inline void TripLeg_Edge::clear_way_id() {
  if (has_way_id()) {
    has_way_id_.way_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_way_id();
  }
}
inline ::google::protobuf::uint64 TripLeg_Edge::way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.way_id)
  if (has_way_id()) {
    return has_way_id_.way_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TripLeg_Edge::set_way_id(::google::protobuf::uint64 value) {
  if (!has_way_id()) {
    clear_has_way_id();
    set_has_way_id();
  }
  has_way_id_.way_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.way_id)
}

// optional float weighted_grade = 28;
inline bool TripLeg_Edge::has_weighted_grade() const {
  return has_weighted_grade_case() == kWeightedGrade;
}
inline void TripLeg_Edge::set_has_weighted_grade() {
  _oneof_case_[24] = kWeightedGrade;
}
inline void TripLeg_Edge::clear_weighted_grade() {
  if (has_weighted_grade()) {
    has_weighted_grade_.weighted_grade_ = 0;
    clear_has_has_weighted_grade();
  }
}
inline float TripLeg_Edge::weighted_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.weighted_grade)
  if (has_weighted_grade()) {
    return has_weighted_grade_.weighted_grade_;
  }
  return 0;
}
inline void TripLeg_Edge::set_weighted_grade(float value) {
  if (!has_weighted_grade()) {
    clear_has_weighted_grade();
    set_has_weighted_grade();
  }
  has_weighted_grade_.weighted_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.weighted_grade)
}

// optional int32 max_upward_grade = 29;
inline bool TripLeg_Edge::has_max_upward_grade() const {
  return has_max_upward_grade_case() == kMaxUpwardGrade;
}
inline void TripLeg_Edge::set_has_max_upward_grade() {
  _oneof_case_[25] = kMaxUpwardGrade;
}
inline void TripLeg_Edge::clear_max_upward_grade() {
  if (has_max_upward_grade()) {
    has_max_upward_grade_.max_upward_grade_ = 0;
    clear_has_has_max_upward_grade();
  }
}
inline ::google::protobuf::int32 TripLeg_Edge::max_upward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_upward_grade)
  if (has_max_upward_grade()) {
    return has_max_upward_grade_.max_upward_grade_;
  }
  return 0;
}
inline void TripLeg_Edge::set_max_upward_grade(::google::protobuf::int32 value) {
  if (!has_max_upward_grade()) {
    clear_has_max_upward_grade();
    set_has_max_upward_grade();
  }
  has_max_upward_grade_.max_upward_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_upward_grade)
}

// optional int32 max_downward_grade = 30;
inline bool TripLeg_Edge::has_max_downward_grade() const {
  return has_max_downward_grade_case() == kMaxDownwardGrade;
}
inline void TripLeg_Edge::set_has_max_downward_grade() {
  _oneof_case_[26] = kMaxDownwardGrade;
}
inline void TripLeg_Edge::clear_max_downward_grade() {
  if (has_max_downward_grade()) {
    has_max_downward_grade_.max_downward_grade_ = 0;
    clear_has_has_max_downward_grade();
  }
}
inline ::google::protobuf::int32 TripLeg_Edge::max_downward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_downward_grade)
  if (has_max_downward_grade()) {
    return has_max_downward_grade_.max_downward_grade_;
  }
  return 0;
}
inline void TripLeg_Edge::set_max_downward_grade(::google::protobuf::int32 value) {
  if (!has_max_downward_grade()) {
    clear_has_max_downward_grade();
    set_has_max_downward_grade();
  }
  has_max_downward_grade_.max_downward_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_downward_grade)
}

// optional uint32 lane_count = 31;
inline bool TripLeg_Edge::has_lane_count() const {
  return has_lane_count_case() == kLaneCount;
}
inline void TripLeg_Edge::set_has_lane_count() {
  _oneof_case_[27] = kLaneCount;
}
inline void TripLeg_Edge::clear_lane_count() {
  if (has_lane_count()) {
    has_lane_count_.lane_count_ = 0u;
    clear_has_has_lane_count();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_count)
  if (has_lane_count()) {
    return has_lane_count_.lane_count_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_lane_count(::google::protobuf::uint32 value) {
  if (!has_lane_count()) {
    clear_has_lane_count();
    set_has_lane_count();
  }
  has_lane_count_.lane_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.lane_count)
}

// optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
inline bool TripLeg_Edge::has_cycle_lane() const {
  return has_cycle_lane_case() == kCycleLane;
}
inline void TripLeg_Edge::set_has_cycle_lane() {
  _oneof_case_[28] = kCycleLane;
}
inline void TripLeg_Edge::clear_cycle_lane() {
  if (has_cycle_lane()) {
    has_cycle_lane_.cycle_lane_ = 0;
    clear_has_has_cycle_lane();
  }
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::cycle_lane() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.cycle_lane)
  if (has_cycle_lane()) {
    return static_cast< ::valhalla::TripLeg_CycleLane >(has_cycle_lane_.cycle_lane_);
  }
  return static_cast< ::valhalla::TripLeg_CycleLane >(0);
}
inline void TripLeg_Edge::set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  if (!has_cycle_lane()) {
    clear_has_cycle_lane();
    set_has_cycle_lane();
  }
  has_cycle_lane_.cycle_lane_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.cycle_lane)
}

// optional uint32 bicycle_network = 33;
inline bool TripLeg_Edge::has_bicycle_network() const {
  return has_bicycle_network_case() == kBicycleNetwork;
}
inline void TripLeg_Edge::set_has_bicycle_network() {
  _oneof_case_[29] = kBicycleNetwork;
}
inline void TripLeg_Edge::clear_bicycle_network() {
  if (has_bicycle_network()) {
    has_bicycle_network_.bicycle_network_ = 0u;
    clear_has_has_bicycle_network();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::bicycle_network() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_network)
  if (has_bicycle_network()) {
    return has_bicycle_network_.bicycle_network_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_bicycle_network(::google::protobuf::uint32 value) {
  if (!has_bicycle_network()) {
    clear_has_bicycle_network();
    set_has_bicycle_network();
  }
  has_bicycle_network_.bicycle_network_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_network)
}

// optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
inline bool TripLeg_Edge::has_sidewalk() const {
  return has_sidewalk_case() == kSidewalk;
}
inline void TripLeg_Edge::set_has_sidewalk() {
  _oneof_case_[30] = kSidewalk;
}
inline void TripLeg_Edge::clear_sidewalk() {
  if (has_sidewalk()) {
    has_sidewalk_.sidewalk_ = 0;
    clear_has_has_sidewalk();
  }
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::sidewalk() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sidewalk)
  if (has_sidewalk()) {
    return static_cast< ::valhalla::TripLeg_Sidewalk >(has_sidewalk_.sidewalk_);
  }
  return static_cast< ::valhalla::TripLeg_Sidewalk >(0);
}
inline void TripLeg_Edge::set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  if (!has_sidewalk()) {
    clear_has_sidewalk();
    set_has_sidewalk();
  }
  has_sidewalk_.sidewalk_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sidewalk)
}

// optional uint32 density = 35;
inline bool TripLeg_Edge::has_density() const {
  return has_density_case() == kDensity;
}
inline void TripLeg_Edge::set_has_density() {
  _oneof_case_[31] = kDensity;
}
inline void TripLeg_Edge::clear_density() {
  if (has_density()) {
    has_density_.density_ = 0u;
    clear_has_has_density();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::density() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.density)
  if (has_density()) {
    return has_density_.density_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_density(::google::protobuf::uint32 value) {
  if (!has_density()) {
    clear_has_density();
    set_has_density();
  }
  has_density_.density_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.density)
}

// optional uint32 speed_limit = 36;
inline bool TripLeg_Edge::has_speed_limit() const {
  return has_speed_limit_case() == kSpeedLimit;
}
inline void TripLeg_Edge::set_has_speed_limit() {
  _oneof_case_[32] = kSpeedLimit;
}
inline void TripLeg_Edge::clear_speed_limit() {
  if (has_speed_limit()) {
    has_speed_limit_.speed_limit_ = 0u;
    clear_has_has_speed_limit();
  }
}
inline ::google::protobuf::uint32 TripLeg_Edge::speed_limit() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed_limit)
  if (has_speed_limit()) {
    return has_speed_limit_.speed_limit_;
  }
  return 0u;
}
inline void TripLeg_Edge::set_speed_limit(::google::protobuf::uint32 value) {
  if (!has_speed_limit()) {
    clear_has_speed_limit();
    set_has_speed_limit();
  }
  has_speed_limit_.speed_limit_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed_limit)
}

// optional float truck_speed = 37;
inline bool TripLeg_Edge::has_truck_speed() const {
  return has_truck_speed_case() == kTruckSpeed;
}
inline void TripLeg_Edge::set_has_truck_speed() {
  _oneof_case_[33] = kTruckSpeed;
}
inline void TripLeg_Edge::clear_truck_speed() {
  if (has_truck_speed()) {
    has_truck_speed_.truck_speed_ = 0;
    clear_has_has_truck_speed();
  }
}
inline float TripLeg_Edge::truck_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_speed)
  if (has_truck_speed()) {
    return has_truck_speed_.truck_speed_;
  }
  return 0;
}
inline void TripLeg_Edge::set_truck_speed(float value) {
  if (!has_truck_speed()) {
    clear_has_truck_speed();
    set_has_truck_speed();
  }
  has_truck_speed_.truck_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_speed)
}

// optional bool truck_route = 38;
inline bool TripLeg_Edge::has_truck_route() const {
  return has_truck_route_case() == kTruckRoute;
}
inline void TripLeg_Edge::set_has_truck_route() {
  _oneof_case_[34] = kTruckRoute;
}
inline void TripLeg_Edge::clear_truck_route() {
  if (has_truck_route()) {
    has_truck_route_.truck_route_ = false;
    clear_has_has_truck_route();
  }
}
inline bool TripLeg_Edge::truck_route() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_route)
  if (has_truck_route()) {
    return has_truck_route_.truck_route_;
  }
  return false;
}
inline void TripLeg_Edge::set_truck_route(bool value) {
  if (!has_truck_route()) {
    clear_has_truck_route();
    set_has_truck_route();
  }
  has_truck_route_.truck_route_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_route)
}

// repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
inline int TripLeg_Edge::lane_connectivity_size() const {
  return lane_connectivity_.size();
}
inline void TripLeg_Edge::clear_lane_connectivity() {
  lane_connectivity_.Clear();
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::lane_connectivity(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_.Get(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::mutable_lane_connectivity(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_.Mutable(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::add_lane_connectivity() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
TripLeg_Edge::mutable_lane_connectivity() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.lane_connectivity)
  return &lane_connectivity_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
TripLeg_Edge::lane_connectivity() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_;
}

// optional int32 mean_elevation = 40;
inline bool TripLeg_Edge::has_mean_elevation() const {
  return has_mean_elevation_case() == kMeanElevation;
}
inline void TripLeg_Edge::set_has_mean_elevation() {
  _oneof_case_[35] = kMeanElevation;
}
inline void TripLeg_Edge::clear_mean_elevation() {
  if (has_mean_elevation()) {
    has_mean_elevation_.mean_elevation_ = 0;
    clear_has_has_mean_elevation();
  }
}
inline ::google::protobuf::int32 TripLeg_Edge::mean_elevation() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.mean_elevation)
  if (has_mean_elevation()) {
    return has_mean_elevation_.mean_elevation_;
  }
  return 0;
}
inline void TripLeg_Edge::set_mean_elevation(::google::protobuf::int32 value) {
  if (!has_mean_elevation()) {
    clear_has_mean_elevation();
    set_has_mean_elevation();
  }
  has_mean_elevation_.mean_elevation_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.mean_elevation)
}

// repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
inline int TripLeg_Edge::traffic_segment_size() const {
  return traffic_segment_.size();
}
inline void TripLeg_Edge::clear_traffic_segment() {
  traffic_segment_.Clear();
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::traffic_segment(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_.Get(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::mutable_traffic_segment(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_.Mutable(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::add_traffic_segment() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
TripLeg_Edge::mutable_traffic_segment() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.traffic_segment)
  return &traffic_segment_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
TripLeg_Edge::traffic_segment() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_;
}

// repeated .valhalla.TurnLane turn_lanes = 42;
inline int TripLeg_Edge::turn_lanes_size() const {
  return turn_lanes_.size();
}
inline void TripLeg_Edge::clear_turn_lanes() {
  turn_lanes_.Clear();
}
inline const ::valhalla::TurnLane& TripLeg_Edge::turn_lanes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_.Get(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::mutable_turn_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_.Mutable(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::add_turn_lanes() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >*
TripLeg_Edge::mutable_turn_lanes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.turn_lanes)
  return &turn_lanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >&
TripLeg_Edge::turn_lanes() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_;
}

// optional bool has_time_restrictions = 43;
inline bool TripLeg_Edge::has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
inline void TripLeg_Edge::set_has_has_time_restrictions() {
  _oneof_case_[36] = kHasTimeRestrictions;
}
inline void TripLeg_Edge::clear_has_time_restrictions() {
  if (has_has_time_restrictions()) {
    has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
inline bool TripLeg_Edge::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.has_time_restrictions)
  if (has_has_time_restrictions()) {
    return has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
inline void TripLeg_Edge::set_has_time_restrictions(bool value) {
  if (!has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  has_has_time_restrictions_.has_time_restrictions_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.has_time_restrictions)
}

// optional float default_speed = 44;
inline bool TripLeg_Edge::has_default_speed() const {
  return has_default_speed_case() == kDefaultSpeed;
}
inline void TripLeg_Edge::set_has_default_speed() {
  _oneof_case_[37] = kDefaultSpeed;
}
inline void TripLeg_Edge::clear_default_speed() {
  if (has_default_speed()) {
    has_default_speed_.default_speed_ = 0;
    clear_has_has_default_speed();
  }
}
inline float TripLeg_Edge::default_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.default_speed)
  if (has_default_speed()) {
    return has_default_speed_.default_speed_;
  }
  return 0;
}
inline void TripLeg_Edge::set_default_speed(float value) {
  if (!has_default_speed()) {
    clear_has_default_speed();
    set_has_default_speed();
  }
  has_default_speed_.default_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.default_speed)
}

// optional .valhalla.TripLeg.Restriction restriction = 45;
inline bool TripLeg_Edge::has_restriction() const {
  return !_is_default_instance_ && restriction_ != NULL;
}
inline void TripLeg_Edge::clear_restriction() {
  if (GetArenaNoVirtual() == NULL && restriction_ != NULL) delete restriction_;
  restriction_ = NULL;
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::restriction() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.restriction)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return restriction_ != NULL ? *restriction_ : *default_instance().restriction_;
#else
  return restriction_ != NULL ? *restriction_ : *default_instance_->restriction_;
#endif
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::mutable_restriction() {
  
  if (restriction_ == NULL) {
    restriction_ = new ::valhalla::TripLeg_Restriction;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.restriction)
  return restriction_;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::release_restriction() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.restriction)
  
  ::valhalla::TripLeg_Restriction* temp = restriction_;
  restriction_ = NULL;
  return temp;
}
inline void TripLeg_Edge::set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction) {
  delete restriction_;
  restriction_ = restriction;
  if (restriction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.restriction)
}

// optional bool destination_only = 46;
inline bool TripLeg_Edge::has_destination_only() const {
  return has_destination_only_case() == kDestinationOnly;
}
inline void TripLeg_Edge::set_has_destination_only() {
  _oneof_case_[38] = kDestinationOnly;
}
inline void TripLeg_Edge::clear_destination_only() {
  if (has_destination_only()) {
    has_destination_only_.destination_only_ = false;
    clear_has_has_destination_only();
  }
}
inline bool TripLeg_Edge::destination_only() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.destination_only)
  if (has_destination_only()) {
    return has_destination_only_.destination_only_;
  }
  return false;
}
inline void TripLeg_Edge::set_destination_only(bool value) {
  if (!has_destination_only()) {
    clear_has_destination_only();
    set_has_destination_only();
  }
  has_destination_only_.destination_only_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.destination_only)
}

// optional bool is_urban = 47;
inline bool TripLeg_Edge::has_is_urban() const {
  return has_is_urban_case() == kIsUrban;
}
inline void TripLeg_Edge::set_has_is_urban() {
  _oneof_case_[39] = kIsUrban;
}
inline void TripLeg_Edge::clear_is_urban() {
  if (has_is_urban()) {
    has_is_urban_.is_urban_ = false;
    clear_has_has_is_urban();
  }
}
inline bool TripLeg_Edge::is_urban() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.is_urban)
  if (has_is_urban()) {
    return has_is_urban_.is_urban_;
  }
  return false;
}
inline void TripLeg_Edge::set_is_urban(bool value) {
  if (!has_is_urban()) {
    clear_has_is_urban();
    set_has_is_urban();
  }
  has_is_urban_.is_urban_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.is_urban)
}

// repeated .valhalla.TaggedValue tagged_value = 48;
inline int TripLeg_Edge::tagged_value_size() const {
  return tagged_value_.size();
}
inline void TripLeg_Edge::clear_tagged_value() {
  tagged_value_.Clear();
}
inline const ::valhalla::TaggedValue& TripLeg_Edge::tagged_value(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_.Get(index);
}
inline ::valhalla::TaggedValue* TripLeg_Edge::mutable_tagged_value(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_.Mutable(index);
}
inline ::valhalla::TaggedValue* TripLeg_Edge::add_tagged_value() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >*
TripLeg_Edge::mutable_tagged_value() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.tagged_value)
  return &tagged_value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >&
TripLeg_Edge::tagged_value() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_;
}

// optional float source_along_edge = 49;
inline bool TripLeg_Edge::has_source_along_edge() const {
  return has_source_along_edge_case() == kSourceAlongEdge;
}
inline void TripLeg_Edge::set_has_source_along_edge() {
  _oneof_case_[40] = kSourceAlongEdge;
}
inline void TripLeg_Edge::clear_source_along_edge() {
  if (has_source_along_edge()) {
    has_source_along_edge_.source_along_edge_ = 0;
    clear_has_has_source_along_edge();
  }
}
inline float TripLeg_Edge::source_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.source_along_edge)
  if (has_source_along_edge()) {
    return has_source_along_edge_.source_along_edge_;
  }
  return 0;
}
inline void TripLeg_Edge::set_source_along_edge(float value) {
  if (!has_source_along_edge()) {
    clear_has_source_along_edge();
    set_has_source_along_edge();
  }
  has_source_along_edge_.source_along_edge_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.source_along_edge)
}

// optional float target_along_edge = 50;
inline bool TripLeg_Edge::has_target_along_edge() const {
  return has_target_along_edge_case() == kTargetAlongEdge;
}
inline void TripLeg_Edge::set_has_target_along_edge() {
  _oneof_case_[41] = kTargetAlongEdge;
}
inline void TripLeg_Edge::clear_target_along_edge() {
  if (has_target_along_edge()) {
    has_target_along_edge_.target_along_edge_ = 0;
    clear_has_has_target_along_edge();
  }
}
inline float TripLeg_Edge::target_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.target_along_edge)
  if (has_target_along_edge()) {
    return has_target_along_edge_.target_along_edge_;
  }
  return 0;
}
inline void TripLeg_Edge::set_target_along_edge(float value) {
  if (!has_target_along_edge()) {
    clear_has_target_along_edge();
    set_has_target_along_edge();
  }
  has_target_along_edge_.target_along_edge_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.target_along_edge)
}

// optional .valhalla.TripLeg.SacScale sac_scale = 51;
inline bool TripLeg_Edge::has_sac_scale() const {
  return has_sac_scale_case() == kSacScale;
}
inline void TripLeg_Edge::set_has_sac_scale() {
  _oneof_case_[42] = kSacScale;
}
inline void TripLeg_Edge::clear_sac_scale() {
  if (has_sac_scale()) {
    has_sac_scale_.sac_scale_ = 0;
    clear_has_has_sac_scale();
  }
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::sac_scale() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sac_scale)
  if (has_sac_scale()) {
    return static_cast< ::valhalla::TripLeg_SacScale >(has_sac_scale_.sac_scale_);
  }
  return static_cast< ::valhalla::TripLeg_SacScale >(0);
}
inline void TripLeg_Edge::set_sac_scale(::valhalla::TripLeg_SacScale value) {
  if (!has_sac_scale()) {
    clear_has_sac_scale();
    set_has_sac_scale();
  }
  has_sac_scale_.sac_scale_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sac_scale)
}

// optional bool shoulder = 52;
inline bool TripLeg_Edge::has_shoulder() const {
  return has_shoulder_case() == kShoulder;
}
inline void TripLeg_Edge::set_has_shoulder() {
  _oneof_case_[43] = kShoulder;
}
inline void TripLeg_Edge::clear_shoulder() {
  if (has_shoulder()) {
    has_shoulder_.shoulder_ = false;
    clear_has_has_shoulder();
  }
}
inline bool TripLeg_Edge::shoulder() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.shoulder)
  if (has_shoulder()) {
    return has_shoulder_.shoulder_;
  }
  return false;
}
inline void TripLeg_Edge::set_shoulder(bool value) {
  if (!has_shoulder()) {
    clear_has_shoulder();
    set_has_shoulder();
  }
  has_shoulder_.shoulder_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.shoulder)
}

// optional float total_length_km = 53;
inline bool TripLeg_Edge::has_total_length_km() const {
  return has_total_length_km_case() == kTotalLengthKm;
}
inline void TripLeg_Edge::set_has_total_length_km() {
  _oneof_case_[44] = kTotalLengthKm;
}
inline void TripLeg_Edge::clear_total_length_km() {
  if (has_total_length_km()) {
    has_total_length_km_.total_length_km_ = 0;
    clear_has_has_total_length_km();
  }
}
inline float TripLeg_Edge::total_length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.total_length_km)
  if (has_total_length_km()) {
    return has_total_length_km_.total_length_km_;
  }
  return 0;
}
inline void TripLeg_Edge::set_total_length_km(float value) {
  if (!has_total_length_km()) {
    clear_has_total_length_km();
    set_has_total_length_km();
  }
  has_total_length_km_.total_length_km_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.total_length_km)
}

// optional int64 shortcut_id = 54;
inline bool TripLeg_Edge::has_shortcut_id() const {
  return has_shortcut_id_case() == kShortcutId;
}
inline void TripLeg_Edge::set_has_shortcut_id() {
  _oneof_case_[45] = kShortcutId;
}
inline void TripLeg_Edge::clear_shortcut_id() {
  if (has_shortcut_id()) {
    has_shortcut_id_.shortcut_id_ = GOOGLE_LONGLONG(0);
    clear_has_has_shortcut_id();
  }
}
inline ::google::protobuf::int64 TripLeg_Edge::shortcut_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.shortcut_id)
  if (has_shortcut_id()) {
    return has_shortcut_id_.shortcut_id_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TripLeg_Edge::set_shortcut_id(::google::protobuf::int64 value) {
  if (!has_shortcut_id()) {
    clear_has_shortcut_id();
    set_has_shortcut_id();
  }
  has_shortcut_id_.shortcut_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.shortcut_id)
}

inline bool TripLeg_Edge::has_has_length_km() const {
  return has_length_km_case() != HAS_LENGTH_KM_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_length_km() {
  _oneof_case_[0] = HAS_LENGTH_KM_NOT_SET;
}
inline bool TripLeg_Edge::has_has_speed() const {
  return has_speed_case() != HAS_SPEED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_speed() {
  _oneof_case_[1] = HAS_SPEED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_road_class() const {
  return has_road_class_case() != HAS_ROAD_CLASS_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_road_class() {
  _oneof_case_[2] = HAS_ROAD_CLASS_NOT_SET;
}
inline bool TripLeg_Edge::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_begin_heading() {
  _oneof_case_[3] = HAS_BEGIN_HEADING_NOT_SET;
}
inline bool TripLeg_Edge::has_has_end_heading() const {
  return has_end_heading_case() != HAS_END_HEADING_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_end_heading() {
  _oneof_case_[4] = HAS_END_HEADING_NOT_SET;
}
inline bool TripLeg_Edge::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_begin_shape_index() {
  _oneof_case_[5] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Edge::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_end_shape_index() {
  _oneof_case_[6] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Edge::has_has_traversability() const {
  return has_traversability_case() != HAS_TRAVERSABILITY_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_traversability() {
  _oneof_case_[7] = HAS_TRAVERSABILITY_NOT_SET;
}
inline bool TripLeg_Edge::has_has_use() const {
  return has_use_case() != HAS_USE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_use() {
  _oneof_case_[8] = HAS_USE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_toll() const {
  return has_toll_case() != HAS_TOLL_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_toll() {
  _oneof_case_[9] = HAS_TOLL_NOT_SET;
}
inline bool TripLeg_Edge::has_has_unpaved() const {
  return has_unpaved_case() != HAS_UNPAVED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_unpaved() {
  _oneof_case_[10] = HAS_UNPAVED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_tunnel() const {
  return has_tunnel_case() != HAS_TUNNEL_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_tunnel() {
  _oneof_case_[11] = HAS_TUNNEL_NOT_SET;
}
inline bool TripLeg_Edge::has_has_bridge() const {
  return has_bridge_case() != HAS_BRIDGE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_bridge() {
  _oneof_case_[12] = HAS_BRIDGE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_roundabout() const {
  return has_roundabout_case() != HAS_ROUNDABOUT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_roundabout() {
  _oneof_case_[13] = HAS_ROUNDABOUT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_internal_intersection() const {
  return has_internal_intersection_case() != HAS_INTERNAL_INTERSECTION_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_internal_intersection() {
  _oneof_case_[14] = HAS_INTERNAL_INTERSECTION_NOT_SET;
}
inline bool TripLeg_Edge::has_has_drive_on_left() const {
  return has_drive_on_left_case() != HAS_DRIVE_ON_LEFT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_drive_on_left() {
  _oneof_case_[15] = HAS_DRIVE_ON_LEFT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_surface() const {
  return has_surface_case() != HAS_SURFACE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_surface() {
  _oneof_case_[16] = HAS_SURFACE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_travel_mode() const {
  return has_travel_mode_case() != HAS_TRAVEL_MODE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_travel_mode() {
  _oneof_case_[17] = HAS_TRAVEL_MODE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_vehicle_type() const {
  return has_vehicle_type_case() != HAS_VEHICLE_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_vehicle_type() {
  _oneof_case_[18] = HAS_VEHICLE_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_pedestrian_type() const {
  return has_pedestrian_type_case() != HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_pedestrian_type() {
  _oneof_case_[19] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_bicycle_type() const {
  return has_bicycle_type_case() != HAS_BICYCLE_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_bicycle_type() {
  _oneof_case_[20] = HAS_BICYCLE_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_transit_type() const {
  return has_transit_type_case() != HAS_TRANSIT_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_transit_type() {
  _oneof_case_[21] = HAS_TRANSIT_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_id() {
  _oneof_case_[22] = HAS_ID_NOT_SET;
}
inline bool TripLeg_Edge::has_has_way_id() const {
  return has_way_id_case() != HAS_WAY_ID_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_way_id() {
  _oneof_case_[23] = HAS_WAY_ID_NOT_SET;
}
inline bool TripLeg_Edge::has_has_weighted_grade() const {
  return has_weighted_grade_case() != HAS_WEIGHTED_GRADE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_weighted_grade() {
  _oneof_case_[24] = HAS_WEIGHTED_GRADE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_max_upward_grade() const {
  return has_max_upward_grade_case() != HAS_MAX_UPWARD_GRADE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_max_upward_grade() {
  _oneof_case_[25] = HAS_MAX_UPWARD_GRADE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_max_downward_grade() const {
  return has_max_downward_grade_case() != HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_max_downward_grade() {
  _oneof_case_[26] = HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_lane_count() const {
  return has_lane_count_case() != HAS_LANE_COUNT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_lane_count() {
  _oneof_case_[27] = HAS_LANE_COUNT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_cycle_lane() const {
  return has_cycle_lane_case() != HAS_CYCLE_LANE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_cycle_lane() {
  _oneof_case_[28] = HAS_CYCLE_LANE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_bicycle_network() const {
  return has_bicycle_network_case() != HAS_BICYCLE_NETWORK_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_bicycle_network() {
  _oneof_case_[29] = HAS_BICYCLE_NETWORK_NOT_SET;
}
inline bool TripLeg_Edge::has_has_sidewalk() const {
  return has_sidewalk_case() != HAS_SIDEWALK_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_sidewalk() {
  _oneof_case_[30] = HAS_SIDEWALK_NOT_SET;
}
inline bool TripLeg_Edge::has_has_density() const {
  return has_density_case() != HAS_DENSITY_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_density() {
  _oneof_case_[31] = HAS_DENSITY_NOT_SET;
}
inline bool TripLeg_Edge::has_has_speed_limit() const {
  return has_speed_limit_case() != HAS_SPEED_LIMIT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_speed_limit() {
  _oneof_case_[32] = HAS_SPEED_LIMIT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_truck_speed() const {
  return has_truck_speed_case() != HAS_TRUCK_SPEED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_truck_speed() {
  _oneof_case_[33] = HAS_TRUCK_SPEED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_truck_route() const {
  return has_truck_route_case() != HAS_TRUCK_ROUTE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_truck_route() {
  _oneof_case_[34] = HAS_TRUCK_ROUTE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_mean_elevation() const {
  return has_mean_elevation_case() != HAS_MEAN_ELEVATION_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_mean_elevation() {
  _oneof_case_[35] = HAS_MEAN_ELEVATION_NOT_SET;
}
inline bool TripLeg_Edge::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_has_time_restrictions() {
  _oneof_case_[36] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline bool TripLeg_Edge::has_has_default_speed() const {
  return has_default_speed_case() != HAS_DEFAULT_SPEED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_default_speed() {
  _oneof_case_[37] = HAS_DEFAULT_SPEED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_destination_only() const {
  return has_destination_only_case() != HAS_DESTINATION_ONLY_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_destination_only() {
  _oneof_case_[38] = HAS_DESTINATION_ONLY_NOT_SET;
}
inline bool TripLeg_Edge::has_has_is_urban() const {
  return has_is_urban_case() != HAS_IS_URBAN_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_is_urban() {
  _oneof_case_[39] = HAS_IS_URBAN_NOT_SET;
}
inline bool TripLeg_Edge::has_has_source_along_edge() const {
  return has_source_along_edge_case() != HAS_SOURCE_ALONG_EDGE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_source_along_edge() {
  _oneof_case_[40] = HAS_SOURCE_ALONG_EDGE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_target_along_edge() const {
  return has_target_along_edge_case() != HAS_TARGET_ALONG_EDGE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_target_along_edge() {
  _oneof_case_[41] = HAS_TARGET_ALONG_EDGE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_sac_scale() const {
  return has_sac_scale_case() != HAS_SAC_SCALE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_sac_scale() {
  _oneof_case_[42] = HAS_SAC_SCALE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_shoulder() const {
  return has_shoulder_case() != HAS_SHOULDER_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_shoulder() {
  _oneof_case_[43] = HAS_SHOULDER_NOT_SET;
}
inline bool TripLeg_Edge::has_has_total_length_km() const {
  return has_total_length_km_case() != HAS_TOTAL_LENGTH_KM_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_total_length_km() {
  _oneof_case_[44] = HAS_TOTAL_LENGTH_KM_NOT_SET;
}
inline bool TripLeg_Edge::has_has_shortcut_id() const {
  return has_shortcut_id_case() != HAS_SHORTCUT_ID_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_shortcut_id() {
  _oneof_case_[45] = HAS_SHORTCUT_ID_NOT_SET;
}
inline TripLeg_Edge::HasLengthKmCase TripLeg_Edge::has_length_km_case() const {
  return TripLeg_Edge::HasLengthKmCase(_oneof_case_[0]);
}
inline TripLeg_Edge::HasSpeedCase TripLeg_Edge::has_speed_case() const {
  return TripLeg_Edge::HasSpeedCase(_oneof_case_[1]);
}
inline TripLeg_Edge::HasRoadClassCase TripLeg_Edge::has_road_class_case() const {
  return TripLeg_Edge::HasRoadClassCase(_oneof_case_[2]);
}
inline TripLeg_Edge::HasBeginHeadingCase TripLeg_Edge::has_begin_heading_case() const {
  return TripLeg_Edge::HasBeginHeadingCase(_oneof_case_[3]);
}
inline TripLeg_Edge::HasEndHeadingCase TripLeg_Edge::has_end_heading_case() const {
  return TripLeg_Edge::HasEndHeadingCase(_oneof_case_[4]);
}
inline TripLeg_Edge::HasBeginShapeIndexCase TripLeg_Edge::has_begin_shape_index_case() const {
  return TripLeg_Edge::HasBeginShapeIndexCase(_oneof_case_[5]);
}
inline TripLeg_Edge::HasEndShapeIndexCase TripLeg_Edge::has_end_shape_index_case() const {
  return TripLeg_Edge::HasEndShapeIndexCase(_oneof_case_[6]);
}
inline TripLeg_Edge::HasTraversabilityCase TripLeg_Edge::has_traversability_case() const {
  return TripLeg_Edge::HasTraversabilityCase(_oneof_case_[7]);
}
inline TripLeg_Edge::HasUseCase TripLeg_Edge::has_use_case() const {
  return TripLeg_Edge::HasUseCase(_oneof_case_[8]);
}
inline TripLeg_Edge::HasTollCase TripLeg_Edge::has_toll_case() const {
  return TripLeg_Edge::HasTollCase(_oneof_case_[9]);
}
inline TripLeg_Edge::HasUnpavedCase TripLeg_Edge::has_unpaved_case() const {
  return TripLeg_Edge::HasUnpavedCase(_oneof_case_[10]);
}
inline TripLeg_Edge::HasTunnelCase TripLeg_Edge::has_tunnel_case() const {
  return TripLeg_Edge::HasTunnelCase(_oneof_case_[11]);
}
inline TripLeg_Edge::HasBridgeCase TripLeg_Edge::has_bridge_case() const {
  return TripLeg_Edge::HasBridgeCase(_oneof_case_[12]);
}
inline TripLeg_Edge::HasRoundaboutCase TripLeg_Edge::has_roundabout_case() const {
  return TripLeg_Edge::HasRoundaboutCase(_oneof_case_[13]);
}
inline TripLeg_Edge::HasInternalIntersectionCase TripLeg_Edge::has_internal_intersection_case() const {
  return TripLeg_Edge::HasInternalIntersectionCase(_oneof_case_[14]);
}
inline TripLeg_Edge::HasDriveOnLeftCase TripLeg_Edge::has_drive_on_left_case() const {
  return TripLeg_Edge::HasDriveOnLeftCase(_oneof_case_[15]);
}
inline TripLeg_Edge::HasSurfaceCase TripLeg_Edge::has_surface_case() const {
  return TripLeg_Edge::HasSurfaceCase(_oneof_case_[16]);
}
inline TripLeg_Edge::HasTravelModeCase TripLeg_Edge::has_travel_mode_case() const {
  return TripLeg_Edge::HasTravelModeCase(_oneof_case_[17]);
}
inline TripLeg_Edge::HasVehicleTypeCase TripLeg_Edge::has_vehicle_type_case() const {
  return TripLeg_Edge::HasVehicleTypeCase(_oneof_case_[18]);
}
inline TripLeg_Edge::HasPedestrianTypeCase TripLeg_Edge::has_pedestrian_type_case() const {
  return TripLeg_Edge::HasPedestrianTypeCase(_oneof_case_[19]);
}
inline TripLeg_Edge::HasBicycleTypeCase TripLeg_Edge::has_bicycle_type_case() const {
  return TripLeg_Edge::HasBicycleTypeCase(_oneof_case_[20]);
}
inline TripLeg_Edge::HasTransitTypeCase TripLeg_Edge::has_transit_type_case() const {
  return TripLeg_Edge::HasTransitTypeCase(_oneof_case_[21]);
}
inline TripLeg_Edge::HasIdCase TripLeg_Edge::has_id_case() const {
  return TripLeg_Edge::HasIdCase(_oneof_case_[22]);
}
inline TripLeg_Edge::HasWayIdCase TripLeg_Edge::has_way_id_case() const {
  return TripLeg_Edge::HasWayIdCase(_oneof_case_[23]);
}
inline TripLeg_Edge::HasWeightedGradeCase TripLeg_Edge::has_weighted_grade_case() const {
  return TripLeg_Edge::HasWeightedGradeCase(_oneof_case_[24]);
}
inline TripLeg_Edge::HasMaxUpwardGradeCase TripLeg_Edge::has_max_upward_grade_case() const {
  return TripLeg_Edge::HasMaxUpwardGradeCase(_oneof_case_[25]);
}
inline TripLeg_Edge::HasMaxDownwardGradeCase TripLeg_Edge::has_max_downward_grade_case() const {
  return TripLeg_Edge::HasMaxDownwardGradeCase(_oneof_case_[26]);
}
inline TripLeg_Edge::HasLaneCountCase TripLeg_Edge::has_lane_count_case() const {
  return TripLeg_Edge::HasLaneCountCase(_oneof_case_[27]);
}
inline TripLeg_Edge::HasCycleLaneCase TripLeg_Edge::has_cycle_lane_case() const {
  return TripLeg_Edge::HasCycleLaneCase(_oneof_case_[28]);
}
inline TripLeg_Edge::HasBicycleNetworkCase TripLeg_Edge::has_bicycle_network_case() const {
  return TripLeg_Edge::HasBicycleNetworkCase(_oneof_case_[29]);
}
inline TripLeg_Edge::HasSidewalkCase TripLeg_Edge::has_sidewalk_case() const {
  return TripLeg_Edge::HasSidewalkCase(_oneof_case_[30]);
}
inline TripLeg_Edge::HasDensityCase TripLeg_Edge::has_density_case() const {
  return TripLeg_Edge::HasDensityCase(_oneof_case_[31]);
}
inline TripLeg_Edge::HasSpeedLimitCase TripLeg_Edge::has_speed_limit_case() const {
  return TripLeg_Edge::HasSpeedLimitCase(_oneof_case_[32]);
}
inline TripLeg_Edge::HasTruckSpeedCase TripLeg_Edge::has_truck_speed_case() const {
  return TripLeg_Edge::HasTruckSpeedCase(_oneof_case_[33]);
}
inline TripLeg_Edge::HasTruckRouteCase TripLeg_Edge::has_truck_route_case() const {
  return TripLeg_Edge::HasTruckRouteCase(_oneof_case_[34]);
}
inline TripLeg_Edge::HasMeanElevationCase TripLeg_Edge::has_mean_elevation_case() const {
  return TripLeg_Edge::HasMeanElevationCase(_oneof_case_[35]);
}
inline TripLeg_Edge::HasHasTimeRestrictionsCase TripLeg_Edge::has_has_time_restrictions_case() const {
  return TripLeg_Edge::HasHasTimeRestrictionsCase(_oneof_case_[36]);
}
inline TripLeg_Edge::HasDefaultSpeedCase TripLeg_Edge::has_default_speed_case() const {
  return TripLeg_Edge::HasDefaultSpeedCase(_oneof_case_[37]);
}
inline TripLeg_Edge::HasDestinationOnlyCase TripLeg_Edge::has_destination_only_case() const {
  return TripLeg_Edge::HasDestinationOnlyCase(_oneof_case_[38]);
}
inline TripLeg_Edge::HasIsUrbanCase TripLeg_Edge::has_is_urban_case() const {
  return TripLeg_Edge::HasIsUrbanCase(_oneof_case_[39]);
}
inline TripLeg_Edge::HasSourceAlongEdgeCase TripLeg_Edge::has_source_along_edge_case() const {
  return TripLeg_Edge::HasSourceAlongEdgeCase(_oneof_case_[40]);
}
inline TripLeg_Edge::HasTargetAlongEdgeCase TripLeg_Edge::has_target_along_edge_case() const {
  return TripLeg_Edge::HasTargetAlongEdgeCase(_oneof_case_[41]);
}
inline TripLeg_Edge::HasSacScaleCase TripLeg_Edge::has_sac_scale_case() const {
  return TripLeg_Edge::HasSacScaleCase(_oneof_case_[42]);
}
inline TripLeg_Edge::HasShoulderCase TripLeg_Edge::has_shoulder_case() const {
  return TripLeg_Edge::HasShoulderCase(_oneof_case_[43]);
}
inline TripLeg_Edge::HasTotalLengthKmCase TripLeg_Edge::has_total_length_km_case() const {
  return TripLeg_Edge::HasTotalLengthKmCase(_oneof_case_[44]);
}
inline TripLeg_Edge::HasShortcutIdCase TripLeg_Edge::has_shortcut_id_case() const {
  return TripLeg_Edge::HasShortcutIdCase(_oneof_case_[45]);
}
// -------------------------------------------------------------------

// TripLeg_IntersectingEdge

// optional uint32 begin_heading = 1;
inline bool TripLeg_IntersectingEdge::has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
inline void TripLeg_IntersectingEdge::set_has_begin_heading() {
  _oneof_case_[0] = kBeginHeading;
}
inline void TripLeg_IntersectingEdge::clear_begin_heading() {
  if (has_begin_heading()) {
    has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
inline ::google::protobuf::uint32 TripLeg_IntersectingEdge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.begin_heading)
  if (has_begin_heading()) {
    return has_begin_heading_.begin_heading_;
  }
  return 0u;
}
inline void TripLeg_IntersectingEdge::set_begin_heading(::google::protobuf::uint32 value) {
  if (!has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  has_begin_heading_.begin_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.begin_heading)
}

// optional bool prev_name_consistency = 2;
inline bool TripLeg_IntersectingEdge::has_prev_name_consistency() const {
  return has_prev_name_consistency_case() == kPrevNameConsistency;
}
inline void TripLeg_IntersectingEdge::set_has_prev_name_consistency() {
  _oneof_case_[1] = kPrevNameConsistency;
}
inline void TripLeg_IntersectingEdge::clear_prev_name_consistency() {
  if (has_prev_name_consistency()) {
    has_prev_name_consistency_.prev_name_consistency_ = false;
    clear_has_has_prev_name_consistency();
  }
}
inline bool TripLeg_IntersectingEdge::prev_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
  if (has_prev_name_consistency()) {
    return has_prev_name_consistency_.prev_name_consistency_;
  }
  return false;
}
inline void TripLeg_IntersectingEdge::set_prev_name_consistency(bool value) {
  if (!has_prev_name_consistency()) {
    clear_has_prev_name_consistency();
    set_has_prev_name_consistency();
  }
  has_prev_name_consistency_.prev_name_consistency_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
}

// optional bool curr_name_consistency = 3;
inline bool TripLeg_IntersectingEdge::has_curr_name_consistency() const {
  return has_curr_name_consistency_case() == kCurrNameConsistency;
}
inline void TripLeg_IntersectingEdge::set_has_curr_name_consistency() {
  _oneof_case_[2] = kCurrNameConsistency;
}
inline void TripLeg_IntersectingEdge::clear_curr_name_consistency() {
  if (has_curr_name_consistency()) {
    has_curr_name_consistency_.curr_name_consistency_ = false;
    clear_has_has_curr_name_consistency();
  }
}
inline bool TripLeg_IntersectingEdge::curr_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
  if (has_curr_name_consistency()) {
    return has_curr_name_consistency_.curr_name_consistency_;
  }
  return false;
}
inline void TripLeg_IntersectingEdge::set_curr_name_consistency(bool value) {
  if (!has_curr_name_consistency()) {
    clear_has_curr_name_consistency();
    set_has_curr_name_consistency();
  }
  has_curr_name_consistency_.curr_name_consistency_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
}

// optional .valhalla.TripLeg.Traversability driveability = 4;
inline bool TripLeg_IntersectingEdge::has_driveability() const {
  return has_driveability_case() == kDriveability;
}
inline void TripLeg_IntersectingEdge::set_has_driveability() {
  _oneof_case_[3] = kDriveability;
}
inline void TripLeg_IntersectingEdge::clear_driveability() {
  if (has_driveability()) {
    has_driveability_.driveability_ = 0;
    clear_has_has_driveability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::driveability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.driveability)
  if (has_driveability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_driveability_.driveability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline void TripLeg_IntersectingEdge::set_driveability(::valhalla::TripLeg_Traversability value) {
  if (!has_driveability()) {
    clear_has_driveability();
    set_has_driveability();
  }
  has_driveability_.driveability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.driveability)
}

// optional .valhalla.TripLeg.Traversability cyclability = 5;
inline bool TripLeg_IntersectingEdge::has_cyclability() const {
  return has_cyclability_case() == kCyclability;
}
inline void TripLeg_IntersectingEdge::set_has_cyclability() {
  _oneof_case_[4] = kCyclability;
}
inline void TripLeg_IntersectingEdge::clear_cyclability() {
  if (has_cyclability()) {
    has_cyclability_.cyclability_ = 0;
    clear_has_has_cyclability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::cyclability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.cyclability)
  if (has_cyclability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_cyclability_.cyclability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline void TripLeg_IntersectingEdge::set_cyclability(::valhalla::TripLeg_Traversability value) {
  if (!has_cyclability()) {
    clear_has_cyclability();
    set_has_cyclability();
  }
  has_cyclability_.cyclability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.cyclability)
}

// optional .valhalla.TripLeg.Traversability walkability = 6;
inline bool TripLeg_IntersectingEdge::has_walkability() const {
  return has_walkability_case() == kWalkability;
}
inline void TripLeg_IntersectingEdge::set_has_walkability() {
  _oneof_case_[5] = kWalkability;
}
inline void TripLeg_IntersectingEdge::clear_walkability() {
  if (has_walkability()) {
    has_walkability_.walkability_ = 0;
    clear_has_has_walkability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::walkability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.walkability)
  if (has_walkability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_walkability_.walkability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline void TripLeg_IntersectingEdge::set_walkability(::valhalla::TripLeg_Traversability value) {
  if (!has_walkability()) {
    clear_has_walkability();
    set_has_walkability();
  }
  has_walkability_.walkability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.walkability)
}

// optional .valhalla.TripLeg.Use use = 7;
inline bool TripLeg_IntersectingEdge::has_use() const {
  return has_use_case() == kUse;
}
inline void TripLeg_IntersectingEdge::set_has_use() {
  _oneof_case_[6] = kUse;
}
inline void TripLeg_IntersectingEdge::clear_use() {
  if (has_use()) {
    has_use_.use_ = 0;
    clear_has_has_use();
  }
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.use)
  if (has_use()) {
    return static_cast< ::valhalla::TripLeg_Use >(has_use_.use_);
  }
  return static_cast< ::valhalla::TripLeg_Use >(0);
}
inline void TripLeg_IntersectingEdge::set_use(::valhalla::TripLeg_Use value) {
  if (!has_use()) {
    clear_has_use();
    set_has_use();
  }
  has_use_.use_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.use)
}

// optional .valhalla.RoadClass road_class = 8;
inline bool TripLeg_IntersectingEdge::has_road_class() const {
  return has_road_class_case() == kRoadClass;
}
inline void TripLeg_IntersectingEdge::set_has_road_class() {
  _oneof_case_[7] = kRoadClass;
}
inline void TripLeg_IntersectingEdge::clear_road_class() {
  if (has_road_class()) {
    has_road_class_.road_class_ = 0;
    clear_has_has_road_class();
  }
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.road_class)
  if (has_road_class()) {
    return static_cast< ::valhalla::RoadClass >(has_road_class_.road_class_);
  }
  return static_cast< ::valhalla::RoadClass >(0);
}
inline void TripLeg_IntersectingEdge::set_road_class(::valhalla::RoadClass value) {
  if (!has_road_class()) {
    clear_has_road_class();
    set_has_road_class();
  }
  has_road_class_.road_class_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.road_class)
}

// optional uint32 lane_count = 9;
inline bool TripLeg_IntersectingEdge::has_lane_count() const {
  return has_lane_count_case() == kLaneCount;
}
inline void TripLeg_IntersectingEdge::set_has_lane_count() {
  _oneof_case_[8] = kLaneCount;
}
inline void TripLeg_IntersectingEdge::clear_lane_count() {
  if (has_lane_count()) {
    has_lane_count_.lane_count_ = 0u;
    clear_has_has_lane_count();
  }
}
inline ::google::protobuf::uint32 TripLeg_IntersectingEdge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.lane_count)
  if (has_lane_count()) {
    return has_lane_count_.lane_count_;
  }
  return 0u;
}
inline void TripLeg_IntersectingEdge::set_lane_count(::google::protobuf::uint32 value) {
  if (!has_lane_count()) {
    clear_has_lane_count();
    set_has_lane_count();
  }
  has_lane_count_.lane_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.lane_count)
}

// optional .valhalla.TripSign sign = 10;
inline bool TripLeg_IntersectingEdge::has_sign() const {
  return !_is_default_instance_ && sign_ != NULL;
}
inline void TripLeg_IntersectingEdge::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.sign)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::valhalla::TripSign;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.IntersectingEdge.sign)
  return sign_;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.IntersectingEdge.sign)
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void TripLeg_IntersectingEdge::set_allocated_sign(::valhalla::TripSign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}

inline bool TripLeg_IntersectingEdge::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_begin_heading() {
  _oneof_case_[0] = HAS_BEGIN_HEADING_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_prev_name_consistency() const {
  return has_prev_name_consistency_case() != HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_prev_name_consistency() {
  _oneof_case_[1] = HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_curr_name_consistency() const {
  return has_curr_name_consistency_case() != HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_curr_name_consistency() {
  _oneof_case_[2] = HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_driveability() const {
  return has_driveability_case() != HAS_DRIVEABILITY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_driveability() {
  _oneof_case_[3] = HAS_DRIVEABILITY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_cyclability() const {
  return has_cyclability_case() != HAS_CYCLABILITY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_cyclability() {
  _oneof_case_[4] = HAS_CYCLABILITY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_walkability() const {
  return has_walkability_case() != HAS_WALKABILITY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_walkability() {
  _oneof_case_[5] = HAS_WALKABILITY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_use() const {
  return has_use_case() != HAS_USE_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_use() {
  _oneof_case_[6] = HAS_USE_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_road_class() const {
  return has_road_class_case() != HAS_ROAD_CLASS_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_road_class() {
  _oneof_case_[7] = HAS_ROAD_CLASS_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_lane_count() const {
  return has_lane_count_case() != HAS_LANE_COUNT_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_lane_count() {
  _oneof_case_[8] = HAS_LANE_COUNT_NOT_SET;
}
inline TripLeg_IntersectingEdge::HasBeginHeadingCase TripLeg_IntersectingEdge::has_begin_heading_case() const {
  return TripLeg_IntersectingEdge::HasBeginHeadingCase(_oneof_case_[0]);
}
inline TripLeg_IntersectingEdge::HasPrevNameConsistencyCase TripLeg_IntersectingEdge::has_prev_name_consistency_case() const {
  return TripLeg_IntersectingEdge::HasPrevNameConsistencyCase(_oneof_case_[1]);
}
inline TripLeg_IntersectingEdge::HasCurrNameConsistencyCase TripLeg_IntersectingEdge::has_curr_name_consistency_case() const {
  return TripLeg_IntersectingEdge::HasCurrNameConsistencyCase(_oneof_case_[2]);
}
inline TripLeg_IntersectingEdge::HasDriveabilityCase TripLeg_IntersectingEdge::has_driveability_case() const {
  return TripLeg_IntersectingEdge::HasDriveabilityCase(_oneof_case_[3]);
}
inline TripLeg_IntersectingEdge::HasCyclabilityCase TripLeg_IntersectingEdge::has_cyclability_case() const {
  return TripLeg_IntersectingEdge::HasCyclabilityCase(_oneof_case_[4]);
}
inline TripLeg_IntersectingEdge::HasWalkabilityCase TripLeg_IntersectingEdge::has_walkability_case() const {
  return TripLeg_IntersectingEdge::HasWalkabilityCase(_oneof_case_[5]);
}
inline TripLeg_IntersectingEdge::HasUseCase TripLeg_IntersectingEdge::has_use_case() const {
  return TripLeg_IntersectingEdge::HasUseCase(_oneof_case_[6]);
}
inline TripLeg_IntersectingEdge::HasRoadClassCase TripLeg_IntersectingEdge::has_road_class_case() const {
  return TripLeg_IntersectingEdge::HasRoadClassCase(_oneof_case_[7]);
}
inline TripLeg_IntersectingEdge::HasLaneCountCase TripLeg_IntersectingEdge::has_lane_count_case() const {
  return TripLeg_IntersectingEdge::HasLaneCountCase(_oneof_case_[8]);
}
// -------------------------------------------------------------------

// TripLeg_Cost

// optional double seconds = 1;
inline bool TripLeg_Cost::has_seconds() const {
  return has_seconds_case() == kSeconds;
}
inline void TripLeg_Cost::set_has_seconds() {
  _oneof_case_[0] = kSeconds;
}
inline void TripLeg_Cost::clear_seconds() {
  if (has_seconds()) {
    has_seconds_.seconds_ = 0;
    clear_has_has_seconds();
  }
}
inline double TripLeg_Cost::seconds() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.seconds)
  if (has_seconds()) {
    return has_seconds_.seconds_;
  }
  return 0;
}
inline void TripLeg_Cost::set_seconds(double value) {
  if (!has_seconds()) {
    clear_has_seconds();
    set_has_seconds();
  }
  has_seconds_.seconds_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.seconds)
}

// optional double cost = 2;
inline bool TripLeg_Cost::has_cost() const {
  return has_cost_case() == kCost;
}
inline void TripLeg_Cost::set_has_cost() {
  _oneof_case_[1] = kCost;
}
inline void TripLeg_Cost::clear_cost() {
  if (has_cost()) {
    has_cost_.cost_ = 0;
    clear_has_has_cost();
  }
}
inline double TripLeg_Cost::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.cost)
  if (has_cost()) {
    return has_cost_.cost_;
  }
  return 0;
}
inline void TripLeg_Cost::set_cost(double value) {
  if (!has_cost()) {
    clear_has_cost();
    set_has_cost();
  }
  has_cost_.cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.cost)
}

inline bool TripLeg_Cost::has_has_seconds() const {
  return has_seconds_case() != HAS_SECONDS_NOT_SET;
}
inline void TripLeg_Cost::clear_has_has_seconds() {
  _oneof_case_[0] = HAS_SECONDS_NOT_SET;
}
inline bool TripLeg_Cost::has_has_cost() const {
  return has_cost_case() != HAS_COST_NOT_SET;
}
inline void TripLeg_Cost::clear_has_has_cost() {
  _oneof_case_[1] = HAS_COST_NOT_SET;
}
inline TripLeg_Cost::HasSecondsCase TripLeg_Cost::has_seconds_case() const {
  return TripLeg_Cost::HasSecondsCase(_oneof_case_[0]);
}
inline TripLeg_Cost::HasCostCase TripLeg_Cost::has_cost_case() const {
  return TripLeg_Cost::HasCostCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg_PathCost

// optional .valhalla.TripLeg.Cost elapsed_cost = 1;
inline bool TripLeg_PathCost::has_elapsed_cost() const {
  return !_is_default_instance_ && elapsed_cost_ != NULL;
}
inline void TripLeg_PathCost::clear_elapsed_cost() {
  if (GetArenaNoVirtual() == NULL && elapsed_cost_ != NULL) delete elapsed_cost_;
  elapsed_cost_ = NULL;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::elapsed_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.elapsed_cost)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return elapsed_cost_ != NULL ? *elapsed_cost_ : *default_instance().elapsed_cost_;
#else
  return elapsed_cost_ != NULL ? *elapsed_cost_ : *default_instance_->elapsed_cost_;
#endif
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_elapsed_cost() {
  
  if (elapsed_cost_ == NULL) {
    elapsed_cost_ = new ::valhalla::TripLeg_Cost;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.elapsed_cost)
  return elapsed_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_elapsed_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.elapsed_cost)
  
  ::valhalla::TripLeg_Cost* temp = elapsed_cost_;
  elapsed_cost_ = NULL;
  return temp;
}
inline void TripLeg_PathCost::set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost) {
  delete elapsed_cost_;
  elapsed_cost_ = elapsed_cost;
  if (elapsed_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}

// optional .valhalla.TripLeg.Cost transition_cost = 2;
inline bool TripLeg_PathCost::has_transition_cost() const {
  return !_is_default_instance_ && transition_cost_ != NULL;
}
inline void TripLeg_PathCost::clear_transition_cost() {
  if (GetArenaNoVirtual() == NULL && transition_cost_ != NULL) delete transition_cost_;
  transition_cost_ = NULL;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::transition_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.transition_cost)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transition_cost_ != NULL ? *transition_cost_ : *default_instance().transition_cost_;
#else
  return transition_cost_ != NULL ? *transition_cost_ : *default_instance_->transition_cost_;
#endif
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_transition_cost() {
  
  if (transition_cost_ == NULL) {
    transition_cost_ = new ::valhalla::TripLeg_Cost;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.transition_cost)
  return transition_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_transition_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.transition_cost)
  
  ::valhalla::TripLeg_Cost* temp = transition_cost_;
  transition_cost_ = NULL;
  return temp;
}
inline void TripLeg_PathCost::set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost) {
  delete transition_cost_;
  transition_cost_ = transition_cost;
  if (transition_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}

// -------------------------------------------------------------------

// TripLeg_Node

// optional .valhalla.TripLeg.Edge edge = 1;
inline bool TripLeg_Node::has_edge() const {
  return !_is_default_instance_ && edge_ != NULL;
}
inline void TripLeg_Node::clear_edge() {
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) delete edge_;
  edge_ = NULL;
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.edge)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return edge_ != NULL ? *edge_ : *default_instance().edge_;
#else
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
#endif
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::mutable_edge() {
  
  if (edge_ == NULL) {
    edge_ = new ::valhalla::TripLeg_Edge;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.edge)
  return edge_;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::release_edge() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.edge)
  
  ::valhalla::TripLeg_Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_edge(::valhalla::TripLeg_Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.edge)
}

// repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
inline int TripLeg_Node::intersecting_edge_size() const {
  return intersecting_edge_.size();
}
inline void TripLeg_Node::clear_intersecting_edge() {
  intersecting_edge_.Clear();
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::intersecting_edge(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_.Get(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::mutable_intersecting_edge(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_.Mutable(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::add_intersecting_edge() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
TripLeg_Node::mutable_intersecting_edge() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.intersecting_edge)
  return &intersecting_edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
TripLeg_Node::intersecting_edge() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_;
}

// optional uint32 admin_index = 3;
inline bool TripLeg_Node::has_admin_index() const {
  return has_admin_index_case() == kAdminIndex;
}
inline void TripLeg_Node::set_has_admin_index() {
  _oneof_case_[0] = kAdminIndex;
}
inline void TripLeg_Node::clear_admin_index() {
  if (has_admin_index()) {
    has_admin_index_.admin_index_ = 0u;
    clear_has_has_admin_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Node::admin_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.admin_index)
  if (has_admin_index()) {
    return has_admin_index_.admin_index_;
  }
  return 0u;
}
inline void TripLeg_Node::set_admin_index(::google::protobuf::uint32 value) {
  if (!has_admin_index()) {
    clear_has_admin_index();
    set_has_admin_index();
  }
  has_admin_index_.admin_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.admin_index)
}

// optional .valhalla.TripLeg.Node.Type type = 4;
inline bool TripLeg_Node::has_type() const {
  return has_type_case() == kType;
}
inline void TripLeg_Node::set_has_type() {
  _oneof_case_[1] = kType;
}
inline void TripLeg_Node::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.type)
  if (has_type()) {
    return static_cast< ::valhalla::TripLeg_Node_Type >(has_type_.type_);
  }
  return static_cast< ::valhalla::TripLeg_Node_Type >(0);
}
inline void TripLeg_Node::set_type(::valhalla::TripLeg_Node_Type value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.type)
}

// optional bool fork = 5;
inline bool TripLeg_Node::has_fork() const {
  return has_fork_case() == kFork;
}
inline void TripLeg_Node::set_has_fork() {
  _oneof_case_[2] = kFork;
}
inline void TripLeg_Node::clear_fork() {
  if (has_fork()) {
    has_fork_.fork_ = false;
    clear_has_has_fork();
  }
}
inline bool TripLeg_Node::fork() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.fork)
  if (has_fork()) {
    return has_fork_.fork_;
  }
  return false;
}
inline void TripLeg_Node::set_fork(bool value) {
  if (!has_fork()) {
    clear_has_fork();
    set_has_fork();
  }
  has_fork_.fork_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.fork)
}

// optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
inline bool TripLeg_Node::has_transit_platform_info() const {
  return !_is_default_instance_ && transit_platform_info_ != NULL;
}
inline void TripLeg_Node::clear_transit_platform_info() {
  if (GetArenaNoVirtual() == NULL && transit_platform_info_ != NULL) delete transit_platform_info_;
  transit_platform_info_ = NULL;
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::transit_platform_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_platform_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_platform_info_ != NULL ? *transit_platform_info_ : *default_instance().transit_platform_info_;
#else
  return transit_platform_info_ != NULL ? *transit_platform_info_ : *default_instance_->transit_platform_info_;
#endif
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::mutable_transit_platform_info() {
  
  if (transit_platform_info_ == NULL) {
    transit_platform_info_ = new ::valhalla::TransitPlatformInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_platform_info)
  return transit_platform_info_;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::release_transit_platform_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_platform_info)
  
  ::valhalla::TransitPlatformInfo* temp = transit_platform_info_;
  transit_platform_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info) {
  delete transit_platform_info_;
  transit_platform_info_ = transit_platform_info;
  if (transit_platform_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}

// optional .valhalla.TransitStationInfo transit_station_info = 7;
inline bool TripLeg_Node::has_transit_station_info() const {
  return !_is_default_instance_ && transit_station_info_ != NULL;
}
inline void TripLeg_Node::clear_transit_station_info() {
  if (GetArenaNoVirtual() == NULL && transit_station_info_ != NULL) delete transit_station_info_;
  transit_station_info_ = NULL;
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::transit_station_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_station_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_station_info_ != NULL ? *transit_station_info_ : *default_instance().transit_station_info_;
#else
  return transit_station_info_ != NULL ? *transit_station_info_ : *default_instance_->transit_station_info_;
#endif
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::mutable_transit_station_info() {
  
  if (transit_station_info_ == NULL) {
    transit_station_info_ = new ::valhalla::TransitStationInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_station_info)
  return transit_station_info_;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::release_transit_station_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_station_info)
  
  ::valhalla::TransitStationInfo* temp = transit_station_info_;
  transit_station_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info) {
  delete transit_station_info_;
  transit_station_info_ = transit_station_info;
  if (transit_station_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}

// optional .valhalla.TransitEgressInfo transit_egress_info = 10;
inline bool TripLeg_Node::has_transit_egress_info() const {
  return !_is_default_instance_ && transit_egress_info_ != NULL;
}
inline void TripLeg_Node::clear_transit_egress_info() {
  if (GetArenaNoVirtual() == NULL && transit_egress_info_ != NULL) delete transit_egress_info_;
  transit_egress_info_ = NULL;
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::transit_egress_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_egress_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_egress_info_ != NULL ? *transit_egress_info_ : *default_instance().transit_egress_info_;
#else
  return transit_egress_info_ != NULL ? *transit_egress_info_ : *default_instance_->transit_egress_info_;
#endif
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::mutable_transit_egress_info() {
  
  if (transit_egress_info_ == NULL) {
    transit_egress_info_ = new ::valhalla::TransitEgressInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_egress_info)
  return transit_egress_info_;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::release_transit_egress_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_egress_info)
  
  ::valhalla::TransitEgressInfo* temp = transit_egress_info_;
  transit_egress_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info) {
  delete transit_egress_info_;
  transit_egress_info_ = transit_egress_info;
  if (transit_egress_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}

// optional string time_zone = 11;
inline bool TripLeg_Node::has_time_zone() const {
  return has_time_zone_case() == kTimeZone;
}
inline void TripLeg_Node::set_has_time_zone() {
  _oneof_case_[3] = kTimeZone;
}
inline void TripLeg_Node::clear_time_zone() {
  if (has_time_zone()) {
    has_time_zone_.time_zone_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_time_zone();
  }
}
inline const ::std::string& TripLeg_Node::time_zone() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.time_zone)
  if (has_time_zone()) {
    return has_time_zone_.time_zone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Node::set_time_zone(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_time_zone_.time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
}
inline void TripLeg_Node::set_time_zone(const char* value) {
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_time_zone_.time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Node.time_zone)
}
inline void TripLeg_Node::set_time_zone(const char* value, size_t size) {
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_time_zone_.time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Node.time_zone)
}
inline ::std::string* TripLeg_Node::mutable_time_zone() {
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.time_zone)
  return has_time_zone_.time_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_Node::release_time_zone() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.time_zone)
  if (has_time_zone()) {
    clear_has_has_time_zone();
    return has_time_zone_.time_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_Node::set_allocated_time_zone(::std::string* time_zone) {
  if (!has_time_zone()) {
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_time_zone();
  if (time_zone != NULL) {
    set_has_time_zone();
    has_time_zone_.time_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        time_zone);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.time_zone)
}

// optional .valhalla.TripLeg.PathCost cost = 12;
inline bool TripLeg_Node::has_cost() const {
  return !_is_default_instance_ && cost_ != NULL;
}
inline void TripLeg_Node::clear_cost() {
  if (GetArenaNoVirtual() == NULL && cost_ != NULL) delete cost_;
  cost_ = NULL;
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.cost)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cost_ != NULL ? *cost_ : *default_instance().cost_;
#else
  return cost_ != NULL ? *cost_ : *default_instance_->cost_;
#endif
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_cost() {
  
  if (cost_ == NULL) {
    cost_ = new ::valhalla::TripLeg_PathCost;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.cost)
  return cost_;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::release_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.cost)
  
  ::valhalla::TripLeg_PathCost* temp = cost_;
  cost_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_cost(::valhalla::TripLeg_PathCost* cost) {
  delete cost_;
  cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.cost)
}

// repeated .valhalla.TripLeg.PathCost recosts = 13;
inline int TripLeg_Node::recosts_size() const {
  return recosts_.size();
}
inline void TripLeg_Node::clear_recosts() {
  recosts_.Clear();
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::recosts(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.recosts)
  return recosts_.Get(index);
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_recosts(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.recosts)
  return recosts_.Mutable(index);
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::add_recosts() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.recosts)
  return recosts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
TripLeg_Node::mutable_recosts() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.recosts)
  return &recosts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
TripLeg_Node::recosts() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.recosts)
  return recosts_;
}

// optional .valhalla.BikeShareStationInfo bss_info = 14;
inline bool TripLeg_Node::has_bss_info() const {
  return !_is_default_instance_ && bss_info_ != NULL;
}
inline void TripLeg_Node::clear_bss_info() {
  if (GetArenaNoVirtual() == NULL && bss_info_ != NULL) delete bss_info_;
  bss_info_ = NULL;
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.bss_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bss_info_ != NULL ? *bss_info_ : *default_instance().bss_info_;
#else
  return bss_info_ != NULL ? *bss_info_ : *default_instance_->bss_info_;
#endif
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::mutable_bss_info() {
  
  if (bss_info_ == NULL) {
    bss_info_ = new ::valhalla::BikeShareStationInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.bss_info)
  return bss_info_;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = bss_info_;
  bss_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  delete bss_info_;
  bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.bss_info)
}

inline bool TripLeg_Node::has_has_admin_index() const {
  return has_admin_index_case() != HAS_ADMIN_INDEX_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_admin_index() {
  _oneof_case_[0] = HAS_ADMIN_INDEX_NOT_SET;
}
inline bool TripLeg_Node::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_type() {
  _oneof_case_[1] = HAS_TYPE_NOT_SET;
}
inline bool TripLeg_Node::has_has_fork() const {
  return has_fork_case() != HAS_FORK_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_fork() {
  _oneof_case_[2] = HAS_FORK_NOT_SET;
}
inline bool TripLeg_Node::has_has_time_zone() const {
  return has_time_zone_case() != HAS_TIME_ZONE_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_time_zone() {
  _oneof_case_[3] = HAS_TIME_ZONE_NOT_SET;
}
inline TripLeg_Node::HasAdminIndexCase TripLeg_Node::has_admin_index_case() const {
  return TripLeg_Node::HasAdminIndexCase(_oneof_case_[0]);
}
inline TripLeg_Node::HasTypeCase TripLeg_Node::has_type_case() const {
  return TripLeg_Node::HasTypeCase(_oneof_case_[1]);
}
inline TripLeg_Node::HasForkCase TripLeg_Node::has_fork_case() const {
  return TripLeg_Node::HasForkCase(_oneof_case_[2]);
}
inline TripLeg_Node::HasTimeZoneCase TripLeg_Node::has_time_zone_case() const {
  return TripLeg_Node::HasTimeZoneCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// TripLeg_Admin

// optional string country_code = 1;
inline bool TripLeg_Admin::has_country_code() const {
  return has_country_code_case() == kCountryCode;
}
inline void TripLeg_Admin::set_has_country_code() {
  _oneof_case_[0] = kCountryCode;
}
inline void TripLeg_Admin::clear_country_code() {
  if (has_country_code()) {
    has_country_code_.country_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_country_code();
  }
}
inline const ::std::string& TripLeg_Admin::country_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_code)
  if (has_country_code()) {
    return has_country_code_.country_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::set_country_code(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_code_.country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
}
inline void TripLeg_Admin::set_country_code(const char* value) {
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_code_.country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.country_code)
}
inline void TripLeg_Admin::set_country_code(const char* value, size_t size) {
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_code_.country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.country_code)
}
inline ::std::string* TripLeg_Admin::mutable_country_code() {
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_code)
  return has_country_code_.country_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_Admin::release_country_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_code)
  if (has_country_code()) {
    clear_has_has_country_code();
    return has_country_code_.country_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_Admin::set_allocated_country_code(::std::string* country_code) {
  if (!has_country_code()) {
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_country_code();
  if (country_code != NULL) {
    set_has_country_code();
    has_country_code_.country_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        country_code);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_code)
}

// optional string country_text = 2;
inline bool TripLeg_Admin::has_country_text() const {
  return has_country_text_case() == kCountryText;
}
inline void TripLeg_Admin::set_has_country_text() {
  _oneof_case_[1] = kCountryText;
}
inline void TripLeg_Admin::clear_country_text() {
  if (has_country_text()) {
    has_country_text_.country_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_country_text();
  }
}
inline const ::std::string& TripLeg_Admin::country_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_text)
  if (has_country_text()) {
    return has_country_text_.country_text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::set_country_text(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_text_.country_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
}
inline void TripLeg_Admin::set_country_text(const char* value) {
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_text_.country_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.country_text)
}
inline void TripLeg_Admin::set_country_text(const char* value, size_t size) {
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_text_.country_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.country_text)
}
inline ::std::string* TripLeg_Admin::mutable_country_text() {
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_text)
  return has_country_text_.country_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_Admin::release_country_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_text)
  if (has_country_text()) {
    clear_has_has_country_text();
    return has_country_text_.country_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_Admin::set_allocated_country_text(::std::string* country_text) {
  if (!has_country_text()) {
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_country_text();
  if (country_text != NULL) {
    set_has_country_text();
    has_country_text_.country_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        country_text);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_text)
}

// optional string state_code = 3;
inline bool TripLeg_Admin::has_state_code() const {
  return has_state_code_case() == kStateCode;
}
inline void TripLeg_Admin::set_has_state_code() {
  _oneof_case_[2] = kStateCode;
}
inline void TripLeg_Admin::clear_state_code() {
  if (has_state_code()) {
    has_state_code_.state_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_state_code();
  }
}
inline const ::std::string& TripLeg_Admin::state_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_code)
  if (has_state_code()) {
    return has_state_code_.state_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::set_state_code(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_code_.state_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
}
inline void TripLeg_Admin::set_state_code(const char* value) {
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_code_.state_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.state_code)
}
inline void TripLeg_Admin::set_state_code(const char* value, size_t size) {
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_code_.state_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.state_code)
}
inline ::std::string* TripLeg_Admin::mutable_state_code() {
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_code)
  return has_state_code_.state_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_Admin::release_state_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_code)
  if (has_state_code()) {
    clear_has_has_state_code();
    return has_state_code_.state_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_Admin::set_allocated_state_code(::std::string* state_code) {
  if (!has_state_code()) {
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_state_code();
  if (state_code != NULL) {
    set_has_state_code();
    has_state_code_.state_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        state_code);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_code)
}

// optional string state_text = 4;
inline bool TripLeg_Admin::has_state_text() const {
  return has_state_text_case() == kStateText;
}
inline void TripLeg_Admin::set_has_state_text() {
  _oneof_case_[3] = kStateText;
}
inline void TripLeg_Admin::clear_state_text() {
  if (has_state_text()) {
    has_state_text_.state_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_state_text();
  }
}
inline const ::std::string& TripLeg_Admin::state_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_text)
  if (has_state_text()) {
    return has_state_text_.state_text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::set_state_text(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_text_.state_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
}
inline void TripLeg_Admin::set_state_text(const char* value) {
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_text_.state_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.state_text)
}
inline void TripLeg_Admin::set_state_text(const char* value, size_t size) {
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_text_.state_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.state_text)
}
inline ::std::string* TripLeg_Admin::mutable_state_text() {
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_text)
  return has_state_text_.state_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg_Admin::release_state_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_text)
  if (has_state_text()) {
    clear_has_has_state_text();
    return has_state_text_.state_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg_Admin::set_allocated_state_text(::std::string* state_text) {
  if (!has_state_text()) {
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_state_text();
  if (state_text != NULL) {
    set_has_state_text();
    has_state_text_.state_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        state_text);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_text)
}

inline bool TripLeg_Admin::has_has_country_code() const {
  return has_country_code_case() != HAS_COUNTRY_CODE_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_country_code() {
  _oneof_case_[0] = HAS_COUNTRY_CODE_NOT_SET;
}
inline bool TripLeg_Admin::has_has_country_text() const {
  return has_country_text_case() != HAS_COUNTRY_TEXT_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_country_text() {
  _oneof_case_[1] = HAS_COUNTRY_TEXT_NOT_SET;
}
inline bool TripLeg_Admin::has_has_state_code() const {
  return has_state_code_case() != HAS_STATE_CODE_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_state_code() {
  _oneof_case_[2] = HAS_STATE_CODE_NOT_SET;
}
inline bool TripLeg_Admin::has_has_state_text() const {
  return has_state_text_case() != HAS_STATE_TEXT_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_state_text() {
  _oneof_case_[3] = HAS_STATE_TEXT_NOT_SET;
}
inline TripLeg_Admin::HasCountryCodeCase TripLeg_Admin::has_country_code_case() const {
  return TripLeg_Admin::HasCountryCodeCase(_oneof_case_[0]);
}
inline TripLeg_Admin::HasCountryTextCase TripLeg_Admin::has_country_text_case() const {
  return TripLeg_Admin::HasCountryTextCase(_oneof_case_[1]);
}
inline TripLeg_Admin::HasStateCodeCase TripLeg_Admin::has_state_code_case() const {
  return TripLeg_Admin::HasStateCodeCase(_oneof_case_[2]);
}
inline TripLeg_Admin::HasStateTextCase TripLeg_Admin::has_state_text_case() const {
  return TripLeg_Admin::HasStateTextCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// TripLeg_ShapeAttributes

// repeated uint32 time = 1 [packed = true];
inline int TripLeg_ShapeAttributes::time_size() const {
  return time_.size();
}
inline void TripLeg_ShapeAttributes::clear_time() {
  time_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::time(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.time)
  return time_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_time(int index, ::google::protobuf::uint32 value) {
  time_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.time)
}
inline void TripLeg_ShapeAttributes::add_time(::google::protobuf::uint32 value) {
  time_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.time)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::time() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.time)
  return time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_time() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.time)
  return &time_;
}

// repeated uint32 length = 2 [packed = true];
inline int TripLeg_ShapeAttributes::length_size() const {
  return length_.size();
}
inline void TripLeg_ShapeAttributes::clear_length() {
  length_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::length(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.length)
  return length_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_length(int index, ::google::protobuf::uint32 value) {
  length_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.length)
}
inline void TripLeg_ShapeAttributes::add_length(::google::protobuf::uint32 value) {
  length_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.length)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::length() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.length)
  return length_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_length() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.length)
  return &length_;
}

// repeated uint32 speed = 3 [packed = true];
inline int TripLeg_ShapeAttributes::speed_size() const {
  return speed_.size();
}
inline void TripLeg_ShapeAttributes::clear_speed() {
  speed_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::speed(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed)
  return speed_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_speed(int index, ::google::protobuf::uint32 value) {
  speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed)
}
inline void TripLeg_ShapeAttributes::add_speed(::google::protobuf::uint32 value) {
  speed_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::speed() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed)
  return speed_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_speed() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed)
  return &speed_;
}

// repeated uint32 speed_limit = 5 [packed = true];
inline int TripLeg_ShapeAttributes::speed_limit_size() const {
  return speed_limit_.size();
}
inline void TripLeg_ShapeAttributes::clear_speed_limit() {
  speed_limit_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::speed_limit(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return speed_limit_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_speed_limit(int index, ::google::protobuf::uint32 value) {
  speed_limit_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline void TripLeg_ShapeAttributes::add_speed_limit(::google::protobuf::uint32 value) {
  speed_limit_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::speed_limit() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return speed_limit_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_speed_limit() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return &speed_limit_;
}

// -------------------------------------------------------------------

// TripLeg_Incident

// optional .valhalla.IncidentsTile.Metadata metadata = 1;
inline bool TripLeg_Incident::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void TripLeg_Incident::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::metadata() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return metadata_ != NULL ? *metadata_ : *default_instance().metadata_;
#else
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
#endif
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::valhalla::IncidentsTile_Metadata;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Incident.metadata)
  return metadata_;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::release_metadata() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Incident.metadata)
  
  ::valhalla::IncidentsTile_Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void TripLeg_Incident::set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Incident.metadata)
}

// optional uint32 begin_shape_index = 3;
inline bool TripLeg_Incident::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline void TripLeg_Incident::set_has_begin_shape_index() {
  _oneof_case_[0] = kBeginShapeIndex;
}
inline void TripLeg_Incident::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Incident::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Incident::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.begin_shape_index)
}

// optional uint32 end_shape_index = 4;
inline bool TripLeg_Incident::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline void TripLeg_Incident::set_has_end_shape_index() {
  _oneof_case_[1] = kEndShapeIndex;
}
inline void TripLeg_Incident::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Incident::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Incident::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.end_shape_index)
}

inline bool TripLeg_Incident::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Incident::clear_has_has_begin_shape_index() {
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Incident::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Incident::clear_has_has_end_shape_index() {
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline TripLeg_Incident::HasBeginShapeIndexCase TripLeg_Incident::has_begin_shape_index_case() const {
  return TripLeg_Incident::HasBeginShapeIndexCase(_oneof_case_[0]);
}
inline TripLeg_Incident::HasEndShapeIndexCase TripLeg_Incident::has_end_shape_index_case() const {
  return TripLeg_Incident::HasEndShapeIndexCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg_Closure

// optional uint32 begin_shape_index = 1;
inline bool TripLeg_Closure::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline void TripLeg_Closure::set_has_begin_shape_index() {
  _oneof_case_[0] = kBeginShapeIndex;
}
inline void TripLeg_Closure::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Closure::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.begin_shape_index)
}

// optional uint32 end_shape_index = 2;
inline bool TripLeg_Closure::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline void TripLeg_Closure::set_has_end_shape_index() {
  _oneof_case_[1] = kEndShapeIndex;
}
inline void TripLeg_Closure::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline ::google::protobuf::uint32 TripLeg_Closure::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.end_shape_index)
}

inline bool TripLeg_Closure::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_begin_shape_index() {
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Closure::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_end_shape_index() {
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline TripLeg_Closure::HasBeginShapeIndexCase TripLeg_Closure::has_begin_shape_index_case() const {
  return TripLeg_Closure::HasBeginShapeIndexCase(_oneof_case_[0]);
}
inline TripLeg_Closure::HasEndShapeIndexCase TripLeg_Closure::has_end_shape_index_case() const {
  return TripLeg_Closure::HasEndShapeIndexCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg

// optional uint64 osm_changeset = 1;
inline bool TripLeg::has_osm_changeset() const {
  return has_osm_changeset_case() == kOsmChangeset;
}
inline void TripLeg::set_has_osm_changeset() {
  _oneof_case_[0] = kOsmChangeset;
}
inline void TripLeg::clear_osm_changeset() {
  if (has_osm_changeset()) {
    has_osm_changeset_.osm_changeset_ = GOOGLE_ULONGLONG(0);
    clear_has_has_osm_changeset();
  }
}
inline ::google::protobuf::uint64 TripLeg::osm_changeset() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.osm_changeset)
  if (has_osm_changeset()) {
    return has_osm_changeset_.osm_changeset_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TripLeg::set_osm_changeset(::google::protobuf::uint64 value) {
  if (!has_osm_changeset()) {
    clear_has_osm_changeset();
    set_has_osm_changeset();
  }
  has_osm_changeset_.osm_changeset_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.osm_changeset)
}

// optional uint64 trip_id = 2;
inline bool TripLeg::has_trip_id() const {
  return has_trip_id_case() == kTripId;
}
inline void TripLeg::set_has_trip_id() {
  _oneof_case_[1] = kTripId;
}
inline void TripLeg::clear_trip_id() {
  if (has_trip_id()) {
    has_trip_id_.trip_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_trip_id();
  }
}
inline ::google::protobuf::uint64 TripLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.trip_id)
  if (has_trip_id()) {
    return has_trip_id_.trip_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TripLeg::set_trip_id(::google::protobuf::uint64 value) {
  if (!has_trip_id()) {
    clear_has_trip_id();
    set_has_trip_id();
  }
  has_trip_id_.trip_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.trip_id)
}

// optional uint32 leg_id = 3;
inline bool TripLeg::has_leg_id() const {
  return has_leg_id_case() == kLegId;
}
inline void TripLeg::set_has_leg_id() {
  _oneof_case_[2] = kLegId;
}
inline void TripLeg::clear_leg_id() {
  if (has_leg_id()) {
    has_leg_id_.leg_id_ = 0u;
    clear_has_has_leg_id();
  }
}
inline ::google::protobuf::uint32 TripLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_id)
  if (has_leg_id()) {
    return has_leg_id_.leg_id_;
  }
  return 0u;
}
inline void TripLeg::set_leg_id(::google::protobuf::uint32 value) {
  if (!has_leg_id()) {
    clear_has_leg_id();
    set_has_leg_id();
  }
  has_leg_id_.leg_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_id)
}

// optional uint32 leg_count = 4;
inline bool TripLeg::has_leg_count() const {
  return has_leg_count_case() == kLegCount;
}
inline void TripLeg::set_has_leg_count() {
  _oneof_case_[3] = kLegCount;
}
inline void TripLeg::clear_leg_count() {
  if (has_leg_count()) {
    has_leg_count_.leg_count_ = 0u;
    clear_has_has_leg_count();
  }
}
inline ::google::protobuf::uint32 TripLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_count)
  if (has_leg_count()) {
    return has_leg_count_.leg_count_;
  }
  return 0u;
}
inline void TripLeg::set_leg_count(::google::protobuf::uint32 value) {
  if (!has_leg_count()) {
    clear_has_leg_count();
    set_has_leg_count();
  }
  has_leg_count_.leg_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_count)
}

// repeated .valhalla.Location location = 5;
inline int TripLeg::location_size() const {
  return location_.size();
}
inline void TripLeg::clear_location() {
  location_.Clear();
}
inline const ::valhalla::Location& TripLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.location)
  return location_.Get(index);
}
inline ::valhalla::Location* TripLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.location)
  return location_.Mutable(index);
}
inline ::valhalla::Location* TripLeg::add_location() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.location)
  return location_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
TripLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.location)
  return &location_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
TripLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.location)
  return location_;
}

// repeated .valhalla.TripLeg.Node node = 6;
inline int TripLeg::node_size() const {
  return node_.size();
}
inline void TripLeg::clear_node() {
  node_.Clear();
}
inline const ::valhalla::TripLeg_Node& TripLeg::node(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.node)
  return node_.Get(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.node)
  return node_.Mutable(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::add_node() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >*
TripLeg::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >&
TripLeg::node() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.node)
  return node_;
}

// repeated .valhalla.TripLeg.Admin admin = 7;
inline int TripLeg::admin_size() const {
  return admin_.size();
}
inline void TripLeg::clear_admin() {
  admin_.Clear();
}
inline const ::valhalla::TripLeg_Admin& TripLeg::admin(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.admin)
  return admin_.Get(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::mutable_admin(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.admin)
  return admin_.Mutable(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::add_admin() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.admin)
  return admin_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
TripLeg::mutable_admin() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.admin)
  return &admin_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
TripLeg::admin() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.admin)
  return admin_;
}

// optional string shape = 8;
inline bool TripLeg::has_shape() const {
  return has_shape_case() == kShape;
}
inline void TripLeg::set_has_shape() {
  _oneof_case_[4] = kShape;
}
inline void TripLeg::clear_shape() {
  if (has_shape()) {
    has_shape_.shape_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_shape();
  }
}
inline const ::std::string& TripLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape)
  if (has_shape()) {
    return has_shape_.shape_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg::set_shape(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
}
inline void TripLeg::set_shape(const char* value) {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.shape)
}
inline void TripLeg::set_shape(const char* value, size_t size) {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.shape)
}
inline ::std::string* TripLeg::mutable_shape() {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape)
  return has_shape_.shape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape)
  if (has_shape()) {
    clear_has_has_shape();
    return has_shape_.shape_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TripLeg::set_allocated_shape(::std::string* shape) {
  if (!has_shape()) {
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_shape();
  if (shape != NULL) {
    set_has_shape();
    has_shape_.shape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        shape);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape)
}

// optional .valhalla.BoundingBox bbox = 9;
inline bool TripLeg::has_bbox() const {
  return !_is_default_instance_ && bbox_ != NULL;
}
inline void TripLeg::clear_bbox() {
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) delete bbox_;
  bbox_ = NULL;
}
inline const ::valhalla::BoundingBox& TripLeg::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.bbox)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bbox_ != NULL ? *bbox_ : *default_instance().bbox_;
#else
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
#endif
}
inline ::valhalla::BoundingBox* TripLeg::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::valhalla::BoundingBox;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.bbox)
  return bbox_;
}
inline ::valhalla::BoundingBox* TripLeg::release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.bbox)
  
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void TripLeg::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.bbox)
}

// optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
inline bool TripLeg::has_shape_attributes() const {
  return !_is_default_instance_ && shape_attributes_ != NULL;
}
inline void TripLeg::clear_shape_attributes() {
  if (GetArenaNoVirtual() == NULL && shape_attributes_ != NULL) delete shape_attributes_;
  shape_attributes_ = NULL;
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::shape_attributes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape_attributes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shape_attributes_ != NULL ? *shape_attributes_ : *default_instance().shape_attributes_;
#else
  return shape_attributes_ != NULL ? *shape_attributes_ : *default_instance_->shape_attributes_;
#endif
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::mutable_shape_attributes() {
  
  if (shape_attributes_ == NULL) {
    shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape_attributes)
  return shape_attributes_;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::release_shape_attributes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape_attributes)
  
  ::valhalla::TripLeg_ShapeAttributes* temp = shape_attributes_;
  shape_attributes_ = NULL;
  return temp;
}
inline void TripLeg::set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  delete shape_attributes_;
  shape_attributes_ = shape_attributes;
  if (shape_attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape_attributes)
}

// repeated .valhalla.TripLeg.Incident incidents = 11;
inline int TripLeg::incidents_size() const {
  return incidents_.size();
}
inline void TripLeg::clear_incidents() {
  incidents_.Clear();
}
inline const ::valhalla::TripLeg_Incident& TripLeg::incidents(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.incidents)
  return incidents_.Get(index);
}
inline ::valhalla::TripLeg_Incident* TripLeg::mutable_incidents(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.incidents)
  return incidents_.Mutable(index);
}
inline ::valhalla::TripLeg_Incident* TripLeg::add_incidents() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.incidents)
  return incidents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
TripLeg::mutable_incidents() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.incidents)
  return &incidents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
TripLeg::incidents() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.incidents)
  return incidents_;
}

// repeated string algorithms = 12;
inline int TripLeg::algorithms_size() const {
  return algorithms_.size();
}
inline void TripLeg::clear_algorithms() {
  algorithms_.Clear();
}
inline const ::std::string& TripLeg::algorithms(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.algorithms)
  return algorithms_.Get(index);
}
inline ::std::string* TripLeg::mutable_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.algorithms)
  return algorithms_.Mutable(index);
}
inline void TripLeg::set_algorithms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
  algorithms_.Mutable(index)->assign(value);
}
inline void TripLeg::set_algorithms(int index, const char* value) {
  algorithms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value, size_t size) {
  algorithms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.algorithms)
}
inline ::std::string* TripLeg::add_algorithms() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.TripLeg.algorithms)
  return algorithms_.Add();
}
inline void TripLeg::add_algorithms(const ::std::string& value) {
  algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value) {
  algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value, size_t size) {
  algorithms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.TripLeg.algorithms)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripLeg::algorithms() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.algorithms)
  return algorithms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripLeg::mutable_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.algorithms)
  return &algorithms_;
}

// repeated .valhalla.TripLeg.Closure closures = 13;
inline int TripLeg::closures_size() const {
  return closures_.size();
}
inline void TripLeg::clear_closures() {
  closures_.Clear();
}
inline const ::valhalla::TripLeg_Closure& TripLeg::closures(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.closures)
  return closures_.Get(index);
}
inline ::valhalla::TripLeg_Closure* TripLeg::mutable_closures(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.closures)
  return closures_.Mutable(index);
}
inline ::valhalla::TripLeg_Closure* TripLeg::add_closures() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.closures)
  return closures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
TripLeg::mutable_closures() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.closures)
  return &closures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
TripLeg::closures() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.closures)
  return closures_;
}

inline bool TripLeg::has_has_osm_changeset() const {
  return has_osm_changeset_case() != HAS_OSM_CHANGESET_NOT_SET;
}
inline void TripLeg::clear_has_has_osm_changeset() {
  _oneof_case_[0] = HAS_OSM_CHANGESET_NOT_SET;
}
inline bool TripLeg::has_has_trip_id() const {
  return has_trip_id_case() != HAS_TRIP_ID_NOT_SET;
}
inline void TripLeg::clear_has_has_trip_id() {
  _oneof_case_[1] = HAS_TRIP_ID_NOT_SET;
}
inline bool TripLeg::has_has_leg_id() const {
  return has_leg_id_case() != HAS_LEG_ID_NOT_SET;
}
inline void TripLeg::clear_has_has_leg_id() {
  _oneof_case_[2] = HAS_LEG_ID_NOT_SET;
}
inline bool TripLeg::has_has_leg_count() const {
  return has_leg_count_case() != HAS_LEG_COUNT_NOT_SET;
}
inline void TripLeg::clear_has_has_leg_count() {
  _oneof_case_[3] = HAS_LEG_COUNT_NOT_SET;
}
inline bool TripLeg::has_has_shape() const {
  return has_shape_case() != HAS_SHAPE_NOT_SET;
}
inline void TripLeg::clear_has_has_shape() {
  _oneof_case_[4] = HAS_SHAPE_NOT_SET;
}
inline TripLeg::HasOsmChangesetCase TripLeg::has_osm_changeset_case() const {
  return TripLeg::HasOsmChangesetCase(_oneof_case_[0]);
}
inline TripLeg::HasTripIdCase TripLeg::has_trip_id_case() const {
  return TripLeg::HasTripIdCase(_oneof_case_[1]);
}
inline TripLeg::HasLegIdCase TripLeg::has_leg_id_case() const {
  return TripLeg::HasLegIdCase(_oneof_case_[2]);
}
inline TripLeg::HasLegCountCase TripLeg::has_leg_count_case() const {
  return TripLeg::HasLegCountCase(_oneof_case_[3]);
}
inline TripLeg::HasShapeCase TripLeg::has_shape_case() const {
  return TripLeg::HasShapeCase(_oneof_case_[4]);
}
// -------------------------------------------------------------------

// TripRoute

// repeated .valhalla.TripLeg legs = 1;
inline int TripRoute::legs_size() const {
  return legs_.size();
}
inline void TripRoute::clear_legs() {
  legs_.Clear();
}
inline const ::valhalla::TripLeg& TripRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripRoute.legs)
  return legs_.Get(index);
}
inline ::valhalla::TripLeg* TripRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripRoute.legs)
  return legs_.Mutable(index);
}
inline ::valhalla::TripLeg* TripRoute::add_legs() {
  // @@protoc_insertion_point(field_add:valhalla.TripRoute.legs)
  return legs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >*
TripRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripRoute.legs)
  return &legs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >&
TripRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.TripRoute.legs)
  return legs_;
}

// -------------------------------------------------------------------

// Trip

// repeated .valhalla.TripRoute routes = 1;
inline int Trip::routes_size() const {
  return routes_.size();
}
inline void Trip::clear_routes() {
  routes_.Clear();
}
inline const ::valhalla::TripRoute& Trip::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Trip.routes)
  return routes_.Get(index);
}
inline ::valhalla::TripRoute* Trip::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Trip.routes)
  return routes_.Mutable(index);
}
inline ::valhalla::TripRoute* Trip::add_routes() {
  // @@protoc_insertion_point(field_add:valhalla.Trip.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >*
Trip::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Trip.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >&
Trip::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Trip.routes)
  return routes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::valhalla::TripLeg_Node_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Traversability> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Use> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Surface> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_CycleLane> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_SacScale> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Sidewalk> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trip_2eproto__INCLUDED
