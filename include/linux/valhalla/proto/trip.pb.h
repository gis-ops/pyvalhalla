// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_trip_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_trip_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"
#include "sign.pb.h"
#include "incidents.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_trip_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_trip_2eproto {
  static const uint32_t offsets[];
};
namespace valhalla {
class Trip;
struct TripDefaultTypeInternal;
extern TripDefaultTypeInternal _Trip_default_instance_;
class TripLeg;
struct TripLegDefaultTypeInternal;
extern TripLegDefaultTypeInternal _TripLeg_default_instance_;
class TripLeg_Admin;
struct TripLeg_AdminDefaultTypeInternal;
extern TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
class TripLeg_Closure;
struct TripLeg_ClosureDefaultTypeInternal;
extern TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
class TripLeg_Cost;
struct TripLeg_CostDefaultTypeInternal;
extern TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
class TripLeg_Edge;
struct TripLeg_EdgeDefaultTypeInternal;
extern TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
class TripLeg_Incident;
struct TripLeg_IncidentDefaultTypeInternal;
extern TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
class TripLeg_IntersectingEdge;
struct TripLeg_IntersectingEdgeDefaultTypeInternal;
extern TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
class TripLeg_LaneConnectivity;
struct TripLeg_LaneConnectivityDefaultTypeInternal;
extern TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
class TripLeg_Node;
struct TripLeg_NodeDefaultTypeInternal;
extern TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
class TripLeg_PathCost;
struct TripLeg_PathCostDefaultTypeInternal;
extern TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
class TripLeg_Restriction;
struct TripLeg_RestrictionDefaultTypeInternal;
extern TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
class TripLeg_ShapeAttributes;
struct TripLeg_ShapeAttributesDefaultTypeInternal;
extern TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
class TripLeg_TrafficSegment;
struct TripLeg_TrafficSegmentDefaultTypeInternal;
extern TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
class TripRoute;
struct TripRouteDefaultTypeInternal;
extern TripRouteDefaultTypeInternal _TripRoute_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::Trip* Arena::CreateMaybeMessage<::valhalla::Trip>(Arena*);
template<> ::valhalla::TripLeg* Arena::CreateMaybeMessage<::valhalla::TripLeg>(Arena*);
template<> ::valhalla::TripLeg_Admin* Arena::CreateMaybeMessage<::valhalla::TripLeg_Admin>(Arena*);
template<> ::valhalla::TripLeg_Closure* Arena::CreateMaybeMessage<::valhalla::TripLeg_Closure>(Arena*);
template<> ::valhalla::TripLeg_Cost* Arena::CreateMaybeMessage<::valhalla::TripLeg_Cost>(Arena*);
template<> ::valhalla::TripLeg_Edge* Arena::CreateMaybeMessage<::valhalla::TripLeg_Edge>(Arena*);
template<> ::valhalla::TripLeg_Incident* Arena::CreateMaybeMessage<::valhalla::TripLeg_Incident>(Arena*);
template<> ::valhalla::TripLeg_IntersectingEdge* Arena::CreateMaybeMessage<::valhalla::TripLeg_IntersectingEdge>(Arena*);
template<> ::valhalla::TripLeg_LaneConnectivity* Arena::CreateMaybeMessage<::valhalla::TripLeg_LaneConnectivity>(Arena*);
template<> ::valhalla::TripLeg_Node* Arena::CreateMaybeMessage<::valhalla::TripLeg_Node>(Arena*);
template<> ::valhalla::TripLeg_PathCost* Arena::CreateMaybeMessage<::valhalla::TripLeg_PathCost>(Arena*);
template<> ::valhalla::TripLeg_Restriction* Arena::CreateMaybeMessage<::valhalla::TripLeg_Restriction>(Arena*);
template<> ::valhalla::TripLeg_ShapeAttributes* Arena::CreateMaybeMessage<::valhalla::TripLeg_ShapeAttributes>(Arena*);
template<> ::valhalla::TripLeg_TrafficSegment* Arena::CreateMaybeMessage<::valhalla::TripLeg_TrafficSegment>(Arena*);
template<> ::valhalla::TripRoute* Arena::CreateMaybeMessage<::valhalla::TripRoute>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum TripLeg_Node_Type : int {
  TripLeg_Node_Type_kStreetIntersection = 0,
  TripLeg_Node_Type_kGate = 1,
  TripLeg_Node_Type_kBollard = 2,
  TripLeg_Node_Type_kTollBooth = 3,
  TripLeg_Node_Type_kTransitEgress = 4,
  TripLeg_Node_Type_kTransitStation = 5,
  TripLeg_Node_Type_kTransitPlatform = 6,
  TripLeg_Node_Type_kBikeShare = 7,
  TripLeg_Node_Type_kParking = 8,
  TripLeg_Node_Type_kMotorwayJunction = 9,
  TripLeg_Node_Type_kBorderControl = 10,
  TripLeg_Node_Type_kTollGantry = 11,
  TripLeg_Node_Type_kSumpBuster = 12,
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Node_Type_IsValid(int value);
constexpr TripLeg_Node_Type TripLeg_Node_Type_Type_MIN = TripLeg_Node_Type_kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node_Type_Type_MAX = TripLeg_Node_Type_kSumpBuster;
constexpr int TripLeg_Node_Type_Type_ARRAYSIZE = TripLeg_Node_Type_Type_MAX + 1;

const std::string& TripLeg_Node_Type_Name(TripLeg_Node_Type value);
template<typename T>
inline const std::string& TripLeg_Node_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Node_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Node_Type_Name.");
  return TripLeg_Node_Type_Name(static_cast<TripLeg_Node_Type>(enum_t_value));
}
bool TripLeg_Node_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Node_Type* value);
enum TripLeg_Traversability : int {
  TripLeg_Traversability_kNone = 0,
  TripLeg_Traversability_kForward = 1,
  TripLeg_Traversability_kBackward = 2,
  TripLeg_Traversability_kBoth = 3,
  TripLeg_Traversability_TripLeg_Traversability_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Traversability_TripLeg_Traversability_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Traversability_IsValid(int value);
constexpr TripLeg_Traversability TripLeg_Traversability_Traversability_MIN = TripLeg_Traversability_kNone;
constexpr TripLeg_Traversability TripLeg_Traversability_Traversability_MAX = TripLeg_Traversability_kBoth;
constexpr int TripLeg_Traversability_Traversability_ARRAYSIZE = TripLeg_Traversability_Traversability_MAX + 1;

const std::string& TripLeg_Traversability_Name(TripLeg_Traversability value);
template<typename T>
inline const std::string& TripLeg_Traversability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Traversability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Traversability_Name.");
  return TripLeg_Traversability_Name(static_cast<TripLeg_Traversability>(enum_t_value));
}
bool TripLeg_Traversability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Traversability* value);
enum TripLeg_Use : int {
  TripLeg_Use_kRoadUse = 0,
  TripLeg_Use_kRampUse = 1,
  TripLeg_Use_kTurnChannelUse = 2,
  TripLeg_Use_kTrackUse = 3,
  TripLeg_Use_kDrivewayUse = 4,
  TripLeg_Use_kAlleyUse = 5,
  TripLeg_Use_kParkingAisleUse = 6,
  TripLeg_Use_kEmergencyAccessUse = 7,
  TripLeg_Use_kDriveThruUse = 8,
  TripLeg_Use_kCuldesacUse = 9,
  TripLeg_Use_kLivingStreetUse = 10,
  TripLeg_Use_kServiceRoadUse = 11,
  TripLeg_Use_kCyclewayUse = 20,
  TripLeg_Use_kMountainBikeUse = 21,
  TripLeg_Use_kSidewalkUse = 24,
  TripLeg_Use_kFootwayUse = 25,
  TripLeg_Use_kStepsUse = 26,
  TripLeg_Use_kPathUse = 27,
  TripLeg_Use_kPedestrianUse = 28,
  TripLeg_Use_kBridlewayUse = 29,
  TripLeg_Use_kPedestrianCrossingUse = 32,
  TripLeg_Use_kRestAreaUse = 30,
  TripLeg_Use_kServiceAreaUse = 31,
  TripLeg_Use_kOtherUse = 40,
  TripLeg_Use_kFerryUse = 41,
  TripLeg_Use_kRailFerryUse = 42,
  TripLeg_Use_kRailUse = 50,
  TripLeg_Use_kBusUse = 51,
  TripLeg_Use_kEgressConnectionUse = 52,
  TripLeg_Use_kPlatformConnectionUse = 53,
  TripLeg_Use_kTransitConnectionUse = 54,
  TripLeg_Use_TripLeg_Use_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Use_TripLeg_Use_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Use_IsValid(int value);
constexpr TripLeg_Use TripLeg_Use_Use_MIN = TripLeg_Use_kRoadUse;
constexpr TripLeg_Use TripLeg_Use_Use_MAX = TripLeg_Use_kTransitConnectionUse;
constexpr int TripLeg_Use_Use_ARRAYSIZE = TripLeg_Use_Use_MAX + 1;

const std::string& TripLeg_Use_Name(TripLeg_Use value);
template<typename T>
inline const std::string& TripLeg_Use_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Use>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Use_Name.");
  return TripLeg_Use_Name(static_cast<TripLeg_Use>(enum_t_value));
}
bool TripLeg_Use_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Use* value);
enum TripLeg_Surface : int {
  TripLeg_Surface_kPavedSmooth = 0,
  TripLeg_Surface_kPaved = 1,
  TripLeg_Surface_kPavedRough = 2,
  TripLeg_Surface_kCompacted = 3,
  TripLeg_Surface_kDirt = 4,
  TripLeg_Surface_kGravel = 5,
  TripLeg_Surface_kPath = 6,
  TripLeg_Surface_kImpassable = 7,
  TripLeg_Surface_TripLeg_Surface_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Surface_TripLeg_Surface_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Surface_IsValid(int value);
constexpr TripLeg_Surface TripLeg_Surface_Surface_MIN = TripLeg_Surface_kPavedSmooth;
constexpr TripLeg_Surface TripLeg_Surface_Surface_MAX = TripLeg_Surface_kImpassable;
constexpr int TripLeg_Surface_Surface_ARRAYSIZE = TripLeg_Surface_Surface_MAX + 1;

const std::string& TripLeg_Surface_Name(TripLeg_Surface value);
template<typename T>
inline const std::string& TripLeg_Surface_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Surface>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Surface_Name.");
  return TripLeg_Surface_Name(static_cast<TripLeg_Surface>(enum_t_value));
}
bool TripLeg_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Surface* value);
enum TripLeg_CycleLane : int {
  TripLeg_CycleLane_kNoCycleLane = 0,
  TripLeg_CycleLane_kShared = 1,
  TripLeg_CycleLane_kDedicated = 2,
  TripLeg_CycleLane_kSeparated = 3,
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_CycleLane_IsValid(int value);
constexpr TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MIN = TripLeg_CycleLane_kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MAX = TripLeg_CycleLane_kSeparated;
constexpr int TripLeg_CycleLane_CycleLane_ARRAYSIZE = TripLeg_CycleLane_CycleLane_MAX + 1;

const std::string& TripLeg_CycleLane_Name(TripLeg_CycleLane value);
template<typename T>
inline const std::string& TripLeg_CycleLane_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_CycleLane>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_CycleLane_Name.");
  return TripLeg_CycleLane_Name(static_cast<TripLeg_CycleLane>(enum_t_value));
}
bool TripLeg_CycleLane_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_CycleLane* value);
enum TripLeg_SacScale : int {
  TripLeg_SacScale_kNoSacScale = 0,
  TripLeg_SacScale_kHiking = 1,
  TripLeg_SacScale_kMountainHiking = 2,
  TripLeg_SacScale_kDemandingMountainHiking = 3,
  TripLeg_SacScale_kAlpineHiking = 4,
  TripLeg_SacScale_kDemandingAlpineHiking = 5,
  TripLeg_SacScale_kDifficultAlpineHiking = 6,
  TripLeg_SacScale_TripLeg_SacScale_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_SacScale_TripLeg_SacScale_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_SacScale_IsValid(int value);
constexpr TripLeg_SacScale TripLeg_SacScale_SacScale_MIN = TripLeg_SacScale_kNoSacScale;
constexpr TripLeg_SacScale TripLeg_SacScale_SacScale_MAX = TripLeg_SacScale_kDifficultAlpineHiking;
constexpr int TripLeg_SacScale_SacScale_ARRAYSIZE = TripLeg_SacScale_SacScale_MAX + 1;

const std::string& TripLeg_SacScale_Name(TripLeg_SacScale value);
template<typename T>
inline const std::string& TripLeg_SacScale_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_SacScale>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_SacScale_Name.");
  return TripLeg_SacScale_Name(static_cast<TripLeg_SacScale>(enum_t_value));
}
bool TripLeg_SacScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_SacScale* value);
enum TripLeg_Sidewalk : int {
  TripLeg_Sidewalk_kNoSidewalk = 0,
  TripLeg_Sidewalk_kLeft = 1,
  TripLeg_Sidewalk_kRight = 2,
  TripLeg_Sidewalk_kBothSides = 3,
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripLeg_Sidewalk_IsValid(int value);
constexpr TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MIN = TripLeg_Sidewalk_kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MAX = TripLeg_Sidewalk_kBothSides;
constexpr int TripLeg_Sidewalk_Sidewalk_ARRAYSIZE = TripLeg_Sidewalk_Sidewalk_MAX + 1;

const std::string& TripLeg_Sidewalk_Name(TripLeg_Sidewalk value);
template<typename T>
inline const std::string& TripLeg_Sidewalk_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripLeg_Sidewalk>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripLeg_Sidewalk_Name.");
  return TripLeg_Sidewalk_Name(static_cast<TripLeg_Sidewalk>(enum_t_value));
}
bool TripLeg_Sidewalk_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Sidewalk* value);
// ===================================================================

class TripLeg_LaneConnectivity final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.LaneConnectivity) */ {
 public:
  inline TripLeg_LaneConnectivity() : TripLeg_LaneConnectivity(nullptr) {}
  ~TripLeg_LaneConnectivity() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from);
  TripLeg_LaneConnectivity(TripLeg_LaneConnectivity&& from) noexcept
    : TripLeg_LaneConnectivity() {
    *this = ::std::move(from);
  }

  inline TripLeg_LaneConnectivity& operator=(const TripLeg_LaneConnectivity& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_LaneConnectivity& operator=(TripLeg_LaneConnectivity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_LaneConnectivity& default_instance() {
    return *internal_default_instance();
  }
  enum HasFromWayIdCase {
    kFromWayId = 1,
    HAS_FROM_WAY_ID_NOT_SET = 0,
  };

  enum HasFromLanesCase {
    kFromLanes = 2,
    HAS_FROM_LANES_NOT_SET = 0,
  };

  enum HasToLanesCase {
    kToLanes = 3,
    HAS_TO_LANES_NOT_SET = 0,
  };

  static inline const TripLeg_LaneConnectivity* internal_default_instance() {
    return reinterpret_cast<const TripLeg_LaneConnectivity*>(
               &_TripLeg_LaneConnectivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TripLeg_LaneConnectivity& a, TripLeg_LaneConnectivity& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_LaneConnectivity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_LaneConnectivity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_LaneConnectivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_LaneConnectivity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_LaneConnectivity& from);
  void MergeFrom(const TripLeg_LaneConnectivity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_LaneConnectivity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.LaneConnectivity";
  }
  protected:
  explicit TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromWayIdFieldNumber = 1,
    kFromLanesFieldNumber = 2,
    kToLanesFieldNumber = 3,
  };
  // uint64 from_way_id = 1;
  bool has_from_way_id() const;
  private:
  bool _internal_has_from_way_id() const;
  public:
  void clear_from_way_id();
  uint64_t from_way_id() const;
  void set_from_way_id(uint64_t value);
  private:
  uint64_t _internal_from_way_id() const;
  void _internal_set_from_way_id(uint64_t value);
  public:

  // string from_lanes = 2;
  bool has_from_lanes() const;
  private:
  bool _internal_has_from_lanes() const;
  public:
  void clear_from_lanes();
  const std::string& from_lanes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_lanes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_lanes();
  PROTOBUF_NODISCARD std::string* release_from_lanes();
  void set_allocated_from_lanes(std::string* from_lanes);
  private:
  const std::string& _internal_from_lanes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_lanes(const std::string& value);
  std::string* _internal_mutable_from_lanes();
  public:

  // string to_lanes = 3;
  bool has_to_lanes() const;
  private:
  bool _internal_has_to_lanes() const;
  public:
  void clear_to_lanes();
  const std::string& to_lanes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_lanes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_lanes();
  PROTOBUF_NODISCARD std::string* release_to_lanes();
  void set_allocated_to_lanes(std::string* to_lanes);
  private:
  const std::string& _internal_to_lanes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_lanes(const std::string& value);
  std::string* _internal_mutable_to_lanes();
  public:

  void clear_has_from_way_id();
  HasFromWayIdCase has_from_way_id_case() const;
  void clear_has_from_lanes();
  HasFromLanesCase has_from_lanes_case() const;
  void clear_has_to_lanes();
  HasToLanesCase has_to_lanes_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.LaneConnectivity)
 private:
  class _Internal;
  void set_has_from_way_id();
  void set_has_from_lanes();
  void set_has_to_lanes();

  inline bool has_has_from_way_id() const;
  inline void clear_has_has_from_way_id();

  inline bool has_has_from_lanes() const;
  inline void clear_has_has_from_lanes();

  inline bool has_has_to_lanes() const;
  inline void clear_has_has_to_lanes();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasFromWayIdUnion {
      constexpr HasFromWayIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t from_way_id_;
    } has_from_way_id_;
    union HasFromLanesUnion {
      constexpr HasFromLanesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_lanes_;
    } has_from_lanes_;
    union HasToLanesUnion {
      constexpr HasToLanesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_lanes_;
    } has_to_lanes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[3];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_TrafficSegment final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.TrafficSegment) */ {
 public:
  inline TripLeg_TrafficSegment() : TripLeg_TrafficSegment(nullptr) {}
  ~TripLeg_TrafficSegment() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from);
  TripLeg_TrafficSegment(TripLeg_TrafficSegment&& from) noexcept
    : TripLeg_TrafficSegment() {
    *this = ::std::move(from);
  }

  inline TripLeg_TrafficSegment& operator=(const TripLeg_TrafficSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_TrafficSegment& operator=(TripLeg_TrafficSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_TrafficSegment& default_instance() {
    return *internal_default_instance();
  }
  enum HasSegmentIdCase {
    kSegmentId = 1,
    HAS_SEGMENT_ID_NOT_SET = 0,
  };

  enum HasBeginPercentCase {
    kBeginPercent = 2,
    HAS_BEGIN_PERCENT_NOT_SET = 0,
  };

  enum HasEndPercentCase {
    kEndPercent = 3,
    HAS_END_PERCENT_NOT_SET = 0,
  };

  enum HasStartsSegmentCase {
    kStartsSegment = 4,
    HAS_STARTS_SEGMENT_NOT_SET = 0,
  };

  enum HasEndsSegmentCase {
    kEndsSegment = 5,
    HAS_ENDS_SEGMENT_NOT_SET = 0,
  };

  static inline const TripLeg_TrafficSegment* internal_default_instance() {
    return reinterpret_cast<const TripLeg_TrafficSegment*>(
               &_TripLeg_TrafficSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TripLeg_TrafficSegment& a, TripLeg_TrafficSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_TrafficSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_TrafficSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_TrafficSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_TrafficSegment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_TrafficSegment& from);
  void MergeFrom(const TripLeg_TrafficSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_TrafficSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.TrafficSegment";
  }
  protected:
  explicit TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentIdFieldNumber = 1,
    kBeginPercentFieldNumber = 2,
    kEndPercentFieldNumber = 3,
    kStartsSegmentFieldNumber = 4,
    kEndsSegmentFieldNumber = 5,
  };
  // uint64 segment_id = 1;
  bool has_segment_id() const;
  private:
  bool _internal_has_segment_id() const;
  public:
  void clear_segment_id();
  uint64_t segment_id() const;
  void set_segment_id(uint64_t value);
  private:
  uint64_t _internal_segment_id() const;
  void _internal_set_segment_id(uint64_t value);
  public:

  // float begin_percent = 2;
  bool has_begin_percent() const;
  private:
  bool _internal_has_begin_percent() const;
  public:
  void clear_begin_percent();
  float begin_percent() const;
  void set_begin_percent(float value);
  private:
  float _internal_begin_percent() const;
  void _internal_set_begin_percent(float value);
  public:

  // float end_percent = 3;
  bool has_end_percent() const;
  private:
  bool _internal_has_end_percent() const;
  public:
  void clear_end_percent();
  float end_percent() const;
  void set_end_percent(float value);
  private:
  float _internal_end_percent() const;
  void _internal_set_end_percent(float value);
  public:

  // bool starts_segment = 4;
  bool has_starts_segment() const;
  private:
  bool _internal_has_starts_segment() const;
  public:
  void clear_starts_segment();
  bool starts_segment() const;
  void set_starts_segment(bool value);
  private:
  bool _internal_starts_segment() const;
  void _internal_set_starts_segment(bool value);
  public:

  // bool ends_segment = 5;
  bool has_ends_segment() const;
  private:
  bool _internal_has_ends_segment() const;
  public:
  void clear_ends_segment();
  bool ends_segment() const;
  void set_ends_segment(bool value);
  private:
  bool _internal_ends_segment() const;
  void _internal_set_ends_segment(bool value);
  public:

  void clear_has_segment_id();
  HasSegmentIdCase has_segment_id_case() const;
  void clear_has_begin_percent();
  HasBeginPercentCase has_begin_percent_case() const;
  void clear_has_end_percent();
  HasEndPercentCase has_end_percent_case() const;
  void clear_has_starts_segment();
  HasStartsSegmentCase has_starts_segment_case() const;
  void clear_has_ends_segment();
  HasEndsSegmentCase has_ends_segment_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TrafficSegment)
 private:
  class _Internal;
  void set_has_segment_id();
  void set_has_begin_percent();
  void set_has_end_percent();
  void set_has_starts_segment();
  void set_has_ends_segment();

  inline bool has_has_segment_id() const;
  inline void clear_has_has_segment_id();

  inline bool has_has_begin_percent() const;
  inline void clear_has_has_begin_percent();

  inline bool has_has_end_percent() const;
  inline void clear_has_has_end_percent();

  inline bool has_has_starts_segment() const;
  inline void clear_has_has_starts_segment();

  inline bool has_has_ends_segment() const;
  inline void clear_has_has_ends_segment();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasSegmentIdUnion {
      constexpr HasSegmentIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t segment_id_;
    } has_segment_id_;
    union HasBeginPercentUnion {
      constexpr HasBeginPercentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float begin_percent_;
    } has_begin_percent_;
    union HasEndPercentUnion {
      constexpr HasEndPercentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float end_percent_;
    } has_end_percent_;
    union HasStartsSegmentUnion {
      constexpr HasStartsSegmentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool starts_segment_;
    } has_starts_segment_;
    union HasEndsSegmentUnion {
      constexpr HasEndsSegmentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool ends_segment_;
    } has_ends_segment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[5];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Restriction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Restriction) */ {
 public:
  inline TripLeg_Restriction() : TripLeg_Restriction(nullptr) {}
  ~TripLeg_Restriction() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Restriction(const TripLeg_Restriction& from);
  TripLeg_Restriction(TripLeg_Restriction&& from) noexcept
    : TripLeg_Restriction() {
    *this = ::std::move(from);
  }

  inline TripLeg_Restriction& operator=(const TripLeg_Restriction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Restriction& operator=(TripLeg_Restriction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Restriction& default_instance() {
    return *internal_default_instance();
  }
  enum HasTypeCase {
    kType = 1,
    HAS_TYPE_NOT_SET = 0,
  };

  static inline const TripLeg_Restriction* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Restriction*>(
               &_TripLeg_Restriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TripLeg_Restriction& a, TripLeg_Restriction& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Restriction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Restriction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Restriction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Restriction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Restriction& from);
  void MergeFrom(const TripLeg_Restriction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Restriction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Restriction";
  }
  protected:
  explicit TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  void clear_has_type();
  HasTypeCase has_type_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Restriction)
 private:
  class _Internal;
  void set_has_type();

  inline bool has_has_type() const;
  inline void clear_has_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasTypeUnion {
      constexpr HasTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t type_;
    } has_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Edge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Edge) */ {
 public:
  inline TripLeg_Edge() : TripLeg_Edge(nullptr) {}
  ~TripLeg_Edge() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Edge(const TripLeg_Edge& from);
  TripLeg_Edge(TripLeg_Edge&& from) noexcept
    : TripLeg_Edge() {
    *this = ::std::move(from);
  }

  inline TripLeg_Edge& operator=(const TripLeg_Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Edge& operator=(TripLeg_Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Edge& default_instance() {
    return *internal_default_instance();
  }
  enum HasLengthKmCase {
    kLengthKm = 2,
    HAS_LENGTH_KM_NOT_SET = 0,
  };

  enum HasSpeedCase {
    kSpeed = 3,
    HAS_SPEED_NOT_SET = 0,
  };

  enum HasRoadClassCase {
    kRoadClass = 4,
    HAS_ROAD_CLASS_NOT_SET = 0,
  };

  enum HasBeginHeadingCase {
    kBeginHeading = 5,
    HAS_BEGIN_HEADING_NOT_SET = 0,
  };

  enum HasEndHeadingCase {
    kEndHeading = 6,
    HAS_END_HEADING_NOT_SET = 0,
  };

  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 7,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 8,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasTraversabilityCase {
    kTraversability = 9,
    HAS_TRAVERSABILITY_NOT_SET = 0,
  };

  enum HasUseCase {
    kUse = 10,
    HAS_USE_NOT_SET = 0,
  };

  enum HasTollCase {
    kToll = 11,
    HAS_TOLL_NOT_SET = 0,
  };

  enum HasUnpavedCase {
    kUnpaved = 12,
    HAS_UNPAVED_NOT_SET = 0,
  };

  enum HasTunnelCase {
    kTunnel = 13,
    HAS_TUNNEL_NOT_SET = 0,
  };

  enum HasBridgeCase {
    kBridge = 14,
    HAS_BRIDGE_NOT_SET = 0,
  };

  enum HasRoundaboutCase {
    kRoundabout = 15,
    HAS_ROUNDABOUT_NOT_SET = 0,
  };

  enum HasInternalIntersectionCase {
    kInternalIntersection = 16,
    HAS_INTERNAL_INTERSECTION_NOT_SET = 0,
  };

  enum HasDriveOnLeftCase {
    kDriveOnLeft = 17,
    HAS_DRIVE_ON_LEFT_NOT_SET = 0,
  };

  enum HasSurfaceCase {
    kSurface = 18,
    HAS_SURFACE_NOT_SET = 0,
  };

  enum HasTravelModeCase {
    kTravelMode = 20,
    HAS_TRAVEL_MODE_NOT_SET = 0,
  };

  enum HasVehicleTypeCase {
    kVehicleType = 21,
    HAS_VEHICLE_TYPE_NOT_SET = 0,
  };

  enum HasPedestrianTypeCase {
    kPedestrianType = 22,
    HAS_PEDESTRIAN_TYPE_NOT_SET = 0,
  };

  enum HasBicycleTypeCase {
    kBicycleType = 23,
    HAS_BICYCLE_TYPE_NOT_SET = 0,
  };

  enum HasTransitTypeCase {
    kTransitType = 24,
    HAS_TRANSIT_TYPE_NOT_SET = 0,
  };

  enum HasIdCase {
    kId = 26,
    HAS_ID_NOT_SET = 0,
  };

  enum HasWayIdCase {
    kWayId = 27,
    HAS_WAY_ID_NOT_SET = 0,
  };

  enum HasWeightedGradeCase {
    kWeightedGrade = 28,
    HAS_WEIGHTED_GRADE_NOT_SET = 0,
  };

  enum HasMaxUpwardGradeCase {
    kMaxUpwardGrade = 29,
    HAS_MAX_UPWARD_GRADE_NOT_SET = 0,
  };

  enum HasMaxDownwardGradeCase {
    kMaxDownwardGrade = 30,
    HAS_MAX_DOWNWARD_GRADE_NOT_SET = 0,
  };

  enum HasLaneCountCase {
    kLaneCount = 31,
    HAS_LANE_COUNT_NOT_SET = 0,
  };

  enum HasCycleLaneCase {
    kCycleLane = 32,
    HAS_CYCLE_LANE_NOT_SET = 0,
  };

  enum HasBicycleNetworkCase {
    kBicycleNetwork = 33,
    HAS_BICYCLE_NETWORK_NOT_SET = 0,
  };

  enum HasSidewalkCase {
    kSidewalk = 34,
    HAS_SIDEWALK_NOT_SET = 0,
  };

  enum HasDensityCase {
    kDensity = 35,
    HAS_DENSITY_NOT_SET = 0,
  };

  enum HasSpeedLimitCase {
    kSpeedLimit = 36,
    HAS_SPEED_LIMIT_NOT_SET = 0,
  };

  enum HasTruckSpeedCase {
    kTruckSpeed = 37,
    HAS_TRUCK_SPEED_NOT_SET = 0,
  };

  enum HasTruckRouteCase {
    kTruckRoute = 38,
    HAS_TRUCK_ROUTE_NOT_SET = 0,
  };

  enum HasMeanElevationCase {
    kMeanElevation = 40,
    HAS_MEAN_ELEVATION_NOT_SET = 0,
  };

  enum HasHasTimeRestrictionsCase {
    kHasTimeRestrictions = 43,
    HAS_HAS_TIME_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasDefaultSpeedCase {
    kDefaultSpeed = 44,
    HAS_DEFAULT_SPEED_NOT_SET = 0,
  };

  enum HasDestinationOnlyCase {
    kDestinationOnly = 46,
    HAS_DESTINATION_ONLY_NOT_SET = 0,
  };

  enum HasIsUrbanCase {
    kIsUrban = 47,
    HAS_IS_URBAN_NOT_SET = 0,
  };

  enum HasSourceAlongEdgeCase {
    kSourceAlongEdge = 49,
    HAS_SOURCE_ALONG_EDGE_NOT_SET = 0,
  };

  enum HasTargetAlongEdgeCase {
    kTargetAlongEdge = 50,
    HAS_TARGET_ALONG_EDGE_NOT_SET = 0,
  };

  enum HasSacScaleCase {
    kSacScale = 51,
    HAS_SAC_SCALE_NOT_SET = 0,
  };

  enum HasShoulderCase {
    kShoulder = 52,
    HAS_SHOULDER_NOT_SET = 0,
  };

  static inline const TripLeg_Edge* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Edge*>(
               &_TripLeg_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TripLeg_Edge& a, TripLeg_Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Edge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Edge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Edge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Edge& from);
  void MergeFrom(const TripLeg_Edge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Edge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Edge";
  }
  protected:
  explicit TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLaneConnectivityFieldNumber = 39,
    kTrafficSegmentFieldNumber = 41,
    kTurnLanesFieldNumber = 42,
    kTaggedValueFieldNumber = 48,
    kSignFieldNumber = 19,
    kTransitRouteInfoFieldNumber = 25,
    kRestrictionFieldNumber = 45,
    kLengthKmFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kRoadClassFieldNumber = 4,
    kBeginHeadingFieldNumber = 5,
    kEndHeadingFieldNumber = 6,
    kBeginShapeIndexFieldNumber = 7,
    kEndShapeIndexFieldNumber = 8,
    kTraversabilityFieldNumber = 9,
    kUseFieldNumber = 10,
    kTollFieldNumber = 11,
    kUnpavedFieldNumber = 12,
    kTunnelFieldNumber = 13,
    kBridgeFieldNumber = 14,
    kRoundaboutFieldNumber = 15,
    kInternalIntersectionFieldNumber = 16,
    kDriveOnLeftFieldNumber = 17,
    kSurfaceFieldNumber = 18,
    kTravelModeFieldNumber = 20,
    kVehicleTypeFieldNumber = 21,
    kPedestrianTypeFieldNumber = 22,
    kBicycleTypeFieldNumber = 23,
    kTransitTypeFieldNumber = 24,
    kIdFieldNumber = 26,
    kWayIdFieldNumber = 27,
    kWeightedGradeFieldNumber = 28,
    kMaxUpwardGradeFieldNumber = 29,
    kMaxDownwardGradeFieldNumber = 30,
    kLaneCountFieldNumber = 31,
    kCycleLaneFieldNumber = 32,
    kBicycleNetworkFieldNumber = 33,
    kSidewalkFieldNumber = 34,
    kDensityFieldNumber = 35,
    kSpeedLimitFieldNumber = 36,
    kTruckSpeedFieldNumber = 37,
    kTruckRouteFieldNumber = 38,
    kMeanElevationFieldNumber = 40,
    kHasTimeRestrictionsFieldNumber = 43,
    kDefaultSpeedFieldNumber = 44,
    kDestinationOnlyFieldNumber = 46,
    kIsUrbanFieldNumber = 47,
    kSourceAlongEdgeFieldNumber = 49,
    kTargetAlongEdgeFieldNumber = 50,
    kSacScaleFieldNumber = 51,
    kShoulderFieldNumber = 52,
  };
  // repeated .valhalla.StreetName name = 1;
  int name_size() const;
  private:
  int _internal_name_size() const;
  public:
  void clear_name();
  ::valhalla::StreetName* mutable_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_name();
  private:
  const ::valhalla::StreetName& _internal_name(int index) const;
  ::valhalla::StreetName* _internal_add_name();
  public:
  const ::valhalla::StreetName& name(int index) const;
  ::valhalla::StreetName* add_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      name() const;

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  int lane_connectivity_size() const;
  private:
  int _internal_lane_connectivity_size() const;
  public:
  void clear_lane_connectivity();
  ::valhalla::TripLeg_LaneConnectivity* mutable_lane_connectivity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
      mutable_lane_connectivity();
  private:
  const ::valhalla::TripLeg_LaneConnectivity& _internal_lane_connectivity(int index) const;
  ::valhalla::TripLeg_LaneConnectivity* _internal_add_lane_connectivity();
  public:
  const ::valhalla::TripLeg_LaneConnectivity& lane_connectivity(int index) const;
  ::valhalla::TripLeg_LaneConnectivity* add_lane_connectivity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
      lane_connectivity() const;

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  int traffic_segment_size() const;
  private:
  int _internal_traffic_segment_size() const;
  public:
  void clear_traffic_segment();
  ::valhalla::TripLeg_TrafficSegment* mutable_traffic_segment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
      mutable_traffic_segment();
  private:
  const ::valhalla::TripLeg_TrafficSegment& _internal_traffic_segment(int index) const;
  ::valhalla::TripLeg_TrafficSegment* _internal_add_traffic_segment();
  public:
  const ::valhalla::TripLeg_TrafficSegment& traffic_segment(int index) const;
  ::valhalla::TripLeg_TrafficSegment* add_traffic_segment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
      traffic_segment() const;

  // repeated .valhalla.TurnLane turn_lanes = 42;
  int turn_lanes_size() const;
  private:
  int _internal_turn_lanes_size() const;
  public:
  void clear_turn_lanes();
  ::valhalla::TurnLane* mutable_turn_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >*
      mutable_turn_lanes();
  private:
  const ::valhalla::TurnLane& _internal_turn_lanes(int index) const;
  ::valhalla::TurnLane* _internal_add_turn_lanes();
  public:
  const ::valhalla::TurnLane& turn_lanes(int index) const;
  ::valhalla::TurnLane* add_turn_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >&
      turn_lanes() const;

  // repeated .valhalla.TaggedValue tagged_value = 48;
  int tagged_value_size() const;
  private:
  int _internal_tagged_value_size() const;
  public:
  void clear_tagged_value();
  ::valhalla::TaggedValue* mutable_tagged_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >*
      mutable_tagged_value();
  private:
  const ::valhalla::TaggedValue& _internal_tagged_value(int index) const;
  ::valhalla::TaggedValue* _internal_add_tagged_value();
  public:
  const ::valhalla::TaggedValue& tagged_value(int index) const;
  ::valhalla::TaggedValue* add_tagged_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >&
      tagged_value() const;

  // .valhalla.TripSign sign = 19;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);
  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::TripSign* sign);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  bool has_transit_route_info() const;
  private:
  bool _internal_has_transit_route_info() const;
  public:
  void clear_transit_route_info();
  const ::valhalla::TransitRouteInfo& transit_route_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitRouteInfo* release_transit_route_info();
  ::valhalla::TransitRouteInfo* mutable_transit_route_info();
  void set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info);
  private:
  const ::valhalla::TransitRouteInfo& _internal_transit_route_info() const;
  ::valhalla::TransitRouteInfo* _internal_mutable_transit_route_info();
  public:
  void unsafe_arena_set_allocated_transit_route_info(
      ::valhalla::TransitRouteInfo* transit_route_info);
  ::valhalla::TransitRouteInfo* unsafe_arena_release_transit_route_info();

  // .valhalla.TripLeg.Restriction restriction = 45;
  bool has_restriction() const;
  private:
  bool _internal_has_restriction() const;
  public:
  void clear_restriction();
  const ::valhalla::TripLeg_Restriction& restriction() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Restriction* release_restriction();
  ::valhalla::TripLeg_Restriction* mutable_restriction();
  void set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction);
  private:
  const ::valhalla::TripLeg_Restriction& _internal_restriction() const;
  ::valhalla::TripLeg_Restriction* _internal_mutable_restriction();
  public:
  void unsafe_arena_set_allocated_restriction(
      ::valhalla::TripLeg_Restriction* restriction);
  ::valhalla::TripLeg_Restriction* unsafe_arena_release_restriction();

  // float length_km = 2;
  bool has_length_km() const;
  private:
  bool _internal_has_length_km() const;
  public:
  void clear_length_km();
  float length_km() const;
  void set_length_km(float value);
  private:
  float _internal_length_km() const;
  void _internal_set_length_km(float value);
  public:

  // float speed = 3;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // .valhalla.RoadClass road_class = 4;
  bool has_road_class() const;
  private:
  bool _internal_has_road_class() const;
  public:
  void clear_road_class();
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);
  private:
  ::valhalla::RoadClass _internal_road_class() const;
  void _internal_set_road_class(::valhalla::RoadClass value);
  public:

  // uint32 begin_heading = 5;
  bool has_begin_heading() const;
  private:
  bool _internal_has_begin_heading() const;
  public:
  void clear_begin_heading();
  uint32_t begin_heading() const;
  void set_begin_heading(uint32_t value);
  private:
  uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(uint32_t value);
  public:

  // uint32 end_heading = 6;
  bool has_end_heading() const;
  private:
  bool _internal_has_end_heading() const;
  public:
  void clear_end_heading();
  uint32_t end_heading() const;
  void set_end_heading(uint32_t value);
  private:
  uint32_t _internal_end_heading() const;
  void _internal_set_end_heading(uint32_t value);
  public:

  // uint32 begin_shape_index = 7;
  bool has_begin_shape_index() const;
  private:
  bool _internal_has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 8;
  bool has_end_shape_index() const;
  private:
  bool _internal_has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  // .valhalla.TripLeg.Traversability traversability = 9;
  bool has_traversability() const;
  private:
  bool _internal_has_traversability() const;
  public:
  void clear_traversability();
  ::valhalla::TripLeg_Traversability traversability() const;
  void set_traversability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_traversability() const;
  void _internal_set_traversability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Use use = 10;
  bool has_use() const;
  private:
  bool _internal_has_use() const;
  public:
  void clear_use();
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);
  private:
  ::valhalla::TripLeg_Use _internal_use() const;
  void _internal_set_use(::valhalla::TripLeg_Use value);
  public:

  // bool toll = 11;
  bool has_toll() const;
  private:
  bool _internal_has_toll() const;
  public:
  void clear_toll();
  bool toll() const;
  void set_toll(bool value);
  private:
  bool _internal_toll() const;
  void _internal_set_toll(bool value);
  public:

  // bool unpaved = 12;
  bool has_unpaved() const;
  private:
  bool _internal_has_unpaved() const;
  public:
  void clear_unpaved();
  bool unpaved() const;
  void set_unpaved(bool value);
  private:
  bool _internal_unpaved() const;
  void _internal_set_unpaved(bool value);
  public:

  // bool tunnel = 13;
  bool has_tunnel() const;
  private:
  bool _internal_has_tunnel() const;
  public:
  void clear_tunnel();
  bool tunnel() const;
  void set_tunnel(bool value);
  private:
  bool _internal_tunnel() const;
  void _internal_set_tunnel(bool value);
  public:

  // bool bridge = 14;
  bool has_bridge() const;
  private:
  bool _internal_has_bridge() const;
  public:
  void clear_bridge();
  bool bridge() const;
  void set_bridge(bool value);
  private:
  bool _internal_bridge() const;
  void _internal_set_bridge(bool value);
  public:

  // bool roundabout = 15;
  bool has_roundabout() const;
  private:
  bool _internal_has_roundabout() const;
  public:
  void clear_roundabout();
  bool roundabout() const;
  void set_roundabout(bool value);
  private:
  bool _internal_roundabout() const;
  void _internal_set_roundabout(bool value);
  public:

  // bool internal_intersection = 16;
  bool has_internal_intersection() const;
  private:
  bool _internal_has_internal_intersection() const;
  public:
  void clear_internal_intersection();
  bool internal_intersection() const;
  void set_internal_intersection(bool value);
  private:
  bool _internal_internal_intersection() const;
  void _internal_set_internal_intersection(bool value);
  public:

  // bool drive_on_left = 17;
  bool has_drive_on_left() const;
  private:
  bool _internal_has_drive_on_left() const;
  public:
  void clear_drive_on_left();
  bool drive_on_left() const;
  void set_drive_on_left(bool value);
  private:
  bool _internal_drive_on_left() const;
  void _internal_set_drive_on_left(bool value);
  public:

  // .valhalla.TripLeg.Surface surface = 18;
  bool has_surface() const;
  private:
  bool _internal_has_surface() const;
  public:
  void clear_surface();
  ::valhalla::TripLeg_Surface surface() const;
  void set_surface(::valhalla::TripLeg_Surface value);
  private:
  ::valhalla::TripLeg_Surface _internal_surface() const;
  void _internal_set_surface(::valhalla::TripLeg_Surface value);
  public:

  // .valhalla.TravelMode travel_mode = 20;
  bool has_travel_mode() const;
  private:
  bool _internal_has_travel_mode() const;
  public:
  void clear_travel_mode();
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);
  private:
  ::valhalla::TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::TravelMode value);
  public:

  // .valhalla.VehicleType vehicle_type = 21;
  bool has_vehicle_type() const;
  private:
  bool _internal_has_vehicle_type() const;
  public:
  void clear_vehicle_type();
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);
  private:
  ::valhalla::VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::VehicleType value);
  public:

  // .valhalla.PedestrianType pedestrian_type = 22;
  bool has_pedestrian_type() const;
  private:
  bool _internal_has_pedestrian_type() const;
  public:
  void clear_pedestrian_type();
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);
  private:
  ::valhalla::PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::PedestrianType value);
  public:

  // .valhalla.BicycleType bicycle_type = 23;
  bool has_bicycle_type() const;
  private:
  bool _internal_has_bicycle_type() const;
  public:
  void clear_bicycle_type();
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);
  private:
  ::valhalla::BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::BicycleType value);
  public:

  // .valhalla.TransitType transit_type = 24;
  bool has_transit_type() const;
  private:
  bool _internal_has_transit_type() const;
  public:
  void clear_transit_type();
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);
  private:
  ::valhalla::TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::TransitType value);
  public:

  // uint64 id = 26;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 way_id = 27;
  bool has_way_id() const;
  private:
  bool _internal_has_way_id() const;
  public:
  void clear_way_id();
  uint64_t way_id() const;
  void set_way_id(uint64_t value);
  private:
  uint64_t _internal_way_id() const;
  void _internal_set_way_id(uint64_t value);
  public:

  // float weighted_grade = 28;
  bool has_weighted_grade() const;
  private:
  bool _internal_has_weighted_grade() const;
  public:
  void clear_weighted_grade();
  float weighted_grade() const;
  void set_weighted_grade(float value);
  private:
  float _internal_weighted_grade() const;
  void _internal_set_weighted_grade(float value);
  public:

  // int32 max_upward_grade = 29;
  bool has_max_upward_grade() const;
  private:
  bool _internal_has_max_upward_grade() const;
  public:
  void clear_max_upward_grade();
  int32_t max_upward_grade() const;
  void set_max_upward_grade(int32_t value);
  private:
  int32_t _internal_max_upward_grade() const;
  void _internal_set_max_upward_grade(int32_t value);
  public:

  // int32 max_downward_grade = 30;
  bool has_max_downward_grade() const;
  private:
  bool _internal_has_max_downward_grade() const;
  public:
  void clear_max_downward_grade();
  int32_t max_downward_grade() const;
  void set_max_downward_grade(int32_t value);
  private:
  int32_t _internal_max_downward_grade() const;
  void _internal_set_max_downward_grade(int32_t value);
  public:

  // uint32 lane_count = 31;
  bool has_lane_count() const;
  private:
  bool _internal_has_lane_count() const;
  public:
  void clear_lane_count();
  uint32_t lane_count() const;
  void set_lane_count(uint32_t value);
  private:
  uint32_t _internal_lane_count() const;
  void _internal_set_lane_count(uint32_t value);
  public:

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  bool has_cycle_lane() const;
  private:
  bool _internal_has_cycle_lane() const;
  public:
  void clear_cycle_lane();
  ::valhalla::TripLeg_CycleLane cycle_lane() const;
  void set_cycle_lane(::valhalla::TripLeg_CycleLane value);
  private:
  ::valhalla::TripLeg_CycleLane _internal_cycle_lane() const;
  void _internal_set_cycle_lane(::valhalla::TripLeg_CycleLane value);
  public:

  // uint32 bicycle_network = 33;
  bool has_bicycle_network() const;
  private:
  bool _internal_has_bicycle_network() const;
  public:
  void clear_bicycle_network();
  uint32_t bicycle_network() const;
  void set_bicycle_network(uint32_t value);
  private:
  uint32_t _internal_bicycle_network() const;
  void _internal_set_bicycle_network(uint32_t value);
  public:

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  bool has_sidewalk() const;
  private:
  bool _internal_has_sidewalk() const;
  public:
  void clear_sidewalk();
  ::valhalla::TripLeg_Sidewalk sidewalk() const;
  void set_sidewalk(::valhalla::TripLeg_Sidewalk value);
  private:
  ::valhalla::TripLeg_Sidewalk _internal_sidewalk() const;
  void _internal_set_sidewalk(::valhalla::TripLeg_Sidewalk value);
  public:

  // uint32 density = 35;
  bool has_density() const;
  private:
  bool _internal_has_density() const;
  public:
  void clear_density();
  uint32_t density() const;
  void set_density(uint32_t value);
  private:
  uint32_t _internal_density() const;
  void _internal_set_density(uint32_t value);
  public:

  // uint32 speed_limit = 36;
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  uint32_t speed_limit() const;
  void set_speed_limit(uint32_t value);
  private:
  uint32_t _internal_speed_limit() const;
  void _internal_set_speed_limit(uint32_t value);
  public:

  // float truck_speed = 37;
  bool has_truck_speed() const;
  private:
  bool _internal_has_truck_speed() const;
  public:
  void clear_truck_speed();
  float truck_speed() const;
  void set_truck_speed(float value);
  private:
  float _internal_truck_speed() const;
  void _internal_set_truck_speed(float value);
  public:

  // bool truck_route = 38;
  bool has_truck_route() const;
  private:
  bool _internal_has_truck_route() const;
  public:
  void clear_truck_route();
  bool truck_route() const;
  void set_truck_route(bool value);
  private:
  bool _internal_truck_route() const;
  void _internal_set_truck_route(bool value);
  public:

  // int32 mean_elevation = 40;
  bool has_mean_elevation() const;
  private:
  bool _internal_has_mean_elevation() const;
  public:
  void clear_mean_elevation();
  int32_t mean_elevation() const;
  void set_mean_elevation(int32_t value);
  private:
  int32_t _internal_mean_elevation() const;
  void _internal_set_mean_elevation(int32_t value);
  public:

  // bool has_time_restrictions = 43;
  bool has_has_time_restrictions() const;
  private:
  bool _internal_has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // float default_speed = 44;
  bool has_default_speed() const;
  private:
  bool _internal_has_default_speed() const;
  public:
  void clear_default_speed();
  float default_speed() const;
  void set_default_speed(float value);
  private:
  float _internal_default_speed() const;
  void _internal_set_default_speed(float value);
  public:

  // bool destination_only = 46;
  bool has_destination_only() const;
  private:
  bool _internal_has_destination_only() const;
  public:
  void clear_destination_only();
  bool destination_only() const;
  void set_destination_only(bool value);
  private:
  bool _internal_destination_only() const;
  void _internal_set_destination_only(bool value);
  public:

  // bool is_urban = 47;
  bool has_is_urban() const;
  private:
  bool _internal_has_is_urban() const;
  public:
  void clear_is_urban();
  bool is_urban() const;
  void set_is_urban(bool value);
  private:
  bool _internal_is_urban() const;
  void _internal_set_is_urban(bool value);
  public:

  // float source_along_edge = 49;
  bool has_source_along_edge() const;
  private:
  bool _internal_has_source_along_edge() const;
  public:
  void clear_source_along_edge();
  float source_along_edge() const;
  void set_source_along_edge(float value);
  private:
  float _internal_source_along_edge() const;
  void _internal_set_source_along_edge(float value);
  public:

  // float target_along_edge = 50;
  bool has_target_along_edge() const;
  private:
  bool _internal_has_target_along_edge() const;
  public:
  void clear_target_along_edge();
  float target_along_edge() const;
  void set_target_along_edge(float value);
  private:
  float _internal_target_along_edge() const;
  void _internal_set_target_along_edge(float value);
  public:

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  bool has_sac_scale() const;
  private:
  bool _internal_has_sac_scale() const;
  public:
  void clear_sac_scale();
  ::valhalla::TripLeg_SacScale sac_scale() const;
  void set_sac_scale(::valhalla::TripLeg_SacScale value);
  private:
  ::valhalla::TripLeg_SacScale _internal_sac_scale() const;
  void _internal_set_sac_scale(::valhalla::TripLeg_SacScale value);
  public:

  // bool shoulder = 52;
  bool has_shoulder() const;
  private:
  bool _internal_has_shoulder() const;
  public:
  void clear_shoulder();
  bool shoulder() const;
  void set_shoulder(bool value);
  private:
  bool _internal_shoulder() const;
  void _internal_set_shoulder(bool value);
  public:

  void clear_has_length_km();
  HasLengthKmCase has_length_km_case() const;
  void clear_has_speed();
  HasSpeedCase has_speed_case() const;
  void clear_has_road_class();
  HasRoadClassCase has_road_class_case() const;
  void clear_has_begin_heading();
  HasBeginHeadingCase has_begin_heading_case() const;
  void clear_has_end_heading();
  HasEndHeadingCase has_end_heading_case() const;
  void clear_has_begin_shape_index();
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  void clear_has_end_shape_index();
  HasEndShapeIndexCase has_end_shape_index_case() const;
  void clear_has_traversability();
  HasTraversabilityCase has_traversability_case() const;
  void clear_has_use();
  HasUseCase has_use_case() const;
  void clear_has_toll();
  HasTollCase has_toll_case() const;
  void clear_has_unpaved();
  HasUnpavedCase has_unpaved_case() const;
  void clear_has_tunnel();
  HasTunnelCase has_tunnel_case() const;
  void clear_has_bridge();
  HasBridgeCase has_bridge_case() const;
  void clear_has_roundabout();
  HasRoundaboutCase has_roundabout_case() const;
  void clear_has_internal_intersection();
  HasInternalIntersectionCase has_internal_intersection_case() const;
  void clear_has_drive_on_left();
  HasDriveOnLeftCase has_drive_on_left_case() const;
  void clear_has_surface();
  HasSurfaceCase has_surface_case() const;
  void clear_has_travel_mode();
  HasTravelModeCase has_travel_mode_case() const;
  void clear_has_vehicle_type();
  HasVehicleTypeCase has_vehicle_type_case() const;
  void clear_has_pedestrian_type();
  HasPedestrianTypeCase has_pedestrian_type_case() const;
  void clear_has_bicycle_type();
  HasBicycleTypeCase has_bicycle_type_case() const;
  void clear_has_transit_type();
  HasTransitTypeCase has_transit_type_case() const;
  void clear_has_id();
  HasIdCase has_id_case() const;
  void clear_has_way_id();
  HasWayIdCase has_way_id_case() const;
  void clear_has_weighted_grade();
  HasWeightedGradeCase has_weighted_grade_case() const;
  void clear_has_max_upward_grade();
  HasMaxUpwardGradeCase has_max_upward_grade_case() const;
  void clear_has_max_downward_grade();
  HasMaxDownwardGradeCase has_max_downward_grade_case() const;
  void clear_has_lane_count();
  HasLaneCountCase has_lane_count_case() const;
  void clear_has_cycle_lane();
  HasCycleLaneCase has_cycle_lane_case() const;
  void clear_has_bicycle_network();
  HasBicycleNetworkCase has_bicycle_network_case() const;
  void clear_has_sidewalk();
  HasSidewalkCase has_sidewalk_case() const;
  void clear_has_density();
  HasDensityCase has_density_case() const;
  void clear_has_speed_limit();
  HasSpeedLimitCase has_speed_limit_case() const;
  void clear_has_truck_speed();
  HasTruckSpeedCase has_truck_speed_case() const;
  void clear_has_truck_route();
  HasTruckRouteCase has_truck_route_case() const;
  void clear_has_mean_elevation();
  HasMeanElevationCase has_mean_elevation_case() const;
  void clear_has_has_time_restrictions();
  HasHasTimeRestrictionsCase has_has_time_restrictions_case() const;
  void clear_has_default_speed();
  HasDefaultSpeedCase has_default_speed_case() const;
  void clear_has_destination_only();
  HasDestinationOnlyCase has_destination_only_case() const;
  void clear_has_is_urban();
  HasIsUrbanCase has_is_urban_case() const;
  void clear_has_source_along_edge();
  HasSourceAlongEdgeCase has_source_along_edge_case() const;
  void clear_has_target_along_edge();
  HasTargetAlongEdgeCase has_target_along_edge_case() const;
  void clear_has_sac_scale();
  HasSacScaleCase has_sac_scale_case() const;
  void clear_has_shoulder();
  HasShoulderCase has_shoulder_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Edge)
 private:
  class _Internal;
  void set_has_length_km();
  void set_has_speed();
  void set_has_road_class();
  void set_has_begin_heading();
  void set_has_end_heading();
  void set_has_begin_shape_index();
  void set_has_end_shape_index();
  void set_has_traversability();
  void set_has_use();
  void set_has_toll();
  void set_has_unpaved();
  void set_has_tunnel();
  void set_has_bridge();
  void set_has_roundabout();
  void set_has_internal_intersection();
  void set_has_drive_on_left();
  void set_has_surface();
  void set_has_travel_mode();
  void set_has_vehicle_type();
  void set_has_pedestrian_type();
  void set_has_bicycle_type();
  void set_has_transit_type();
  void set_has_id();
  void set_has_way_id();
  void set_has_weighted_grade();
  void set_has_max_upward_grade();
  void set_has_max_downward_grade();
  void set_has_lane_count();
  void set_has_cycle_lane();
  void set_has_bicycle_network();
  void set_has_sidewalk();
  void set_has_density();
  void set_has_speed_limit();
  void set_has_truck_speed();
  void set_has_truck_route();
  void set_has_mean_elevation();
  void set_has_has_time_restrictions();
  void set_has_default_speed();
  void set_has_destination_only();
  void set_has_is_urban();
  void set_has_source_along_edge();
  void set_has_target_along_edge();
  void set_has_sac_scale();
  void set_has_shoulder();

  inline bool has_has_length_km() const;
  inline void clear_has_has_length_km();

  inline bool has_has_speed() const;
  inline void clear_has_has_speed();

  inline bool has_has_road_class() const;
  inline void clear_has_has_road_class();

  inline bool has_has_begin_heading() const;
  inline void clear_has_has_begin_heading();

  inline bool has_has_end_heading() const;
  inline void clear_has_has_end_heading();

  inline bool has_has_begin_shape_index() const;
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  inline void clear_has_has_end_shape_index();

  inline bool has_has_traversability() const;
  inline void clear_has_has_traversability();

  inline bool has_has_use() const;
  inline void clear_has_has_use();

  inline bool has_has_toll() const;
  inline void clear_has_has_toll();

  inline bool has_has_unpaved() const;
  inline void clear_has_has_unpaved();

  inline bool has_has_tunnel() const;
  inline void clear_has_has_tunnel();

  inline bool has_has_bridge() const;
  inline void clear_has_has_bridge();

  inline bool has_has_roundabout() const;
  inline void clear_has_has_roundabout();

  inline bool has_has_internal_intersection() const;
  inline void clear_has_has_internal_intersection();

  inline bool has_has_drive_on_left() const;
  inline void clear_has_has_drive_on_left();

  inline bool has_has_surface() const;
  inline void clear_has_has_surface();

  inline bool has_has_travel_mode() const;
  inline void clear_has_has_travel_mode();

  inline bool has_has_vehicle_type() const;
  inline void clear_has_has_vehicle_type();

  inline bool has_has_pedestrian_type() const;
  inline void clear_has_has_pedestrian_type();

  inline bool has_has_bicycle_type() const;
  inline void clear_has_has_bicycle_type();

  inline bool has_has_transit_type() const;
  inline void clear_has_has_transit_type();

  inline bool has_has_id() const;
  inline void clear_has_has_id();

  inline bool has_has_way_id() const;
  inline void clear_has_has_way_id();

  inline bool has_has_weighted_grade() const;
  inline void clear_has_has_weighted_grade();

  inline bool has_has_max_upward_grade() const;
  inline void clear_has_has_max_upward_grade();

  inline bool has_has_max_downward_grade() const;
  inline void clear_has_has_max_downward_grade();

  inline bool has_has_lane_count() const;
  inline void clear_has_has_lane_count();

  inline bool has_has_cycle_lane() const;
  inline void clear_has_has_cycle_lane();

  inline bool has_has_bicycle_network() const;
  inline void clear_has_has_bicycle_network();

  inline bool has_has_sidewalk() const;
  inline void clear_has_has_sidewalk();

  inline bool has_has_density() const;
  inline void clear_has_has_density();

  inline bool has_has_speed_limit() const;
  inline void clear_has_has_speed_limit();

  inline bool has_has_truck_speed() const;
  inline void clear_has_has_truck_speed();

  inline bool has_has_truck_route() const;
  inline void clear_has_has_truck_route();

  inline bool has_has_mean_elevation() const;
  inline void clear_has_has_mean_elevation();

  inline bool has_has_has_time_restrictions() const;
  inline void clear_has_has_has_time_restrictions();

  inline bool has_has_default_speed() const;
  inline void clear_has_has_default_speed();

  inline bool has_has_destination_only() const;
  inline void clear_has_has_destination_only();

  inline bool has_has_is_urban() const;
  inline void clear_has_has_is_urban();

  inline bool has_has_source_along_edge() const;
  inline void clear_has_has_source_along_edge();

  inline bool has_has_target_along_edge() const;
  inline void clear_has_has_target_along_edge();

  inline bool has_has_sac_scale() const;
  inline void clear_has_has_sac_scale();

  inline bool has_has_shoulder() const;
  inline void clear_has_has_shoulder();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity > lane_connectivity_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment > traffic_segment_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane > turn_lanes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue > tagged_value_;
    ::valhalla::TripSign* sign_;
    ::valhalla::TransitRouteInfo* transit_route_info_;
    ::valhalla::TripLeg_Restriction* restriction_;
    union HasLengthKmUnion {
      constexpr HasLengthKmUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float length_km_;
    } has_length_km_;
    union HasSpeedUnion {
      constexpr HasSpeedUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float speed_;
    } has_speed_;
    union HasRoadClassUnion {
      constexpr HasRoadClassUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int road_class_;
    } has_road_class_;
    union HasBeginHeadingUnion {
      constexpr HasBeginHeadingUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t begin_heading_;
    } has_begin_heading_;
    union HasEndHeadingUnion {
      constexpr HasEndHeadingUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t end_heading_;
    } has_end_heading_;
    union HasBeginShapeIndexUnion {
      constexpr HasBeginShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t begin_shape_index_;
    } has_begin_shape_index_;
    union HasEndShapeIndexUnion {
      constexpr HasEndShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t end_shape_index_;
    } has_end_shape_index_;
    union HasTraversabilityUnion {
      constexpr HasTraversabilityUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int traversability_;
    } has_traversability_;
    union HasUseUnion {
      constexpr HasUseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int use_;
    } has_use_;
    union HasTollUnion {
      constexpr HasTollUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool toll_;
    } has_toll_;
    union HasUnpavedUnion {
      constexpr HasUnpavedUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool unpaved_;
    } has_unpaved_;
    union HasTunnelUnion {
      constexpr HasTunnelUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool tunnel_;
    } has_tunnel_;
    union HasBridgeUnion {
      constexpr HasBridgeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool bridge_;
    } has_bridge_;
    union HasRoundaboutUnion {
      constexpr HasRoundaboutUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool roundabout_;
    } has_roundabout_;
    union HasInternalIntersectionUnion {
      constexpr HasInternalIntersectionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool internal_intersection_;
    } has_internal_intersection_;
    union HasDriveOnLeftUnion {
      constexpr HasDriveOnLeftUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool drive_on_left_;
    } has_drive_on_left_;
    union HasSurfaceUnion {
      constexpr HasSurfaceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int surface_;
    } has_surface_;
    union HasTravelModeUnion {
      constexpr HasTravelModeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int travel_mode_;
    } has_travel_mode_;
    union HasVehicleTypeUnion {
      constexpr HasVehicleTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int vehicle_type_;
    } has_vehicle_type_;
    union HasPedestrianTypeUnion {
      constexpr HasPedestrianTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int pedestrian_type_;
    } has_pedestrian_type_;
    union HasBicycleTypeUnion {
      constexpr HasBicycleTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int bicycle_type_;
    } has_bicycle_type_;
    union HasTransitTypeUnion {
      constexpr HasTransitTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int transit_type_;
    } has_transit_type_;
    union HasIdUnion {
      constexpr HasIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t id_;
    } has_id_;
    union HasWayIdUnion {
      constexpr HasWayIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t way_id_;
    } has_way_id_;
    union HasWeightedGradeUnion {
      constexpr HasWeightedGradeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float weighted_grade_;
    } has_weighted_grade_;
    union HasMaxUpwardGradeUnion {
      constexpr HasMaxUpwardGradeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t max_upward_grade_;
    } has_max_upward_grade_;
    union HasMaxDownwardGradeUnion {
      constexpr HasMaxDownwardGradeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t max_downward_grade_;
    } has_max_downward_grade_;
    union HasLaneCountUnion {
      constexpr HasLaneCountUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t lane_count_;
    } has_lane_count_;
    union HasCycleLaneUnion {
      constexpr HasCycleLaneUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int cycle_lane_;
    } has_cycle_lane_;
    union HasBicycleNetworkUnion {
      constexpr HasBicycleNetworkUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t bicycle_network_;
    } has_bicycle_network_;
    union HasSidewalkUnion {
      constexpr HasSidewalkUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int sidewalk_;
    } has_sidewalk_;
    union HasDensityUnion {
      constexpr HasDensityUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t density_;
    } has_density_;
    union HasSpeedLimitUnion {
      constexpr HasSpeedLimitUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t speed_limit_;
    } has_speed_limit_;
    union HasTruckSpeedUnion {
      constexpr HasTruckSpeedUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float truck_speed_;
    } has_truck_speed_;
    union HasTruckRouteUnion {
      constexpr HasTruckRouteUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool truck_route_;
    } has_truck_route_;
    union HasMeanElevationUnion {
      constexpr HasMeanElevationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t mean_elevation_;
    } has_mean_elevation_;
    union HasHasTimeRestrictionsUnion {
      constexpr HasHasTimeRestrictionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool has_time_restrictions_;
    } has_has_time_restrictions_;
    union HasDefaultSpeedUnion {
      constexpr HasDefaultSpeedUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float default_speed_;
    } has_default_speed_;
    union HasDestinationOnlyUnion {
      constexpr HasDestinationOnlyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool destination_only_;
    } has_destination_only_;
    union HasIsUrbanUnion {
      constexpr HasIsUrbanUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool is_urban_;
    } has_is_urban_;
    union HasSourceAlongEdgeUnion {
      constexpr HasSourceAlongEdgeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float source_along_edge_;
    } has_source_along_edge_;
    union HasTargetAlongEdgeUnion {
      constexpr HasTargetAlongEdgeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float target_along_edge_;
    } has_target_along_edge_;
    union HasSacScaleUnion {
      constexpr HasSacScaleUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int sac_scale_;
    } has_sac_scale_;
    union HasShoulderUnion {
      constexpr HasShoulderUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool shoulder_;
    } has_shoulder_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[44];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_IntersectingEdge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.IntersectingEdge) */ {
 public:
  inline TripLeg_IntersectingEdge() : TripLeg_IntersectingEdge(nullptr) {}
  ~TripLeg_IntersectingEdge() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from);
  TripLeg_IntersectingEdge(TripLeg_IntersectingEdge&& from) noexcept
    : TripLeg_IntersectingEdge() {
    *this = ::std::move(from);
  }

  inline TripLeg_IntersectingEdge& operator=(const TripLeg_IntersectingEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_IntersectingEdge& operator=(TripLeg_IntersectingEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_IntersectingEdge& default_instance() {
    return *internal_default_instance();
  }
  enum HasBeginHeadingCase {
    kBeginHeading = 1,
    HAS_BEGIN_HEADING_NOT_SET = 0,
  };

  enum HasPrevNameConsistencyCase {
    kPrevNameConsistency = 2,
    HAS_PREV_NAME_CONSISTENCY_NOT_SET = 0,
  };

  enum HasCurrNameConsistencyCase {
    kCurrNameConsistency = 3,
    HAS_CURR_NAME_CONSISTENCY_NOT_SET = 0,
  };

  enum HasDriveabilityCase {
    kDriveability = 4,
    HAS_DRIVEABILITY_NOT_SET = 0,
  };

  enum HasCyclabilityCase {
    kCyclability = 5,
    HAS_CYCLABILITY_NOT_SET = 0,
  };

  enum HasWalkabilityCase {
    kWalkability = 6,
    HAS_WALKABILITY_NOT_SET = 0,
  };

  enum HasUseCase {
    kUse = 7,
    HAS_USE_NOT_SET = 0,
  };

  enum HasRoadClassCase {
    kRoadClass = 8,
    HAS_ROAD_CLASS_NOT_SET = 0,
  };

  enum HasLaneCountCase {
    kLaneCount = 9,
    HAS_LANE_COUNT_NOT_SET = 0,
  };

  static inline const TripLeg_IntersectingEdge* internal_default_instance() {
    return reinterpret_cast<const TripLeg_IntersectingEdge*>(
               &_TripLeg_IntersectingEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TripLeg_IntersectingEdge& a, TripLeg_IntersectingEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_IntersectingEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_IntersectingEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_IntersectingEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_IntersectingEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_IntersectingEdge& from);
  void MergeFrom(const TripLeg_IntersectingEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_IntersectingEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.IntersectingEdge";
  }
  protected:
  explicit TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignFieldNumber = 10,
    kBeginHeadingFieldNumber = 1,
    kPrevNameConsistencyFieldNumber = 2,
    kCurrNameConsistencyFieldNumber = 3,
    kDriveabilityFieldNumber = 4,
    kCyclabilityFieldNumber = 5,
    kWalkabilityFieldNumber = 6,
    kUseFieldNumber = 7,
    kRoadClassFieldNumber = 8,
    kLaneCountFieldNumber = 9,
  };
  // .valhalla.TripSign sign = 10;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);
  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::TripSign* sign);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  // uint32 begin_heading = 1;
  bool has_begin_heading() const;
  private:
  bool _internal_has_begin_heading() const;
  public:
  void clear_begin_heading();
  uint32_t begin_heading() const;
  void set_begin_heading(uint32_t value);
  private:
  uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(uint32_t value);
  public:

  // bool prev_name_consistency = 2;
  bool has_prev_name_consistency() const;
  private:
  bool _internal_has_prev_name_consistency() const;
  public:
  void clear_prev_name_consistency();
  bool prev_name_consistency() const;
  void set_prev_name_consistency(bool value);
  private:
  bool _internal_prev_name_consistency() const;
  void _internal_set_prev_name_consistency(bool value);
  public:

  // bool curr_name_consistency = 3;
  bool has_curr_name_consistency() const;
  private:
  bool _internal_has_curr_name_consistency() const;
  public:
  void clear_curr_name_consistency();
  bool curr_name_consistency() const;
  void set_curr_name_consistency(bool value);
  private:
  bool _internal_curr_name_consistency() const;
  void _internal_set_curr_name_consistency(bool value);
  public:

  // .valhalla.TripLeg.Traversability driveability = 4;
  bool has_driveability() const;
  private:
  bool _internal_has_driveability() const;
  public:
  void clear_driveability();
  ::valhalla::TripLeg_Traversability driveability() const;
  void set_driveability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_driveability() const;
  void _internal_set_driveability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Traversability cyclability = 5;
  bool has_cyclability() const;
  private:
  bool _internal_has_cyclability() const;
  public:
  void clear_cyclability();
  ::valhalla::TripLeg_Traversability cyclability() const;
  void set_cyclability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_cyclability() const;
  void _internal_set_cyclability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Traversability walkability = 6;
  bool has_walkability() const;
  private:
  bool _internal_has_walkability() const;
  public:
  void clear_walkability();
  ::valhalla::TripLeg_Traversability walkability() const;
  void set_walkability(::valhalla::TripLeg_Traversability value);
  private:
  ::valhalla::TripLeg_Traversability _internal_walkability() const;
  void _internal_set_walkability(::valhalla::TripLeg_Traversability value);
  public:

  // .valhalla.TripLeg.Use use = 7;
  bool has_use() const;
  private:
  bool _internal_has_use() const;
  public:
  void clear_use();
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);
  private:
  ::valhalla::TripLeg_Use _internal_use() const;
  void _internal_set_use(::valhalla::TripLeg_Use value);
  public:

  // .valhalla.RoadClass road_class = 8;
  bool has_road_class() const;
  private:
  bool _internal_has_road_class() const;
  public:
  void clear_road_class();
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);
  private:
  ::valhalla::RoadClass _internal_road_class() const;
  void _internal_set_road_class(::valhalla::RoadClass value);
  public:

  // uint32 lane_count = 9;
  bool has_lane_count() const;
  private:
  bool _internal_has_lane_count() const;
  public:
  void clear_lane_count();
  uint32_t lane_count() const;
  void set_lane_count(uint32_t value);
  private:
  uint32_t _internal_lane_count() const;
  void _internal_set_lane_count(uint32_t value);
  public:

  void clear_has_begin_heading();
  HasBeginHeadingCase has_begin_heading_case() const;
  void clear_has_prev_name_consistency();
  HasPrevNameConsistencyCase has_prev_name_consistency_case() const;
  void clear_has_curr_name_consistency();
  HasCurrNameConsistencyCase has_curr_name_consistency_case() const;
  void clear_has_driveability();
  HasDriveabilityCase has_driveability_case() const;
  void clear_has_cyclability();
  HasCyclabilityCase has_cyclability_case() const;
  void clear_has_walkability();
  HasWalkabilityCase has_walkability_case() const;
  void clear_has_use();
  HasUseCase has_use_case() const;
  void clear_has_road_class();
  HasRoadClassCase has_road_class_case() const;
  void clear_has_lane_count();
  HasLaneCountCase has_lane_count_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.IntersectingEdge)
 private:
  class _Internal;
  void set_has_begin_heading();
  void set_has_prev_name_consistency();
  void set_has_curr_name_consistency();
  void set_has_driveability();
  void set_has_cyclability();
  void set_has_walkability();
  void set_has_use();
  void set_has_road_class();
  void set_has_lane_count();

  inline bool has_has_begin_heading() const;
  inline void clear_has_has_begin_heading();

  inline bool has_has_prev_name_consistency() const;
  inline void clear_has_has_prev_name_consistency();

  inline bool has_has_curr_name_consistency() const;
  inline void clear_has_has_curr_name_consistency();

  inline bool has_has_driveability() const;
  inline void clear_has_has_driveability();

  inline bool has_has_cyclability() const;
  inline void clear_has_has_cyclability();

  inline bool has_has_walkability() const;
  inline void clear_has_has_walkability();

  inline bool has_has_use() const;
  inline void clear_has_has_use();

  inline bool has_has_road_class() const;
  inline void clear_has_has_road_class();

  inline bool has_has_lane_count() const;
  inline void clear_has_has_lane_count();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::TripSign* sign_;
    union HasBeginHeadingUnion {
      constexpr HasBeginHeadingUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t begin_heading_;
    } has_begin_heading_;
    union HasPrevNameConsistencyUnion {
      constexpr HasPrevNameConsistencyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool prev_name_consistency_;
    } has_prev_name_consistency_;
    union HasCurrNameConsistencyUnion {
      constexpr HasCurrNameConsistencyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool curr_name_consistency_;
    } has_curr_name_consistency_;
    union HasDriveabilityUnion {
      constexpr HasDriveabilityUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int driveability_;
    } has_driveability_;
    union HasCyclabilityUnion {
      constexpr HasCyclabilityUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int cyclability_;
    } has_cyclability_;
    union HasWalkabilityUnion {
      constexpr HasWalkabilityUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int walkability_;
    } has_walkability_;
    union HasUseUnion {
      constexpr HasUseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int use_;
    } has_use_;
    union HasRoadClassUnion {
      constexpr HasRoadClassUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int road_class_;
    } has_road_class_;
    union HasLaneCountUnion {
      constexpr HasLaneCountUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t lane_count_;
    } has_lane_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[9];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Cost final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Cost) */ {
 public:
  inline TripLeg_Cost() : TripLeg_Cost(nullptr) {}
  ~TripLeg_Cost() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Cost(const TripLeg_Cost& from);
  TripLeg_Cost(TripLeg_Cost&& from) noexcept
    : TripLeg_Cost() {
    *this = ::std::move(from);
  }

  inline TripLeg_Cost& operator=(const TripLeg_Cost& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Cost& operator=(TripLeg_Cost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Cost& default_instance() {
    return *internal_default_instance();
  }
  enum HasSecondsCase {
    kSeconds = 1,
    HAS_SECONDS_NOT_SET = 0,
  };

  enum HasCostCase {
    kCost = 2,
    HAS_COST_NOT_SET = 0,
  };

  static inline const TripLeg_Cost* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Cost*>(
               &_TripLeg_Cost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TripLeg_Cost& a, TripLeg_Cost& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Cost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Cost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Cost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Cost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Cost& from);
  void MergeFrom(const TripLeg_Cost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Cost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Cost";
  }
  protected:
  explicit TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // double seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  double seconds() const;
  void set_seconds(double value);
  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);
  public:

  // double cost = 2;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  double cost() const;
  void set_cost(double value);
  private:
  double _internal_cost() const;
  void _internal_set_cost(double value);
  public:

  void clear_has_seconds();
  HasSecondsCase has_seconds_case() const;
  void clear_has_cost();
  HasCostCase has_cost_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Cost)
 private:
  class _Internal;
  void set_has_seconds();
  void set_has_cost();

  inline bool has_has_seconds() const;
  inline void clear_has_has_seconds();

  inline bool has_has_cost() const;
  inline void clear_has_has_cost();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasSecondsUnion {
      constexpr HasSecondsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double seconds_;
    } has_seconds_;
    union HasCostUnion {
      constexpr HasCostUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double cost_;
    } has_cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_PathCost final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.PathCost) */ {
 public:
  inline TripLeg_PathCost() : TripLeg_PathCost(nullptr) {}
  ~TripLeg_PathCost() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_PathCost(const TripLeg_PathCost& from);
  TripLeg_PathCost(TripLeg_PathCost&& from) noexcept
    : TripLeg_PathCost() {
    *this = ::std::move(from);
  }

  inline TripLeg_PathCost& operator=(const TripLeg_PathCost& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_PathCost& operator=(TripLeg_PathCost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_PathCost& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_PathCost* internal_default_instance() {
    return reinterpret_cast<const TripLeg_PathCost*>(
               &_TripLeg_PathCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TripLeg_PathCost& a, TripLeg_PathCost& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_PathCost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_PathCost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_PathCost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_PathCost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_PathCost& from);
  void MergeFrom(const TripLeg_PathCost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_PathCost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.PathCost";
  }
  protected:
  explicit TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElapsedCostFieldNumber = 1,
    kTransitionCostFieldNumber = 2,
  };
  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  bool has_elapsed_cost() const;
  private:
  bool _internal_has_elapsed_cost() const;
  public:
  void clear_elapsed_cost();
  const ::valhalla::TripLeg_Cost& elapsed_cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Cost* release_elapsed_cost();
  ::valhalla::TripLeg_Cost* mutable_elapsed_cost();
  void set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost);
  private:
  const ::valhalla::TripLeg_Cost& _internal_elapsed_cost() const;
  ::valhalla::TripLeg_Cost* _internal_mutable_elapsed_cost();
  public:
  void unsafe_arena_set_allocated_elapsed_cost(
      ::valhalla::TripLeg_Cost* elapsed_cost);
  ::valhalla::TripLeg_Cost* unsafe_arena_release_elapsed_cost();

  // .valhalla.TripLeg.Cost transition_cost = 2;
  bool has_transition_cost() const;
  private:
  bool _internal_has_transition_cost() const;
  public:
  void clear_transition_cost();
  const ::valhalla::TripLeg_Cost& transition_cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Cost* release_transition_cost();
  ::valhalla::TripLeg_Cost* mutable_transition_cost();
  void set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost);
  private:
  const ::valhalla::TripLeg_Cost& _internal_transition_cost() const;
  ::valhalla::TripLeg_Cost* _internal_mutable_transition_cost();
  public:
  void unsafe_arena_set_allocated_transition_cost(
      ::valhalla::TripLeg_Cost* transition_cost);
  ::valhalla::TripLeg_Cost* unsafe_arena_release_transition_cost();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.PathCost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::TripLeg_Cost* elapsed_cost_;
    ::valhalla::TripLeg_Cost* transition_cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Node final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Node) */ {
 public:
  inline TripLeg_Node() : TripLeg_Node(nullptr) {}
  ~TripLeg_Node() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Node(const TripLeg_Node& from);
  TripLeg_Node(TripLeg_Node&& from) noexcept
    : TripLeg_Node() {
    *this = ::std::move(from);
  }

  inline TripLeg_Node& operator=(const TripLeg_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Node& operator=(TripLeg_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Node& default_instance() {
    return *internal_default_instance();
  }
  enum HasAdminIndexCase {
    kAdminIndex = 3,
    HAS_ADMIN_INDEX_NOT_SET = 0,
  };

  enum HasTypeCase {
    kType = 4,
    HAS_TYPE_NOT_SET = 0,
  };

  enum HasForkCase {
    kFork = 5,
    HAS_FORK_NOT_SET = 0,
  };

  enum HasTimeZoneCase {
    kTimeZone = 11,
    HAS_TIME_ZONE_NOT_SET = 0,
  };

  static inline const TripLeg_Node* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Node*>(
               &_TripLeg_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TripLeg_Node& a, TripLeg_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Node>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Node& from);
  void MergeFrom(const TripLeg_Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Node";
  }
  protected:
  explicit TripLeg_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TripLeg_Node_Type Type;
  static constexpr Type kStreetIntersection =
    TripLeg_Node_Type_kStreetIntersection;
  static constexpr Type kGate =
    TripLeg_Node_Type_kGate;
  static constexpr Type kBollard =
    TripLeg_Node_Type_kBollard;
  static constexpr Type kTollBooth =
    TripLeg_Node_Type_kTollBooth;
  static constexpr Type kTransitEgress =
    TripLeg_Node_Type_kTransitEgress;
  static constexpr Type kTransitStation =
    TripLeg_Node_Type_kTransitStation;
  static constexpr Type kTransitPlatform =
    TripLeg_Node_Type_kTransitPlatform;
  static constexpr Type kBikeShare =
    TripLeg_Node_Type_kBikeShare;
  static constexpr Type kParking =
    TripLeg_Node_Type_kParking;
  static constexpr Type kMotorwayJunction =
    TripLeg_Node_Type_kMotorwayJunction;
  static constexpr Type kBorderControl =
    TripLeg_Node_Type_kBorderControl;
  static constexpr Type kTollGantry =
    TripLeg_Node_Type_kTollGantry;
  static constexpr Type kSumpBuster =
    TripLeg_Node_Type_kSumpBuster;
  static inline bool Type_IsValid(int value) {
    return TripLeg_Node_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TripLeg_Node_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TripLeg_Node_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TripLeg_Node_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TripLeg_Node_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TripLeg_Node_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectingEdgeFieldNumber = 2,
    kRecostsFieldNumber = 13,
    kEdgeFieldNumber = 1,
    kTransitPlatformInfoFieldNumber = 6,
    kTransitStationInfoFieldNumber = 7,
    kTransitEgressInfoFieldNumber = 10,
    kCostFieldNumber = 12,
    kBssInfoFieldNumber = 14,
    kAdminIndexFieldNumber = 3,
    kTypeFieldNumber = 4,
    kForkFieldNumber = 5,
    kTimeZoneFieldNumber = 11,
  };
  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  int intersecting_edge_size() const;
  private:
  int _internal_intersecting_edge_size() const;
  public:
  void clear_intersecting_edge();
  ::valhalla::TripLeg_IntersectingEdge* mutable_intersecting_edge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
      mutable_intersecting_edge();
  private:
  const ::valhalla::TripLeg_IntersectingEdge& _internal_intersecting_edge(int index) const;
  ::valhalla::TripLeg_IntersectingEdge* _internal_add_intersecting_edge();
  public:
  const ::valhalla::TripLeg_IntersectingEdge& intersecting_edge(int index) const;
  ::valhalla::TripLeg_IntersectingEdge* add_intersecting_edge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
      intersecting_edge() const;

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  int recosts_size() const;
  private:
  int _internal_recosts_size() const;
  public:
  void clear_recosts();
  ::valhalla::TripLeg_PathCost* mutable_recosts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
      mutable_recosts();
  private:
  const ::valhalla::TripLeg_PathCost& _internal_recosts(int index) const;
  ::valhalla::TripLeg_PathCost* _internal_add_recosts();
  public:
  const ::valhalla::TripLeg_PathCost& recosts(int index) const;
  ::valhalla::TripLeg_PathCost* add_recosts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
      recosts() const;

  // .valhalla.TripLeg.Edge edge = 1;
  bool has_edge() const;
  private:
  bool _internal_has_edge() const;
  public:
  void clear_edge();
  const ::valhalla::TripLeg_Edge& edge() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Edge* release_edge();
  ::valhalla::TripLeg_Edge* mutable_edge();
  void set_allocated_edge(::valhalla::TripLeg_Edge* edge);
  private:
  const ::valhalla::TripLeg_Edge& _internal_edge() const;
  ::valhalla::TripLeg_Edge* _internal_mutable_edge();
  public:
  void unsafe_arena_set_allocated_edge(
      ::valhalla::TripLeg_Edge* edge);
  ::valhalla::TripLeg_Edge* unsafe_arena_release_edge();

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  bool has_transit_platform_info() const;
  private:
  bool _internal_has_transit_platform_info() const;
  public:
  void clear_transit_platform_info();
  const ::valhalla::TransitPlatformInfo& transit_platform_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitPlatformInfo* release_transit_platform_info();
  ::valhalla::TransitPlatformInfo* mutable_transit_platform_info();
  void set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info);
  private:
  const ::valhalla::TransitPlatformInfo& _internal_transit_platform_info() const;
  ::valhalla::TransitPlatformInfo* _internal_mutable_transit_platform_info();
  public:
  void unsafe_arena_set_allocated_transit_platform_info(
      ::valhalla::TransitPlatformInfo* transit_platform_info);
  ::valhalla::TransitPlatformInfo* unsafe_arena_release_transit_platform_info();

  // .valhalla.TransitStationInfo transit_station_info = 7;
  bool has_transit_station_info() const;
  private:
  bool _internal_has_transit_station_info() const;
  public:
  void clear_transit_station_info();
  const ::valhalla::TransitStationInfo& transit_station_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitStationInfo* release_transit_station_info();
  ::valhalla::TransitStationInfo* mutable_transit_station_info();
  void set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info);
  private:
  const ::valhalla::TransitStationInfo& _internal_transit_station_info() const;
  ::valhalla::TransitStationInfo* _internal_mutable_transit_station_info();
  public:
  void unsafe_arena_set_allocated_transit_station_info(
      ::valhalla::TransitStationInfo* transit_station_info);
  ::valhalla::TransitStationInfo* unsafe_arena_release_transit_station_info();

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  bool has_transit_egress_info() const;
  private:
  bool _internal_has_transit_egress_info() const;
  public:
  void clear_transit_egress_info();
  const ::valhalla::TransitEgressInfo& transit_egress_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitEgressInfo* release_transit_egress_info();
  ::valhalla::TransitEgressInfo* mutable_transit_egress_info();
  void set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info);
  private:
  const ::valhalla::TransitEgressInfo& _internal_transit_egress_info() const;
  ::valhalla::TransitEgressInfo* _internal_mutable_transit_egress_info();
  public:
  void unsafe_arena_set_allocated_transit_egress_info(
      ::valhalla::TransitEgressInfo* transit_egress_info);
  ::valhalla::TransitEgressInfo* unsafe_arena_release_transit_egress_info();

  // .valhalla.TripLeg.PathCost cost = 12;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  const ::valhalla::TripLeg_PathCost& cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_PathCost* release_cost();
  ::valhalla::TripLeg_PathCost* mutable_cost();
  void set_allocated_cost(::valhalla::TripLeg_PathCost* cost);
  private:
  const ::valhalla::TripLeg_PathCost& _internal_cost() const;
  ::valhalla::TripLeg_PathCost* _internal_mutable_cost();
  public:
  void unsafe_arena_set_allocated_cost(
      ::valhalla::TripLeg_PathCost* cost);
  ::valhalla::TripLeg_PathCost* unsafe_arena_release_cost();

  // .valhalla.BikeShareStationInfo bss_info = 14;
  bool has_bss_info() const;
  private:
  bool _internal_has_bss_info() const;
  public:
  void clear_bss_info();
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  PROTOBUF_NODISCARD ::valhalla::BikeShareStationInfo* release_bss_info();
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info);
  private:
  const ::valhalla::BikeShareStationInfo& _internal_bss_info() const;
  ::valhalla::BikeShareStationInfo* _internal_mutable_bss_info();
  public:
  void unsafe_arena_set_allocated_bss_info(
      ::valhalla::BikeShareStationInfo* bss_info);
  ::valhalla::BikeShareStationInfo* unsafe_arena_release_bss_info();

  // uint32 admin_index = 3;
  bool has_admin_index() const;
  private:
  bool _internal_has_admin_index() const;
  public:
  void clear_admin_index();
  uint32_t admin_index() const;
  void set_admin_index(uint32_t value);
  private:
  uint32_t _internal_admin_index() const;
  void _internal_set_admin_index(uint32_t value);
  public:

  // .valhalla.TripLeg.Node.Type type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::TripLeg_Node_Type type() const;
  void set_type(::valhalla::TripLeg_Node_Type value);
  private:
  ::valhalla::TripLeg_Node_Type _internal_type() const;
  void _internal_set_type(::valhalla::TripLeg_Node_Type value);
  public:

  // bool fork = 5;
  bool has_fork() const;
  private:
  bool _internal_has_fork() const;
  public:
  void clear_fork();
  bool fork() const;
  void set_fork(bool value);
  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);
  public:

  // string time_zone = 11;
  bool has_time_zone() const;
  private:
  bool _internal_has_time_zone() const;
  public:
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  void clear_has_admin_index();
  HasAdminIndexCase has_admin_index_case() const;
  void clear_has_type();
  HasTypeCase has_type_case() const;
  void clear_has_fork();
  HasForkCase has_fork_case() const;
  void clear_has_time_zone();
  HasTimeZoneCase has_time_zone_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Node)
 private:
  class _Internal;
  void set_has_admin_index();
  void set_has_type();
  void set_has_fork();
  void set_has_time_zone();

  inline bool has_has_admin_index() const;
  inline void clear_has_has_admin_index();

  inline bool has_has_type() const;
  inline void clear_has_has_type();

  inline bool has_has_fork() const;
  inline void clear_has_has_fork();

  inline bool has_has_time_zone() const;
  inline void clear_has_has_time_zone();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge > intersecting_edge_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost > recosts_;
    ::valhalla::TripLeg_Edge* edge_;
    ::valhalla::TransitPlatformInfo* transit_platform_info_;
    ::valhalla::TransitStationInfo* transit_station_info_;
    ::valhalla::TransitEgressInfo* transit_egress_info_;
    ::valhalla::TripLeg_PathCost* cost_;
    ::valhalla::BikeShareStationInfo* bss_info_;
    union HasAdminIndexUnion {
      constexpr HasAdminIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t admin_index_;
    } has_admin_index_;
    union HasTypeUnion {
      constexpr HasTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int type_;
    } has_type_;
    union HasForkUnion {
      constexpr HasForkUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool fork_;
    } has_fork_;
    union HasTimeZoneUnion {
      constexpr HasTimeZoneUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    } has_time_zone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[4];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Admin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Admin) */ {
 public:
  inline TripLeg_Admin() : TripLeg_Admin(nullptr) {}
  ~TripLeg_Admin() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Admin(const TripLeg_Admin& from);
  TripLeg_Admin(TripLeg_Admin&& from) noexcept
    : TripLeg_Admin() {
    *this = ::std::move(from);
  }

  inline TripLeg_Admin& operator=(const TripLeg_Admin& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Admin& operator=(TripLeg_Admin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Admin& default_instance() {
    return *internal_default_instance();
  }
  enum HasCountryCodeCase {
    kCountryCode = 1,
    HAS_COUNTRY_CODE_NOT_SET = 0,
  };

  enum HasCountryTextCase {
    kCountryText = 2,
    HAS_COUNTRY_TEXT_NOT_SET = 0,
  };

  enum HasStateCodeCase {
    kStateCode = 3,
    HAS_STATE_CODE_NOT_SET = 0,
  };

  enum HasStateTextCase {
    kStateText = 4,
    HAS_STATE_TEXT_NOT_SET = 0,
  };

  static inline const TripLeg_Admin* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Admin*>(
               &_TripLeg_Admin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TripLeg_Admin& a, TripLeg_Admin& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Admin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Admin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Admin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Admin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Admin& from);
  void MergeFrom(const TripLeg_Admin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Admin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Admin";
  }
  protected:
  explicit TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryCodeFieldNumber = 1,
    kCountryTextFieldNumber = 2,
    kStateCodeFieldNumber = 3,
    kStateTextFieldNumber = 4,
  };
  // string country_code = 1;
  bool has_country_code() const;
  private:
  bool _internal_has_country_code() const;
  public:
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // string country_text = 2;
  bool has_country_text() const;
  private:
  bool _internal_has_country_text() const;
  public:
  void clear_country_text();
  const std::string& country_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_text();
  PROTOBUF_NODISCARD std::string* release_country_text();
  void set_allocated_country_text(std::string* country_text);
  private:
  const std::string& _internal_country_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_text(const std::string& value);
  std::string* _internal_mutable_country_text();
  public:

  // string state_code = 3;
  bool has_state_code() const;
  private:
  bool _internal_has_state_code() const;
  public:
  void clear_state_code();
  const std::string& state_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_code();
  PROTOBUF_NODISCARD std::string* release_state_code();
  void set_allocated_state_code(std::string* state_code);
  private:
  const std::string& _internal_state_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_code(const std::string& value);
  std::string* _internal_mutable_state_code();
  public:

  // string state_text = 4;
  bool has_state_text() const;
  private:
  bool _internal_has_state_text() const;
  public:
  void clear_state_text();
  const std::string& state_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_text();
  PROTOBUF_NODISCARD std::string* release_state_text();
  void set_allocated_state_text(std::string* state_text);
  private:
  const std::string& _internal_state_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_text(const std::string& value);
  std::string* _internal_mutable_state_text();
  public:

  void clear_has_country_code();
  HasCountryCodeCase has_country_code_case() const;
  void clear_has_country_text();
  HasCountryTextCase has_country_text_case() const;
  void clear_has_state_code();
  HasStateCodeCase has_state_code_case() const;
  void clear_has_state_text();
  HasStateTextCase has_state_text_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Admin)
 private:
  class _Internal;
  void set_has_country_code();
  void set_has_country_text();
  void set_has_state_code();
  void set_has_state_text();

  inline bool has_has_country_code() const;
  inline void clear_has_has_country_code();

  inline bool has_has_country_text() const;
  inline void clear_has_has_country_text();

  inline bool has_has_state_code() const;
  inline void clear_has_has_state_code();

  inline bool has_has_state_text() const;
  inline void clear_has_has_state_text();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasCountryCodeUnion {
      constexpr HasCountryCodeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    } has_country_code_;
    union HasCountryTextUnion {
      constexpr HasCountryTextUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_text_;
    } has_country_text_;
    union HasStateCodeUnion {
      constexpr HasStateCodeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_code_;
    } has_state_code_;
    union HasStateTextUnion {
      constexpr HasStateTextUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_text_;
    } has_state_text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[4];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_ShapeAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.ShapeAttributes) */ {
 public:
  inline TripLeg_ShapeAttributes() : TripLeg_ShapeAttributes(nullptr) {}
  ~TripLeg_ShapeAttributes() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from);
  TripLeg_ShapeAttributes(TripLeg_ShapeAttributes&& from) noexcept
    : TripLeg_ShapeAttributes() {
    *this = ::std::move(from);
  }

  inline TripLeg_ShapeAttributes& operator=(const TripLeg_ShapeAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_ShapeAttributes& operator=(TripLeg_ShapeAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_ShapeAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_ShapeAttributes* internal_default_instance() {
    return reinterpret_cast<const TripLeg_ShapeAttributes*>(
               &_TripLeg_ShapeAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TripLeg_ShapeAttributes& a, TripLeg_ShapeAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_ShapeAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_ShapeAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_ShapeAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_ShapeAttributes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_ShapeAttributes& from);
  void MergeFrom(const TripLeg_ShapeAttributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_ShapeAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.ShapeAttributes";
  }
  protected:
  explicit TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kLengthFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kSpeedLimitFieldNumber = 5,
  };
  // repeated uint32 time = 1 [packed = true];
  int time_size() const;
  private:
  int _internal_time_size() const;
  public:
  void clear_time();
  private:
  uint32_t _internal_time(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_time() const;
  void _internal_add_time(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_time();
  public:
  uint32_t time(int index) const;
  void set_time(int index, uint32_t value);
  void add_time(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_time();

  // repeated uint32 length = 2 [packed = true];
  int length_size() const;
  private:
  int _internal_length_size() const;
  public:
  void clear_length();
  private:
  uint32_t _internal_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_length() const;
  void _internal_add_length(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_length();
  public:
  uint32_t length(int index) const;
  void set_length(int index, uint32_t value);
  void add_length(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_length();

  // repeated uint32 speed = 3 [packed = true];
  int speed_size() const;
  private:
  int _internal_speed_size() const;
  public:
  void clear_speed();
  private:
  uint32_t _internal_speed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_speed() const;
  void _internal_add_speed(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_speed();
  public:
  uint32_t speed(int index) const;
  void set_speed(int index, uint32_t value);
  void add_speed(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      speed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_speed();

  // repeated uint32 speed_limit = 5 [packed = true];
  int speed_limit_size() const;
  private:
  int _internal_speed_limit_size() const;
  public:
  void clear_speed_limit();
  private:
  uint32_t _internal_speed_limit(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_speed_limit() const;
  void _internal_add_speed_limit(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_speed_limit();
  public:
  uint32_t speed_limit(int index) const;
  void set_speed_limit(int index, uint32_t value);
  void add_speed_limit(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      speed_limit() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_speed_limit();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.ShapeAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > time_;
    mutable std::atomic<int> _time_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > length_;
    mutable std::atomic<int> _length_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > speed_;
    mutable std::atomic<int> _speed_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > speed_limit_;
    mutable std::atomic<int> _speed_limit_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Incident final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Incident) */ {
 public:
  inline TripLeg_Incident() : TripLeg_Incident(nullptr) {}
  ~TripLeg_Incident() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Incident(const TripLeg_Incident& from);
  TripLeg_Incident(TripLeg_Incident&& from) noexcept
    : TripLeg_Incident() {
    *this = ::std::move(from);
  }

  inline TripLeg_Incident& operator=(const TripLeg_Incident& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Incident& operator=(TripLeg_Incident&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Incident& default_instance() {
    return *internal_default_instance();
  }
  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 3,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 4,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  static inline const TripLeg_Incident* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Incident*>(
               &_TripLeg_Incident_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TripLeg_Incident& a, TripLeg_Incident& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Incident* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Incident* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Incident* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Incident>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Incident& from);
  void MergeFrom(const TripLeg_Incident& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Incident* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Incident";
  }
  protected:
  explicit TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kBeginShapeIndexFieldNumber = 3,
    kEndShapeIndexFieldNumber = 4,
  };
  // .valhalla.IncidentsTile.Metadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::valhalla::IncidentsTile_Metadata& metadata() const;
  PROTOBUF_NODISCARD ::valhalla::IncidentsTile_Metadata* release_metadata();
  ::valhalla::IncidentsTile_Metadata* mutable_metadata();
  void set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata);
  private:
  const ::valhalla::IncidentsTile_Metadata& _internal_metadata() const;
  ::valhalla::IncidentsTile_Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::valhalla::IncidentsTile_Metadata* metadata);
  ::valhalla::IncidentsTile_Metadata* unsafe_arena_release_metadata();

  // uint32 begin_shape_index = 3;
  bool has_begin_shape_index() const;
  private:
  bool _internal_has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 4;
  bool has_end_shape_index() const;
  private:
  bool _internal_has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  void clear_has_begin_shape_index();
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  void clear_has_end_shape_index();
  HasEndShapeIndexCase has_end_shape_index_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Incident)
 private:
  class _Internal;
  void set_has_begin_shape_index();
  void set_has_end_shape_index();

  inline bool has_has_begin_shape_index() const;
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  inline void clear_has_has_end_shape_index();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::IncidentsTile_Metadata* metadata_;
    union HasBeginShapeIndexUnion {
      constexpr HasBeginShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t begin_shape_index_;
    } has_begin_shape_index_;
    union HasEndShapeIndexUnion {
      constexpr HasEndShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t end_shape_index_;
    } has_end_shape_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg_Closure final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Closure) */ {
 public:
  inline TripLeg_Closure() : TripLeg_Closure(nullptr) {}
  ~TripLeg_Closure() override;
  explicit PROTOBUF_CONSTEXPR TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg_Closure(const TripLeg_Closure& from);
  TripLeg_Closure(TripLeg_Closure&& from) noexcept
    : TripLeg_Closure() {
    *this = ::std::move(from);
  }

  inline TripLeg_Closure& operator=(const TripLeg_Closure& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Closure& operator=(TripLeg_Closure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg_Closure& default_instance() {
    return *internal_default_instance();
  }
  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 1,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 2,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  static inline const TripLeg_Closure* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Closure*>(
               &_TripLeg_Closure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TripLeg_Closure& a, TripLeg_Closure& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Closure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Closure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Closure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Closure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Closure& from);
  void MergeFrom(const TripLeg_Closure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg_Closure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg.Closure";
  }
  protected:
  explicit TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginShapeIndexFieldNumber = 1,
    kEndShapeIndexFieldNumber = 2,
  };
  // uint32 begin_shape_index = 1;
  bool has_begin_shape_index() const;
  private:
  bool _internal_has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 2;
  bool has_end_shape_index() const;
  private:
  bool _internal_has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  void clear_has_begin_shape_index();
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  void clear_has_end_shape_index();
  HasEndShapeIndexCase has_end_shape_index_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Closure)
 private:
  class _Internal;
  void set_has_begin_shape_index();
  void set_has_end_shape_index();

  inline bool has_has_begin_shape_index() const;
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  inline void clear_has_has_end_shape_index();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union HasBeginShapeIndexUnion {
      constexpr HasBeginShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t begin_shape_index_;
    } has_begin_shape_index_;
    union HasEndShapeIndexUnion {
      constexpr HasEndShapeIndexUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t end_shape_index_;
    } has_end_shape_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripLeg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg) */ {
 public:
  inline TripLeg() : TripLeg(nullptr) {}
  ~TripLeg() override;
  explicit PROTOBUF_CONSTEXPR TripLeg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripLeg(const TripLeg& from);
  TripLeg(TripLeg&& from) noexcept
    : TripLeg() {
    *this = ::std::move(from);
  }

  inline TripLeg& operator=(const TripLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg& operator=(TripLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripLeg& default_instance() {
    return *internal_default_instance();
  }
  enum HasOsmChangesetCase {
    kOsmChangeset = 1,
    HAS_OSM_CHANGESET_NOT_SET = 0,
  };

  enum HasTripIdCase {
    kTripId = 2,
    HAS_TRIP_ID_NOT_SET = 0,
  };

  enum HasLegIdCase {
    kLegId = 3,
    HAS_LEG_ID_NOT_SET = 0,
  };

  enum HasLegCountCase {
    kLegCount = 4,
    HAS_LEG_COUNT_NOT_SET = 0,
  };

  enum HasShapeCase {
    kShape = 8,
    HAS_SHAPE_NOT_SET = 0,
  };

  static inline const TripLeg* internal_default_instance() {
    return reinterpret_cast<const TripLeg*>(
               &_TripLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TripLeg& a, TripLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripLeg& from);
  void MergeFrom(const TripLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripLeg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripLeg";
  }
  protected:
  explicit TripLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TripLeg_LaneConnectivity LaneConnectivity;
  typedef TripLeg_TrafficSegment TrafficSegment;
  typedef TripLeg_Restriction Restriction;
  typedef TripLeg_Edge Edge;
  typedef TripLeg_IntersectingEdge IntersectingEdge;
  typedef TripLeg_Cost Cost;
  typedef TripLeg_PathCost PathCost;
  typedef TripLeg_Node Node;
  typedef TripLeg_Admin Admin;
  typedef TripLeg_ShapeAttributes ShapeAttributes;
  typedef TripLeg_Incident Incident;
  typedef TripLeg_Closure Closure;

  typedef TripLeg_Traversability Traversability;
  static constexpr Traversability kNone =
    TripLeg_Traversability_kNone;
  static constexpr Traversability kForward =
    TripLeg_Traversability_kForward;
  static constexpr Traversability kBackward =
    TripLeg_Traversability_kBackward;
  static constexpr Traversability kBoth =
    TripLeg_Traversability_kBoth;
  static inline bool Traversability_IsValid(int value) {
    return TripLeg_Traversability_IsValid(value);
  }
  static constexpr Traversability Traversability_MIN =
    TripLeg_Traversability_Traversability_MIN;
  static constexpr Traversability Traversability_MAX =
    TripLeg_Traversability_Traversability_MAX;
  static constexpr int Traversability_ARRAYSIZE =
    TripLeg_Traversability_Traversability_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Traversability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Traversability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Traversability_Name.");
    return TripLeg_Traversability_Name(enum_t_value);
  }
  static inline bool Traversability_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Traversability* value) {
    return TripLeg_Traversability_Parse(name, value);
  }

  typedef TripLeg_Use Use;
  static constexpr Use kRoadUse =
    TripLeg_Use_kRoadUse;
  static constexpr Use kRampUse =
    TripLeg_Use_kRampUse;
  static constexpr Use kTurnChannelUse =
    TripLeg_Use_kTurnChannelUse;
  static constexpr Use kTrackUse =
    TripLeg_Use_kTrackUse;
  static constexpr Use kDrivewayUse =
    TripLeg_Use_kDrivewayUse;
  static constexpr Use kAlleyUse =
    TripLeg_Use_kAlleyUse;
  static constexpr Use kParkingAisleUse =
    TripLeg_Use_kParkingAisleUse;
  static constexpr Use kEmergencyAccessUse =
    TripLeg_Use_kEmergencyAccessUse;
  static constexpr Use kDriveThruUse =
    TripLeg_Use_kDriveThruUse;
  static constexpr Use kCuldesacUse =
    TripLeg_Use_kCuldesacUse;
  static constexpr Use kLivingStreetUse =
    TripLeg_Use_kLivingStreetUse;
  static constexpr Use kServiceRoadUse =
    TripLeg_Use_kServiceRoadUse;
  static constexpr Use kCyclewayUse =
    TripLeg_Use_kCyclewayUse;
  static constexpr Use kMountainBikeUse =
    TripLeg_Use_kMountainBikeUse;
  static constexpr Use kSidewalkUse =
    TripLeg_Use_kSidewalkUse;
  static constexpr Use kFootwayUse =
    TripLeg_Use_kFootwayUse;
  static constexpr Use kStepsUse =
    TripLeg_Use_kStepsUse;
  static constexpr Use kPathUse =
    TripLeg_Use_kPathUse;
  static constexpr Use kPedestrianUse =
    TripLeg_Use_kPedestrianUse;
  static constexpr Use kBridlewayUse =
    TripLeg_Use_kBridlewayUse;
  static constexpr Use kPedestrianCrossingUse =
    TripLeg_Use_kPedestrianCrossingUse;
  static constexpr Use kRestAreaUse =
    TripLeg_Use_kRestAreaUse;
  static constexpr Use kServiceAreaUse =
    TripLeg_Use_kServiceAreaUse;
  static constexpr Use kOtherUse =
    TripLeg_Use_kOtherUse;
  static constexpr Use kFerryUse =
    TripLeg_Use_kFerryUse;
  static constexpr Use kRailFerryUse =
    TripLeg_Use_kRailFerryUse;
  static constexpr Use kRailUse =
    TripLeg_Use_kRailUse;
  static constexpr Use kBusUse =
    TripLeg_Use_kBusUse;
  static constexpr Use kEgressConnectionUse =
    TripLeg_Use_kEgressConnectionUse;
  static constexpr Use kPlatformConnectionUse =
    TripLeg_Use_kPlatformConnectionUse;
  static constexpr Use kTransitConnectionUse =
    TripLeg_Use_kTransitConnectionUse;
  static inline bool Use_IsValid(int value) {
    return TripLeg_Use_IsValid(value);
  }
  static constexpr Use Use_MIN =
    TripLeg_Use_Use_MIN;
  static constexpr Use Use_MAX =
    TripLeg_Use_Use_MAX;
  static constexpr int Use_ARRAYSIZE =
    TripLeg_Use_Use_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Use_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Use>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Use_Name.");
    return TripLeg_Use_Name(enum_t_value);
  }
  static inline bool Use_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Use* value) {
    return TripLeg_Use_Parse(name, value);
  }

  typedef TripLeg_Surface Surface;
  static constexpr Surface kPavedSmooth =
    TripLeg_Surface_kPavedSmooth;
  static constexpr Surface kPaved =
    TripLeg_Surface_kPaved;
  static constexpr Surface kPavedRough =
    TripLeg_Surface_kPavedRough;
  static constexpr Surface kCompacted =
    TripLeg_Surface_kCompacted;
  static constexpr Surface kDirt =
    TripLeg_Surface_kDirt;
  static constexpr Surface kGravel =
    TripLeg_Surface_kGravel;
  static constexpr Surface kPath =
    TripLeg_Surface_kPath;
  static constexpr Surface kImpassable =
    TripLeg_Surface_kImpassable;
  static inline bool Surface_IsValid(int value) {
    return TripLeg_Surface_IsValid(value);
  }
  static constexpr Surface Surface_MIN =
    TripLeg_Surface_Surface_MIN;
  static constexpr Surface Surface_MAX =
    TripLeg_Surface_Surface_MAX;
  static constexpr int Surface_ARRAYSIZE =
    TripLeg_Surface_Surface_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Surface_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Surface>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Surface_Name.");
    return TripLeg_Surface_Name(enum_t_value);
  }
  static inline bool Surface_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Surface* value) {
    return TripLeg_Surface_Parse(name, value);
  }

  typedef TripLeg_CycleLane CycleLane;
  static constexpr CycleLane kNoCycleLane =
    TripLeg_CycleLane_kNoCycleLane;
  static constexpr CycleLane kShared =
    TripLeg_CycleLane_kShared;
  static constexpr CycleLane kDedicated =
    TripLeg_CycleLane_kDedicated;
  static constexpr CycleLane kSeparated =
    TripLeg_CycleLane_kSeparated;
  static inline bool CycleLane_IsValid(int value) {
    return TripLeg_CycleLane_IsValid(value);
  }
  static constexpr CycleLane CycleLane_MIN =
    TripLeg_CycleLane_CycleLane_MIN;
  static constexpr CycleLane CycleLane_MAX =
    TripLeg_CycleLane_CycleLane_MAX;
  static constexpr int CycleLane_ARRAYSIZE =
    TripLeg_CycleLane_CycleLane_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CycleLane_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CycleLane>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CycleLane_Name.");
    return TripLeg_CycleLane_Name(enum_t_value);
  }
  static inline bool CycleLane_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CycleLane* value) {
    return TripLeg_CycleLane_Parse(name, value);
  }

  typedef TripLeg_SacScale SacScale;
  static constexpr SacScale kNoSacScale =
    TripLeg_SacScale_kNoSacScale;
  static constexpr SacScale kHiking =
    TripLeg_SacScale_kHiking;
  static constexpr SacScale kMountainHiking =
    TripLeg_SacScale_kMountainHiking;
  static constexpr SacScale kDemandingMountainHiking =
    TripLeg_SacScale_kDemandingMountainHiking;
  static constexpr SacScale kAlpineHiking =
    TripLeg_SacScale_kAlpineHiking;
  static constexpr SacScale kDemandingAlpineHiking =
    TripLeg_SacScale_kDemandingAlpineHiking;
  static constexpr SacScale kDifficultAlpineHiking =
    TripLeg_SacScale_kDifficultAlpineHiking;
  static inline bool SacScale_IsValid(int value) {
    return TripLeg_SacScale_IsValid(value);
  }
  static constexpr SacScale SacScale_MIN =
    TripLeg_SacScale_SacScale_MIN;
  static constexpr SacScale SacScale_MAX =
    TripLeg_SacScale_SacScale_MAX;
  static constexpr int SacScale_ARRAYSIZE =
    TripLeg_SacScale_SacScale_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SacScale_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SacScale>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SacScale_Name.");
    return TripLeg_SacScale_Name(enum_t_value);
  }
  static inline bool SacScale_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SacScale* value) {
    return TripLeg_SacScale_Parse(name, value);
  }

  typedef TripLeg_Sidewalk Sidewalk;
  static constexpr Sidewalk kNoSidewalk =
    TripLeg_Sidewalk_kNoSidewalk;
  static constexpr Sidewalk kLeft =
    TripLeg_Sidewalk_kLeft;
  static constexpr Sidewalk kRight =
    TripLeg_Sidewalk_kRight;
  static constexpr Sidewalk kBothSides =
    TripLeg_Sidewalk_kBothSides;
  static inline bool Sidewalk_IsValid(int value) {
    return TripLeg_Sidewalk_IsValid(value);
  }
  static constexpr Sidewalk Sidewalk_MIN =
    TripLeg_Sidewalk_Sidewalk_MIN;
  static constexpr Sidewalk Sidewalk_MAX =
    TripLeg_Sidewalk_Sidewalk_MAX;
  static constexpr int Sidewalk_ARRAYSIZE =
    TripLeg_Sidewalk_Sidewalk_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Sidewalk_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Sidewalk>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Sidewalk_Name.");
    return TripLeg_Sidewalk_Name(enum_t_value);
  }
  static inline bool Sidewalk_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Sidewalk* value) {
    return TripLeg_Sidewalk_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 5,
    kNodeFieldNumber = 6,
    kAdminFieldNumber = 7,
    kIncidentsFieldNumber = 11,
    kAlgorithmsFieldNumber = 12,
    kClosuresFieldNumber = 13,
    kBboxFieldNumber = 9,
    kShapeAttributesFieldNumber = 10,
    kOsmChangesetFieldNumber = 1,
    kTripIdFieldNumber = 2,
    kLegIdFieldNumber = 3,
    kLegCountFieldNumber = 4,
    kShapeFieldNumber = 8,
  };
  // repeated .valhalla.Location location = 5;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::valhalla::Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::valhalla::Location& _internal_location(int index) const;
  ::valhalla::Location* _internal_add_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // repeated .valhalla.TripLeg.Node node = 6;
  int node_size() const;
  private:
  int _internal_node_size() const;
  public:
  void clear_node();
  ::valhalla::TripLeg_Node* mutable_node(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >*
      mutable_node();
  private:
  const ::valhalla::TripLeg_Node& _internal_node(int index) const;
  ::valhalla::TripLeg_Node* _internal_add_node();
  public:
  const ::valhalla::TripLeg_Node& node(int index) const;
  ::valhalla::TripLeg_Node* add_node();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >&
      node() const;

  // repeated .valhalla.TripLeg.Admin admin = 7;
  int admin_size() const;
  private:
  int _internal_admin_size() const;
  public:
  void clear_admin();
  ::valhalla::TripLeg_Admin* mutable_admin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
      mutable_admin();
  private:
  const ::valhalla::TripLeg_Admin& _internal_admin(int index) const;
  ::valhalla::TripLeg_Admin* _internal_add_admin();
  public:
  const ::valhalla::TripLeg_Admin& admin(int index) const;
  ::valhalla::TripLeg_Admin* add_admin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
      admin() const;

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  int incidents_size() const;
  private:
  int _internal_incidents_size() const;
  public:
  void clear_incidents();
  ::valhalla::TripLeg_Incident* mutable_incidents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
      mutable_incidents();
  private:
  const ::valhalla::TripLeg_Incident& _internal_incidents(int index) const;
  ::valhalla::TripLeg_Incident* _internal_add_incidents();
  public:
  const ::valhalla::TripLeg_Incident& incidents(int index) const;
  ::valhalla::TripLeg_Incident* add_incidents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
      incidents() const;

  // repeated string algorithms = 12;
  int algorithms_size() const;
  private:
  int _internal_algorithms_size() const;
  public:
  void clear_algorithms();
  const std::string& algorithms(int index) const;
  std::string* mutable_algorithms(int index);
  void set_algorithms(int index, const std::string& value);
  void set_algorithms(int index, std::string&& value);
  void set_algorithms(int index, const char* value);
  void set_algorithms(int index, const char* value, size_t size);
  std::string* add_algorithms();
  void add_algorithms(const std::string& value);
  void add_algorithms(std::string&& value);
  void add_algorithms(const char* value);
  void add_algorithms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& algorithms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_algorithms();
  private:
  const std::string& _internal_algorithms(int index) const;
  std::string* _internal_add_algorithms();
  public:

  // repeated .valhalla.TripLeg.Closure closures = 13;
  int closures_size() const;
  private:
  int _internal_closures_size() const;
  public:
  void clear_closures();
  ::valhalla::TripLeg_Closure* mutable_closures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
      mutable_closures();
  private:
  const ::valhalla::TripLeg_Closure& _internal_closures(int index) const;
  ::valhalla::TripLeg_Closure* _internal_add_closures();
  public:
  const ::valhalla::TripLeg_Closure& closures(int index) const;
  ::valhalla::TripLeg_Closure* add_closures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
      closures() const;

  // .valhalla.BoundingBox bbox = 9;
  bool has_bbox() const;
  private:
  bool _internal_has_bbox() const;
  public:
  void clear_bbox();
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_NODISCARD ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);
  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();
  public:
  void unsafe_arena_set_allocated_bbox(
      ::valhalla::BoundingBox* bbox);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  bool has_shape_attributes() const;
  private:
  bool _internal_has_shape_attributes() const;
  public:
  void clear_shape_attributes();
  const ::valhalla::TripLeg_ShapeAttributes& shape_attributes() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_ShapeAttributes* release_shape_attributes();
  ::valhalla::TripLeg_ShapeAttributes* mutable_shape_attributes();
  void set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes);
  private:
  const ::valhalla::TripLeg_ShapeAttributes& _internal_shape_attributes() const;
  ::valhalla::TripLeg_ShapeAttributes* _internal_mutable_shape_attributes();
  public:
  void unsafe_arena_set_allocated_shape_attributes(
      ::valhalla::TripLeg_ShapeAttributes* shape_attributes);
  ::valhalla::TripLeg_ShapeAttributes* unsafe_arena_release_shape_attributes();

  // uint64 osm_changeset = 1;
  bool has_osm_changeset() const;
  private:
  bool _internal_has_osm_changeset() const;
  public:
  void clear_osm_changeset();
  uint64_t osm_changeset() const;
  void set_osm_changeset(uint64_t value);
  private:
  uint64_t _internal_osm_changeset() const;
  void _internal_set_osm_changeset(uint64_t value);
  public:

  // uint64 trip_id = 2;
  bool has_trip_id() const;
  private:
  bool _internal_has_trip_id() const;
  public:
  void clear_trip_id();
  uint64_t trip_id() const;
  void set_trip_id(uint64_t value);
  private:
  uint64_t _internal_trip_id() const;
  void _internal_set_trip_id(uint64_t value);
  public:

  // uint32 leg_id = 3;
  bool has_leg_id() const;
  private:
  bool _internal_has_leg_id() const;
  public:
  void clear_leg_id();
  uint32_t leg_id() const;
  void set_leg_id(uint32_t value);
  private:
  uint32_t _internal_leg_id() const;
  void _internal_set_leg_id(uint32_t value);
  public:

  // uint32 leg_count = 4;
  bool has_leg_count() const;
  private:
  bool _internal_has_leg_count() const;
  public:
  void clear_leg_count();
  uint32_t leg_count() const;
  void set_leg_count(uint32_t value);
  private:
  uint32_t _internal_leg_count() const;
  void _internal_set_leg_count(uint32_t value);
  public:

  // string shape = 8;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const std::string& shape() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* shape);
  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(const std::string& value);
  std::string* _internal_mutable_shape();
  public:

  void clear_has_osm_changeset();
  HasOsmChangesetCase has_osm_changeset_case() const;
  void clear_has_trip_id();
  HasTripIdCase has_trip_id_case() const;
  void clear_has_leg_id();
  HasLegIdCase has_leg_id_case() const;
  void clear_has_leg_count();
  HasLegCountCase has_leg_count_case() const;
  void clear_has_shape();
  HasShapeCase has_shape_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg)
 private:
  class _Internal;
  void set_has_osm_changeset();
  void set_has_trip_id();
  void set_has_leg_id();
  void set_has_leg_count();
  void set_has_shape();

  inline bool has_has_osm_changeset() const;
  inline void clear_has_has_osm_changeset();

  inline bool has_has_trip_id() const;
  inline void clear_has_has_trip_id();

  inline bool has_has_leg_id() const;
  inline void clear_has_has_leg_id();

  inline bool has_has_leg_count() const;
  inline void clear_has_has_leg_count();

  inline bool has_has_shape() const;
  inline void clear_has_has_shape();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > location_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node > node_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin > admin_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident > incidents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> algorithms_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure > closures_;
    ::valhalla::BoundingBox* bbox_;
    ::valhalla::TripLeg_ShapeAttributes* shape_attributes_;
    union HasOsmChangesetUnion {
      constexpr HasOsmChangesetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t osm_changeset_;
    } has_osm_changeset_;
    union HasTripIdUnion {
      constexpr HasTripIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t trip_id_;
    } has_trip_id_;
    union HasLegIdUnion {
      constexpr HasLegIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t leg_id_;
    } has_leg_id_;
    union HasLegCountUnion {
      constexpr HasLegCountUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t leg_count_;
    } has_leg_count_;
    union HasShapeUnion {
      constexpr HasShapeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_;
    } has_shape_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[5];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class TripRoute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripRoute) */ {
 public:
  inline TripRoute() : TripRoute(nullptr) {}
  ~TripRoute() override;
  explicit PROTOBUF_CONSTEXPR TripRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripRoute(const TripRoute& from);
  TripRoute(TripRoute&& from) noexcept
    : TripRoute() {
    *this = ::std::move(from);
  }

  inline TripRoute& operator=(const TripRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripRoute& operator=(TripRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TripRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripRoute* internal_default_instance() {
    return reinterpret_cast<const TripRoute*>(
               &_TripRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TripRoute& a, TripRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(TripRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TripRoute& from);
  void MergeFrom(const TripRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TripRoute";
  }
  protected:
  explicit TripRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.TripLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;
  public:
  void clear_legs();
  ::valhalla::TripLeg* mutable_legs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >*
      mutable_legs();
  private:
  const ::valhalla::TripLeg& _internal_legs(int index) const;
  ::valhalla::TripLeg* _internal_add_legs();
  public:
  const ::valhalla::TripLeg& legs(int index) const;
  ::valhalla::TripLeg* add_legs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.TripRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg > legs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// -------------------------------------------------------------------

class Trip final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Trip) */ {
 public:
  inline Trip() : Trip(nullptr) {}
  ~Trip() override;
  explicit PROTOBUF_CONSTEXPR Trip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trip(const Trip& from);
  Trip(Trip&& from) noexcept
    : Trip() {
    *this = ::std::move(from);
  }

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trip& operator=(Trip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Trip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trip* internal_default_instance() {
    return reinterpret_cast<const Trip*>(
               &_Trip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Trip& a, Trip& b) {
    a.Swap(&b);
  }
  inline void Swap(Trip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trip>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Trip& from);
  void MergeFrom(const Trip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Trip";
  }
  protected:
  explicit Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.TripRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::valhalla::TripRoute* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >*
      mutable_routes();
  private:
  const ::valhalla::TripRoute& _internal_routes(int index) const;
  ::valhalla::TripRoute* _internal_add_routes();
  public:
  const ::valhalla::TripRoute& routes(int index) const;
  ::valhalla::TripRoute* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Trip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute > routes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TripLeg_LaneConnectivity

// uint64 from_way_id = 1;
inline bool TripLeg_LaneConnectivity::_internal_has_from_way_id() const {
  return has_from_way_id_case() == kFromWayId;
}
inline bool TripLeg_LaneConnectivity::has_from_way_id() const {
  return _internal_has_from_way_id();
}
inline void TripLeg_LaneConnectivity::set_has_from_way_id() {
  _impl_._oneof_case_[0] = kFromWayId;
}
inline void TripLeg_LaneConnectivity::clear_from_way_id() {
  if (_internal_has_from_way_id()) {
    _impl_.has_from_way_id_.from_way_id_ = uint64_t{0u};
    clear_has_has_from_way_id();
  }
}
inline uint64_t TripLeg_LaneConnectivity::_internal_from_way_id() const {
  if (_internal_has_from_way_id()) {
    return _impl_.has_from_way_id_.from_way_id_;
  }
  return uint64_t{0u};
}
inline void TripLeg_LaneConnectivity::_internal_set_from_way_id(uint64_t value) {
  if (!_internal_has_from_way_id()) {
    clear_has_from_way_id();
    set_has_from_way_id();
  }
  _impl_.has_from_way_id_.from_way_id_ = value;
}
inline uint64_t TripLeg_LaneConnectivity::from_way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_way_id)
  return _internal_from_way_id();
}
inline void TripLeg_LaneConnectivity::set_from_way_id(uint64_t value) {
  _internal_set_from_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_way_id)
}

// string from_lanes = 2;
inline bool TripLeg_LaneConnectivity::_internal_has_from_lanes() const {
  return has_from_lanes_case() == kFromLanes;
}
inline bool TripLeg_LaneConnectivity::has_from_lanes() const {
  return _internal_has_from_lanes();
}
inline void TripLeg_LaneConnectivity::set_has_from_lanes() {
  _impl_._oneof_case_[1] = kFromLanes;
}
inline void TripLeg_LaneConnectivity::clear_from_lanes() {
  if (_internal_has_from_lanes()) {
    _impl_.has_from_lanes_.from_lanes_.Destroy();
    clear_has_has_from_lanes();
  }
}
inline const std::string& TripLeg_LaneConnectivity::from_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _internal_from_lanes();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_LaneConnectivity::set_from_lanes(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    _impl_.has_from_lanes_.from_lanes_.InitDefault();
  }
  _impl_.has_from_lanes_.from_lanes_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
inline std::string* TripLeg_LaneConnectivity::mutable_from_lanes() {
  std::string* _s = _internal_mutable_from_lanes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _s;
}
inline const std::string& TripLeg_LaneConnectivity::_internal_from_lanes() const {
  if (_internal_has_from_lanes()) {
    return _impl_.has_from_lanes_.from_lanes_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_LaneConnectivity::_internal_set_from_lanes(const std::string& value) {
  if (!_internal_has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    _impl_.has_from_lanes_.from_lanes_.InitDefault();
  }
  _impl_.has_from_lanes_.from_lanes_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::_internal_mutable_from_lanes() {
  if (!_internal_has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    _impl_.has_from_lanes_.from_lanes_.InitDefault();
  }
  return _impl_.has_from_lanes_.from_lanes_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::release_from_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (_internal_has_from_lanes()) {
    clear_has_has_from_lanes();
    return _impl_.has_from_lanes_.from_lanes_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_LaneConnectivity::set_allocated_from_lanes(std::string* from_lanes) {
  if (has_has_from_lanes()) {
    clear_has_from_lanes();
  }
  if (from_lanes != nullptr) {
    set_has_from_lanes();
    _impl_.has_from_lanes_.from_lanes_.InitAllocated(from_lanes, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.from_lanes)
}

// string to_lanes = 3;
inline bool TripLeg_LaneConnectivity::_internal_has_to_lanes() const {
  return has_to_lanes_case() == kToLanes;
}
inline bool TripLeg_LaneConnectivity::has_to_lanes() const {
  return _internal_has_to_lanes();
}
inline void TripLeg_LaneConnectivity::set_has_to_lanes() {
  _impl_._oneof_case_[2] = kToLanes;
}
inline void TripLeg_LaneConnectivity::clear_to_lanes() {
  if (_internal_has_to_lanes()) {
    _impl_.has_to_lanes_.to_lanes_.Destroy();
    clear_has_has_to_lanes();
  }
}
inline const std::string& TripLeg_LaneConnectivity::to_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _internal_to_lanes();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_LaneConnectivity::set_to_lanes(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    _impl_.has_to_lanes_.to_lanes_.InitDefault();
  }
  _impl_.has_to_lanes_.to_lanes_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
inline std::string* TripLeg_LaneConnectivity::mutable_to_lanes() {
  std::string* _s = _internal_mutable_to_lanes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _s;
}
inline const std::string& TripLeg_LaneConnectivity::_internal_to_lanes() const {
  if (_internal_has_to_lanes()) {
    return _impl_.has_to_lanes_.to_lanes_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_LaneConnectivity::_internal_set_to_lanes(const std::string& value) {
  if (!_internal_has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    _impl_.has_to_lanes_.to_lanes_.InitDefault();
  }
  _impl_.has_to_lanes_.to_lanes_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::_internal_mutable_to_lanes() {
  if (!_internal_has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    _impl_.has_to_lanes_.to_lanes_.InitDefault();
  }
  return _impl_.has_to_lanes_.to_lanes_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_LaneConnectivity::release_to_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (_internal_has_to_lanes()) {
    clear_has_has_to_lanes();
    return _impl_.has_to_lanes_.to_lanes_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_LaneConnectivity::set_allocated_to_lanes(std::string* to_lanes) {
  if (has_has_to_lanes()) {
    clear_has_to_lanes();
  }
  if (to_lanes != nullptr) {
    set_has_to_lanes();
    _impl_.has_to_lanes_.to_lanes_.InitAllocated(to_lanes, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.to_lanes)
}

inline bool TripLeg_LaneConnectivity::has_has_from_way_id() const {
  return has_from_way_id_case() != HAS_FROM_WAY_ID_NOT_SET;
}
inline void TripLeg_LaneConnectivity::clear_has_has_from_way_id() {
  _impl_._oneof_case_[0] = HAS_FROM_WAY_ID_NOT_SET;
}
inline bool TripLeg_LaneConnectivity::has_has_from_lanes() const {
  return has_from_lanes_case() != HAS_FROM_LANES_NOT_SET;
}
inline void TripLeg_LaneConnectivity::clear_has_has_from_lanes() {
  _impl_._oneof_case_[1] = HAS_FROM_LANES_NOT_SET;
}
inline bool TripLeg_LaneConnectivity::has_has_to_lanes() const {
  return has_to_lanes_case() != HAS_TO_LANES_NOT_SET;
}
inline void TripLeg_LaneConnectivity::clear_has_has_to_lanes() {
  _impl_._oneof_case_[2] = HAS_TO_LANES_NOT_SET;
}
inline TripLeg_LaneConnectivity::HasFromWayIdCase TripLeg_LaneConnectivity::has_from_way_id_case() const {
  return TripLeg_LaneConnectivity::HasFromWayIdCase(_impl_._oneof_case_[0]);
}
inline TripLeg_LaneConnectivity::HasFromLanesCase TripLeg_LaneConnectivity::has_from_lanes_case() const {
  return TripLeg_LaneConnectivity::HasFromLanesCase(_impl_._oneof_case_[1]);
}
inline TripLeg_LaneConnectivity::HasToLanesCase TripLeg_LaneConnectivity::has_to_lanes_case() const {
  return TripLeg_LaneConnectivity::HasToLanesCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// TripLeg_TrafficSegment

// uint64 segment_id = 1;
inline bool TripLeg_TrafficSegment::_internal_has_segment_id() const {
  return has_segment_id_case() == kSegmentId;
}
inline bool TripLeg_TrafficSegment::has_segment_id() const {
  return _internal_has_segment_id();
}
inline void TripLeg_TrafficSegment::set_has_segment_id() {
  _impl_._oneof_case_[0] = kSegmentId;
}
inline void TripLeg_TrafficSegment::clear_segment_id() {
  if (_internal_has_segment_id()) {
    _impl_.has_segment_id_.segment_id_ = uint64_t{0u};
    clear_has_has_segment_id();
  }
}
inline uint64_t TripLeg_TrafficSegment::_internal_segment_id() const {
  if (_internal_has_segment_id()) {
    return _impl_.has_segment_id_.segment_id_;
  }
  return uint64_t{0u};
}
inline void TripLeg_TrafficSegment::_internal_set_segment_id(uint64_t value) {
  if (!_internal_has_segment_id()) {
    clear_has_segment_id();
    set_has_segment_id();
  }
  _impl_.has_segment_id_.segment_id_ = value;
}
inline uint64_t TripLeg_TrafficSegment::segment_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.segment_id)
  return _internal_segment_id();
}
inline void TripLeg_TrafficSegment::set_segment_id(uint64_t value) {
  _internal_set_segment_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.segment_id)
}

// float begin_percent = 2;
inline bool TripLeg_TrafficSegment::_internal_has_begin_percent() const {
  return has_begin_percent_case() == kBeginPercent;
}
inline bool TripLeg_TrafficSegment::has_begin_percent() const {
  return _internal_has_begin_percent();
}
inline void TripLeg_TrafficSegment::set_has_begin_percent() {
  _impl_._oneof_case_[1] = kBeginPercent;
}
inline void TripLeg_TrafficSegment::clear_begin_percent() {
  if (_internal_has_begin_percent()) {
    _impl_.has_begin_percent_.begin_percent_ = 0;
    clear_has_has_begin_percent();
  }
}
inline float TripLeg_TrafficSegment::_internal_begin_percent() const {
  if (_internal_has_begin_percent()) {
    return _impl_.has_begin_percent_.begin_percent_;
  }
  return 0;
}
inline void TripLeg_TrafficSegment::_internal_set_begin_percent(float value) {
  if (!_internal_has_begin_percent()) {
    clear_has_begin_percent();
    set_has_begin_percent();
  }
  _impl_.has_begin_percent_.begin_percent_ = value;
}
inline float TripLeg_TrafficSegment::begin_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.begin_percent)
  return _internal_begin_percent();
}
inline void TripLeg_TrafficSegment::set_begin_percent(float value) {
  _internal_set_begin_percent(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.begin_percent)
}

// float end_percent = 3;
inline bool TripLeg_TrafficSegment::_internal_has_end_percent() const {
  return has_end_percent_case() == kEndPercent;
}
inline bool TripLeg_TrafficSegment::has_end_percent() const {
  return _internal_has_end_percent();
}
inline void TripLeg_TrafficSegment::set_has_end_percent() {
  _impl_._oneof_case_[2] = kEndPercent;
}
inline void TripLeg_TrafficSegment::clear_end_percent() {
  if (_internal_has_end_percent()) {
    _impl_.has_end_percent_.end_percent_ = 0;
    clear_has_has_end_percent();
  }
}
inline float TripLeg_TrafficSegment::_internal_end_percent() const {
  if (_internal_has_end_percent()) {
    return _impl_.has_end_percent_.end_percent_;
  }
  return 0;
}
inline void TripLeg_TrafficSegment::_internal_set_end_percent(float value) {
  if (!_internal_has_end_percent()) {
    clear_has_end_percent();
    set_has_end_percent();
  }
  _impl_.has_end_percent_.end_percent_ = value;
}
inline float TripLeg_TrafficSegment::end_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.end_percent)
  return _internal_end_percent();
}
inline void TripLeg_TrafficSegment::set_end_percent(float value) {
  _internal_set_end_percent(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.end_percent)
}

// bool starts_segment = 4;
inline bool TripLeg_TrafficSegment::_internal_has_starts_segment() const {
  return has_starts_segment_case() == kStartsSegment;
}
inline bool TripLeg_TrafficSegment::has_starts_segment() const {
  return _internal_has_starts_segment();
}
inline void TripLeg_TrafficSegment::set_has_starts_segment() {
  _impl_._oneof_case_[3] = kStartsSegment;
}
inline void TripLeg_TrafficSegment::clear_starts_segment() {
  if (_internal_has_starts_segment()) {
    _impl_.has_starts_segment_.starts_segment_ = false;
    clear_has_has_starts_segment();
  }
}
inline bool TripLeg_TrafficSegment::_internal_starts_segment() const {
  if (_internal_has_starts_segment()) {
    return _impl_.has_starts_segment_.starts_segment_;
  }
  return false;
}
inline void TripLeg_TrafficSegment::_internal_set_starts_segment(bool value) {
  if (!_internal_has_starts_segment()) {
    clear_has_starts_segment();
    set_has_starts_segment();
  }
  _impl_.has_starts_segment_.starts_segment_ = value;
}
inline bool TripLeg_TrafficSegment::starts_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.starts_segment)
  return _internal_starts_segment();
}
inline void TripLeg_TrafficSegment::set_starts_segment(bool value) {
  _internal_set_starts_segment(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.starts_segment)
}

// bool ends_segment = 5;
inline bool TripLeg_TrafficSegment::_internal_has_ends_segment() const {
  return has_ends_segment_case() == kEndsSegment;
}
inline bool TripLeg_TrafficSegment::has_ends_segment() const {
  return _internal_has_ends_segment();
}
inline void TripLeg_TrafficSegment::set_has_ends_segment() {
  _impl_._oneof_case_[4] = kEndsSegment;
}
inline void TripLeg_TrafficSegment::clear_ends_segment() {
  if (_internal_has_ends_segment()) {
    _impl_.has_ends_segment_.ends_segment_ = false;
    clear_has_has_ends_segment();
  }
}
inline bool TripLeg_TrafficSegment::_internal_ends_segment() const {
  if (_internal_has_ends_segment()) {
    return _impl_.has_ends_segment_.ends_segment_;
  }
  return false;
}
inline void TripLeg_TrafficSegment::_internal_set_ends_segment(bool value) {
  if (!_internal_has_ends_segment()) {
    clear_has_ends_segment();
    set_has_ends_segment();
  }
  _impl_.has_ends_segment_.ends_segment_ = value;
}
inline bool TripLeg_TrafficSegment::ends_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.ends_segment)
  return _internal_ends_segment();
}
inline void TripLeg_TrafficSegment::set_ends_segment(bool value) {
  _internal_set_ends_segment(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.ends_segment)
}

inline bool TripLeg_TrafficSegment::has_has_segment_id() const {
  return has_segment_id_case() != HAS_SEGMENT_ID_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_segment_id() {
  _impl_._oneof_case_[0] = HAS_SEGMENT_ID_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_begin_percent() const {
  return has_begin_percent_case() != HAS_BEGIN_PERCENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_begin_percent() {
  _impl_._oneof_case_[1] = HAS_BEGIN_PERCENT_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_end_percent() const {
  return has_end_percent_case() != HAS_END_PERCENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_end_percent() {
  _impl_._oneof_case_[2] = HAS_END_PERCENT_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_starts_segment() const {
  return has_starts_segment_case() != HAS_STARTS_SEGMENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_starts_segment() {
  _impl_._oneof_case_[3] = HAS_STARTS_SEGMENT_NOT_SET;
}
inline bool TripLeg_TrafficSegment::has_has_ends_segment() const {
  return has_ends_segment_case() != HAS_ENDS_SEGMENT_NOT_SET;
}
inline void TripLeg_TrafficSegment::clear_has_has_ends_segment() {
  _impl_._oneof_case_[4] = HAS_ENDS_SEGMENT_NOT_SET;
}
inline TripLeg_TrafficSegment::HasSegmentIdCase TripLeg_TrafficSegment::has_segment_id_case() const {
  return TripLeg_TrafficSegment::HasSegmentIdCase(_impl_._oneof_case_[0]);
}
inline TripLeg_TrafficSegment::HasBeginPercentCase TripLeg_TrafficSegment::has_begin_percent_case() const {
  return TripLeg_TrafficSegment::HasBeginPercentCase(_impl_._oneof_case_[1]);
}
inline TripLeg_TrafficSegment::HasEndPercentCase TripLeg_TrafficSegment::has_end_percent_case() const {
  return TripLeg_TrafficSegment::HasEndPercentCase(_impl_._oneof_case_[2]);
}
inline TripLeg_TrafficSegment::HasStartsSegmentCase TripLeg_TrafficSegment::has_starts_segment_case() const {
  return TripLeg_TrafficSegment::HasStartsSegmentCase(_impl_._oneof_case_[3]);
}
inline TripLeg_TrafficSegment::HasEndsSegmentCase TripLeg_TrafficSegment::has_ends_segment_case() const {
  return TripLeg_TrafficSegment::HasEndsSegmentCase(_impl_._oneof_case_[4]);
}
// -------------------------------------------------------------------

// TripLeg_Restriction

// uint32 type = 1;
inline bool TripLeg_Restriction::_internal_has_type() const {
  return has_type_case() == kType;
}
inline bool TripLeg_Restriction::has_type() const {
  return _internal_has_type();
}
inline void TripLeg_Restriction::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline void TripLeg_Restriction::clear_type() {
  if (_internal_has_type()) {
    _impl_.has_type_.type_ = 0u;
    clear_has_has_type();
  }
}
inline uint32_t TripLeg_Restriction::_internal_type() const {
  if (_internal_has_type()) {
    return _impl_.has_type_.type_;
  }
  return 0u;
}
inline void TripLeg_Restriction::_internal_set_type(uint32_t value) {
  if (!_internal_has_type()) {
    clear_has_type();
    set_has_type();
  }
  _impl_.has_type_.type_ = value;
}
inline uint32_t TripLeg_Restriction::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Restriction.type)
  return _internal_type();
}
inline void TripLeg_Restriction::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Restriction.type)
}

inline bool TripLeg_Restriction::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void TripLeg_Restriction::clear_has_has_type() {
  _impl_._oneof_case_[0] = HAS_TYPE_NOT_SET;
}
inline TripLeg_Restriction::HasTypeCase TripLeg_Restriction::has_type_case() const {
  return TripLeg_Restriction::HasTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TripLeg_Edge

// repeated .valhalla.StreetName name = 1;
inline int TripLeg_Edge::_internal_name_size() const {
  return _impl_.name_.size();
}
inline int TripLeg_Edge::name_size() const {
  return _internal_name_size();
}
inline ::valhalla::StreetName* TripLeg_Edge::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.name)
  return _impl_.name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
TripLeg_Edge::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.name)
  return &_impl_.name_;
}
inline const ::valhalla::StreetName& TripLeg_Edge::_internal_name(int index) const {
  return _impl_.name_.Get(index);
}
inline const ::valhalla::StreetName& TripLeg_Edge::name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.name)
  return _internal_name(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::_internal_add_name() {
  return _impl_.name_.Add();
}
inline ::valhalla::StreetName* TripLeg_Edge::add_name() {
  ::valhalla::StreetName* _add = _internal_add_name();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
TripLeg_Edge::name() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.name)
  return _impl_.name_;
}

// float length_km = 2;
inline bool TripLeg_Edge::_internal_has_length_km() const {
  return has_length_km_case() == kLengthKm;
}
inline bool TripLeg_Edge::has_length_km() const {
  return _internal_has_length_km();
}
inline void TripLeg_Edge::set_has_length_km() {
  _impl_._oneof_case_[0] = kLengthKm;
}
inline void TripLeg_Edge::clear_length_km() {
  if (_internal_has_length_km()) {
    _impl_.has_length_km_.length_km_ = 0;
    clear_has_has_length_km();
  }
}
inline float TripLeg_Edge::_internal_length_km() const {
  if (_internal_has_length_km()) {
    return _impl_.has_length_km_.length_km_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_length_km(float value) {
  if (!_internal_has_length_km()) {
    clear_has_length_km();
    set_has_length_km();
  }
  _impl_.has_length_km_.length_km_ = value;
}
inline float TripLeg_Edge::length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.length_km)
  return _internal_length_km();
}
inline void TripLeg_Edge::set_length_km(float value) {
  _internal_set_length_km(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.length_km)
}

// float speed = 3;
inline bool TripLeg_Edge::_internal_has_speed() const {
  return has_speed_case() == kSpeed;
}
inline bool TripLeg_Edge::has_speed() const {
  return _internal_has_speed();
}
inline void TripLeg_Edge::set_has_speed() {
  _impl_._oneof_case_[1] = kSpeed;
}
inline void TripLeg_Edge::clear_speed() {
  if (_internal_has_speed()) {
    _impl_.has_speed_.speed_ = 0;
    clear_has_has_speed();
  }
}
inline float TripLeg_Edge::_internal_speed() const {
  if (_internal_has_speed()) {
    return _impl_.has_speed_.speed_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_speed(float value) {
  if (!_internal_has_speed()) {
    clear_has_speed();
    set_has_speed();
  }
  _impl_.has_speed_.speed_ = value;
}
inline float TripLeg_Edge::speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed)
  return _internal_speed();
}
inline void TripLeg_Edge::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed)
}

// .valhalla.RoadClass road_class = 4;
inline bool TripLeg_Edge::_internal_has_road_class() const {
  return has_road_class_case() == kRoadClass;
}
inline bool TripLeg_Edge::has_road_class() const {
  return _internal_has_road_class();
}
inline void TripLeg_Edge::set_has_road_class() {
  _impl_._oneof_case_[2] = kRoadClass;
}
inline void TripLeg_Edge::clear_road_class() {
  if (_internal_has_road_class()) {
    _impl_.has_road_class_.road_class_ = 0;
    clear_has_has_road_class();
  }
}
inline ::valhalla::RoadClass TripLeg_Edge::_internal_road_class() const {
  if (_internal_has_road_class()) {
    return static_cast< ::valhalla::RoadClass >(_impl_.has_road_class_.road_class_);
  }
  return static_cast< ::valhalla::RoadClass >(0);
}
inline ::valhalla::RoadClass TripLeg_Edge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.road_class)
  return _internal_road_class();
}
inline void TripLeg_Edge::_internal_set_road_class(::valhalla::RoadClass value) {
  if (!_internal_has_road_class()) {
    clear_has_road_class();
    set_has_road_class();
  }
  _impl_.has_road_class_.road_class_ = value;
}
inline void TripLeg_Edge::set_road_class(::valhalla::RoadClass value) {
  _internal_set_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.road_class)
}

// uint32 begin_heading = 5;
inline bool TripLeg_Edge::_internal_has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
inline bool TripLeg_Edge::has_begin_heading() const {
  return _internal_has_begin_heading();
}
inline void TripLeg_Edge::set_has_begin_heading() {
  _impl_._oneof_case_[3] = kBeginHeading;
}
inline void TripLeg_Edge::clear_begin_heading() {
  if (_internal_has_begin_heading()) {
    _impl_.has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
inline uint32_t TripLeg_Edge::_internal_begin_heading() const {
  if (_internal_has_begin_heading()) {
    return _impl_.has_begin_heading_.begin_heading_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_begin_heading(uint32_t value) {
  if (!_internal_has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  _impl_.has_begin_heading_.begin_heading_ = value;
}
inline uint32_t TripLeg_Edge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_heading)
  return _internal_begin_heading();
}
inline void TripLeg_Edge::set_begin_heading(uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_heading)
}

// uint32 end_heading = 6;
inline bool TripLeg_Edge::_internal_has_end_heading() const {
  return has_end_heading_case() == kEndHeading;
}
inline bool TripLeg_Edge::has_end_heading() const {
  return _internal_has_end_heading();
}
inline void TripLeg_Edge::set_has_end_heading() {
  _impl_._oneof_case_[4] = kEndHeading;
}
inline void TripLeg_Edge::clear_end_heading() {
  if (_internal_has_end_heading()) {
    _impl_.has_end_heading_.end_heading_ = 0u;
    clear_has_has_end_heading();
  }
}
inline uint32_t TripLeg_Edge::_internal_end_heading() const {
  if (_internal_has_end_heading()) {
    return _impl_.has_end_heading_.end_heading_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_end_heading(uint32_t value) {
  if (!_internal_has_end_heading()) {
    clear_has_end_heading();
    set_has_end_heading();
  }
  _impl_.has_end_heading_.end_heading_ = value;
}
inline uint32_t TripLeg_Edge::end_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_heading)
  return _internal_end_heading();
}
inline void TripLeg_Edge::set_end_heading(uint32_t value) {
  _internal_set_end_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_heading)
}

// uint32 begin_shape_index = 7;
inline bool TripLeg_Edge::_internal_has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline bool TripLeg_Edge::has_begin_shape_index() const {
  return _internal_has_begin_shape_index();
}
inline void TripLeg_Edge::set_has_begin_shape_index() {
  _impl_._oneof_case_[5] = kBeginShapeIndex;
}
inline void TripLeg_Edge::clear_begin_shape_index() {
  if (_internal_has_begin_shape_index()) {
    _impl_.has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline uint32_t TripLeg_Edge::_internal_begin_shape_index() const {
  if (_internal_has_begin_shape_index()) {
    return _impl_.has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_begin_shape_index(uint32_t value) {
  if (!_internal_has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  _impl_.has_begin_shape_index_.begin_shape_index_ = value;
}
inline uint32_t TripLeg_Edge::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Edge::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_shape_index)
}

// uint32 end_shape_index = 8;
inline bool TripLeg_Edge::_internal_has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline bool TripLeg_Edge::has_end_shape_index() const {
  return _internal_has_end_shape_index();
}
inline void TripLeg_Edge::set_has_end_shape_index() {
  _impl_._oneof_case_[6] = kEndShapeIndex;
}
inline void TripLeg_Edge::clear_end_shape_index() {
  if (_internal_has_end_shape_index()) {
    _impl_.has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline uint32_t TripLeg_Edge::_internal_end_shape_index() const {
  if (_internal_has_end_shape_index()) {
    return _impl_.has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_end_shape_index(uint32_t value) {
  if (!_internal_has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  _impl_.has_end_shape_index_.end_shape_index_ = value;
}
inline uint32_t TripLeg_Edge::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Edge::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_shape_index)
}

// .valhalla.TripLeg.Traversability traversability = 9;
inline bool TripLeg_Edge::_internal_has_traversability() const {
  return has_traversability_case() == kTraversability;
}
inline bool TripLeg_Edge::has_traversability() const {
  return _internal_has_traversability();
}
inline void TripLeg_Edge::set_has_traversability() {
  _impl_._oneof_case_[7] = kTraversability;
}
inline void TripLeg_Edge::clear_traversability() {
  if (_internal_has_traversability()) {
    _impl_.has_traversability_.traversability_ = 0;
    clear_has_has_traversability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::_internal_traversability() const {
  if (_internal_has_traversability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.has_traversability_.traversability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::traversability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traversability)
  return _internal_traversability();
}
inline void TripLeg_Edge::_internal_set_traversability(::valhalla::TripLeg_Traversability value) {
  if (!_internal_has_traversability()) {
    clear_has_traversability();
    set_has_traversability();
  }
  _impl_.has_traversability_.traversability_ = value;
}
inline void TripLeg_Edge::set_traversability(::valhalla::TripLeg_Traversability value) {
  _internal_set_traversability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.traversability)
}

// .valhalla.TripLeg.Use use = 10;
inline bool TripLeg_Edge::_internal_has_use() const {
  return has_use_case() == kUse;
}
inline bool TripLeg_Edge::has_use() const {
  return _internal_has_use();
}
inline void TripLeg_Edge::set_has_use() {
  _impl_._oneof_case_[8] = kUse;
}
inline void TripLeg_Edge::clear_use() {
  if (_internal_has_use()) {
    _impl_.has_use_.use_ = 0;
    clear_has_has_use();
  }
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::_internal_use() const {
  if (_internal_has_use()) {
    return static_cast< ::valhalla::TripLeg_Use >(_impl_.has_use_.use_);
  }
  return static_cast< ::valhalla::TripLeg_Use >(0);
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.use)
  return _internal_use();
}
inline void TripLeg_Edge::_internal_set_use(::valhalla::TripLeg_Use value) {
  if (!_internal_has_use()) {
    clear_has_use();
    set_has_use();
  }
  _impl_.has_use_.use_ = value;
}
inline void TripLeg_Edge::set_use(::valhalla::TripLeg_Use value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.use)
}

// bool toll = 11;
inline bool TripLeg_Edge::_internal_has_toll() const {
  return has_toll_case() == kToll;
}
inline bool TripLeg_Edge::has_toll() const {
  return _internal_has_toll();
}
inline void TripLeg_Edge::set_has_toll() {
  _impl_._oneof_case_[9] = kToll;
}
inline void TripLeg_Edge::clear_toll() {
  if (_internal_has_toll()) {
    _impl_.has_toll_.toll_ = false;
    clear_has_has_toll();
  }
}
inline bool TripLeg_Edge::_internal_toll() const {
  if (_internal_has_toll()) {
    return _impl_.has_toll_.toll_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_toll(bool value) {
  if (!_internal_has_toll()) {
    clear_has_toll();
    set_has_toll();
  }
  _impl_.has_toll_.toll_ = value;
}
inline bool TripLeg_Edge::toll() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.toll)
  return _internal_toll();
}
inline void TripLeg_Edge::set_toll(bool value) {
  _internal_set_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.toll)
}

// bool unpaved = 12;
inline bool TripLeg_Edge::_internal_has_unpaved() const {
  return has_unpaved_case() == kUnpaved;
}
inline bool TripLeg_Edge::has_unpaved() const {
  return _internal_has_unpaved();
}
inline void TripLeg_Edge::set_has_unpaved() {
  _impl_._oneof_case_[10] = kUnpaved;
}
inline void TripLeg_Edge::clear_unpaved() {
  if (_internal_has_unpaved()) {
    _impl_.has_unpaved_.unpaved_ = false;
    clear_has_has_unpaved();
  }
}
inline bool TripLeg_Edge::_internal_unpaved() const {
  if (_internal_has_unpaved()) {
    return _impl_.has_unpaved_.unpaved_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_unpaved(bool value) {
  if (!_internal_has_unpaved()) {
    clear_has_unpaved();
    set_has_unpaved();
  }
  _impl_.has_unpaved_.unpaved_ = value;
}
inline bool TripLeg_Edge::unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.unpaved)
  return _internal_unpaved();
}
inline void TripLeg_Edge::set_unpaved(bool value) {
  _internal_set_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.unpaved)
}

// bool tunnel = 13;
inline bool TripLeg_Edge::_internal_has_tunnel() const {
  return has_tunnel_case() == kTunnel;
}
inline bool TripLeg_Edge::has_tunnel() const {
  return _internal_has_tunnel();
}
inline void TripLeg_Edge::set_has_tunnel() {
  _impl_._oneof_case_[11] = kTunnel;
}
inline void TripLeg_Edge::clear_tunnel() {
  if (_internal_has_tunnel()) {
    _impl_.has_tunnel_.tunnel_ = false;
    clear_has_has_tunnel();
  }
}
inline bool TripLeg_Edge::_internal_tunnel() const {
  if (_internal_has_tunnel()) {
    return _impl_.has_tunnel_.tunnel_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_tunnel(bool value) {
  if (!_internal_has_tunnel()) {
    clear_has_tunnel();
    set_has_tunnel();
  }
  _impl_.has_tunnel_.tunnel_ = value;
}
inline bool TripLeg_Edge::tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tunnel)
  return _internal_tunnel();
}
inline void TripLeg_Edge::set_tunnel(bool value) {
  _internal_set_tunnel(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.tunnel)
}

// bool bridge = 14;
inline bool TripLeg_Edge::_internal_has_bridge() const {
  return has_bridge_case() == kBridge;
}
inline bool TripLeg_Edge::has_bridge() const {
  return _internal_has_bridge();
}
inline void TripLeg_Edge::set_has_bridge() {
  _impl_._oneof_case_[12] = kBridge;
}
inline void TripLeg_Edge::clear_bridge() {
  if (_internal_has_bridge()) {
    _impl_.has_bridge_.bridge_ = false;
    clear_has_has_bridge();
  }
}
inline bool TripLeg_Edge::_internal_bridge() const {
  if (_internal_has_bridge()) {
    return _impl_.has_bridge_.bridge_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_bridge(bool value) {
  if (!_internal_has_bridge()) {
    clear_has_bridge();
    set_has_bridge();
  }
  _impl_.has_bridge_.bridge_ = value;
}
inline bool TripLeg_Edge::bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bridge)
  return _internal_bridge();
}
inline void TripLeg_Edge::set_bridge(bool value) {
  _internal_set_bridge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bridge)
}

// bool roundabout = 15;
inline bool TripLeg_Edge::_internal_has_roundabout() const {
  return has_roundabout_case() == kRoundabout;
}
inline bool TripLeg_Edge::has_roundabout() const {
  return _internal_has_roundabout();
}
inline void TripLeg_Edge::set_has_roundabout() {
  _impl_._oneof_case_[13] = kRoundabout;
}
inline void TripLeg_Edge::clear_roundabout() {
  if (_internal_has_roundabout()) {
    _impl_.has_roundabout_.roundabout_ = false;
    clear_has_has_roundabout();
  }
}
inline bool TripLeg_Edge::_internal_roundabout() const {
  if (_internal_has_roundabout()) {
    return _impl_.has_roundabout_.roundabout_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_roundabout(bool value) {
  if (!_internal_has_roundabout()) {
    clear_has_roundabout();
    set_has_roundabout();
  }
  _impl_.has_roundabout_.roundabout_ = value;
}
inline bool TripLeg_Edge::roundabout() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.roundabout)
  return _internal_roundabout();
}
inline void TripLeg_Edge::set_roundabout(bool value) {
  _internal_set_roundabout(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.roundabout)
}

// bool internal_intersection = 16;
inline bool TripLeg_Edge::_internal_has_internal_intersection() const {
  return has_internal_intersection_case() == kInternalIntersection;
}
inline bool TripLeg_Edge::has_internal_intersection() const {
  return _internal_has_internal_intersection();
}
inline void TripLeg_Edge::set_has_internal_intersection() {
  _impl_._oneof_case_[14] = kInternalIntersection;
}
inline void TripLeg_Edge::clear_internal_intersection() {
  if (_internal_has_internal_intersection()) {
    _impl_.has_internal_intersection_.internal_intersection_ = false;
    clear_has_has_internal_intersection();
  }
}
inline bool TripLeg_Edge::_internal_internal_intersection() const {
  if (_internal_has_internal_intersection()) {
    return _impl_.has_internal_intersection_.internal_intersection_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_internal_intersection(bool value) {
  if (!_internal_has_internal_intersection()) {
    clear_has_internal_intersection();
    set_has_internal_intersection();
  }
  _impl_.has_internal_intersection_.internal_intersection_ = value;
}
inline bool TripLeg_Edge::internal_intersection() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.internal_intersection)
  return _internal_internal_intersection();
}
inline void TripLeg_Edge::set_internal_intersection(bool value) {
  _internal_set_internal_intersection(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.internal_intersection)
}

// bool drive_on_left = 17;
inline bool TripLeg_Edge::_internal_has_drive_on_left() const {
  return has_drive_on_left_case() == kDriveOnLeft;
}
inline bool TripLeg_Edge::has_drive_on_left() const {
  return _internal_has_drive_on_left();
}
inline void TripLeg_Edge::set_has_drive_on_left() {
  _impl_._oneof_case_[15] = kDriveOnLeft;
}
inline void TripLeg_Edge::clear_drive_on_left() {
  if (_internal_has_drive_on_left()) {
    _impl_.has_drive_on_left_.drive_on_left_ = false;
    clear_has_has_drive_on_left();
  }
}
inline bool TripLeg_Edge::_internal_drive_on_left() const {
  if (_internal_has_drive_on_left()) {
    return _impl_.has_drive_on_left_.drive_on_left_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_drive_on_left(bool value) {
  if (!_internal_has_drive_on_left()) {
    clear_has_drive_on_left();
    set_has_drive_on_left();
  }
  _impl_.has_drive_on_left_.drive_on_left_ = value;
}
inline bool TripLeg_Edge::drive_on_left() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.drive_on_left)
  return _internal_drive_on_left();
}
inline void TripLeg_Edge::set_drive_on_left(bool value) {
  _internal_set_drive_on_left(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.drive_on_left)
}

// .valhalla.TripLeg.Surface surface = 18;
inline bool TripLeg_Edge::_internal_has_surface() const {
  return has_surface_case() == kSurface;
}
inline bool TripLeg_Edge::has_surface() const {
  return _internal_has_surface();
}
inline void TripLeg_Edge::set_has_surface() {
  _impl_._oneof_case_[16] = kSurface;
}
inline void TripLeg_Edge::clear_surface() {
  if (_internal_has_surface()) {
    _impl_.has_surface_.surface_ = 0;
    clear_has_has_surface();
  }
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::_internal_surface() const {
  if (_internal_has_surface()) {
    return static_cast< ::valhalla::TripLeg_Surface >(_impl_.has_surface_.surface_);
  }
  return static_cast< ::valhalla::TripLeg_Surface >(0);
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::surface() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.surface)
  return _internal_surface();
}
inline void TripLeg_Edge::_internal_set_surface(::valhalla::TripLeg_Surface value) {
  if (!_internal_has_surface()) {
    clear_has_surface();
    set_has_surface();
  }
  _impl_.has_surface_.surface_ = value;
}
inline void TripLeg_Edge::set_surface(::valhalla::TripLeg_Surface value) {
  _internal_set_surface(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.surface)
}

// .valhalla.TripSign sign = 19;
inline bool TripLeg_Edge::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool TripLeg_Edge::has_sign() const {
  return _internal_has_sign();
}
inline const ::valhalla::TripSign& TripLeg_Edge::_internal_sign() const {
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(
      ::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& TripLeg_Edge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sign)
  return _internal_sign();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_sign(
    ::valhalla::TripSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.sign)
}
inline ::valhalla::TripSign* TripLeg_Edge::release_sign() {
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripSign* TripLeg_Edge::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.sign)
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* TripLeg_Edge::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* TripLeg_Edge::mutable_sign() {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.sign)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_sign(::valhalla::TripSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.sign)
}

// .valhalla.TravelMode travel_mode = 20;
inline bool TripLeg_Edge::_internal_has_travel_mode() const {
  return has_travel_mode_case() == kTravelMode;
}
inline bool TripLeg_Edge::has_travel_mode() const {
  return _internal_has_travel_mode();
}
inline void TripLeg_Edge::set_has_travel_mode() {
  _impl_._oneof_case_[17] = kTravelMode;
}
inline void TripLeg_Edge::clear_travel_mode() {
  if (_internal_has_travel_mode()) {
    _impl_.has_travel_mode_.travel_mode_ = 0;
    clear_has_has_travel_mode();
  }
}
inline ::valhalla::TravelMode TripLeg_Edge::_internal_travel_mode() const {
  if (_internal_has_travel_mode()) {
    return static_cast< ::valhalla::TravelMode >(_impl_.has_travel_mode_.travel_mode_);
  }
  return static_cast< ::valhalla::TravelMode >(0);
}
inline ::valhalla::TravelMode TripLeg_Edge::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.travel_mode)
  return _internal_travel_mode();
}
inline void TripLeg_Edge::_internal_set_travel_mode(::valhalla::TravelMode value) {
  if (!_internal_has_travel_mode()) {
    clear_has_travel_mode();
    set_has_travel_mode();
  }
  _impl_.has_travel_mode_.travel_mode_ = value;
}
inline void TripLeg_Edge::set_travel_mode(::valhalla::TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.travel_mode)
}

// .valhalla.VehicleType vehicle_type = 21;
inline bool TripLeg_Edge::_internal_has_vehicle_type() const {
  return has_vehicle_type_case() == kVehicleType;
}
inline bool TripLeg_Edge::has_vehicle_type() const {
  return _internal_has_vehicle_type();
}
inline void TripLeg_Edge::set_has_vehicle_type() {
  _impl_._oneof_case_[18] = kVehicleType;
}
inline void TripLeg_Edge::clear_vehicle_type() {
  if (_internal_has_vehicle_type()) {
    _impl_.has_vehicle_type_.vehicle_type_ = 0;
    clear_has_has_vehicle_type();
  }
}
inline ::valhalla::VehicleType TripLeg_Edge::_internal_vehicle_type() const {
  if (_internal_has_vehicle_type()) {
    return static_cast< ::valhalla::VehicleType >(_impl_.has_vehicle_type_.vehicle_type_);
  }
  return static_cast< ::valhalla::VehicleType >(0);
}
inline ::valhalla::VehicleType TripLeg_Edge::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.vehicle_type)
  return _internal_vehicle_type();
}
inline void TripLeg_Edge::_internal_set_vehicle_type(::valhalla::VehicleType value) {
  if (!_internal_has_vehicle_type()) {
    clear_has_vehicle_type();
    set_has_vehicle_type();
  }
  _impl_.has_vehicle_type_.vehicle_type_ = value;
}
inline void TripLeg_Edge::set_vehicle_type(::valhalla::VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.vehicle_type)
}

// .valhalla.PedestrianType pedestrian_type = 22;
inline bool TripLeg_Edge::_internal_has_pedestrian_type() const {
  return has_pedestrian_type_case() == kPedestrianType;
}
inline bool TripLeg_Edge::has_pedestrian_type() const {
  return _internal_has_pedestrian_type();
}
inline void TripLeg_Edge::set_has_pedestrian_type() {
  _impl_._oneof_case_[19] = kPedestrianType;
}
inline void TripLeg_Edge::clear_pedestrian_type() {
  if (_internal_has_pedestrian_type()) {
    _impl_.has_pedestrian_type_.pedestrian_type_ = 0;
    clear_has_has_pedestrian_type();
  }
}
inline ::valhalla::PedestrianType TripLeg_Edge::_internal_pedestrian_type() const {
  if (_internal_has_pedestrian_type()) {
    return static_cast< ::valhalla::PedestrianType >(_impl_.has_pedestrian_type_.pedestrian_type_);
  }
  return static_cast< ::valhalla::PedestrianType >(0);
}
inline ::valhalla::PedestrianType TripLeg_Edge::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void TripLeg_Edge::_internal_set_pedestrian_type(::valhalla::PedestrianType value) {
  if (!_internal_has_pedestrian_type()) {
    clear_has_pedestrian_type();
    set_has_pedestrian_type();
  }
  _impl_.has_pedestrian_type_.pedestrian_type_ = value;
}
inline void TripLeg_Edge::set_pedestrian_type(::valhalla::PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.pedestrian_type)
}

// .valhalla.BicycleType bicycle_type = 23;
inline bool TripLeg_Edge::_internal_has_bicycle_type() const {
  return has_bicycle_type_case() == kBicycleType;
}
inline bool TripLeg_Edge::has_bicycle_type() const {
  return _internal_has_bicycle_type();
}
inline void TripLeg_Edge::set_has_bicycle_type() {
  _impl_._oneof_case_[20] = kBicycleType;
}
inline void TripLeg_Edge::clear_bicycle_type() {
  if (_internal_has_bicycle_type()) {
    _impl_.has_bicycle_type_.bicycle_type_ = 0;
    clear_has_has_bicycle_type();
  }
}
inline ::valhalla::BicycleType TripLeg_Edge::_internal_bicycle_type() const {
  if (_internal_has_bicycle_type()) {
    return static_cast< ::valhalla::BicycleType >(_impl_.has_bicycle_type_.bicycle_type_);
  }
  return static_cast< ::valhalla::BicycleType >(0);
}
inline ::valhalla::BicycleType TripLeg_Edge::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_type)
  return _internal_bicycle_type();
}
inline void TripLeg_Edge::_internal_set_bicycle_type(::valhalla::BicycleType value) {
  if (!_internal_has_bicycle_type()) {
    clear_has_bicycle_type();
    set_has_bicycle_type();
  }
  _impl_.has_bicycle_type_.bicycle_type_ = value;
}
inline void TripLeg_Edge::set_bicycle_type(::valhalla::BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_type)
}

// .valhalla.TransitType transit_type = 24;
inline bool TripLeg_Edge::_internal_has_transit_type() const {
  return has_transit_type_case() == kTransitType;
}
inline bool TripLeg_Edge::has_transit_type() const {
  return _internal_has_transit_type();
}
inline void TripLeg_Edge::set_has_transit_type() {
  _impl_._oneof_case_[21] = kTransitType;
}
inline void TripLeg_Edge::clear_transit_type() {
  if (_internal_has_transit_type()) {
    _impl_.has_transit_type_.transit_type_ = 0;
    clear_has_has_transit_type();
  }
}
inline ::valhalla::TransitType TripLeg_Edge::_internal_transit_type() const {
  if (_internal_has_transit_type()) {
    return static_cast< ::valhalla::TransitType >(_impl_.has_transit_type_.transit_type_);
  }
  return static_cast< ::valhalla::TransitType >(0);
}
inline ::valhalla::TransitType TripLeg_Edge::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_type)
  return _internal_transit_type();
}
inline void TripLeg_Edge::_internal_set_transit_type(::valhalla::TransitType value) {
  if (!_internal_has_transit_type()) {
    clear_has_transit_type();
    set_has_transit_type();
  }
  _impl_.has_transit_type_.transit_type_ = value;
}
inline void TripLeg_Edge::set_transit_type(::valhalla::TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.transit_type)
}

// .valhalla.TransitRouteInfo transit_route_info = 25;
inline bool TripLeg_Edge::_internal_has_transit_route_info() const {
  return this != internal_default_instance() && _impl_.transit_route_info_ != nullptr;
}
inline bool TripLeg_Edge::has_transit_route_info() const {
  return _internal_has_transit_route_info();
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::_internal_transit_route_info() const {
  const ::valhalla::TransitRouteInfo* p = _impl_.transit_route_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitRouteInfo&>(
      ::valhalla::_TransitRouteInfo_default_instance_);
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::transit_route_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_route_info)
  return _internal_transit_route_info();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_transit_route_info(
    ::valhalla::TransitRouteInfo* transit_route_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_route_info_);
  }
  _impl_.transit_route_info_ = transit_route_info;
  if (transit_route_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::release_transit_route_info() {
  
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_route_info_;
  _impl_.transit_route_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::unsafe_arena_release_transit_route_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.transit_route_info)
  
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_route_info_;
  _impl_.transit_route_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::_internal_mutable_transit_route_info() {
  
  if (_impl_.transit_route_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitRouteInfo>(GetArenaForAllocation());
    _impl_.transit_route_info_ = p;
  }
  return _impl_.transit_route_info_;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::mutable_transit_route_info() {
  ::valhalla::TransitRouteInfo* _msg = _internal_mutable_transit_route_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.transit_route_info)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_route_info_);
  }
  if (transit_route_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_route_info));
    if (message_arena != submessage_arena) {
      transit_route_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_route_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_route_info_ = transit_route_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}

// uint64 id = 26;
inline bool TripLeg_Edge::_internal_has_id() const {
  return has_id_case() == kId;
}
inline bool TripLeg_Edge::has_id() const {
  return _internal_has_id();
}
inline void TripLeg_Edge::set_has_id() {
  _impl_._oneof_case_[22] = kId;
}
inline void TripLeg_Edge::clear_id() {
  if (_internal_has_id()) {
    _impl_.has_id_.id_ = uint64_t{0u};
    clear_has_has_id();
  }
}
inline uint64_t TripLeg_Edge::_internal_id() const {
  if (_internal_has_id()) {
    return _impl_.has_id_.id_;
  }
  return uint64_t{0u};
}
inline void TripLeg_Edge::_internal_set_id(uint64_t value) {
  if (!_internal_has_id()) {
    clear_has_id();
    set_has_id();
  }
  _impl_.has_id_.id_ = value;
}
inline uint64_t TripLeg_Edge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.id)
  return _internal_id();
}
inline void TripLeg_Edge::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.id)
}

// uint64 way_id = 27;
inline bool TripLeg_Edge::_internal_has_way_id() const {
  return has_way_id_case() == kWayId;
}
inline bool TripLeg_Edge::has_way_id() const {
  return _internal_has_way_id();
}
inline void TripLeg_Edge::set_has_way_id() {
  _impl_._oneof_case_[23] = kWayId;
}
inline void TripLeg_Edge::clear_way_id() {
  if (_internal_has_way_id()) {
    _impl_.has_way_id_.way_id_ = uint64_t{0u};
    clear_has_has_way_id();
  }
}
inline uint64_t TripLeg_Edge::_internal_way_id() const {
  if (_internal_has_way_id()) {
    return _impl_.has_way_id_.way_id_;
  }
  return uint64_t{0u};
}
inline void TripLeg_Edge::_internal_set_way_id(uint64_t value) {
  if (!_internal_has_way_id()) {
    clear_has_way_id();
    set_has_way_id();
  }
  _impl_.has_way_id_.way_id_ = value;
}
inline uint64_t TripLeg_Edge::way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.way_id)
  return _internal_way_id();
}
inline void TripLeg_Edge::set_way_id(uint64_t value) {
  _internal_set_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.way_id)
}

// float weighted_grade = 28;
inline bool TripLeg_Edge::_internal_has_weighted_grade() const {
  return has_weighted_grade_case() == kWeightedGrade;
}
inline bool TripLeg_Edge::has_weighted_grade() const {
  return _internal_has_weighted_grade();
}
inline void TripLeg_Edge::set_has_weighted_grade() {
  _impl_._oneof_case_[24] = kWeightedGrade;
}
inline void TripLeg_Edge::clear_weighted_grade() {
  if (_internal_has_weighted_grade()) {
    _impl_.has_weighted_grade_.weighted_grade_ = 0;
    clear_has_has_weighted_grade();
  }
}
inline float TripLeg_Edge::_internal_weighted_grade() const {
  if (_internal_has_weighted_grade()) {
    return _impl_.has_weighted_grade_.weighted_grade_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_weighted_grade(float value) {
  if (!_internal_has_weighted_grade()) {
    clear_has_weighted_grade();
    set_has_weighted_grade();
  }
  _impl_.has_weighted_grade_.weighted_grade_ = value;
}
inline float TripLeg_Edge::weighted_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.weighted_grade)
  return _internal_weighted_grade();
}
inline void TripLeg_Edge::set_weighted_grade(float value) {
  _internal_set_weighted_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.weighted_grade)
}

// int32 max_upward_grade = 29;
inline bool TripLeg_Edge::_internal_has_max_upward_grade() const {
  return has_max_upward_grade_case() == kMaxUpwardGrade;
}
inline bool TripLeg_Edge::has_max_upward_grade() const {
  return _internal_has_max_upward_grade();
}
inline void TripLeg_Edge::set_has_max_upward_grade() {
  _impl_._oneof_case_[25] = kMaxUpwardGrade;
}
inline void TripLeg_Edge::clear_max_upward_grade() {
  if (_internal_has_max_upward_grade()) {
    _impl_.has_max_upward_grade_.max_upward_grade_ = 0;
    clear_has_has_max_upward_grade();
  }
}
inline int32_t TripLeg_Edge::_internal_max_upward_grade() const {
  if (_internal_has_max_upward_grade()) {
    return _impl_.has_max_upward_grade_.max_upward_grade_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_max_upward_grade(int32_t value) {
  if (!_internal_has_max_upward_grade()) {
    clear_has_max_upward_grade();
    set_has_max_upward_grade();
  }
  _impl_.has_max_upward_grade_.max_upward_grade_ = value;
}
inline int32_t TripLeg_Edge::max_upward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_upward_grade)
  return _internal_max_upward_grade();
}
inline void TripLeg_Edge::set_max_upward_grade(int32_t value) {
  _internal_set_max_upward_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_upward_grade)
}

// int32 max_downward_grade = 30;
inline bool TripLeg_Edge::_internal_has_max_downward_grade() const {
  return has_max_downward_grade_case() == kMaxDownwardGrade;
}
inline bool TripLeg_Edge::has_max_downward_grade() const {
  return _internal_has_max_downward_grade();
}
inline void TripLeg_Edge::set_has_max_downward_grade() {
  _impl_._oneof_case_[26] = kMaxDownwardGrade;
}
inline void TripLeg_Edge::clear_max_downward_grade() {
  if (_internal_has_max_downward_grade()) {
    _impl_.has_max_downward_grade_.max_downward_grade_ = 0;
    clear_has_has_max_downward_grade();
  }
}
inline int32_t TripLeg_Edge::_internal_max_downward_grade() const {
  if (_internal_has_max_downward_grade()) {
    return _impl_.has_max_downward_grade_.max_downward_grade_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_max_downward_grade(int32_t value) {
  if (!_internal_has_max_downward_grade()) {
    clear_has_max_downward_grade();
    set_has_max_downward_grade();
  }
  _impl_.has_max_downward_grade_.max_downward_grade_ = value;
}
inline int32_t TripLeg_Edge::max_downward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_downward_grade)
  return _internal_max_downward_grade();
}
inline void TripLeg_Edge::set_max_downward_grade(int32_t value) {
  _internal_set_max_downward_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_downward_grade)
}

// uint32 lane_count = 31;
inline bool TripLeg_Edge::_internal_has_lane_count() const {
  return has_lane_count_case() == kLaneCount;
}
inline bool TripLeg_Edge::has_lane_count() const {
  return _internal_has_lane_count();
}
inline void TripLeg_Edge::set_has_lane_count() {
  _impl_._oneof_case_[27] = kLaneCount;
}
inline void TripLeg_Edge::clear_lane_count() {
  if (_internal_has_lane_count()) {
    _impl_.has_lane_count_.lane_count_ = 0u;
    clear_has_has_lane_count();
  }
}
inline uint32_t TripLeg_Edge::_internal_lane_count() const {
  if (_internal_has_lane_count()) {
    return _impl_.has_lane_count_.lane_count_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_lane_count(uint32_t value) {
  if (!_internal_has_lane_count()) {
    clear_has_lane_count();
    set_has_lane_count();
  }
  _impl_.has_lane_count_.lane_count_ = value;
}
inline uint32_t TripLeg_Edge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_count)
  return _internal_lane_count();
}
inline void TripLeg_Edge::set_lane_count(uint32_t value) {
  _internal_set_lane_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.lane_count)
}

// .valhalla.TripLeg.CycleLane cycle_lane = 32;
inline bool TripLeg_Edge::_internal_has_cycle_lane() const {
  return has_cycle_lane_case() == kCycleLane;
}
inline bool TripLeg_Edge::has_cycle_lane() const {
  return _internal_has_cycle_lane();
}
inline void TripLeg_Edge::set_has_cycle_lane() {
  _impl_._oneof_case_[28] = kCycleLane;
}
inline void TripLeg_Edge::clear_cycle_lane() {
  if (_internal_has_cycle_lane()) {
    _impl_.has_cycle_lane_.cycle_lane_ = 0;
    clear_has_has_cycle_lane();
  }
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::_internal_cycle_lane() const {
  if (_internal_has_cycle_lane()) {
    return static_cast< ::valhalla::TripLeg_CycleLane >(_impl_.has_cycle_lane_.cycle_lane_);
  }
  return static_cast< ::valhalla::TripLeg_CycleLane >(0);
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::cycle_lane() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.cycle_lane)
  return _internal_cycle_lane();
}
inline void TripLeg_Edge::_internal_set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  if (!_internal_has_cycle_lane()) {
    clear_has_cycle_lane();
    set_has_cycle_lane();
  }
  _impl_.has_cycle_lane_.cycle_lane_ = value;
}
inline void TripLeg_Edge::set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  _internal_set_cycle_lane(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.cycle_lane)
}

// uint32 bicycle_network = 33;
inline bool TripLeg_Edge::_internal_has_bicycle_network() const {
  return has_bicycle_network_case() == kBicycleNetwork;
}
inline bool TripLeg_Edge::has_bicycle_network() const {
  return _internal_has_bicycle_network();
}
inline void TripLeg_Edge::set_has_bicycle_network() {
  _impl_._oneof_case_[29] = kBicycleNetwork;
}
inline void TripLeg_Edge::clear_bicycle_network() {
  if (_internal_has_bicycle_network()) {
    _impl_.has_bicycle_network_.bicycle_network_ = 0u;
    clear_has_has_bicycle_network();
  }
}
inline uint32_t TripLeg_Edge::_internal_bicycle_network() const {
  if (_internal_has_bicycle_network()) {
    return _impl_.has_bicycle_network_.bicycle_network_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_bicycle_network(uint32_t value) {
  if (!_internal_has_bicycle_network()) {
    clear_has_bicycle_network();
    set_has_bicycle_network();
  }
  _impl_.has_bicycle_network_.bicycle_network_ = value;
}
inline uint32_t TripLeg_Edge::bicycle_network() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_network)
  return _internal_bicycle_network();
}
inline void TripLeg_Edge::set_bicycle_network(uint32_t value) {
  _internal_set_bicycle_network(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_network)
}

// .valhalla.TripLeg.Sidewalk sidewalk = 34;
inline bool TripLeg_Edge::_internal_has_sidewalk() const {
  return has_sidewalk_case() == kSidewalk;
}
inline bool TripLeg_Edge::has_sidewalk() const {
  return _internal_has_sidewalk();
}
inline void TripLeg_Edge::set_has_sidewalk() {
  _impl_._oneof_case_[30] = kSidewalk;
}
inline void TripLeg_Edge::clear_sidewalk() {
  if (_internal_has_sidewalk()) {
    _impl_.has_sidewalk_.sidewalk_ = 0;
    clear_has_has_sidewalk();
  }
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::_internal_sidewalk() const {
  if (_internal_has_sidewalk()) {
    return static_cast< ::valhalla::TripLeg_Sidewalk >(_impl_.has_sidewalk_.sidewalk_);
  }
  return static_cast< ::valhalla::TripLeg_Sidewalk >(0);
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::sidewalk() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sidewalk)
  return _internal_sidewalk();
}
inline void TripLeg_Edge::_internal_set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  if (!_internal_has_sidewalk()) {
    clear_has_sidewalk();
    set_has_sidewalk();
  }
  _impl_.has_sidewalk_.sidewalk_ = value;
}
inline void TripLeg_Edge::set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  _internal_set_sidewalk(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sidewalk)
}

// uint32 density = 35;
inline bool TripLeg_Edge::_internal_has_density() const {
  return has_density_case() == kDensity;
}
inline bool TripLeg_Edge::has_density() const {
  return _internal_has_density();
}
inline void TripLeg_Edge::set_has_density() {
  _impl_._oneof_case_[31] = kDensity;
}
inline void TripLeg_Edge::clear_density() {
  if (_internal_has_density()) {
    _impl_.has_density_.density_ = 0u;
    clear_has_has_density();
  }
}
inline uint32_t TripLeg_Edge::_internal_density() const {
  if (_internal_has_density()) {
    return _impl_.has_density_.density_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_density(uint32_t value) {
  if (!_internal_has_density()) {
    clear_has_density();
    set_has_density();
  }
  _impl_.has_density_.density_ = value;
}
inline uint32_t TripLeg_Edge::density() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.density)
  return _internal_density();
}
inline void TripLeg_Edge::set_density(uint32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.density)
}

// uint32 speed_limit = 36;
inline bool TripLeg_Edge::_internal_has_speed_limit() const {
  return has_speed_limit_case() == kSpeedLimit;
}
inline bool TripLeg_Edge::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void TripLeg_Edge::set_has_speed_limit() {
  _impl_._oneof_case_[32] = kSpeedLimit;
}
inline void TripLeg_Edge::clear_speed_limit() {
  if (_internal_has_speed_limit()) {
    _impl_.has_speed_limit_.speed_limit_ = 0u;
    clear_has_has_speed_limit();
  }
}
inline uint32_t TripLeg_Edge::_internal_speed_limit() const {
  if (_internal_has_speed_limit()) {
    return _impl_.has_speed_limit_.speed_limit_;
  }
  return 0u;
}
inline void TripLeg_Edge::_internal_set_speed_limit(uint32_t value) {
  if (!_internal_has_speed_limit()) {
    clear_has_speed_limit();
    set_has_speed_limit();
  }
  _impl_.has_speed_limit_.speed_limit_ = value;
}
inline uint32_t TripLeg_Edge::speed_limit() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed_limit)
  return _internal_speed_limit();
}
inline void TripLeg_Edge::set_speed_limit(uint32_t value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed_limit)
}

// float truck_speed = 37;
inline bool TripLeg_Edge::_internal_has_truck_speed() const {
  return has_truck_speed_case() == kTruckSpeed;
}
inline bool TripLeg_Edge::has_truck_speed() const {
  return _internal_has_truck_speed();
}
inline void TripLeg_Edge::set_has_truck_speed() {
  _impl_._oneof_case_[33] = kTruckSpeed;
}
inline void TripLeg_Edge::clear_truck_speed() {
  if (_internal_has_truck_speed()) {
    _impl_.has_truck_speed_.truck_speed_ = 0;
    clear_has_has_truck_speed();
  }
}
inline float TripLeg_Edge::_internal_truck_speed() const {
  if (_internal_has_truck_speed()) {
    return _impl_.has_truck_speed_.truck_speed_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_truck_speed(float value) {
  if (!_internal_has_truck_speed()) {
    clear_has_truck_speed();
    set_has_truck_speed();
  }
  _impl_.has_truck_speed_.truck_speed_ = value;
}
inline float TripLeg_Edge::truck_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_speed)
  return _internal_truck_speed();
}
inline void TripLeg_Edge::set_truck_speed(float value) {
  _internal_set_truck_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_speed)
}

// bool truck_route = 38;
inline bool TripLeg_Edge::_internal_has_truck_route() const {
  return has_truck_route_case() == kTruckRoute;
}
inline bool TripLeg_Edge::has_truck_route() const {
  return _internal_has_truck_route();
}
inline void TripLeg_Edge::set_has_truck_route() {
  _impl_._oneof_case_[34] = kTruckRoute;
}
inline void TripLeg_Edge::clear_truck_route() {
  if (_internal_has_truck_route()) {
    _impl_.has_truck_route_.truck_route_ = false;
    clear_has_has_truck_route();
  }
}
inline bool TripLeg_Edge::_internal_truck_route() const {
  if (_internal_has_truck_route()) {
    return _impl_.has_truck_route_.truck_route_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_truck_route(bool value) {
  if (!_internal_has_truck_route()) {
    clear_has_truck_route();
    set_has_truck_route();
  }
  _impl_.has_truck_route_.truck_route_ = value;
}
inline bool TripLeg_Edge::truck_route() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_route)
  return _internal_truck_route();
}
inline void TripLeg_Edge::set_truck_route(bool value) {
  _internal_set_truck_route(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_route)
}

// repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
inline int TripLeg_Edge::_internal_lane_connectivity_size() const {
  return _impl_.lane_connectivity_.size();
}
inline int TripLeg_Edge::lane_connectivity_size() const {
  return _internal_lane_connectivity_size();
}
inline void TripLeg_Edge::clear_lane_connectivity() {
  _impl_.lane_connectivity_.Clear();
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::mutable_lane_connectivity(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.lane_connectivity)
  return _impl_.lane_connectivity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
TripLeg_Edge::mutable_lane_connectivity() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.lane_connectivity)
  return &_impl_.lane_connectivity_;
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::_internal_lane_connectivity(int index) const {
  return _impl_.lane_connectivity_.Get(index);
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::lane_connectivity(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_connectivity)
  return _internal_lane_connectivity(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::_internal_add_lane_connectivity() {
  return _impl_.lane_connectivity_.Add();
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::add_lane_connectivity() {
  ::valhalla::TripLeg_LaneConnectivity* _add = _internal_add_lane_connectivity();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.lane_connectivity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
TripLeg_Edge::lane_connectivity() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.lane_connectivity)
  return _impl_.lane_connectivity_;
}

// int32 mean_elevation = 40;
inline bool TripLeg_Edge::_internal_has_mean_elevation() const {
  return has_mean_elevation_case() == kMeanElevation;
}
inline bool TripLeg_Edge::has_mean_elevation() const {
  return _internal_has_mean_elevation();
}
inline void TripLeg_Edge::set_has_mean_elevation() {
  _impl_._oneof_case_[35] = kMeanElevation;
}
inline void TripLeg_Edge::clear_mean_elevation() {
  if (_internal_has_mean_elevation()) {
    _impl_.has_mean_elevation_.mean_elevation_ = 0;
    clear_has_has_mean_elevation();
  }
}
inline int32_t TripLeg_Edge::_internal_mean_elevation() const {
  if (_internal_has_mean_elevation()) {
    return _impl_.has_mean_elevation_.mean_elevation_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_mean_elevation(int32_t value) {
  if (!_internal_has_mean_elevation()) {
    clear_has_mean_elevation();
    set_has_mean_elevation();
  }
  _impl_.has_mean_elevation_.mean_elevation_ = value;
}
inline int32_t TripLeg_Edge::mean_elevation() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.mean_elevation)
  return _internal_mean_elevation();
}
inline void TripLeg_Edge::set_mean_elevation(int32_t value) {
  _internal_set_mean_elevation(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.mean_elevation)
}

// repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
inline int TripLeg_Edge::_internal_traffic_segment_size() const {
  return _impl_.traffic_segment_.size();
}
inline int TripLeg_Edge::traffic_segment_size() const {
  return _internal_traffic_segment_size();
}
inline void TripLeg_Edge::clear_traffic_segment() {
  _impl_.traffic_segment_.Clear();
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::mutable_traffic_segment(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.traffic_segment)
  return _impl_.traffic_segment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
TripLeg_Edge::mutable_traffic_segment() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.traffic_segment)
  return &_impl_.traffic_segment_;
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::_internal_traffic_segment(int index) const {
  return _impl_.traffic_segment_.Get(index);
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::traffic_segment(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traffic_segment)
  return _internal_traffic_segment(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::_internal_add_traffic_segment() {
  return _impl_.traffic_segment_.Add();
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::add_traffic_segment() {
  ::valhalla::TripLeg_TrafficSegment* _add = _internal_add_traffic_segment();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.traffic_segment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
TripLeg_Edge::traffic_segment() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.traffic_segment)
  return _impl_.traffic_segment_;
}

// repeated .valhalla.TurnLane turn_lanes = 42;
inline int TripLeg_Edge::_internal_turn_lanes_size() const {
  return _impl_.turn_lanes_.size();
}
inline int TripLeg_Edge::turn_lanes_size() const {
  return _internal_turn_lanes_size();
}
inline ::valhalla::TurnLane* TripLeg_Edge::mutable_turn_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.turn_lanes)
  return _impl_.turn_lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >*
TripLeg_Edge::mutable_turn_lanes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.turn_lanes)
  return &_impl_.turn_lanes_;
}
inline const ::valhalla::TurnLane& TripLeg_Edge::_internal_turn_lanes(int index) const {
  return _impl_.turn_lanes_.Get(index);
}
inline const ::valhalla::TurnLane& TripLeg_Edge::turn_lanes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.turn_lanes)
  return _internal_turn_lanes(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::_internal_add_turn_lanes() {
  return _impl_.turn_lanes_.Add();
}
inline ::valhalla::TurnLane* TripLeg_Edge::add_turn_lanes() {
  ::valhalla::TurnLane* _add = _internal_add_turn_lanes();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.turn_lanes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TurnLane >&
TripLeg_Edge::turn_lanes() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.turn_lanes)
  return _impl_.turn_lanes_;
}

// bool has_time_restrictions = 43;
inline bool TripLeg_Edge::_internal_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
inline bool TripLeg_Edge::has_has_time_restrictions() const {
  return _internal_has_has_time_restrictions();
}
inline void TripLeg_Edge::set_has_has_time_restrictions() {
  _impl_._oneof_case_[36] = kHasTimeRestrictions;
}
inline void TripLeg_Edge::clear_has_time_restrictions() {
  if (_internal_has_has_time_restrictions()) {
    _impl_.has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
inline bool TripLeg_Edge::_internal_has_time_restrictions() const {
  if (_internal_has_has_time_restrictions()) {
    return _impl_.has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_has_time_restrictions(bool value) {
  if (!_internal_has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  _impl_.has_has_time_restrictions_.has_time_restrictions_ = value;
}
inline bool TripLeg_Edge::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void TripLeg_Edge::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.has_time_restrictions)
}

// float default_speed = 44;
inline bool TripLeg_Edge::_internal_has_default_speed() const {
  return has_default_speed_case() == kDefaultSpeed;
}
inline bool TripLeg_Edge::has_default_speed() const {
  return _internal_has_default_speed();
}
inline void TripLeg_Edge::set_has_default_speed() {
  _impl_._oneof_case_[37] = kDefaultSpeed;
}
inline void TripLeg_Edge::clear_default_speed() {
  if (_internal_has_default_speed()) {
    _impl_.has_default_speed_.default_speed_ = 0;
    clear_has_has_default_speed();
  }
}
inline float TripLeg_Edge::_internal_default_speed() const {
  if (_internal_has_default_speed()) {
    return _impl_.has_default_speed_.default_speed_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_default_speed(float value) {
  if (!_internal_has_default_speed()) {
    clear_has_default_speed();
    set_has_default_speed();
  }
  _impl_.has_default_speed_.default_speed_ = value;
}
inline float TripLeg_Edge::default_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.default_speed)
  return _internal_default_speed();
}
inline void TripLeg_Edge::set_default_speed(float value) {
  _internal_set_default_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.default_speed)
}

// .valhalla.TripLeg.Restriction restriction = 45;
inline bool TripLeg_Edge::_internal_has_restriction() const {
  return this != internal_default_instance() && _impl_.restriction_ != nullptr;
}
inline bool TripLeg_Edge::has_restriction() const {
  return _internal_has_restriction();
}
inline void TripLeg_Edge::clear_restriction() {
  if (GetArenaForAllocation() == nullptr && _impl_.restriction_ != nullptr) {
    delete _impl_.restriction_;
  }
  _impl_.restriction_ = nullptr;
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::_internal_restriction() const {
  const ::valhalla::TripLeg_Restriction* p = _impl_.restriction_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Restriction&>(
      ::valhalla::_TripLeg_Restriction_default_instance_);
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::restriction() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.restriction)
  return _internal_restriction();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_restriction(
    ::valhalla::TripLeg_Restriction* restriction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.restriction_);
  }
  _impl_.restriction_ = restriction;
  if (restriction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.restriction)
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::release_restriction() {
  
  ::valhalla::TripLeg_Restriction* temp = _impl_.restriction_;
  _impl_.restriction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::unsafe_arena_release_restriction() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.restriction)
  
  ::valhalla::TripLeg_Restriction* temp = _impl_.restriction_;
  _impl_.restriction_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::_internal_mutable_restriction() {
  
  if (_impl_.restriction_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Restriction>(GetArenaForAllocation());
    _impl_.restriction_ = p;
  }
  return _impl_.restriction_;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::mutable_restriction() {
  ::valhalla::TripLeg_Restriction* _msg = _internal_mutable_restriction();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.restriction)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.restriction_;
  }
  if (restriction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(restriction);
    if (message_arena != submessage_arena) {
      restriction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restriction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.restriction_ = restriction;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.restriction)
}

// bool destination_only = 46;
inline bool TripLeg_Edge::_internal_has_destination_only() const {
  return has_destination_only_case() == kDestinationOnly;
}
inline bool TripLeg_Edge::has_destination_only() const {
  return _internal_has_destination_only();
}
inline void TripLeg_Edge::set_has_destination_only() {
  _impl_._oneof_case_[38] = kDestinationOnly;
}
inline void TripLeg_Edge::clear_destination_only() {
  if (_internal_has_destination_only()) {
    _impl_.has_destination_only_.destination_only_ = false;
    clear_has_has_destination_only();
  }
}
inline bool TripLeg_Edge::_internal_destination_only() const {
  if (_internal_has_destination_only()) {
    return _impl_.has_destination_only_.destination_only_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_destination_only(bool value) {
  if (!_internal_has_destination_only()) {
    clear_has_destination_only();
    set_has_destination_only();
  }
  _impl_.has_destination_only_.destination_only_ = value;
}
inline bool TripLeg_Edge::destination_only() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.destination_only)
  return _internal_destination_only();
}
inline void TripLeg_Edge::set_destination_only(bool value) {
  _internal_set_destination_only(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.destination_only)
}

// bool is_urban = 47;
inline bool TripLeg_Edge::_internal_has_is_urban() const {
  return has_is_urban_case() == kIsUrban;
}
inline bool TripLeg_Edge::has_is_urban() const {
  return _internal_has_is_urban();
}
inline void TripLeg_Edge::set_has_is_urban() {
  _impl_._oneof_case_[39] = kIsUrban;
}
inline void TripLeg_Edge::clear_is_urban() {
  if (_internal_has_is_urban()) {
    _impl_.has_is_urban_.is_urban_ = false;
    clear_has_has_is_urban();
  }
}
inline bool TripLeg_Edge::_internal_is_urban() const {
  if (_internal_has_is_urban()) {
    return _impl_.has_is_urban_.is_urban_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_is_urban(bool value) {
  if (!_internal_has_is_urban()) {
    clear_has_is_urban();
    set_has_is_urban();
  }
  _impl_.has_is_urban_.is_urban_ = value;
}
inline bool TripLeg_Edge::is_urban() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.is_urban)
  return _internal_is_urban();
}
inline void TripLeg_Edge::set_is_urban(bool value) {
  _internal_set_is_urban(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.is_urban)
}

// repeated .valhalla.TaggedValue tagged_value = 48;
inline int TripLeg_Edge::_internal_tagged_value_size() const {
  return _impl_.tagged_value_.size();
}
inline int TripLeg_Edge::tagged_value_size() const {
  return _internal_tagged_value_size();
}
inline ::valhalla::TaggedValue* TripLeg_Edge::mutable_tagged_value(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.tagged_value)
  return _impl_.tagged_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >*
TripLeg_Edge::mutable_tagged_value() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.tagged_value)
  return &_impl_.tagged_value_;
}
inline const ::valhalla::TaggedValue& TripLeg_Edge::_internal_tagged_value(int index) const {
  return _impl_.tagged_value_.Get(index);
}
inline const ::valhalla::TaggedValue& TripLeg_Edge::tagged_value(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tagged_value)
  return _internal_tagged_value(index);
}
inline ::valhalla::TaggedValue* TripLeg_Edge::_internal_add_tagged_value() {
  return _impl_.tagged_value_.Add();
}
inline ::valhalla::TaggedValue* TripLeg_Edge::add_tagged_value() {
  ::valhalla::TaggedValue* _add = _internal_add_tagged_value();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.tagged_value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TaggedValue >&
TripLeg_Edge::tagged_value() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.tagged_value)
  return _impl_.tagged_value_;
}

// float source_along_edge = 49;
inline bool TripLeg_Edge::_internal_has_source_along_edge() const {
  return has_source_along_edge_case() == kSourceAlongEdge;
}
inline bool TripLeg_Edge::has_source_along_edge() const {
  return _internal_has_source_along_edge();
}
inline void TripLeg_Edge::set_has_source_along_edge() {
  _impl_._oneof_case_[40] = kSourceAlongEdge;
}
inline void TripLeg_Edge::clear_source_along_edge() {
  if (_internal_has_source_along_edge()) {
    _impl_.has_source_along_edge_.source_along_edge_ = 0;
    clear_has_has_source_along_edge();
  }
}
inline float TripLeg_Edge::_internal_source_along_edge() const {
  if (_internal_has_source_along_edge()) {
    return _impl_.has_source_along_edge_.source_along_edge_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_source_along_edge(float value) {
  if (!_internal_has_source_along_edge()) {
    clear_has_source_along_edge();
    set_has_source_along_edge();
  }
  _impl_.has_source_along_edge_.source_along_edge_ = value;
}
inline float TripLeg_Edge::source_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.source_along_edge)
  return _internal_source_along_edge();
}
inline void TripLeg_Edge::set_source_along_edge(float value) {
  _internal_set_source_along_edge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.source_along_edge)
}

// float target_along_edge = 50;
inline bool TripLeg_Edge::_internal_has_target_along_edge() const {
  return has_target_along_edge_case() == kTargetAlongEdge;
}
inline bool TripLeg_Edge::has_target_along_edge() const {
  return _internal_has_target_along_edge();
}
inline void TripLeg_Edge::set_has_target_along_edge() {
  _impl_._oneof_case_[41] = kTargetAlongEdge;
}
inline void TripLeg_Edge::clear_target_along_edge() {
  if (_internal_has_target_along_edge()) {
    _impl_.has_target_along_edge_.target_along_edge_ = 0;
    clear_has_has_target_along_edge();
  }
}
inline float TripLeg_Edge::_internal_target_along_edge() const {
  if (_internal_has_target_along_edge()) {
    return _impl_.has_target_along_edge_.target_along_edge_;
  }
  return 0;
}
inline void TripLeg_Edge::_internal_set_target_along_edge(float value) {
  if (!_internal_has_target_along_edge()) {
    clear_has_target_along_edge();
    set_has_target_along_edge();
  }
  _impl_.has_target_along_edge_.target_along_edge_ = value;
}
inline float TripLeg_Edge::target_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.target_along_edge)
  return _internal_target_along_edge();
}
inline void TripLeg_Edge::set_target_along_edge(float value) {
  _internal_set_target_along_edge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.target_along_edge)
}

// .valhalla.TripLeg.SacScale sac_scale = 51;
inline bool TripLeg_Edge::_internal_has_sac_scale() const {
  return has_sac_scale_case() == kSacScale;
}
inline bool TripLeg_Edge::has_sac_scale() const {
  return _internal_has_sac_scale();
}
inline void TripLeg_Edge::set_has_sac_scale() {
  _impl_._oneof_case_[42] = kSacScale;
}
inline void TripLeg_Edge::clear_sac_scale() {
  if (_internal_has_sac_scale()) {
    _impl_.has_sac_scale_.sac_scale_ = 0;
    clear_has_has_sac_scale();
  }
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::_internal_sac_scale() const {
  if (_internal_has_sac_scale()) {
    return static_cast< ::valhalla::TripLeg_SacScale >(_impl_.has_sac_scale_.sac_scale_);
  }
  return static_cast< ::valhalla::TripLeg_SacScale >(0);
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::sac_scale() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sac_scale)
  return _internal_sac_scale();
}
inline void TripLeg_Edge::_internal_set_sac_scale(::valhalla::TripLeg_SacScale value) {
  if (!_internal_has_sac_scale()) {
    clear_has_sac_scale();
    set_has_sac_scale();
  }
  _impl_.has_sac_scale_.sac_scale_ = value;
}
inline void TripLeg_Edge::set_sac_scale(::valhalla::TripLeg_SacScale value) {
  _internal_set_sac_scale(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sac_scale)
}

// bool shoulder = 52;
inline bool TripLeg_Edge::_internal_has_shoulder() const {
  return has_shoulder_case() == kShoulder;
}
inline bool TripLeg_Edge::has_shoulder() const {
  return _internal_has_shoulder();
}
inline void TripLeg_Edge::set_has_shoulder() {
  _impl_._oneof_case_[43] = kShoulder;
}
inline void TripLeg_Edge::clear_shoulder() {
  if (_internal_has_shoulder()) {
    _impl_.has_shoulder_.shoulder_ = false;
    clear_has_has_shoulder();
  }
}
inline bool TripLeg_Edge::_internal_shoulder() const {
  if (_internal_has_shoulder()) {
    return _impl_.has_shoulder_.shoulder_;
  }
  return false;
}
inline void TripLeg_Edge::_internal_set_shoulder(bool value) {
  if (!_internal_has_shoulder()) {
    clear_has_shoulder();
    set_has_shoulder();
  }
  _impl_.has_shoulder_.shoulder_ = value;
}
inline bool TripLeg_Edge::shoulder() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.shoulder)
  return _internal_shoulder();
}
inline void TripLeg_Edge::set_shoulder(bool value) {
  _internal_set_shoulder(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.shoulder)
}

inline bool TripLeg_Edge::has_has_length_km() const {
  return has_length_km_case() != HAS_LENGTH_KM_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_length_km() {
  _impl_._oneof_case_[0] = HAS_LENGTH_KM_NOT_SET;
}
inline bool TripLeg_Edge::has_has_speed() const {
  return has_speed_case() != HAS_SPEED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_speed() {
  _impl_._oneof_case_[1] = HAS_SPEED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_road_class() const {
  return has_road_class_case() != HAS_ROAD_CLASS_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_road_class() {
  _impl_._oneof_case_[2] = HAS_ROAD_CLASS_NOT_SET;
}
inline bool TripLeg_Edge::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_begin_heading() {
  _impl_._oneof_case_[3] = HAS_BEGIN_HEADING_NOT_SET;
}
inline bool TripLeg_Edge::has_has_end_heading() const {
  return has_end_heading_case() != HAS_END_HEADING_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_end_heading() {
  _impl_._oneof_case_[4] = HAS_END_HEADING_NOT_SET;
}
inline bool TripLeg_Edge::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_begin_shape_index() {
  _impl_._oneof_case_[5] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Edge::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_end_shape_index() {
  _impl_._oneof_case_[6] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Edge::has_has_traversability() const {
  return has_traversability_case() != HAS_TRAVERSABILITY_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_traversability() {
  _impl_._oneof_case_[7] = HAS_TRAVERSABILITY_NOT_SET;
}
inline bool TripLeg_Edge::has_has_use() const {
  return has_use_case() != HAS_USE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_use() {
  _impl_._oneof_case_[8] = HAS_USE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_toll() const {
  return has_toll_case() != HAS_TOLL_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_toll() {
  _impl_._oneof_case_[9] = HAS_TOLL_NOT_SET;
}
inline bool TripLeg_Edge::has_has_unpaved() const {
  return has_unpaved_case() != HAS_UNPAVED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_unpaved() {
  _impl_._oneof_case_[10] = HAS_UNPAVED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_tunnel() const {
  return has_tunnel_case() != HAS_TUNNEL_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_tunnel() {
  _impl_._oneof_case_[11] = HAS_TUNNEL_NOT_SET;
}
inline bool TripLeg_Edge::has_has_bridge() const {
  return has_bridge_case() != HAS_BRIDGE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_bridge() {
  _impl_._oneof_case_[12] = HAS_BRIDGE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_roundabout() const {
  return has_roundabout_case() != HAS_ROUNDABOUT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_roundabout() {
  _impl_._oneof_case_[13] = HAS_ROUNDABOUT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_internal_intersection() const {
  return has_internal_intersection_case() != HAS_INTERNAL_INTERSECTION_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_internal_intersection() {
  _impl_._oneof_case_[14] = HAS_INTERNAL_INTERSECTION_NOT_SET;
}
inline bool TripLeg_Edge::has_has_drive_on_left() const {
  return has_drive_on_left_case() != HAS_DRIVE_ON_LEFT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_drive_on_left() {
  _impl_._oneof_case_[15] = HAS_DRIVE_ON_LEFT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_surface() const {
  return has_surface_case() != HAS_SURFACE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_surface() {
  _impl_._oneof_case_[16] = HAS_SURFACE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_travel_mode() const {
  return has_travel_mode_case() != HAS_TRAVEL_MODE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_travel_mode() {
  _impl_._oneof_case_[17] = HAS_TRAVEL_MODE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_vehicle_type() const {
  return has_vehicle_type_case() != HAS_VEHICLE_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_vehicle_type() {
  _impl_._oneof_case_[18] = HAS_VEHICLE_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_pedestrian_type() const {
  return has_pedestrian_type_case() != HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_pedestrian_type() {
  _impl_._oneof_case_[19] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_bicycle_type() const {
  return has_bicycle_type_case() != HAS_BICYCLE_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_bicycle_type() {
  _impl_._oneof_case_[20] = HAS_BICYCLE_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_transit_type() const {
  return has_transit_type_case() != HAS_TRANSIT_TYPE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_transit_type() {
  _impl_._oneof_case_[21] = HAS_TRANSIT_TYPE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_id() {
  _impl_._oneof_case_[22] = HAS_ID_NOT_SET;
}
inline bool TripLeg_Edge::has_has_way_id() const {
  return has_way_id_case() != HAS_WAY_ID_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_way_id() {
  _impl_._oneof_case_[23] = HAS_WAY_ID_NOT_SET;
}
inline bool TripLeg_Edge::has_has_weighted_grade() const {
  return has_weighted_grade_case() != HAS_WEIGHTED_GRADE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_weighted_grade() {
  _impl_._oneof_case_[24] = HAS_WEIGHTED_GRADE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_max_upward_grade() const {
  return has_max_upward_grade_case() != HAS_MAX_UPWARD_GRADE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_max_upward_grade() {
  _impl_._oneof_case_[25] = HAS_MAX_UPWARD_GRADE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_max_downward_grade() const {
  return has_max_downward_grade_case() != HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_max_downward_grade() {
  _impl_._oneof_case_[26] = HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_lane_count() const {
  return has_lane_count_case() != HAS_LANE_COUNT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_lane_count() {
  _impl_._oneof_case_[27] = HAS_LANE_COUNT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_cycle_lane() const {
  return has_cycle_lane_case() != HAS_CYCLE_LANE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_cycle_lane() {
  _impl_._oneof_case_[28] = HAS_CYCLE_LANE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_bicycle_network() const {
  return has_bicycle_network_case() != HAS_BICYCLE_NETWORK_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_bicycle_network() {
  _impl_._oneof_case_[29] = HAS_BICYCLE_NETWORK_NOT_SET;
}
inline bool TripLeg_Edge::has_has_sidewalk() const {
  return has_sidewalk_case() != HAS_SIDEWALK_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_sidewalk() {
  _impl_._oneof_case_[30] = HAS_SIDEWALK_NOT_SET;
}
inline bool TripLeg_Edge::has_has_density() const {
  return has_density_case() != HAS_DENSITY_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_density() {
  _impl_._oneof_case_[31] = HAS_DENSITY_NOT_SET;
}
inline bool TripLeg_Edge::has_has_speed_limit() const {
  return has_speed_limit_case() != HAS_SPEED_LIMIT_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_speed_limit() {
  _impl_._oneof_case_[32] = HAS_SPEED_LIMIT_NOT_SET;
}
inline bool TripLeg_Edge::has_has_truck_speed() const {
  return has_truck_speed_case() != HAS_TRUCK_SPEED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_truck_speed() {
  _impl_._oneof_case_[33] = HAS_TRUCK_SPEED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_truck_route() const {
  return has_truck_route_case() != HAS_TRUCK_ROUTE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_truck_route() {
  _impl_._oneof_case_[34] = HAS_TRUCK_ROUTE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_mean_elevation() const {
  return has_mean_elevation_case() != HAS_MEAN_ELEVATION_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_mean_elevation() {
  _impl_._oneof_case_[35] = HAS_MEAN_ELEVATION_NOT_SET;
}
inline bool TripLeg_Edge::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_has_time_restrictions() {
  _impl_._oneof_case_[36] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline bool TripLeg_Edge::has_has_default_speed() const {
  return has_default_speed_case() != HAS_DEFAULT_SPEED_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_default_speed() {
  _impl_._oneof_case_[37] = HAS_DEFAULT_SPEED_NOT_SET;
}
inline bool TripLeg_Edge::has_has_destination_only() const {
  return has_destination_only_case() != HAS_DESTINATION_ONLY_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_destination_only() {
  _impl_._oneof_case_[38] = HAS_DESTINATION_ONLY_NOT_SET;
}
inline bool TripLeg_Edge::has_has_is_urban() const {
  return has_is_urban_case() != HAS_IS_URBAN_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_is_urban() {
  _impl_._oneof_case_[39] = HAS_IS_URBAN_NOT_SET;
}
inline bool TripLeg_Edge::has_has_source_along_edge() const {
  return has_source_along_edge_case() != HAS_SOURCE_ALONG_EDGE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_source_along_edge() {
  _impl_._oneof_case_[40] = HAS_SOURCE_ALONG_EDGE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_target_along_edge() const {
  return has_target_along_edge_case() != HAS_TARGET_ALONG_EDGE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_target_along_edge() {
  _impl_._oneof_case_[41] = HAS_TARGET_ALONG_EDGE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_sac_scale() const {
  return has_sac_scale_case() != HAS_SAC_SCALE_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_sac_scale() {
  _impl_._oneof_case_[42] = HAS_SAC_SCALE_NOT_SET;
}
inline bool TripLeg_Edge::has_has_shoulder() const {
  return has_shoulder_case() != HAS_SHOULDER_NOT_SET;
}
inline void TripLeg_Edge::clear_has_has_shoulder() {
  _impl_._oneof_case_[43] = HAS_SHOULDER_NOT_SET;
}
inline TripLeg_Edge::HasLengthKmCase TripLeg_Edge::has_length_km_case() const {
  return TripLeg_Edge::HasLengthKmCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Edge::HasSpeedCase TripLeg_Edge::has_speed_case() const {
  return TripLeg_Edge::HasSpeedCase(_impl_._oneof_case_[1]);
}
inline TripLeg_Edge::HasRoadClassCase TripLeg_Edge::has_road_class_case() const {
  return TripLeg_Edge::HasRoadClassCase(_impl_._oneof_case_[2]);
}
inline TripLeg_Edge::HasBeginHeadingCase TripLeg_Edge::has_begin_heading_case() const {
  return TripLeg_Edge::HasBeginHeadingCase(_impl_._oneof_case_[3]);
}
inline TripLeg_Edge::HasEndHeadingCase TripLeg_Edge::has_end_heading_case() const {
  return TripLeg_Edge::HasEndHeadingCase(_impl_._oneof_case_[4]);
}
inline TripLeg_Edge::HasBeginShapeIndexCase TripLeg_Edge::has_begin_shape_index_case() const {
  return TripLeg_Edge::HasBeginShapeIndexCase(_impl_._oneof_case_[5]);
}
inline TripLeg_Edge::HasEndShapeIndexCase TripLeg_Edge::has_end_shape_index_case() const {
  return TripLeg_Edge::HasEndShapeIndexCase(_impl_._oneof_case_[6]);
}
inline TripLeg_Edge::HasTraversabilityCase TripLeg_Edge::has_traversability_case() const {
  return TripLeg_Edge::HasTraversabilityCase(_impl_._oneof_case_[7]);
}
inline TripLeg_Edge::HasUseCase TripLeg_Edge::has_use_case() const {
  return TripLeg_Edge::HasUseCase(_impl_._oneof_case_[8]);
}
inline TripLeg_Edge::HasTollCase TripLeg_Edge::has_toll_case() const {
  return TripLeg_Edge::HasTollCase(_impl_._oneof_case_[9]);
}
inline TripLeg_Edge::HasUnpavedCase TripLeg_Edge::has_unpaved_case() const {
  return TripLeg_Edge::HasUnpavedCase(_impl_._oneof_case_[10]);
}
inline TripLeg_Edge::HasTunnelCase TripLeg_Edge::has_tunnel_case() const {
  return TripLeg_Edge::HasTunnelCase(_impl_._oneof_case_[11]);
}
inline TripLeg_Edge::HasBridgeCase TripLeg_Edge::has_bridge_case() const {
  return TripLeg_Edge::HasBridgeCase(_impl_._oneof_case_[12]);
}
inline TripLeg_Edge::HasRoundaboutCase TripLeg_Edge::has_roundabout_case() const {
  return TripLeg_Edge::HasRoundaboutCase(_impl_._oneof_case_[13]);
}
inline TripLeg_Edge::HasInternalIntersectionCase TripLeg_Edge::has_internal_intersection_case() const {
  return TripLeg_Edge::HasInternalIntersectionCase(_impl_._oneof_case_[14]);
}
inline TripLeg_Edge::HasDriveOnLeftCase TripLeg_Edge::has_drive_on_left_case() const {
  return TripLeg_Edge::HasDriveOnLeftCase(_impl_._oneof_case_[15]);
}
inline TripLeg_Edge::HasSurfaceCase TripLeg_Edge::has_surface_case() const {
  return TripLeg_Edge::HasSurfaceCase(_impl_._oneof_case_[16]);
}
inline TripLeg_Edge::HasTravelModeCase TripLeg_Edge::has_travel_mode_case() const {
  return TripLeg_Edge::HasTravelModeCase(_impl_._oneof_case_[17]);
}
inline TripLeg_Edge::HasVehicleTypeCase TripLeg_Edge::has_vehicle_type_case() const {
  return TripLeg_Edge::HasVehicleTypeCase(_impl_._oneof_case_[18]);
}
inline TripLeg_Edge::HasPedestrianTypeCase TripLeg_Edge::has_pedestrian_type_case() const {
  return TripLeg_Edge::HasPedestrianTypeCase(_impl_._oneof_case_[19]);
}
inline TripLeg_Edge::HasBicycleTypeCase TripLeg_Edge::has_bicycle_type_case() const {
  return TripLeg_Edge::HasBicycleTypeCase(_impl_._oneof_case_[20]);
}
inline TripLeg_Edge::HasTransitTypeCase TripLeg_Edge::has_transit_type_case() const {
  return TripLeg_Edge::HasTransitTypeCase(_impl_._oneof_case_[21]);
}
inline TripLeg_Edge::HasIdCase TripLeg_Edge::has_id_case() const {
  return TripLeg_Edge::HasIdCase(_impl_._oneof_case_[22]);
}
inline TripLeg_Edge::HasWayIdCase TripLeg_Edge::has_way_id_case() const {
  return TripLeg_Edge::HasWayIdCase(_impl_._oneof_case_[23]);
}
inline TripLeg_Edge::HasWeightedGradeCase TripLeg_Edge::has_weighted_grade_case() const {
  return TripLeg_Edge::HasWeightedGradeCase(_impl_._oneof_case_[24]);
}
inline TripLeg_Edge::HasMaxUpwardGradeCase TripLeg_Edge::has_max_upward_grade_case() const {
  return TripLeg_Edge::HasMaxUpwardGradeCase(_impl_._oneof_case_[25]);
}
inline TripLeg_Edge::HasMaxDownwardGradeCase TripLeg_Edge::has_max_downward_grade_case() const {
  return TripLeg_Edge::HasMaxDownwardGradeCase(_impl_._oneof_case_[26]);
}
inline TripLeg_Edge::HasLaneCountCase TripLeg_Edge::has_lane_count_case() const {
  return TripLeg_Edge::HasLaneCountCase(_impl_._oneof_case_[27]);
}
inline TripLeg_Edge::HasCycleLaneCase TripLeg_Edge::has_cycle_lane_case() const {
  return TripLeg_Edge::HasCycleLaneCase(_impl_._oneof_case_[28]);
}
inline TripLeg_Edge::HasBicycleNetworkCase TripLeg_Edge::has_bicycle_network_case() const {
  return TripLeg_Edge::HasBicycleNetworkCase(_impl_._oneof_case_[29]);
}
inline TripLeg_Edge::HasSidewalkCase TripLeg_Edge::has_sidewalk_case() const {
  return TripLeg_Edge::HasSidewalkCase(_impl_._oneof_case_[30]);
}
inline TripLeg_Edge::HasDensityCase TripLeg_Edge::has_density_case() const {
  return TripLeg_Edge::HasDensityCase(_impl_._oneof_case_[31]);
}
inline TripLeg_Edge::HasSpeedLimitCase TripLeg_Edge::has_speed_limit_case() const {
  return TripLeg_Edge::HasSpeedLimitCase(_impl_._oneof_case_[32]);
}
inline TripLeg_Edge::HasTruckSpeedCase TripLeg_Edge::has_truck_speed_case() const {
  return TripLeg_Edge::HasTruckSpeedCase(_impl_._oneof_case_[33]);
}
inline TripLeg_Edge::HasTruckRouteCase TripLeg_Edge::has_truck_route_case() const {
  return TripLeg_Edge::HasTruckRouteCase(_impl_._oneof_case_[34]);
}
inline TripLeg_Edge::HasMeanElevationCase TripLeg_Edge::has_mean_elevation_case() const {
  return TripLeg_Edge::HasMeanElevationCase(_impl_._oneof_case_[35]);
}
inline TripLeg_Edge::HasHasTimeRestrictionsCase TripLeg_Edge::has_has_time_restrictions_case() const {
  return TripLeg_Edge::HasHasTimeRestrictionsCase(_impl_._oneof_case_[36]);
}
inline TripLeg_Edge::HasDefaultSpeedCase TripLeg_Edge::has_default_speed_case() const {
  return TripLeg_Edge::HasDefaultSpeedCase(_impl_._oneof_case_[37]);
}
inline TripLeg_Edge::HasDestinationOnlyCase TripLeg_Edge::has_destination_only_case() const {
  return TripLeg_Edge::HasDestinationOnlyCase(_impl_._oneof_case_[38]);
}
inline TripLeg_Edge::HasIsUrbanCase TripLeg_Edge::has_is_urban_case() const {
  return TripLeg_Edge::HasIsUrbanCase(_impl_._oneof_case_[39]);
}
inline TripLeg_Edge::HasSourceAlongEdgeCase TripLeg_Edge::has_source_along_edge_case() const {
  return TripLeg_Edge::HasSourceAlongEdgeCase(_impl_._oneof_case_[40]);
}
inline TripLeg_Edge::HasTargetAlongEdgeCase TripLeg_Edge::has_target_along_edge_case() const {
  return TripLeg_Edge::HasTargetAlongEdgeCase(_impl_._oneof_case_[41]);
}
inline TripLeg_Edge::HasSacScaleCase TripLeg_Edge::has_sac_scale_case() const {
  return TripLeg_Edge::HasSacScaleCase(_impl_._oneof_case_[42]);
}
inline TripLeg_Edge::HasShoulderCase TripLeg_Edge::has_shoulder_case() const {
  return TripLeg_Edge::HasShoulderCase(_impl_._oneof_case_[43]);
}
// -------------------------------------------------------------------

// TripLeg_IntersectingEdge

// uint32 begin_heading = 1;
inline bool TripLeg_IntersectingEdge::_internal_has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
inline bool TripLeg_IntersectingEdge::has_begin_heading() const {
  return _internal_has_begin_heading();
}
inline void TripLeg_IntersectingEdge::set_has_begin_heading() {
  _impl_._oneof_case_[0] = kBeginHeading;
}
inline void TripLeg_IntersectingEdge::clear_begin_heading() {
  if (_internal_has_begin_heading()) {
    _impl_.has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
inline uint32_t TripLeg_IntersectingEdge::_internal_begin_heading() const {
  if (_internal_has_begin_heading()) {
    return _impl_.has_begin_heading_.begin_heading_;
  }
  return 0u;
}
inline void TripLeg_IntersectingEdge::_internal_set_begin_heading(uint32_t value) {
  if (!_internal_has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  _impl_.has_begin_heading_.begin_heading_ = value;
}
inline uint32_t TripLeg_IntersectingEdge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.begin_heading)
  return _internal_begin_heading();
}
inline void TripLeg_IntersectingEdge::set_begin_heading(uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.begin_heading)
}

// bool prev_name_consistency = 2;
inline bool TripLeg_IntersectingEdge::_internal_has_prev_name_consistency() const {
  return has_prev_name_consistency_case() == kPrevNameConsistency;
}
inline bool TripLeg_IntersectingEdge::has_prev_name_consistency() const {
  return _internal_has_prev_name_consistency();
}
inline void TripLeg_IntersectingEdge::set_has_prev_name_consistency() {
  _impl_._oneof_case_[1] = kPrevNameConsistency;
}
inline void TripLeg_IntersectingEdge::clear_prev_name_consistency() {
  if (_internal_has_prev_name_consistency()) {
    _impl_.has_prev_name_consistency_.prev_name_consistency_ = false;
    clear_has_has_prev_name_consistency();
  }
}
inline bool TripLeg_IntersectingEdge::_internal_prev_name_consistency() const {
  if (_internal_has_prev_name_consistency()) {
    return _impl_.has_prev_name_consistency_.prev_name_consistency_;
  }
  return false;
}
inline void TripLeg_IntersectingEdge::_internal_set_prev_name_consistency(bool value) {
  if (!_internal_has_prev_name_consistency()) {
    clear_has_prev_name_consistency();
    set_has_prev_name_consistency();
  }
  _impl_.has_prev_name_consistency_.prev_name_consistency_ = value;
}
inline bool TripLeg_IntersectingEdge::prev_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
  return _internal_prev_name_consistency();
}
inline void TripLeg_IntersectingEdge::set_prev_name_consistency(bool value) {
  _internal_set_prev_name_consistency(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
}

// bool curr_name_consistency = 3;
inline bool TripLeg_IntersectingEdge::_internal_has_curr_name_consistency() const {
  return has_curr_name_consistency_case() == kCurrNameConsistency;
}
inline bool TripLeg_IntersectingEdge::has_curr_name_consistency() const {
  return _internal_has_curr_name_consistency();
}
inline void TripLeg_IntersectingEdge::set_has_curr_name_consistency() {
  _impl_._oneof_case_[2] = kCurrNameConsistency;
}
inline void TripLeg_IntersectingEdge::clear_curr_name_consistency() {
  if (_internal_has_curr_name_consistency()) {
    _impl_.has_curr_name_consistency_.curr_name_consistency_ = false;
    clear_has_has_curr_name_consistency();
  }
}
inline bool TripLeg_IntersectingEdge::_internal_curr_name_consistency() const {
  if (_internal_has_curr_name_consistency()) {
    return _impl_.has_curr_name_consistency_.curr_name_consistency_;
  }
  return false;
}
inline void TripLeg_IntersectingEdge::_internal_set_curr_name_consistency(bool value) {
  if (!_internal_has_curr_name_consistency()) {
    clear_has_curr_name_consistency();
    set_has_curr_name_consistency();
  }
  _impl_.has_curr_name_consistency_.curr_name_consistency_ = value;
}
inline bool TripLeg_IntersectingEdge::curr_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
  return _internal_curr_name_consistency();
}
inline void TripLeg_IntersectingEdge::set_curr_name_consistency(bool value) {
  _internal_set_curr_name_consistency(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
}

// .valhalla.TripLeg.Traversability driveability = 4;
inline bool TripLeg_IntersectingEdge::_internal_has_driveability() const {
  return has_driveability_case() == kDriveability;
}
inline bool TripLeg_IntersectingEdge::has_driveability() const {
  return _internal_has_driveability();
}
inline void TripLeg_IntersectingEdge::set_has_driveability() {
  _impl_._oneof_case_[3] = kDriveability;
}
inline void TripLeg_IntersectingEdge::clear_driveability() {
  if (_internal_has_driveability()) {
    _impl_.has_driveability_.driveability_ = 0;
    clear_has_has_driveability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_driveability() const {
  if (_internal_has_driveability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.has_driveability_.driveability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::driveability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.driveability)
  return _internal_driveability();
}
inline void TripLeg_IntersectingEdge::_internal_set_driveability(::valhalla::TripLeg_Traversability value) {
  if (!_internal_has_driveability()) {
    clear_has_driveability();
    set_has_driveability();
  }
  _impl_.has_driveability_.driveability_ = value;
}
inline void TripLeg_IntersectingEdge::set_driveability(::valhalla::TripLeg_Traversability value) {
  _internal_set_driveability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.driveability)
}

// .valhalla.TripLeg.Traversability cyclability = 5;
inline bool TripLeg_IntersectingEdge::_internal_has_cyclability() const {
  return has_cyclability_case() == kCyclability;
}
inline bool TripLeg_IntersectingEdge::has_cyclability() const {
  return _internal_has_cyclability();
}
inline void TripLeg_IntersectingEdge::set_has_cyclability() {
  _impl_._oneof_case_[4] = kCyclability;
}
inline void TripLeg_IntersectingEdge::clear_cyclability() {
  if (_internal_has_cyclability()) {
    _impl_.has_cyclability_.cyclability_ = 0;
    clear_has_has_cyclability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_cyclability() const {
  if (_internal_has_cyclability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.has_cyclability_.cyclability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::cyclability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.cyclability)
  return _internal_cyclability();
}
inline void TripLeg_IntersectingEdge::_internal_set_cyclability(::valhalla::TripLeg_Traversability value) {
  if (!_internal_has_cyclability()) {
    clear_has_cyclability();
    set_has_cyclability();
  }
  _impl_.has_cyclability_.cyclability_ = value;
}
inline void TripLeg_IntersectingEdge::set_cyclability(::valhalla::TripLeg_Traversability value) {
  _internal_set_cyclability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.cyclability)
}

// .valhalla.TripLeg.Traversability walkability = 6;
inline bool TripLeg_IntersectingEdge::_internal_has_walkability() const {
  return has_walkability_case() == kWalkability;
}
inline bool TripLeg_IntersectingEdge::has_walkability() const {
  return _internal_has_walkability();
}
inline void TripLeg_IntersectingEdge::set_has_walkability() {
  _impl_._oneof_case_[5] = kWalkability;
}
inline void TripLeg_IntersectingEdge::clear_walkability() {
  if (_internal_has_walkability()) {
    _impl_.has_walkability_.walkability_ = 0;
    clear_has_has_walkability();
  }
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_walkability() const {
  if (_internal_has_walkability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(_impl_.has_walkability_.walkability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::walkability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.walkability)
  return _internal_walkability();
}
inline void TripLeg_IntersectingEdge::_internal_set_walkability(::valhalla::TripLeg_Traversability value) {
  if (!_internal_has_walkability()) {
    clear_has_walkability();
    set_has_walkability();
  }
  _impl_.has_walkability_.walkability_ = value;
}
inline void TripLeg_IntersectingEdge::set_walkability(::valhalla::TripLeg_Traversability value) {
  _internal_set_walkability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.walkability)
}

// .valhalla.TripLeg.Use use = 7;
inline bool TripLeg_IntersectingEdge::_internal_has_use() const {
  return has_use_case() == kUse;
}
inline bool TripLeg_IntersectingEdge::has_use() const {
  return _internal_has_use();
}
inline void TripLeg_IntersectingEdge::set_has_use() {
  _impl_._oneof_case_[6] = kUse;
}
inline void TripLeg_IntersectingEdge::clear_use() {
  if (_internal_has_use()) {
    _impl_.has_use_.use_ = 0;
    clear_has_has_use();
  }
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::_internal_use() const {
  if (_internal_has_use()) {
    return static_cast< ::valhalla::TripLeg_Use >(_impl_.has_use_.use_);
  }
  return static_cast< ::valhalla::TripLeg_Use >(0);
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.use)
  return _internal_use();
}
inline void TripLeg_IntersectingEdge::_internal_set_use(::valhalla::TripLeg_Use value) {
  if (!_internal_has_use()) {
    clear_has_use();
    set_has_use();
  }
  _impl_.has_use_.use_ = value;
}
inline void TripLeg_IntersectingEdge::set_use(::valhalla::TripLeg_Use value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.use)
}

// .valhalla.RoadClass road_class = 8;
inline bool TripLeg_IntersectingEdge::_internal_has_road_class() const {
  return has_road_class_case() == kRoadClass;
}
inline bool TripLeg_IntersectingEdge::has_road_class() const {
  return _internal_has_road_class();
}
inline void TripLeg_IntersectingEdge::set_has_road_class() {
  _impl_._oneof_case_[7] = kRoadClass;
}
inline void TripLeg_IntersectingEdge::clear_road_class() {
  if (_internal_has_road_class()) {
    _impl_.has_road_class_.road_class_ = 0;
    clear_has_has_road_class();
  }
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::_internal_road_class() const {
  if (_internal_has_road_class()) {
    return static_cast< ::valhalla::RoadClass >(_impl_.has_road_class_.road_class_);
  }
  return static_cast< ::valhalla::RoadClass >(0);
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.road_class)
  return _internal_road_class();
}
inline void TripLeg_IntersectingEdge::_internal_set_road_class(::valhalla::RoadClass value) {
  if (!_internal_has_road_class()) {
    clear_has_road_class();
    set_has_road_class();
  }
  _impl_.has_road_class_.road_class_ = value;
}
inline void TripLeg_IntersectingEdge::set_road_class(::valhalla::RoadClass value) {
  _internal_set_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.road_class)
}

// uint32 lane_count = 9;
inline bool TripLeg_IntersectingEdge::_internal_has_lane_count() const {
  return has_lane_count_case() == kLaneCount;
}
inline bool TripLeg_IntersectingEdge::has_lane_count() const {
  return _internal_has_lane_count();
}
inline void TripLeg_IntersectingEdge::set_has_lane_count() {
  _impl_._oneof_case_[8] = kLaneCount;
}
inline void TripLeg_IntersectingEdge::clear_lane_count() {
  if (_internal_has_lane_count()) {
    _impl_.has_lane_count_.lane_count_ = 0u;
    clear_has_has_lane_count();
  }
}
inline uint32_t TripLeg_IntersectingEdge::_internal_lane_count() const {
  if (_internal_has_lane_count()) {
    return _impl_.has_lane_count_.lane_count_;
  }
  return 0u;
}
inline void TripLeg_IntersectingEdge::_internal_set_lane_count(uint32_t value) {
  if (!_internal_has_lane_count()) {
    clear_has_lane_count();
    set_has_lane_count();
  }
  _impl_.has_lane_count_.lane_count_ = value;
}
inline uint32_t TripLeg_IntersectingEdge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.lane_count)
  return _internal_lane_count();
}
inline void TripLeg_IntersectingEdge::set_lane_count(uint32_t value) {
  _internal_set_lane_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.lane_count)
}

// .valhalla.TripSign sign = 10;
inline bool TripLeg_IntersectingEdge::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool TripLeg_IntersectingEdge::has_sign() const {
  return _internal_has_sign();
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::_internal_sign() const {
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(
      ::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.sign)
  return _internal_sign();
}
inline void TripLeg_IntersectingEdge::unsafe_arena_set_allocated_sign(
    ::valhalla::TripSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::release_sign() {
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.IntersectingEdge.sign)
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::mutable_sign() {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.IntersectingEdge.sign)
  return _msg;
}
inline void TripLeg_IntersectingEdge::set_allocated_sign(::valhalla::TripSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}

inline bool TripLeg_IntersectingEdge::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_begin_heading() {
  _impl_._oneof_case_[0] = HAS_BEGIN_HEADING_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_prev_name_consistency() const {
  return has_prev_name_consistency_case() != HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_prev_name_consistency() {
  _impl_._oneof_case_[1] = HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_curr_name_consistency() const {
  return has_curr_name_consistency_case() != HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_curr_name_consistency() {
  _impl_._oneof_case_[2] = HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_driveability() const {
  return has_driveability_case() != HAS_DRIVEABILITY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_driveability() {
  _impl_._oneof_case_[3] = HAS_DRIVEABILITY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_cyclability() const {
  return has_cyclability_case() != HAS_CYCLABILITY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_cyclability() {
  _impl_._oneof_case_[4] = HAS_CYCLABILITY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_walkability() const {
  return has_walkability_case() != HAS_WALKABILITY_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_walkability() {
  _impl_._oneof_case_[5] = HAS_WALKABILITY_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_use() const {
  return has_use_case() != HAS_USE_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_use() {
  _impl_._oneof_case_[6] = HAS_USE_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_road_class() const {
  return has_road_class_case() != HAS_ROAD_CLASS_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_road_class() {
  _impl_._oneof_case_[7] = HAS_ROAD_CLASS_NOT_SET;
}
inline bool TripLeg_IntersectingEdge::has_has_lane_count() const {
  return has_lane_count_case() != HAS_LANE_COUNT_NOT_SET;
}
inline void TripLeg_IntersectingEdge::clear_has_has_lane_count() {
  _impl_._oneof_case_[8] = HAS_LANE_COUNT_NOT_SET;
}
inline TripLeg_IntersectingEdge::HasBeginHeadingCase TripLeg_IntersectingEdge::has_begin_heading_case() const {
  return TripLeg_IntersectingEdge::HasBeginHeadingCase(_impl_._oneof_case_[0]);
}
inline TripLeg_IntersectingEdge::HasPrevNameConsistencyCase TripLeg_IntersectingEdge::has_prev_name_consistency_case() const {
  return TripLeg_IntersectingEdge::HasPrevNameConsistencyCase(_impl_._oneof_case_[1]);
}
inline TripLeg_IntersectingEdge::HasCurrNameConsistencyCase TripLeg_IntersectingEdge::has_curr_name_consistency_case() const {
  return TripLeg_IntersectingEdge::HasCurrNameConsistencyCase(_impl_._oneof_case_[2]);
}
inline TripLeg_IntersectingEdge::HasDriveabilityCase TripLeg_IntersectingEdge::has_driveability_case() const {
  return TripLeg_IntersectingEdge::HasDriveabilityCase(_impl_._oneof_case_[3]);
}
inline TripLeg_IntersectingEdge::HasCyclabilityCase TripLeg_IntersectingEdge::has_cyclability_case() const {
  return TripLeg_IntersectingEdge::HasCyclabilityCase(_impl_._oneof_case_[4]);
}
inline TripLeg_IntersectingEdge::HasWalkabilityCase TripLeg_IntersectingEdge::has_walkability_case() const {
  return TripLeg_IntersectingEdge::HasWalkabilityCase(_impl_._oneof_case_[5]);
}
inline TripLeg_IntersectingEdge::HasUseCase TripLeg_IntersectingEdge::has_use_case() const {
  return TripLeg_IntersectingEdge::HasUseCase(_impl_._oneof_case_[6]);
}
inline TripLeg_IntersectingEdge::HasRoadClassCase TripLeg_IntersectingEdge::has_road_class_case() const {
  return TripLeg_IntersectingEdge::HasRoadClassCase(_impl_._oneof_case_[7]);
}
inline TripLeg_IntersectingEdge::HasLaneCountCase TripLeg_IntersectingEdge::has_lane_count_case() const {
  return TripLeg_IntersectingEdge::HasLaneCountCase(_impl_._oneof_case_[8]);
}
// -------------------------------------------------------------------

// TripLeg_Cost

// double seconds = 1;
inline bool TripLeg_Cost::_internal_has_seconds() const {
  return has_seconds_case() == kSeconds;
}
inline bool TripLeg_Cost::has_seconds() const {
  return _internal_has_seconds();
}
inline void TripLeg_Cost::set_has_seconds() {
  _impl_._oneof_case_[0] = kSeconds;
}
inline void TripLeg_Cost::clear_seconds() {
  if (_internal_has_seconds()) {
    _impl_.has_seconds_.seconds_ = 0;
    clear_has_has_seconds();
  }
}
inline double TripLeg_Cost::_internal_seconds() const {
  if (_internal_has_seconds()) {
    return _impl_.has_seconds_.seconds_;
  }
  return 0;
}
inline void TripLeg_Cost::_internal_set_seconds(double value) {
  if (!_internal_has_seconds()) {
    clear_has_seconds();
    set_has_seconds();
  }
  _impl_.has_seconds_.seconds_ = value;
}
inline double TripLeg_Cost::seconds() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.seconds)
  return _internal_seconds();
}
inline void TripLeg_Cost::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.seconds)
}

// double cost = 2;
inline bool TripLeg_Cost::_internal_has_cost() const {
  return has_cost_case() == kCost;
}
inline bool TripLeg_Cost::has_cost() const {
  return _internal_has_cost();
}
inline void TripLeg_Cost::set_has_cost() {
  _impl_._oneof_case_[1] = kCost;
}
inline void TripLeg_Cost::clear_cost() {
  if (_internal_has_cost()) {
    _impl_.has_cost_.cost_ = 0;
    clear_has_has_cost();
  }
}
inline double TripLeg_Cost::_internal_cost() const {
  if (_internal_has_cost()) {
    return _impl_.has_cost_.cost_;
  }
  return 0;
}
inline void TripLeg_Cost::_internal_set_cost(double value) {
  if (!_internal_has_cost()) {
    clear_has_cost();
    set_has_cost();
  }
  _impl_.has_cost_.cost_ = value;
}
inline double TripLeg_Cost::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.cost)
  return _internal_cost();
}
inline void TripLeg_Cost::set_cost(double value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.cost)
}

inline bool TripLeg_Cost::has_has_seconds() const {
  return has_seconds_case() != HAS_SECONDS_NOT_SET;
}
inline void TripLeg_Cost::clear_has_has_seconds() {
  _impl_._oneof_case_[0] = HAS_SECONDS_NOT_SET;
}
inline bool TripLeg_Cost::has_has_cost() const {
  return has_cost_case() != HAS_COST_NOT_SET;
}
inline void TripLeg_Cost::clear_has_has_cost() {
  _impl_._oneof_case_[1] = HAS_COST_NOT_SET;
}
inline TripLeg_Cost::HasSecondsCase TripLeg_Cost::has_seconds_case() const {
  return TripLeg_Cost::HasSecondsCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Cost::HasCostCase TripLeg_Cost::has_cost_case() const {
  return TripLeg_Cost::HasCostCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg_PathCost

// .valhalla.TripLeg.Cost elapsed_cost = 1;
inline bool TripLeg_PathCost::_internal_has_elapsed_cost() const {
  return this != internal_default_instance() && _impl_.elapsed_cost_ != nullptr;
}
inline bool TripLeg_PathCost::has_elapsed_cost() const {
  return _internal_has_elapsed_cost();
}
inline void TripLeg_PathCost::clear_elapsed_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.elapsed_cost_ != nullptr) {
    delete _impl_.elapsed_cost_;
  }
  _impl_.elapsed_cost_ = nullptr;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_internal_elapsed_cost() const {
  const ::valhalla::TripLeg_Cost* p = _impl_.elapsed_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Cost&>(
      ::valhalla::_TripLeg_Cost_default_instance_);
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::elapsed_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.elapsed_cost)
  return _internal_elapsed_cost();
}
inline void TripLeg_PathCost::unsafe_arena_set_allocated_elapsed_cost(
    ::valhalla::TripLeg_Cost* elapsed_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elapsed_cost_);
  }
  _impl_.elapsed_cost_ = elapsed_cost;
  if (elapsed_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_elapsed_cost() {
  
  ::valhalla::TripLeg_Cost* temp = _impl_.elapsed_cost_;
  _impl_.elapsed_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::unsafe_arena_release_elapsed_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.elapsed_cost)
  
  ::valhalla::TripLeg_Cost* temp = _impl_.elapsed_cost_;
  _impl_.elapsed_cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::_internal_mutable_elapsed_cost() {
  
  if (_impl_.elapsed_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Cost>(GetArenaForAllocation());
    _impl_.elapsed_cost_ = p;
  }
  return _impl_.elapsed_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_elapsed_cost() {
  ::valhalla::TripLeg_Cost* _msg = _internal_mutable_elapsed_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.elapsed_cost)
  return _msg;
}
inline void TripLeg_PathCost::set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.elapsed_cost_;
  }
  if (elapsed_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(elapsed_cost);
    if (message_arena != submessage_arena) {
      elapsed_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, elapsed_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.elapsed_cost_ = elapsed_cost;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}

// .valhalla.TripLeg.Cost transition_cost = 2;
inline bool TripLeg_PathCost::_internal_has_transition_cost() const {
  return this != internal_default_instance() && _impl_.transition_cost_ != nullptr;
}
inline bool TripLeg_PathCost::has_transition_cost() const {
  return _internal_has_transition_cost();
}
inline void TripLeg_PathCost::clear_transition_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.transition_cost_ != nullptr) {
    delete _impl_.transition_cost_;
  }
  _impl_.transition_cost_ = nullptr;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_internal_transition_cost() const {
  const ::valhalla::TripLeg_Cost* p = _impl_.transition_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Cost&>(
      ::valhalla::_TripLeg_Cost_default_instance_);
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::transition_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.transition_cost)
  return _internal_transition_cost();
}
inline void TripLeg_PathCost::unsafe_arena_set_allocated_transition_cost(
    ::valhalla::TripLeg_Cost* transition_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transition_cost_);
  }
  _impl_.transition_cost_ = transition_cost;
  if (transition_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_transition_cost() {
  
  ::valhalla::TripLeg_Cost* temp = _impl_.transition_cost_;
  _impl_.transition_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::unsafe_arena_release_transition_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.transition_cost)
  
  ::valhalla::TripLeg_Cost* temp = _impl_.transition_cost_;
  _impl_.transition_cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::_internal_mutable_transition_cost() {
  
  if (_impl_.transition_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Cost>(GetArenaForAllocation());
    _impl_.transition_cost_ = p;
  }
  return _impl_.transition_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_transition_cost() {
  ::valhalla::TripLeg_Cost* _msg = _internal_mutable_transition_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.transition_cost)
  return _msg;
}
inline void TripLeg_PathCost::set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transition_cost_;
  }
  if (transition_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transition_cost);
    if (message_arena != submessage_arena) {
      transition_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transition_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transition_cost_ = transition_cost;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}

// -------------------------------------------------------------------

// TripLeg_Node

// .valhalla.TripLeg.Edge edge = 1;
inline bool TripLeg_Node::_internal_has_edge() const {
  return this != internal_default_instance() && _impl_.edge_ != nullptr;
}
inline bool TripLeg_Node::has_edge() const {
  return _internal_has_edge();
}
inline void TripLeg_Node::clear_edge() {
  if (GetArenaForAllocation() == nullptr && _impl_.edge_ != nullptr) {
    delete _impl_.edge_;
  }
  _impl_.edge_ = nullptr;
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::_internal_edge() const {
  const ::valhalla::TripLeg_Edge* p = _impl_.edge_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Edge&>(
      ::valhalla::_TripLeg_Edge_default_instance_);
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.edge)
  return _internal_edge();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_edge(
    ::valhalla::TripLeg_Edge* edge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.edge_);
  }
  _impl_.edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.edge)
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::release_edge() {
  
  ::valhalla::TripLeg_Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::unsafe_arena_release_edge() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.edge)
  
  ::valhalla::TripLeg_Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::_internal_mutable_edge() {
  
  if (_impl_.edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Edge>(GetArenaForAllocation());
    _impl_.edge_ = p;
  }
  return _impl_.edge_;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::mutable_edge() {
  ::valhalla::TripLeg_Edge* _msg = _internal_mutable_edge();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.edge)
  return _msg;
}
inline void TripLeg_Node::set_allocated_edge(::valhalla::TripLeg_Edge* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.edge_;
  }
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.edge_ = edge;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.edge)
}

// repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
inline int TripLeg_Node::_internal_intersecting_edge_size() const {
  return _impl_.intersecting_edge_.size();
}
inline int TripLeg_Node::intersecting_edge_size() const {
  return _internal_intersecting_edge_size();
}
inline void TripLeg_Node::clear_intersecting_edge() {
  _impl_.intersecting_edge_.Clear();
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::mutable_intersecting_edge(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.intersecting_edge)
  return _impl_.intersecting_edge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
TripLeg_Node::mutable_intersecting_edge() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.intersecting_edge)
  return &_impl_.intersecting_edge_;
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::_internal_intersecting_edge(int index) const {
  return _impl_.intersecting_edge_.Get(index);
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::intersecting_edge(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.intersecting_edge)
  return _internal_intersecting_edge(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::_internal_add_intersecting_edge() {
  return _impl_.intersecting_edge_.Add();
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::add_intersecting_edge() {
  ::valhalla::TripLeg_IntersectingEdge* _add = _internal_add_intersecting_edge();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.intersecting_edge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
TripLeg_Node::intersecting_edge() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.intersecting_edge)
  return _impl_.intersecting_edge_;
}

// uint32 admin_index = 3;
inline bool TripLeg_Node::_internal_has_admin_index() const {
  return has_admin_index_case() == kAdminIndex;
}
inline bool TripLeg_Node::has_admin_index() const {
  return _internal_has_admin_index();
}
inline void TripLeg_Node::set_has_admin_index() {
  _impl_._oneof_case_[0] = kAdminIndex;
}
inline void TripLeg_Node::clear_admin_index() {
  if (_internal_has_admin_index()) {
    _impl_.has_admin_index_.admin_index_ = 0u;
    clear_has_has_admin_index();
  }
}
inline uint32_t TripLeg_Node::_internal_admin_index() const {
  if (_internal_has_admin_index()) {
    return _impl_.has_admin_index_.admin_index_;
  }
  return 0u;
}
inline void TripLeg_Node::_internal_set_admin_index(uint32_t value) {
  if (!_internal_has_admin_index()) {
    clear_has_admin_index();
    set_has_admin_index();
  }
  _impl_.has_admin_index_.admin_index_ = value;
}
inline uint32_t TripLeg_Node::admin_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.admin_index)
  return _internal_admin_index();
}
inline void TripLeg_Node::set_admin_index(uint32_t value) {
  _internal_set_admin_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.admin_index)
}

// .valhalla.TripLeg.Node.Type type = 4;
inline bool TripLeg_Node::_internal_has_type() const {
  return has_type_case() == kType;
}
inline bool TripLeg_Node::has_type() const {
  return _internal_has_type();
}
inline void TripLeg_Node::set_has_type() {
  _impl_._oneof_case_[1] = kType;
}
inline void TripLeg_Node::clear_type() {
  if (_internal_has_type()) {
    _impl_.has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::_internal_type() const {
  if (_internal_has_type()) {
    return static_cast< ::valhalla::TripLeg_Node_Type >(_impl_.has_type_.type_);
  }
  return static_cast< ::valhalla::TripLeg_Node_Type >(0);
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.type)
  return _internal_type();
}
inline void TripLeg_Node::_internal_set_type(::valhalla::TripLeg_Node_Type value) {
  if (!_internal_has_type()) {
    clear_has_type();
    set_has_type();
  }
  _impl_.has_type_.type_ = value;
}
inline void TripLeg_Node::set_type(::valhalla::TripLeg_Node_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.type)
}

// bool fork = 5;
inline bool TripLeg_Node::_internal_has_fork() const {
  return has_fork_case() == kFork;
}
inline bool TripLeg_Node::has_fork() const {
  return _internal_has_fork();
}
inline void TripLeg_Node::set_has_fork() {
  _impl_._oneof_case_[2] = kFork;
}
inline void TripLeg_Node::clear_fork() {
  if (_internal_has_fork()) {
    _impl_.has_fork_.fork_ = false;
    clear_has_has_fork();
  }
}
inline bool TripLeg_Node::_internal_fork() const {
  if (_internal_has_fork()) {
    return _impl_.has_fork_.fork_;
  }
  return false;
}
inline void TripLeg_Node::_internal_set_fork(bool value) {
  if (!_internal_has_fork()) {
    clear_has_fork();
    set_has_fork();
  }
  _impl_.has_fork_.fork_ = value;
}
inline bool TripLeg_Node::fork() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.fork)
  return _internal_fork();
}
inline void TripLeg_Node::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.fork)
}

// .valhalla.TransitPlatformInfo transit_platform_info = 6;
inline bool TripLeg_Node::_internal_has_transit_platform_info() const {
  return this != internal_default_instance() && _impl_.transit_platform_info_ != nullptr;
}
inline bool TripLeg_Node::has_transit_platform_info() const {
  return _internal_has_transit_platform_info();
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::_internal_transit_platform_info() const {
  const ::valhalla::TransitPlatformInfo* p = _impl_.transit_platform_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitPlatformInfo&>(
      ::valhalla::_TransitPlatformInfo_default_instance_);
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::transit_platform_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_platform_info)
  return _internal_transit_platform_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_platform_info(
    ::valhalla::TransitPlatformInfo* transit_platform_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_platform_info_);
  }
  _impl_.transit_platform_info_ = transit_platform_info;
  if (transit_platform_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::release_transit_platform_info() {
  
  ::valhalla::TransitPlatformInfo* temp = _impl_.transit_platform_info_;
  _impl_.transit_platform_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::unsafe_arena_release_transit_platform_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_platform_info)
  
  ::valhalla::TransitPlatformInfo* temp = _impl_.transit_platform_info_;
  _impl_.transit_platform_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::_internal_mutable_transit_platform_info() {
  
  if (_impl_.transit_platform_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitPlatformInfo>(GetArenaForAllocation());
    _impl_.transit_platform_info_ = p;
  }
  return _impl_.transit_platform_info_;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::mutable_transit_platform_info() {
  ::valhalla::TransitPlatformInfo* _msg = _internal_mutable_transit_platform_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_platform_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_platform_info_);
  }
  if (transit_platform_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_platform_info));
    if (message_arena != submessage_arena) {
      transit_platform_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_platform_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_platform_info_ = transit_platform_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}

// .valhalla.TransitStationInfo transit_station_info = 7;
inline bool TripLeg_Node::_internal_has_transit_station_info() const {
  return this != internal_default_instance() && _impl_.transit_station_info_ != nullptr;
}
inline bool TripLeg_Node::has_transit_station_info() const {
  return _internal_has_transit_station_info();
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::_internal_transit_station_info() const {
  const ::valhalla::TransitStationInfo* p = _impl_.transit_station_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitStationInfo&>(
      ::valhalla::_TransitStationInfo_default_instance_);
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::transit_station_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_station_info)
  return _internal_transit_station_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_station_info(
    ::valhalla::TransitStationInfo* transit_station_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_station_info_);
  }
  _impl_.transit_station_info_ = transit_station_info;
  if (transit_station_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::release_transit_station_info() {
  
  ::valhalla::TransitStationInfo* temp = _impl_.transit_station_info_;
  _impl_.transit_station_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::unsafe_arena_release_transit_station_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_station_info)
  
  ::valhalla::TransitStationInfo* temp = _impl_.transit_station_info_;
  _impl_.transit_station_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::_internal_mutable_transit_station_info() {
  
  if (_impl_.transit_station_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitStationInfo>(GetArenaForAllocation());
    _impl_.transit_station_info_ = p;
  }
  return _impl_.transit_station_info_;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::mutable_transit_station_info() {
  ::valhalla::TransitStationInfo* _msg = _internal_mutable_transit_station_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_station_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_station_info_);
  }
  if (transit_station_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_station_info));
    if (message_arena != submessage_arena) {
      transit_station_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_station_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_station_info_ = transit_station_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}

// .valhalla.TransitEgressInfo transit_egress_info = 10;
inline bool TripLeg_Node::_internal_has_transit_egress_info() const {
  return this != internal_default_instance() && _impl_.transit_egress_info_ != nullptr;
}
inline bool TripLeg_Node::has_transit_egress_info() const {
  return _internal_has_transit_egress_info();
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::_internal_transit_egress_info() const {
  const ::valhalla::TransitEgressInfo* p = _impl_.transit_egress_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitEgressInfo&>(
      ::valhalla::_TransitEgressInfo_default_instance_);
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::transit_egress_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_egress_info)
  return _internal_transit_egress_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_egress_info(
    ::valhalla::TransitEgressInfo* transit_egress_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_egress_info_);
  }
  _impl_.transit_egress_info_ = transit_egress_info;
  if (transit_egress_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::release_transit_egress_info() {
  
  ::valhalla::TransitEgressInfo* temp = _impl_.transit_egress_info_;
  _impl_.transit_egress_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::unsafe_arena_release_transit_egress_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_egress_info)
  
  ::valhalla::TransitEgressInfo* temp = _impl_.transit_egress_info_;
  _impl_.transit_egress_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::_internal_mutable_transit_egress_info() {
  
  if (_impl_.transit_egress_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitEgressInfo>(GetArenaForAllocation());
    _impl_.transit_egress_info_ = p;
  }
  return _impl_.transit_egress_info_;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::mutable_transit_egress_info() {
  ::valhalla::TransitEgressInfo* _msg = _internal_mutable_transit_egress_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_egress_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_egress_info_);
  }
  if (transit_egress_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_egress_info));
    if (message_arena != submessage_arena) {
      transit_egress_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_egress_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_egress_info_ = transit_egress_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}

// string time_zone = 11;
inline bool TripLeg_Node::_internal_has_time_zone() const {
  return has_time_zone_case() == kTimeZone;
}
inline bool TripLeg_Node::has_time_zone() const {
  return _internal_has_time_zone();
}
inline void TripLeg_Node::set_has_time_zone() {
  _impl_._oneof_case_[3] = kTimeZone;
}
inline void TripLeg_Node::clear_time_zone() {
  if (_internal_has_time_zone()) {
    _impl_.has_time_zone_.time_zone_.Destroy();
    clear_has_has_time_zone();
  }
}
inline const std::string& TripLeg_Node::time_zone() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_Node::set_time_zone(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    _impl_.has_time_zone_.time_zone_.InitDefault();
  }
  _impl_.has_time_zone_.time_zone_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
}
inline std::string* TripLeg_Node::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.time_zone)
  return _s;
}
inline const std::string& TripLeg_Node::_internal_time_zone() const {
  if (_internal_has_time_zone()) {
    return _impl_.has_time_zone_.time_zone_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Node::_internal_set_time_zone(const std::string& value) {
  if (!_internal_has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    _impl_.has_time_zone_.time_zone_.InitDefault();
  }
  _impl_.has_time_zone_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Node::_internal_mutable_time_zone() {
  if (!_internal_has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    _impl_.has_time_zone_.time_zone_.InitDefault();
  }
  return _impl_.has_time_zone_.time_zone_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_Node::release_time_zone() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.time_zone)
  if (_internal_has_time_zone()) {
    clear_has_has_time_zone();
    return _impl_.has_time_zone_.time_zone_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_Node::set_allocated_time_zone(std::string* time_zone) {
  if (has_has_time_zone()) {
    clear_has_time_zone();
  }
  if (time_zone != nullptr) {
    set_has_time_zone();
    _impl_.has_time_zone_.time_zone_.InitAllocated(time_zone, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.time_zone)
}

// .valhalla.TripLeg.PathCost cost = 12;
inline bool TripLeg_Node::_internal_has_cost() const {
  return this != internal_default_instance() && _impl_.cost_ != nullptr;
}
inline bool TripLeg_Node::has_cost() const {
  return _internal_has_cost();
}
inline void TripLeg_Node::clear_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.cost_ != nullptr) {
    delete _impl_.cost_;
  }
  _impl_.cost_ = nullptr;
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::_internal_cost() const {
  const ::valhalla::TripLeg_PathCost* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_PathCost&>(
      ::valhalla::_TripLeg_PathCost_default_instance_);
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.cost)
  return _internal_cost();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_cost(
    ::valhalla::TripLeg_PathCost* cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.cost)
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::release_cost() {
  
  ::valhalla::TripLeg_PathCost* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::unsafe_arena_release_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.cost)
  
  ::valhalla::TripLeg_PathCost* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::_internal_mutable_cost() {
  
  if (_impl_.cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_PathCost>(GetArenaForAllocation());
    _impl_.cost_ = p;
  }
  return _impl_.cost_;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_cost() {
  ::valhalla::TripLeg_PathCost* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.cost)
  return _msg;
}
inline void TripLeg_Node::set_allocated_cost(::valhalla::TripLeg_PathCost* cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cost_;
  }
  if (cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cost);
    if (message_arena != submessage_arena) {
      cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cost_ = cost;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.cost)
}

// repeated .valhalla.TripLeg.PathCost recosts = 13;
inline int TripLeg_Node::_internal_recosts_size() const {
  return _impl_.recosts_.size();
}
inline int TripLeg_Node::recosts_size() const {
  return _internal_recosts_size();
}
inline void TripLeg_Node::clear_recosts() {
  _impl_.recosts_.Clear();
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_recosts(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.recosts)
  return _impl_.recosts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
TripLeg_Node::mutable_recosts() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.recosts)
  return &_impl_.recosts_;
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::_internal_recosts(int index) const {
  return _impl_.recosts_.Get(index);
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::recosts(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.recosts)
  return _internal_recosts(index);
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::_internal_add_recosts() {
  return _impl_.recosts_.Add();
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::add_recosts() {
  ::valhalla::TripLeg_PathCost* _add = _internal_add_recosts();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.recosts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
TripLeg_Node::recosts() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.recosts)
  return _impl_.recosts_;
}

// .valhalla.BikeShareStationInfo bss_info = 14;
inline bool TripLeg_Node::_internal_has_bss_info() const {
  return this != internal_default_instance() && _impl_.bss_info_ != nullptr;
}
inline bool TripLeg_Node::has_bss_info() const {
  return _internal_has_bss_info();
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::_internal_bss_info() const {
  const ::valhalla::BikeShareStationInfo* p = _impl_.bss_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BikeShareStationInfo&>(
      ::valhalla::_BikeShareStationInfo_default_instance_);
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.bss_info)
  return _internal_bss_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_bss_info(
    ::valhalla::BikeShareStationInfo* bss_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bss_info_);
  }
  _impl_.bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.bss_info)
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::release_bss_info() {
  
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::unsafe_arena_release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
  return temp;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::_internal_mutable_bss_info() {
  
  if (_impl_.bss_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BikeShareStationInfo>(GetArenaForAllocation());
    _impl_.bss_info_ = p;
  }
  return _impl_.bss_info_;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::mutable_bss_info() {
  ::valhalla::BikeShareStationInfo* _msg = _internal_mutable_bss_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.bss_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bss_info_);
  }
  if (bss_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bss_info));
    if (message_arena != submessage_arena) {
      bss_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bss_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bss_info_ = bss_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.bss_info)
}

inline bool TripLeg_Node::has_has_admin_index() const {
  return has_admin_index_case() != HAS_ADMIN_INDEX_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_admin_index() {
  _impl_._oneof_case_[0] = HAS_ADMIN_INDEX_NOT_SET;
}
inline bool TripLeg_Node::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_type() {
  _impl_._oneof_case_[1] = HAS_TYPE_NOT_SET;
}
inline bool TripLeg_Node::has_has_fork() const {
  return has_fork_case() != HAS_FORK_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_fork() {
  _impl_._oneof_case_[2] = HAS_FORK_NOT_SET;
}
inline bool TripLeg_Node::has_has_time_zone() const {
  return has_time_zone_case() != HAS_TIME_ZONE_NOT_SET;
}
inline void TripLeg_Node::clear_has_has_time_zone() {
  _impl_._oneof_case_[3] = HAS_TIME_ZONE_NOT_SET;
}
inline TripLeg_Node::HasAdminIndexCase TripLeg_Node::has_admin_index_case() const {
  return TripLeg_Node::HasAdminIndexCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Node::HasTypeCase TripLeg_Node::has_type_case() const {
  return TripLeg_Node::HasTypeCase(_impl_._oneof_case_[1]);
}
inline TripLeg_Node::HasForkCase TripLeg_Node::has_fork_case() const {
  return TripLeg_Node::HasForkCase(_impl_._oneof_case_[2]);
}
inline TripLeg_Node::HasTimeZoneCase TripLeg_Node::has_time_zone_case() const {
  return TripLeg_Node::HasTimeZoneCase(_impl_._oneof_case_[3]);
}
// -------------------------------------------------------------------

// TripLeg_Admin

// string country_code = 1;
inline bool TripLeg_Admin::_internal_has_country_code() const {
  return has_country_code_case() == kCountryCode;
}
inline bool TripLeg_Admin::has_country_code() const {
  return _internal_has_country_code();
}
inline void TripLeg_Admin::set_has_country_code() {
  _impl_._oneof_case_[0] = kCountryCode;
}
inline void TripLeg_Admin::clear_country_code() {
  if (_internal_has_country_code()) {
    _impl_.has_country_code_.country_code_.Destroy();
    clear_has_has_country_code();
  }
}
inline const std::string& TripLeg_Admin::country_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_Admin::set_country_code(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    _impl_.has_country_code_.country_code_.InitDefault();
  }
  _impl_.has_country_code_.country_code_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
}
inline std::string* TripLeg_Admin::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_code)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_country_code() const {
  if (_internal_has_country_code()) {
    return _impl_.has_country_code_.country_code_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::_internal_set_country_code(const std::string& value) {
  if (!_internal_has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    _impl_.has_country_code_.country_code_.InitDefault();
  }
  _impl_.has_country_code_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_country_code() {
  if (!_internal_has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    _impl_.has_country_code_.country_code_.InitDefault();
  }
  return _impl_.has_country_code_.country_code_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_country_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_code)
  if (_internal_has_country_code()) {
    clear_has_has_country_code();
    return _impl_.has_country_code_.country_code_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_Admin::set_allocated_country_code(std::string* country_code) {
  if (has_has_country_code()) {
    clear_has_country_code();
  }
  if (country_code != nullptr) {
    set_has_country_code();
    _impl_.has_country_code_.country_code_.InitAllocated(country_code, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_code)
}

// string country_text = 2;
inline bool TripLeg_Admin::_internal_has_country_text() const {
  return has_country_text_case() == kCountryText;
}
inline bool TripLeg_Admin::has_country_text() const {
  return _internal_has_country_text();
}
inline void TripLeg_Admin::set_has_country_text() {
  _impl_._oneof_case_[1] = kCountryText;
}
inline void TripLeg_Admin::clear_country_text() {
  if (_internal_has_country_text()) {
    _impl_.has_country_text_.country_text_.Destroy();
    clear_has_has_country_text();
  }
}
inline const std::string& TripLeg_Admin::country_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_text)
  return _internal_country_text();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_Admin::set_country_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    _impl_.has_country_text_.country_text_.InitDefault();
  }
  _impl_.has_country_text_.country_text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
}
inline std::string* TripLeg_Admin::mutable_country_text() {
  std::string* _s = _internal_mutable_country_text();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_text)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_country_text() const {
  if (_internal_has_country_text()) {
    return _impl_.has_country_text_.country_text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::_internal_set_country_text(const std::string& value) {
  if (!_internal_has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    _impl_.has_country_text_.country_text_.InitDefault();
  }
  _impl_.has_country_text_.country_text_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_country_text() {
  if (!_internal_has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    _impl_.has_country_text_.country_text_.InitDefault();
  }
  return _impl_.has_country_text_.country_text_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_country_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_text)
  if (_internal_has_country_text()) {
    clear_has_has_country_text();
    return _impl_.has_country_text_.country_text_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_Admin::set_allocated_country_text(std::string* country_text) {
  if (has_has_country_text()) {
    clear_has_country_text();
  }
  if (country_text != nullptr) {
    set_has_country_text();
    _impl_.has_country_text_.country_text_.InitAllocated(country_text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_text)
}

// string state_code = 3;
inline bool TripLeg_Admin::_internal_has_state_code() const {
  return has_state_code_case() == kStateCode;
}
inline bool TripLeg_Admin::has_state_code() const {
  return _internal_has_state_code();
}
inline void TripLeg_Admin::set_has_state_code() {
  _impl_._oneof_case_[2] = kStateCode;
}
inline void TripLeg_Admin::clear_state_code() {
  if (_internal_has_state_code()) {
    _impl_.has_state_code_.state_code_.Destroy();
    clear_has_has_state_code();
  }
}
inline const std::string& TripLeg_Admin::state_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_code)
  return _internal_state_code();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_Admin::set_state_code(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    _impl_.has_state_code_.state_code_.InitDefault();
  }
  _impl_.has_state_code_.state_code_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
}
inline std::string* TripLeg_Admin::mutable_state_code() {
  std::string* _s = _internal_mutable_state_code();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_code)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_state_code() const {
  if (_internal_has_state_code()) {
    return _impl_.has_state_code_.state_code_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::_internal_set_state_code(const std::string& value) {
  if (!_internal_has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    _impl_.has_state_code_.state_code_.InitDefault();
  }
  _impl_.has_state_code_.state_code_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_state_code() {
  if (!_internal_has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    _impl_.has_state_code_.state_code_.InitDefault();
  }
  return _impl_.has_state_code_.state_code_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_state_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_code)
  if (_internal_has_state_code()) {
    clear_has_has_state_code();
    return _impl_.has_state_code_.state_code_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_Admin::set_allocated_state_code(std::string* state_code) {
  if (has_has_state_code()) {
    clear_has_state_code();
  }
  if (state_code != nullptr) {
    set_has_state_code();
    _impl_.has_state_code_.state_code_.InitAllocated(state_code, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_code)
}

// string state_text = 4;
inline bool TripLeg_Admin::_internal_has_state_text() const {
  return has_state_text_case() == kStateText;
}
inline bool TripLeg_Admin::has_state_text() const {
  return _internal_has_state_text();
}
inline void TripLeg_Admin::set_has_state_text() {
  _impl_._oneof_case_[3] = kStateText;
}
inline void TripLeg_Admin::clear_state_text() {
  if (_internal_has_state_text()) {
    _impl_.has_state_text_.state_text_.Destroy();
    clear_has_has_state_text();
  }
}
inline const std::string& TripLeg_Admin::state_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_text)
  return _internal_state_text();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg_Admin::set_state_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    _impl_.has_state_text_.state_text_.InitDefault();
  }
  _impl_.has_state_text_.state_text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
}
inline std::string* TripLeg_Admin::mutable_state_text() {
  std::string* _s = _internal_mutable_state_text();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_text)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_state_text() const {
  if (_internal_has_state_text()) {
    return _impl_.has_state_text_.state_text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg_Admin::_internal_set_state_text(const std::string& value) {
  if (!_internal_has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    _impl_.has_state_text_.state_text_.InitDefault();
  }
  _impl_.has_state_text_.state_text_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::_internal_mutable_state_text() {
  if (!_internal_has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    _impl_.has_state_text_.state_text_.InitDefault();
  }
  return _impl_.has_state_text_.state_text_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg_Admin::release_state_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_text)
  if (_internal_has_state_text()) {
    clear_has_has_state_text();
    return _impl_.has_state_text_.state_text_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg_Admin::set_allocated_state_text(std::string* state_text) {
  if (has_has_state_text()) {
    clear_has_state_text();
  }
  if (state_text != nullptr) {
    set_has_state_text();
    _impl_.has_state_text_.state_text_.InitAllocated(state_text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_text)
}

inline bool TripLeg_Admin::has_has_country_code() const {
  return has_country_code_case() != HAS_COUNTRY_CODE_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_country_code() {
  _impl_._oneof_case_[0] = HAS_COUNTRY_CODE_NOT_SET;
}
inline bool TripLeg_Admin::has_has_country_text() const {
  return has_country_text_case() != HAS_COUNTRY_TEXT_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_country_text() {
  _impl_._oneof_case_[1] = HAS_COUNTRY_TEXT_NOT_SET;
}
inline bool TripLeg_Admin::has_has_state_code() const {
  return has_state_code_case() != HAS_STATE_CODE_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_state_code() {
  _impl_._oneof_case_[2] = HAS_STATE_CODE_NOT_SET;
}
inline bool TripLeg_Admin::has_has_state_text() const {
  return has_state_text_case() != HAS_STATE_TEXT_NOT_SET;
}
inline void TripLeg_Admin::clear_has_has_state_text() {
  _impl_._oneof_case_[3] = HAS_STATE_TEXT_NOT_SET;
}
inline TripLeg_Admin::HasCountryCodeCase TripLeg_Admin::has_country_code_case() const {
  return TripLeg_Admin::HasCountryCodeCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Admin::HasCountryTextCase TripLeg_Admin::has_country_text_case() const {
  return TripLeg_Admin::HasCountryTextCase(_impl_._oneof_case_[1]);
}
inline TripLeg_Admin::HasStateCodeCase TripLeg_Admin::has_state_code_case() const {
  return TripLeg_Admin::HasStateCodeCase(_impl_._oneof_case_[2]);
}
inline TripLeg_Admin::HasStateTextCase TripLeg_Admin::has_state_text_case() const {
  return TripLeg_Admin::HasStateTextCase(_impl_._oneof_case_[3]);
}
// -------------------------------------------------------------------

// TripLeg_ShapeAttributes

// repeated uint32 time = 1 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_time_size() const {
  return _impl_.time_.size();
}
inline int TripLeg_ShapeAttributes::time_size() const {
  return _internal_time_size();
}
inline void TripLeg_ShapeAttributes::clear_time() {
  _impl_.time_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_time(int index) const {
  return _impl_.time_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::time(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_time(index);
}
inline void TripLeg_ShapeAttributes::set_time(int index, uint32_t value) {
  _impl_.time_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.time)
}
inline void TripLeg_ShapeAttributes::_internal_add_time(uint32_t value) {
  _impl_.time_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_time(uint32_t value) {
  _internal_add_time(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.time)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_time() const {
  return _impl_.time_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::time() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_time();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_time() {
  return &_impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_time() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_mutable_time();
}

// repeated uint32 length = 2 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_length_size() const {
  return _impl_.length_.size();
}
inline int TripLeg_ShapeAttributes::length_size() const {
  return _internal_length_size();
}
inline void TripLeg_ShapeAttributes::clear_length() {
  _impl_.length_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_length(int index) const {
  return _impl_.length_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::length(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_length(index);
}
inline void TripLeg_ShapeAttributes::set_length(int index, uint32_t value) {
  _impl_.length_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.length)
}
inline void TripLeg_ShapeAttributes::_internal_add_length(uint32_t value) {
  _impl_.length_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_length(uint32_t value) {
  _internal_add_length(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_length() const {
  return _impl_.length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::length() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_length() {
  return &_impl_.length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_length() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_mutable_length();
}

// repeated uint32 speed = 3 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_speed_size() const {
  return _impl_.speed_.size();
}
inline int TripLeg_ShapeAttributes::speed_size() const {
  return _internal_speed_size();
}
inline void TripLeg_ShapeAttributes::clear_speed() {
  _impl_.speed_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_speed(int index) const {
  return _impl_.speed_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::speed(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_speed(index);
}
inline void TripLeg_ShapeAttributes::set_speed(int index, uint32_t value) {
  _impl_.speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed)
}
inline void TripLeg_ShapeAttributes::_internal_add_speed(uint32_t value) {
  _impl_.speed_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_speed(uint32_t value) {
  _internal_add_speed(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_speed() const {
  return _impl_.speed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::speed() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_speed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_speed() {
  return &_impl_.speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_speed() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_mutable_speed();
}

// repeated uint32 speed_limit = 5 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_speed_limit_size() const {
  return _impl_.speed_limit_.size();
}
inline int TripLeg_ShapeAttributes::speed_limit_size() const {
  return _internal_speed_limit_size();
}
inline void TripLeg_ShapeAttributes::clear_speed_limit() {
  _impl_.speed_limit_.Clear();
}
inline uint32_t TripLeg_ShapeAttributes::_internal_speed_limit(int index) const {
  return _impl_.speed_limit_.Get(index);
}
inline uint32_t TripLeg_ShapeAttributes::speed_limit(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_speed_limit(index);
}
inline void TripLeg_ShapeAttributes::set_speed_limit(int index, uint32_t value) {
  _impl_.speed_limit_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline void TripLeg_ShapeAttributes::_internal_add_speed_limit(uint32_t value) {
  _impl_.speed_limit_.Add(value);
}
inline void TripLeg_ShapeAttributes::add_speed_limit(uint32_t value) {
  _internal_add_speed_limit(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::_internal_speed_limit() const {
  return _impl_.speed_limit_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TripLeg_ShapeAttributes::speed_limit() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_speed_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::_internal_mutable_speed_limit() {
  return &_impl_.speed_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TripLeg_ShapeAttributes::mutable_speed_limit() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_mutable_speed_limit();
}

// -------------------------------------------------------------------

// TripLeg_Incident

// .valhalla.IncidentsTile.Metadata metadata = 1;
inline bool TripLeg_Incident::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool TripLeg_Incident::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::_internal_metadata() const {
  const ::valhalla::IncidentsTile_Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::IncidentsTile_Metadata&>(
      ::valhalla::_IncidentsTile_Metadata_default_instance_);
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::metadata() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.metadata)
  return _internal_metadata();
}
inline void TripLeg_Incident::unsafe_arena_set_allocated_metadata(
    ::valhalla::IncidentsTile_Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Incident.metadata)
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::release_metadata() {
  
  ::valhalla::IncidentsTile_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Incident.metadata)
  
  ::valhalla::IncidentsTile_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::IncidentsTile_Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::mutable_metadata() {
  ::valhalla::IncidentsTile_Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Incident.metadata)
  return _msg;
}
inline void TripLeg_Incident::set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Incident.metadata)
}

// uint32 begin_shape_index = 3;
inline bool TripLeg_Incident::_internal_has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline bool TripLeg_Incident::has_begin_shape_index() const {
  return _internal_has_begin_shape_index();
}
inline void TripLeg_Incident::set_has_begin_shape_index() {
  _impl_._oneof_case_[0] = kBeginShapeIndex;
}
inline void TripLeg_Incident::clear_begin_shape_index() {
  if (_internal_has_begin_shape_index()) {
    _impl_.has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline uint32_t TripLeg_Incident::_internal_begin_shape_index() const {
  if (_internal_has_begin_shape_index()) {
    return _impl_.has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Incident::_internal_set_begin_shape_index(uint32_t value) {
  if (!_internal_has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  _impl_.has_begin_shape_index_.begin_shape_index_ = value;
}
inline uint32_t TripLeg_Incident::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Incident::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.begin_shape_index)
}

// uint32 end_shape_index = 4;
inline bool TripLeg_Incident::_internal_has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline bool TripLeg_Incident::has_end_shape_index() const {
  return _internal_has_end_shape_index();
}
inline void TripLeg_Incident::set_has_end_shape_index() {
  _impl_._oneof_case_[1] = kEndShapeIndex;
}
inline void TripLeg_Incident::clear_end_shape_index() {
  if (_internal_has_end_shape_index()) {
    _impl_.has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline uint32_t TripLeg_Incident::_internal_end_shape_index() const {
  if (_internal_has_end_shape_index()) {
    return _impl_.has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Incident::_internal_set_end_shape_index(uint32_t value) {
  if (!_internal_has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  _impl_.has_end_shape_index_.end_shape_index_ = value;
}
inline uint32_t TripLeg_Incident::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Incident::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.end_shape_index)
}

inline bool TripLeg_Incident::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Incident::clear_has_has_begin_shape_index() {
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Incident::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Incident::clear_has_has_end_shape_index() {
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline TripLeg_Incident::HasBeginShapeIndexCase TripLeg_Incident::has_begin_shape_index_case() const {
  return TripLeg_Incident::HasBeginShapeIndexCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Incident::HasEndShapeIndexCase TripLeg_Incident::has_end_shape_index_case() const {
  return TripLeg_Incident::HasEndShapeIndexCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg_Closure

// uint32 begin_shape_index = 1;
inline bool TripLeg_Closure::_internal_has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline bool TripLeg_Closure::has_begin_shape_index() const {
  return _internal_has_begin_shape_index();
}
inline void TripLeg_Closure::set_has_begin_shape_index() {
  _impl_._oneof_case_[0] = kBeginShapeIndex;
}
inline void TripLeg_Closure::clear_begin_shape_index() {
  if (_internal_has_begin_shape_index()) {
    _impl_.has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline uint32_t TripLeg_Closure::_internal_begin_shape_index() const {
  if (_internal_has_begin_shape_index()) {
    return _impl_.has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::_internal_set_begin_shape_index(uint32_t value) {
  if (!_internal_has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  _impl_.has_begin_shape_index_.begin_shape_index_ = value;
}
inline uint32_t TripLeg_Closure::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Closure::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.begin_shape_index)
}

// uint32 end_shape_index = 2;
inline bool TripLeg_Closure::_internal_has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline bool TripLeg_Closure::has_end_shape_index() const {
  return _internal_has_end_shape_index();
}
inline void TripLeg_Closure::set_has_end_shape_index() {
  _impl_._oneof_case_[1] = kEndShapeIndex;
}
inline void TripLeg_Closure::clear_end_shape_index() {
  if (_internal_has_end_shape_index()) {
    _impl_.has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline uint32_t TripLeg_Closure::_internal_end_shape_index() const {
  if (_internal_has_end_shape_index()) {
    return _impl_.has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::_internal_set_end_shape_index(uint32_t value) {
  if (!_internal_has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  _impl_.has_end_shape_index_.end_shape_index_ = value;
}
inline uint32_t TripLeg_Closure::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Closure::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.end_shape_index)
}

inline bool TripLeg_Closure::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_begin_shape_index() {
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Closure::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_end_shape_index() {
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline TripLeg_Closure::HasBeginShapeIndexCase TripLeg_Closure::has_begin_shape_index_case() const {
  return TripLeg_Closure::HasBeginShapeIndexCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Closure::HasEndShapeIndexCase TripLeg_Closure::has_end_shape_index_case() const {
  return TripLeg_Closure::HasEndShapeIndexCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg

// uint64 osm_changeset = 1;
inline bool TripLeg::_internal_has_osm_changeset() const {
  return has_osm_changeset_case() == kOsmChangeset;
}
inline bool TripLeg::has_osm_changeset() const {
  return _internal_has_osm_changeset();
}
inline void TripLeg::set_has_osm_changeset() {
  _impl_._oneof_case_[0] = kOsmChangeset;
}
inline void TripLeg::clear_osm_changeset() {
  if (_internal_has_osm_changeset()) {
    _impl_.has_osm_changeset_.osm_changeset_ = uint64_t{0u};
    clear_has_has_osm_changeset();
  }
}
inline uint64_t TripLeg::_internal_osm_changeset() const {
  if (_internal_has_osm_changeset()) {
    return _impl_.has_osm_changeset_.osm_changeset_;
  }
  return uint64_t{0u};
}
inline void TripLeg::_internal_set_osm_changeset(uint64_t value) {
  if (!_internal_has_osm_changeset()) {
    clear_has_osm_changeset();
    set_has_osm_changeset();
  }
  _impl_.has_osm_changeset_.osm_changeset_ = value;
}
inline uint64_t TripLeg::osm_changeset() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.osm_changeset)
  return _internal_osm_changeset();
}
inline void TripLeg::set_osm_changeset(uint64_t value) {
  _internal_set_osm_changeset(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.osm_changeset)
}

// uint64 trip_id = 2;
inline bool TripLeg::_internal_has_trip_id() const {
  return has_trip_id_case() == kTripId;
}
inline bool TripLeg::has_trip_id() const {
  return _internal_has_trip_id();
}
inline void TripLeg::set_has_trip_id() {
  _impl_._oneof_case_[1] = kTripId;
}
inline void TripLeg::clear_trip_id() {
  if (_internal_has_trip_id()) {
    _impl_.has_trip_id_.trip_id_ = uint64_t{0u};
    clear_has_has_trip_id();
  }
}
inline uint64_t TripLeg::_internal_trip_id() const {
  if (_internal_has_trip_id()) {
    return _impl_.has_trip_id_.trip_id_;
  }
  return uint64_t{0u};
}
inline void TripLeg::_internal_set_trip_id(uint64_t value) {
  if (!_internal_has_trip_id()) {
    clear_has_trip_id();
    set_has_trip_id();
  }
  _impl_.has_trip_id_.trip_id_ = value;
}
inline uint64_t TripLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.trip_id)
  return _internal_trip_id();
}
inline void TripLeg::set_trip_id(uint64_t value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.trip_id)
}

// uint32 leg_id = 3;
inline bool TripLeg::_internal_has_leg_id() const {
  return has_leg_id_case() == kLegId;
}
inline bool TripLeg::has_leg_id() const {
  return _internal_has_leg_id();
}
inline void TripLeg::set_has_leg_id() {
  _impl_._oneof_case_[2] = kLegId;
}
inline void TripLeg::clear_leg_id() {
  if (_internal_has_leg_id()) {
    _impl_.has_leg_id_.leg_id_ = 0u;
    clear_has_has_leg_id();
  }
}
inline uint32_t TripLeg::_internal_leg_id() const {
  if (_internal_has_leg_id()) {
    return _impl_.has_leg_id_.leg_id_;
  }
  return 0u;
}
inline void TripLeg::_internal_set_leg_id(uint32_t value) {
  if (!_internal_has_leg_id()) {
    clear_has_leg_id();
    set_has_leg_id();
  }
  _impl_.has_leg_id_.leg_id_ = value;
}
inline uint32_t TripLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_id)
  return _internal_leg_id();
}
inline void TripLeg::set_leg_id(uint32_t value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_id)
}

// uint32 leg_count = 4;
inline bool TripLeg::_internal_has_leg_count() const {
  return has_leg_count_case() == kLegCount;
}
inline bool TripLeg::has_leg_count() const {
  return _internal_has_leg_count();
}
inline void TripLeg::set_has_leg_count() {
  _impl_._oneof_case_[3] = kLegCount;
}
inline void TripLeg::clear_leg_count() {
  if (_internal_has_leg_count()) {
    _impl_.has_leg_count_.leg_count_ = 0u;
    clear_has_has_leg_count();
  }
}
inline uint32_t TripLeg::_internal_leg_count() const {
  if (_internal_has_leg_count()) {
    return _impl_.has_leg_count_.leg_count_;
  }
  return 0u;
}
inline void TripLeg::_internal_set_leg_count(uint32_t value) {
  if (!_internal_has_leg_count()) {
    clear_has_leg_count();
    set_has_leg_count();
  }
  _impl_.has_leg_count_.leg_count_ = value;
}
inline uint32_t TripLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_count)
  return _internal_leg_count();
}
inline void TripLeg::set_leg_count(uint32_t value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_count)
}

// repeated .valhalla.Location location = 5;
inline int TripLeg::_internal_location_size() const {
  return _impl_.location_.size();
}
inline int TripLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* TripLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.location)
  return _impl_.location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
TripLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.location)
  return &_impl_.location_;
}
inline const ::valhalla::Location& TripLeg::_internal_location(int index) const {
  return _impl_.location_.Get(index);
}
inline const ::valhalla::Location& TripLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.location)
  return _internal_location(index);
}
inline ::valhalla::Location* TripLeg::_internal_add_location() {
  return _impl_.location_.Add();
}
inline ::valhalla::Location* TripLeg::add_location() {
  ::valhalla::Location* _add = _internal_add_location();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.location)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
TripLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.location)
  return _impl_.location_;
}

// repeated .valhalla.TripLeg.Node node = 6;
inline int TripLeg::_internal_node_size() const {
  return _impl_.node_.size();
}
inline int TripLeg::node_size() const {
  return _internal_node_size();
}
inline void TripLeg::clear_node() {
  _impl_.node_.Clear();
}
inline ::valhalla::TripLeg_Node* TripLeg::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.node)
  return _impl_.node_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >*
TripLeg::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.node)
  return &_impl_.node_;
}
inline const ::valhalla::TripLeg_Node& TripLeg::_internal_node(int index) const {
  return _impl_.node_.Get(index);
}
inline const ::valhalla::TripLeg_Node& TripLeg::node(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.node)
  return _internal_node(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::_internal_add_node() {
  return _impl_.node_.Add();
}
inline ::valhalla::TripLeg_Node* TripLeg::add_node() {
  ::valhalla::TripLeg_Node* _add = _internal_add_node();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.node)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Node >&
TripLeg::node() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.node)
  return _impl_.node_;
}

// repeated .valhalla.TripLeg.Admin admin = 7;
inline int TripLeg::_internal_admin_size() const {
  return _impl_.admin_.size();
}
inline int TripLeg::admin_size() const {
  return _internal_admin_size();
}
inline void TripLeg::clear_admin() {
  _impl_.admin_.Clear();
}
inline ::valhalla::TripLeg_Admin* TripLeg::mutable_admin(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.admin)
  return _impl_.admin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
TripLeg::mutable_admin() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.admin)
  return &_impl_.admin_;
}
inline const ::valhalla::TripLeg_Admin& TripLeg::_internal_admin(int index) const {
  return _impl_.admin_.Get(index);
}
inline const ::valhalla::TripLeg_Admin& TripLeg::admin(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.admin)
  return _internal_admin(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::_internal_add_admin() {
  return _impl_.admin_.Add();
}
inline ::valhalla::TripLeg_Admin* TripLeg::add_admin() {
  ::valhalla::TripLeg_Admin* _add = _internal_add_admin();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.admin)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
TripLeg::admin() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.admin)
  return _impl_.admin_;
}

// string shape = 8;
inline bool TripLeg::_internal_has_shape() const {
  return has_shape_case() == kShape;
}
inline bool TripLeg::has_shape() const {
  return _internal_has_shape();
}
inline void TripLeg::set_has_shape() {
  _impl_._oneof_case_[4] = kShape;
}
inline void TripLeg::clear_shape() {
  if (_internal_has_shape()) {
    _impl_.has_shape_.shape_.Destroy();
    clear_has_has_shape();
  }
}
inline const std::string& TripLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape)
  return _internal_shape();
}
template <typename ArgT0, typename... ArgT>
inline void TripLeg::set_shape(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_shape()) {
    clear_has_shape();
    set_has_shape();
    _impl_.has_shape_.shape_.InitDefault();
  }
  _impl_.has_shape_.shape_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
}
inline std::string* TripLeg::mutable_shape() {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape)
  return _s;
}
inline const std::string& TripLeg::_internal_shape() const {
  if (_internal_has_shape()) {
    return _impl_.has_shape_.shape_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TripLeg::_internal_set_shape(const std::string& value) {
  if (!_internal_has_shape()) {
    clear_has_shape();
    set_has_shape();
    _impl_.has_shape_.shape_.InitDefault();
  }
  _impl_.has_shape_.shape_.Set(value, GetArenaForAllocation());
}
inline std::string* TripLeg::_internal_mutable_shape() {
  if (!_internal_has_shape()) {
    clear_has_shape();
    set_has_shape();
    _impl_.has_shape_.shape_.InitDefault();
  }
  return _impl_.has_shape_.shape_.Mutable(      GetArenaForAllocation());
}
inline std::string* TripLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape)
  if (_internal_has_shape()) {
    clear_has_has_shape();
    return _impl_.has_shape_.shape_.Release();
  } else {
    return nullptr;
  }
}
inline void TripLeg::set_allocated_shape(std::string* shape) {
  if (has_has_shape()) {
    clear_has_shape();
  }
  if (shape != nullptr) {
    set_has_shape();
    _impl_.has_shape_.shape_.InitAllocated(shape, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape)
}

// .valhalla.BoundingBox bbox = 9;
inline bool TripLeg::_internal_has_bbox() const {
  return this != internal_default_instance() && _impl_.bbox_ != nullptr;
}
inline bool TripLeg::has_bbox() const {
  return _internal_has_bbox();
}
inline const ::valhalla::BoundingBox& TripLeg::_internal_bbox() const {
  const ::valhalla::BoundingBox* p = _impl_.bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(
      ::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& TripLeg::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.bbox)
  return _internal_bbox();
}
inline void TripLeg::unsafe_arena_set_allocated_bbox(
    ::valhalla::BoundingBox* bbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  _impl_.bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.bbox)
}
inline ::valhalla::BoundingBox* TripLeg::release_bbox() {
  
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BoundingBox* TripLeg::unsafe_arena_release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.bbox)
  
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* TripLeg::_internal_mutable_bbox() {
  
  if (_impl_.bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArenaForAllocation());
    _impl_.bbox_ = p;
  }
  return _impl_.bbox_;
}
inline ::valhalla::BoundingBox* TripLeg::mutable_bbox() {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.bbox)
  return _msg;
}
inline void TripLeg::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  if (bbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox));
    if (message_arena != submessage_arena) {
      bbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.bbox)
}

// .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
inline bool TripLeg::_internal_has_shape_attributes() const {
  return this != internal_default_instance() && _impl_.shape_attributes_ != nullptr;
}
inline bool TripLeg::has_shape_attributes() const {
  return _internal_has_shape_attributes();
}
inline void TripLeg::clear_shape_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.shape_attributes_ != nullptr) {
    delete _impl_.shape_attributes_;
  }
  _impl_.shape_attributes_ = nullptr;
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::_internal_shape_attributes() const {
  const ::valhalla::TripLeg_ShapeAttributes* p = _impl_.shape_attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_ShapeAttributes&>(
      ::valhalla::_TripLeg_ShapeAttributes_default_instance_);
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::shape_attributes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape_attributes)
  return _internal_shape_attributes();
}
inline void TripLeg::unsafe_arena_set_allocated_shape_attributes(
    ::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shape_attributes_);
  }
  _impl_.shape_attributes_ = shape_attributes;
  if (shape_attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.shape_attributes)
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::release_shape_attributes() {
  
  ::valhalla::TripLeg_ShapeAttributes* temp = _impl_.shape_attributes_;
  _impl_.shape_attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::unsafe_arena_release_shape_attributes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape_attributes)
  
  ::valhalla::TripLeg_ShapeAttributes* temp = _impl_.shape_attributes_;
  _impl_.shape_attributes_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::_internal_mutable_shape_attributes() {
  
  if (_impl_.shape_attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_ShapeAttributes>(GetArenaForAllocation());
    _impl_.shape_attributes_ = p;
  }
  return _impl_.shape_attributes_;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::mutable_shape_attributes() {
  ::valhalla::TripLeg_ShapeAttributes* _msg = _internal_mutable_shape_attributes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape_attributes)
  return _msg;
}
inline void TripLeg::set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shape_attributes_;
  }
  if (shape_attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape_attributes);
    if (message_arena != submessage_arena) {
      shape_attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape_attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shape_attributes_ = shape_attributes;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape_attributes)
}

// repeated .valhalla.TripLeg.Incident incidents = 11;
inline int TripLeg::_internal_incidents_size() const {
  return _impl_.incidents_.size();
}
inline int TripLeg::incidents_size() const {
  return _internal_incidents_size();
}
inline void TripLeg::clear_incidents() {
  _impl_.incidents_.Clear();
}
inline ::valhalla::TripLeg_Incident* TripLeg::mutable_incidents(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.incidents)
  return _impl_.incidents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
TripLeg::mutable_incidents() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.incidents)
  return &_impl_.incidents_;
}
inline const ::valhalla::TripLeg_Incident& TripLeg::_internal_incidents(int index) const {
  return _impl_.incidents_.Get(index);
}
inline const ::valhalla::TripLeg_Incident& TripLeg::incidents(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.incidents)
  return _internal_incidents(index);
}
inline ::valhalla::TripLeg_Incident* TripLeg::_internal_add_incidents() {
  return _impl_.incidents_.Add();
}
inline ::valhalla::TripLeg_Incident* TripLeg::add_incidents() {
  ::valhalla::TripLeg_Incident* _add = _internal_add_incidents();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.incidents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
TripLeg::incidents() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.incidents)
  return _impl_.incidents_;
}

// repeated string algorithms = 12;
inline int TripLeg::_internal_algorithms_size() const {
  return _impl_.algorithms_.size();
}
inline int TripLeg::algorithms_size() const {
  return _internal_algorithms_size();
}
inline void TripLeg::clear_algorithms() {
  _impl_.algorithms_.Clear();
}
inline std::string* TripLeg::add_algorithms() {
  std::string* _s = _internal_add_algorithms();
  // @@protoc_insertion_point(field_add_mutable:valhalla.TripLeg.algorithms)
  return _s;
}
inline const std::string& TripLeg::_internal_algorithms(int index) const {
  return _impl_.algorithms_.Get(index);
}
inline const std::string& TripLeg::algorithms(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.algorithms)
  return _internal_algorithms(index);
}
inline std::string* TripLeg::mutable_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.algorithms)
  return _impl_.algorithms_.Mutable(index);
}
inline void TripLeg::set_algorithms(int index, const std::string& value) {
  _impl_.algorithms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, std::string&& value) {
  _impl_.algorithms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.algorithms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value, size_t size) {
  _impl_.algorithms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.algorithms)
}
inline std::string* TripLeg::_internal_add_algorithms() {
  return _impl_.algorithms_.Add();
}
inline void TripLeg::add_algorithms(const std::string& value) {
  _impl_.algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(std::string&& value) {
  _impl_.algorithms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value, size_t size) {
  _impl_.algorithms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.TripLeg.algorithms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TripLeg::algorithms() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.algorithms)
  return _impl_.algorithms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TripLeg::mutable_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.algorithms)
  return &_impl_.algorithms_;
}

// repeated .valhalla.TripLeg.Closure closures = 13;
inline int TripLeg::_internal_closures_size() const {
  return _impl_.closures_.size();
}
inline int TripLeg::closures_size() const {
  return _internal_closures_size();
}
inline void TripLeg::clear_closures() {
  _impl_.closures_.Clear();
}
inline ::valhalla::TripLeg_Closure* TripLeg::mutable_closures(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.closures)
  return _impl_.closures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
TripLeg::mutable_closures() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.closures)
  return &_impl_.closures_;
}
inline const ::valhalla::TripLeg_Closure& TripLeg::_internal_closures(int index) const {
  return _impl_.closures_.Get(index);
}
inline const ::valhalla::TripLeg_Closure& TripLeg::closures(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.closures)
  return _internal_closures(index);
}
inline ::valhalla::TripLeg_Closure* TripLeg::_internal_add_closures() {
  return _impl_.closures_.Add();
}
inline ::valhalla::TripLeg_Closure* TripLeg::add_closures() {
  ::valhalla::TripLeg_Closure* _add = _internal_add_closures();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.closures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
TripLeg::closures() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.closures)
  return _impl_.closures_;
}

inline bool TripLeg::has_has_osm_changeset() const {
  return has_osm_changeset_case() != HAS_OSM_CHANGESET_NOT_SET;
}
inline void TripLeg::clear_has_has_osm_changeset() {
  _impl_._oneof_case_[0] = HAS_OSM_CHANGESET_NOT_SET;
}
inline bool TripLeg::has_has_trip_id() const {
  return has_trip_id_case() != HAS_TRIP_ID_NOT_SET;
}
inline void TripLeg::clear_has_has_trip_id() {
  _impl_._oneof_case_[1] = HAS_TRIP_ID_NOT_SET;
}
inline bool TripLeg::has_has_leg_id() const {
  return has_leg_id_case() != HAS_LEG_ID_NOT_SET;
}
inline void TripLeg::clear_has_has_leg_id() {
  _impl_._oneof_case_[2] = HAS_LEG_ID_NOT_SET;
}
inline bool TripLeg::has_has_leg_count() const {
  return has_leg_count_case() != HAS_LEG_COUNT_NOT_SET;
}
inline void TripLeg::clear_has_has_leg_count() {
  _impl_._oneof_case_[3] = HAS_LEG_COUNT_NOT_SET;
}
inline bool TripLeg::has_has_shape() const {
  return has_shape_case() != HAS_SHAPE_NOT_SET;
}
inline void TripLeg::clear_has_has_shape() {
  _impl_._oneof_case_[4] = HAS_SHAPE_NOT_SET;
}
inline TripLeg::HasOsmChangesetCase TripLeg::has_osm_changeset_case() const {
  return TripLeg::HasOsmChangesetCase(_impl_._oneof_case_[0]);
}
inline TripLeg::HasTripIdCase TripLeg::has_trip_id_case() const {
  return TripLeg::HasTripIdCase(_impl_._oneof_case_[1]);
}
inline TripLeg::HasLegIdCase TripLeg::has_leg_id_case() const {
  return TripLeg::HasLegIdCase(_impl_._oneof_case_[2]);
}
inline TripLeg::HasLegCountCase TripLeg::has_leg_count_case() const {
  return TripLeg::HasLegCountCase(_impl_._oneof_case_[3]);
}
inline TripLeg::HasShapeCase TripLeg::has_shape_case() const {
  return TripLeg::HasShapeCase(_impl_._oneof_case_[4]);
}
// -------------------------------------------------------------------

// TripRoute

// repeated .valhalla.TripLeg legs = 1;
inline int TripRoute::_internal_legs_size() const {
  return _impl_.legs_.size();
}
inline int TripRoute::legs_size() const {
  return _internal_legs_size();
}
inline void TripRoute::clear_legs() {
  _impl_.legs_.Clear();
}
inline ::valhalla::TripLeg* TripRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripRoute.legs)
  return _impl_.legs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >*
TripRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripRoute.legs)
  return &_impl_.legs_;
}
inline const ::valhalla::TripLeg& TripRoute::_internal_legs(int index) const {
  return _impl_.legs_.Get(index);
}
inline const ::valhalla::TripLeg& TripRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripRoute.legs)
  return _internal_legs(index);
}
inline ::valhalla::TripLeg* TripRoute::_internal_add_legs() {
  return _impl_.legs_.Add();
}
inline ::valhalla::TripLeg* TripRoute::add_legs() {
  ::valhalla::TripLeg* _add = _internal_add_legs();
  // @@protoc_insertion_point(field_add:valhalla.TripRoute.legs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripLeg >&
TripRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.TripRoute.legs)
  return _impl_.legs_;
}

// -------------------------------------------------------------------

// Trip

// repeated .valhalla.TripRoute routes = 1;
inline int Trip::_internal_routes_size() const {
  return _impl_.routes_.size();
}
inline int Trip::routes_size() const {
  return _internal_routes_size();
}
inline void Trip::clear_routes() {
  _impl_.routes_.Clear();
}
inline ::valhalla::TripRoute* Trip::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Trip.routes)
  return _impl_.routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >*
Trip::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Trip.routes)
  return &_impl_.routes_;
}
inline const ::valhalla::TripRoute& Trip::_internal_routes(int index) const {
  return _impl_.routes_.Get(index);
}
inline const ::valhalla::TripRoute& Trip::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Trip.routes)
  return _internal_routes(index);
}
inline ::valhalla::TripRoute* Trip::_internal_add_routes() {
  return _impl_.routes_.Add();
}
inline ::valhalla::TripRoute* Trip::add_routes() {
  ::valhalla::TripRoute* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:valhalla.Trip.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TripRoute >&
Trip::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Trip.routes)
  return _impl_.routes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::TripLeg_Node_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Traversability> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Use> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Surface> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_CycleLane> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_SacScale> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TripLeg_Sidewalk> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_trip_2eproto
