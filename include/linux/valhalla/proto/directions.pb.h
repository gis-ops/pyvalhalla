// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_directions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_directions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
#include "sign.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_directions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_directions_2eproto {
  static const uint32_t offsets[];
};
namespace valhalla {
class Directions;
struct DirectionsDefaultTypeInternal;
extern DirectionsDefaultTypeInternal _Directions_default_instance_;
class DirectionsLeg;
struct DirectionsLegDefaultTypeInternal;
extern DirectionsLegDefaultTypeInternal _DirectionsLeg_default_instance_;
class DirectionsLeg_GuidanceView;
struct DirectionsLeg_GuidanceViewDefaultTypeInternal;
extern DirectionsLeg_GuidanceViewDefaultTypeInternal _DirectionsLeg_GuidanceView_default_instance_;
class DirectionsLeg_Maneuver;
struct DirectionsLeg_ManeuverDefaultTypeInternal;
extern DirectionsLeg_ManeuverDefaultTypeInternal _DirectionsLeg_Maneuver_default_instance_;
class DirectionsLeg_Summary;
struct DirectionsLeg_SummaryDefaultTypeInternal;
extern DirectionsLeg_SummaryDefaultTypeInternal _DirectionsLeg_Summary_default_instance_;
class DirectionsRoute;
struct DirectionsRouteDefaultTypeInternal;
extern DirectionsRouteDefaultTypeInternal _DirectionsRoute_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::Directions* Arena::CreateMaybeMessage<::valhalla::Directions>(Arena*);
template<> ::valhalla::DirectionsLeg* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg>(Arena*);
template<> ::valhalla::DirectionsLeg_GuidanceView* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_GuidanceView>(Arena*);
template<> ::valhalla::DirectionsLeg_Maneuver* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Maneuver>(Arena*);
template<> ::valhalla::DirectionsLeg_Summary* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Summary>(Arena*);
template<> ::valhalla::DirectionsRoute* Arena::CreateMaybeMessage<::valhalla::DirectionsRoute>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum DirectionsLeg_GuidanceView_Type : int {
  DirectionsLeg_GuidanceView_Type_kJunction = 0,
  DirectionsLeg_GuidanceView_Type_kSapa = 1,
  DirectionsLeg_GuidanceView_Type_kTollbranch = 2,
  DirectionsLeg_GuidanceView_Type_kAftertoll = 3,
  DirectionsLeg_GuidanceView_Type_kEnt = 4,
  DirectionsLeg_GuidanceView_Type_kExit = 5,
  DirectionsLeg_GuidanceView_Type_kCityreal = 6,
  DirectionsLeg_GuidanceView_Type_kDirectionboard = 7,
  DirectionsLeg_GuidanceView_Type_kSignboard = 8,
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirectionsLeg_GuidanceView_Type_IsValid(int value);
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MIN = DirectionsLeg_GuidanceView_Type_kJunction;
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MAX = DirectionsLeg_GuidanceView_Type_kSignboard;
constexpr int DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE = DirectionsLeg_GuidanceView_Type_Type_MAX + 1;

const std::string& DirectionsLeg_GuidanceView_Type_Name(DirectionsLeg_GuidanceView_Type value);
template<typename T>
inline const std::string& DirectionsLeg_GuidanceView_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_GuidanceView_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_GuidanceView_Type_Name.");
  return DirectionsLeg_GuidanceView_Type_Name(static_cast<DirectionsLeg_GuidanceView_Type>(enum_t_value));
}
bool DirectionsLeg_GuidanceView_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_GuidanceView_Type* value);
enum DirectionsLeg_Maneuver_CardinalDirection : int {
  DirectionsLeg_Maneuver_CardinalDirection_kNorth = 0,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthEast = 1,
  DirectionsLeg_Maneuver_CardinalDirection_kEast = 2,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthEast = 3,
  DirectionsLeg_Maneuver_CardinalDirection_kSouth = 4,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthWest = 5,
  DirectionsLeg_Maneuver_CardinalDirection_kWest = 6,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthWest = 7,
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value);
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
constexpr int DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX + 1;

const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(DirectionsLeg_Maneuver_CardinalDirection value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_CardinalDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_CardinalDirection_Name.");
  return DirectionsLeg_Maneuver_CardinalDirection_Name(static_cast<DirectionsLeg_Maneuver_CardinalDirection>(enum_t_value));
}
bool DirectionsLeg_Maneuver_CardinalDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_CardinalDirection* value);
enum DirectionsLeg_Maneuver_Type : int {
  DirectionsLeg_Maneuver_Type_kNone = 0,
  DirectionsLeg_Maneuver_Type_kStart = 1,
  DirectionsLeg_Maneuver_Type_kStartRight = 2,
  DirectionsLeg_Maneuver_Type_kStartLeft = 3,
  DirectionsLeg_Maneuver_Type_kDestination = 4,
  DirectionsLeg_Maneuver_Type_kDestinationRight = 5,
  DirectionsLeg_Maneuver_Type_kDestinationLeft = 6,
  DirectionsLeg_Maneuver_Type_kBecomes = 7,
  DirectionsLeg_Maneuver_Type_kContinue = 8,
  DirectionsLeg_Maneuver_Type_kSlightRight = 9,
  DirectionsLeg_Maneuver_Type_kRight = 10,
  DirectionsLeg_Maneuver_Type_kSharpRight = 11,
  DirectionsLeg_Maneuver_Type_kUturnRight = 12,
  DirectionsLeg_Maneuver_Type_kUturnLeft = 13,
  DirectionsLeg_Maneuver_Type_kSharpLeft = 14,
  DirectionsLeg_Maneuver_Type_kLeft = 15,
  DirectionsLeg_Maneuver_Type_kSlightLeft = 16,
  DirectionsLeg_Maneuver_Type_kRampStraight = 17,
  DirectionsLeg_Maneuver_Type_kRampRight = 18,
  DirectionsLeg_Maneuver_Type_kRampLeft = 19,
  DirectionsLeg_Maneuver_Type_kExitRight = 20,
  DirectionsLeg_Maneuver_Type_kExitLeft = 21,
  DirectionsLeg_Maneuver_Type_kStayStraight = 22,
  DirectionsLeg_Maneuver_Type_kStayRight = 23,
  DirectionsLeg_Maneuver_Type_kStayLeft = 24,
  DirectionsLeg_Maneuver_Type_kMerge = 25,
  DirectionsLeg_Maneuver_Type_kRoundaboutEnter = 26,
  DirectionsLeg_Maneuver_Type_kRoundaboutExit = 27,
  DirectionsLeg_Maneuver_Type_kFerryEnter = 28,
  DirectionsLeg_Maneuver_Type_kFerryExit = 29,
  DirectionsLeg_Maneuver_Type_kTransit = 30,
  DirectionsLeg_Maneuver_Type_kTransitTransfer = 31,
  DirectionsLeg_Maneuver_Type_kTransitRemainOn = 32,
  DirectionsLeg_Maneuver_Type_kTransitConnectionStart = 33,
  DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer = 34,
  DirectionsLeg_Maneuver_Type_kTransitConnectionDestination = 35,
  DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination = 36,
  DirectionsLeg_Maneuver_Type_kMergeRight = 37,
  DirectionsLeg_Maneuver_Type_kMergeLeft = 38,
  DirectionsLeg_Maneuver_Type_kElevatorEnter = 39,
  DirectionsLeg_Maneuver_Type_kStepsEnter = 40,
  DirectionsLeg_Maneuver_Type_kEscalatorEnter = 41,
  DirectionsLeg_Maneuver_Type_kBuildingEnter = 42,
  DirectionsLeg_Maneuver_Type_kBuildingExit = 43,
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirectionsLeg_Maneuver_Type_IsValid(int value);
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MIN = DirectionsLeg_Maneuver_Type_kNone;
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MAX = DirectionsLeg_Maneuver_Type_kBuildingExit;
constexpr int DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE = DirectionsLeg_Maneuver_Type_Type_MAX + 1;

const std::string& DirectionsLeg_Maneuver_Type_Name(DirectionsLeg_Maneuver_Type value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_Type_Name.");
  return DirectionsLeg_Maneuver_Type_Name(static_cast<DirectionsLeg_Maneuver_Type>(enum_t_value));
}
bool DirectionsLeg_Maneuver_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_Type* value);
enum DirectionsLeg_Maneuver_BssManeuverType : int {
  DirectionsLeg_Maneuver_BssManeuverType_kNoneAction = 0,
  DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare = 1,
  DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare = 2,
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirectionsLeg_Maneuver_BssManeuverType_IsValid(int value);
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN = DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX = DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
constexpr int DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX + 1;

const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(DirectionsLeg_Maneuver_BssManeuverType value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_BssManeuverType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_BssManeuverType_Name.");
  return DirectionsLeg_Maneuver_BssManeuverType_Name(static_cast<DirectionsLeg_Maneuver_BssManeuverType>(enum_t_value));
}
bool DirectionsLeg_Maneuver_BssManeuverType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_BssManeuverType* value);
// ===================================================================

class DirectionsLeg_Summary final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Summary) */ {
 public:
  inline DirectionsLeg_Summary() : DirectionsLeg_Summary(nullptr) {}
  ~DirectionsLeg_Summary() override;
  explicit PROTOBUF_CONSTEXPR DirectionsLeg_Summary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Summary(const DirectionsLeg_Summary& from);
  DirectionsLeg_Summary(DirectionsLeg_Summary&& from) noexcept
    : DirectionsLeg_Summary() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Summary& operator=(const DirectionsLeg_Summary& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Summary& operator=(DirectionsLeg_Summary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg_Summary& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Summary* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Summary*>(
               &_DirectionsLeg_Summary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DirectionsLeg_Summary& a, DirectionsLeg_Summary& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Summary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Summary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg_Summary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg_Summary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Summary& from);
  void MergeFrom(const DirectionsLeg_Summary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Summary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Summary";
  }
  protected:
  explicit DirectionsLeg_Summary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBboxFieldNumber = 3,
    kTimeFieldNumber = 2,
    kLengthFieldNumber = 1,
    kHasTimeRestrictionsFieldNumber = 4,
    kHasTollFieldNumber = 5,
    kHasFerryFieldNumber = 6,
    kHasHighwayFieldNumber = 7,
  };
  // .valhalla.BoundingBox bbox = 3;
  bool has_bbox() const;
  private:
  bool _internal_has_bbox() const;
  public:
  void clear_bbox();
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_NODISCARD ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);
  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();
  public:
  void unsafe_arena_set_allocated_bbox(
      ::valhalla::BoundingBox* bbox);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  // double time = 2;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // float length = 1;
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // bool has_time_restrictions = 4;
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // bool has_toll = 5;
  void clear_has_toll();
  bool has_toll() const;
  void set_has_toll(bool value);
  private:
  bool _internal_has_toll() const;
  void _internal_set_has_toll(bool value);
  public:

  // bool has_ferry = 6;
  void clear_has_ferry();
  bool has_ferry() const;
  void set_has_ferry(bool value);
  private:
  bool _internal_has_ferry() const;
  void _internal_set_has_ferry(bool value);
  public:

  // bool has_highway = 7;
  void clear_has_highway();
  bool has_highway() const;
  void set_has_highway(bool value);
  private:
  bool _internal_has_highway() const;
  void _internal_set_has_highway(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Summary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::valhalla::BoundingBox* bbox_;
    double time_;
    float length_;
    bool has_time_restrictions_;
    bool has_toll_;
    bool has_ferry_;
    bool has_highway_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_GuidanceView final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.GuidanceView) */ {
 public:
  inline DirectionsLeg_GuidanceView() : DirectionsLeg_GuidanceView(nullptr) {}
  ~DirectionsLeg_GuidanceView() override;
  explicit PROTOBUF_CONSTEXPR DirectionsLeg_GuidanceView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_GuidanceView(const DirectionsLeg_GuidanceView& from);
  DirectionsLeg_GuidanceView(DirectionsLeg_GuidanceView&& from) noexcept
    : DirectionsLeg_GuidanceView() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_GuidanceView& operator=(const DirectionsLeg_GuidanceView& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_GuidanceView& operator=(DirectionsLeg_GuidanceView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg_GuidanceView& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_GuidanceView* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_GuidanceView*>(
               &_DirectionsLeg_GuidanceView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DirectionsLeg_GuidanceView& a, DirectionsLeg_GuidanceView& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg_GuidanceView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg_GuidanceView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_GuidanceView& from);
  void MergeFrom(const DirectionsLeg_GuidanceView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_GuidanceView* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.GuidanceView";
  }
  protected:
  explicit DirectionsLeg_GuidanceView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_GuidanceView_Type Type;
  static constexpr Type kJunction =
    DirectionsLeg_GuidanceView_Type_kJunction;
  static constexpr Type kSapa =
    DirectionsLeg_GuidanceView_Type_kSapa;
  static constexpr Type kTollbranch =
    DirectionsLeg_GuidanceView_Type_kTollbranch;
  static constexpr Type kAftertoll =
    DirectionsLeg_GuidanceView_Type_kAftertoll;
  static constexpr Type kEnt =
    DirectionsLeg_GuidanceView_Type_kEnt;
  static constexpr Type kExit =
    DirectionsLeg_GuidanceView_Type_kExit;
  static constexpr Type kCityreal =
    DirectionsLeg_GuidanceView_Type_kCityreal;
  static constexpr Type kDirectionboard =
    DirectionsLeg_GuidanceView_Type_kDirectionboard;
  static constexpr Type kSignboard =
    DirectionsLeg_GuidanceView_Type_kSignboard;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_GuidanceView_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DirectionsLeg_GuidanceView_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DirectionsLeg_GuidanceView_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DirectionsLeg_GuidanceView_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DirectionsLeg_GuidanceView_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayIdsFieldNumber = 4,
    kDataIdFieldNumber = 1,
    kBaseIdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // repeated string overlay_ids = 4;
  int overlay_ids_size() const;
  private:
  int _internal_overlay_ids_size() const;
  public:
  void clear_overlay_ids();
  const std::string& overlay_ids(int index) const;
  std::string* mutable_overlay_ids(int index);
  void set_overlay_ids(int index, const std::string& value);
  void set_overlay_ids(int index, std::string&& value);
  void set_overlay_ids(int index, const char* value);
  void set_overlay_ids(int index, const char* value, size_t size);
  std::string* add_overlay_ids();
  void add_overlay_ids(const std::string& value);
  void add_overlay_ids(std::string&& value);
  void add_overlay_ids(const char* value);
  void add_overlay_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& overlay_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_overlay_ids();
  private:
  const std::string& _internal_overlay_ids(int index) const;
  std::string* _internal_add_overlay_ids();
  public:

  // string data_id = 1;
  void clear_data_id();
  const std::string& data_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_id();
  PROTOBUF_NODISCARD std::string* release_data_id();
  void set_allocated_data_id(std::string* data_id);
  private:
  const std::string& _internal_data_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_id(const std::string& value);
  std::string* _internal_mutable_data_id();
  public:

  // string base_id = 3;
  void clear_base_id();
  const std::string& base_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_id();
  PROTOBUF_NODISCARD std::string* release_base_id();
  void set_allocated_base_id(std::string* base_id);
  private:
  const std::string& _internal_base_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_id(const std::string& value);
  std::string* _internal_mutable_base_id();
  public:

  // .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
  void clear_type();
  ::valhalla::DirectionsLeg_GuidanceView_Type type() const;
  void set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);
  private:
  ::valhalla::DirectionsLeg_GuidanceView_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.GuidanceView)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> overlay_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver) */ {
 public:
  inline DirectionsLeg_Maneuver() : DirectionsLeg_Maneuver(nullptr) {}
  ~DirectionsLeg_Maneuver() override;
  explicit PROTOBUF_CONSTEXPR DirectionsLeg_Maneuver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from);
  DirectionsLeg_Maneuver(DirectionsLeg_Maneuver&& from) noexcept
    : DirectionsLeg_Maneuver() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Maneuver& operator=(const DirectionsLeg_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Maneuver& operator=(DirectionsLeg_Maneuver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg_Maneuver& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Maneuver* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Maneuver*>(
               &_DirectionsLeg_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DirectionsLeg_Maneuver& a, DirectionsLeg_Maneuver& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg_Maneuver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg_Maneuver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Maneuver& from);
  void MergeFrom(const DirectionsLeg_Maneuver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Maneuver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Maneuver";
  }
  protected:
  explicit DirectionsLeg_Maneuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Maneuver_CardinalDirection CardinalDirection;
  static constexpr CardinalDirection kNorth =
    DirectionsLeg_Maneuver_CardinalDirection_kNorth;
  static constexpr CardinalDirection kNorthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthEast;
  static constexpr CardinalDirection kEast =
    DirectionsLeg_Maneuver_CardinalDirection_kEast;
  static constexpr CardinalDirection kSouthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthEast;
  static constexpr CardinalDirection kSouth =
    DirectionsLeg_Maneuver_CardinalDirection_kSouth;
  static constexpr CardinalDirection kSouthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthWest;
  static constexpr CardinalDirection kWest =
    DirectionsLeg_Maneuver_CardinalDirection_kWest;
  static constexpr CardinalDirection kNorthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return DirectionsLeg_Maneuver_CardinalDirection_IsValid(value);
  }
  static constexpr CardinalDirection CardinalDirection_MIN =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static constexpr CardinalDirection CardinalDirection_MAX =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static constexpr int CardinalDirection_ARRAYSIZE =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CardinalDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CardinalDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CardinalDirection_Name.");
    return DirectionsLeg_Maneuver_CardinalDirection_Name(enum_t_value);
  }
  static inline bool CardinalDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CardinalDirection* value) {
    return DirectionsLeg_Maneuver_CardinalDirection_Parse(name, value);
  }

  typedef DirectionsLeg_Maneuver_Type Type;
  static constexpr Type kNone =
    DirectionsLeg_Maneuver_Type_kNone;
  static constexpr Type kStart =
    DirectionsLeg_Maneuver_Type_kStart;
  static constexpr Type kStartRight =
    DirectionsLeg_Maneuver_Type_kStartRight;
  static constexpr Type kStartLeft =
    DirectionsLeg_Maneuver_Type_kStartLeft;
  static constexpr Type kDestination =
    DirectionsLeg_Maneuver_Type_kDestination;
  static constexpr Type kDestinationRight =
    DirectionsLeg_Maneuver_Type_kDestinationRight;
  static constexpr Type kDestinationLeft =
    DirectionsLeg_Maneuver_Type_kDestinationLeft;
  static constexpr Type kBecomes =
    DirectionsLeg_Maneuver_Type_kBecomes;
  static constexpr Type kContinue =
    DirectionsLeg_Maneuver_Type_kContinue;
  static constexpr Type kSlightRight =
    DirectionsLeg_Maneuver_Type_kSlightRight;
  static constexpr Type kRight =
    DirectionsLeg_Maneuver_Type_kRight;
  static constexpr Type kSharpRight =
    DirectionsLeg_Maneuver_Type_kSharpRight;
  static constexpr Type kUturnRight =
    DirectionsLeg_Maneuver_Type_kUturnRight;
  static constexpr Type kUturnLeft =
    DirectionsLeg_Maneuver_Type_kUturnLeft;
  static constexpr Type kSharpLeft =
    DirectionsLeg_Maneuver_Type_kSharpLeft;
  static constexpr Type kLeft =
    DirectionsLeg_Maneuver_Type_kLeft;
  static constexpr Type kSlightLeft =
    DirectionsLeg_Maneuver_Type_kSlightLeft;
  static constexpr Type kRampStraight =
    DirectionsLeg_Maneuver_Type_kRampStraight;
  static constexpr Type kRampRight =
    DirectionsLeg_Maneuver_Type_kRampRight;
  static constexpr Type kRampLeft =
    DirectionsLeg_Maneuver_Type_kRampLeft;
  static constexpr Type kExitRight =
    DirectionsLeg_Maneuver_Type_kExitRight;
  static constexpr Type kExitLeft =
    DirectionsLeg_Maneuver_Type_kExitLeft;
  static constexpr Type kStayStraight =
    DirectionsLeg_Maneuver_Type_kStayStraight;
  static constexpr Type kStayRight =
    DirectionsLeg_Maneuver_Type_kStayRight;
  static constexpr Type kStayLeft =
    DirectionsLeg_Maneuver_Type_kStayLeft;
  static constexpr Type kMerge =
    DirectionsLeg_Maneuver_Type_kMerge;
  static constexpr Type kRoundaboutEnter =
    DirectionsLeg_Maneuver_Type_kRoundaboutEnter;
  static constexpr Type kRoundaboutExit =
    DirectionsLeg_Maneuver_Type_kRoundaboutExit;
  static constexpr Type kFerryEnter =
    DirectionsLeg_Maneuver_Type_kFerryEnter;
  static constexpr Type kFerryExit =
    DirectionsLeg_Maneuver_Type_kFerryExit;
  static constexpr Type kTransit =
    DirectionsLeg_Maneuver_Type_kTransit;
  static constexpr Type kTransitTransfer =
    DirectionsLeg_Maneuver_Type_kTransitTransfer;
  static constexpr Type kTransitRemainOn =
    DirectionsLeg_Maneuver_Type_kTransitRemainOn;
  static constexpr Type kTransitConnectionStart =
    DirectionsLeg_Maneuver_Type_kTransitConnectionStart;
  static constexpr Type kTransitConnectionTransfer =
    DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer;
  static constexpr Type kTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kTransitConnectionDestination;
  static constexpr Type kPostTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination;
  static constexpr Type kMergeRight =
    DirectionsLeg_Maneuver_Type_kMergeRight;
  static constexpr Type kMergeLeft =
    DirectionsLeg_Maneuver_Type_kMergeLeft;
  static constexpr Type kElevatorEnter =
    DirectionsLeg_Maneuver_Type_kElevatorEnter;
  static constexpr Type kStepsEnter =
    DirectionsLeg_Maneuver_Type_kStepsEnter;
  static constexpr Type kEscalatorEnter =
    DirectionsLeg_Maneuver_Type_kEscalatorEnter;
  static constexpr Type kBuildingEnter =
    DirectionsLeg_Maneuver_Type_kBuildingEnter;
  static constexpr Type kBuildingExit =
    DirectionsLeg_Maneuver_Type_kBuildingExit;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_Maneuver_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DirectionsLeg_Maneuver_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DirectionsLeg_Maneuver_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DirectionsLeg_Maneuver_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DirectionsLeg_Maneuver_Type_Parse(name, value);
  }

  typedef DirectionsLeg_Maneuver_BssManeuverType BssManeuverType;
  static constexpr BssManeuverType kNoneAction =
    DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
  static constexpr BssManeuverType kRentBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare;
  static constexpr BssManeuverType kReturnBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
  static inline bool BssManeuverType_IsValid(int value) {
    return DirectionsLeg_Maneuver_BssManeuverType_IsValid(value);
  }
  static constexpr BssManeuverType BssManeuverType_MIN =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN;
  static constexpr BssManeuverType BssManeuverType_MAX =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX;
  static constexpr int BssManeuverType_ARRAYSIZE =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BssManeuverType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BssManeuverType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BssManeuverType_Name.");
    return DirectionsLeg_Maneuver_BssManeuverType_Name(enum_t_value);
  }
  static inline bool BssManeuverType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BssManeuverType* value) {
    return DirectionsLeg_Maneuver_BssManeuverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStreetNameFieldNumber = 3,
    kBeginStreetNameFieldNumber = 15,
    kRoundaboutExitStreetNamesFieldNumber = 32,
    kGuidanceViewsFieldNumber = 35,
    kTextInstructionFieldNumber = 2,
    kVerbalTransitionAlertInstructionFieldNumber = 12,
    kVerbalPreTransitionInstructionFieldNumber = 13,
    kVerbalPostTransitionInstructionFieldNumber = 14,
    kDepartInstructionFieldNumber = 18,
    kVerbalDepartInstructionFieldNumber = 19,
    kArriveInstructionFieldNumber = 20,
    kVerbalArriveInstructionFieldNumber = 21,
    kVerbalSuccinctTransitionInstructionFieldNumber = 37,
    kSignFieldNumber = 16,
    kTransitInfoFieldNumber = 22,
    kBssInfoFieldNumber = 38,
    kTypeFieldNumber = 1,
    kLengthFieldNumber = 4,
    kTimeFieldNumber = 5,
    kBeginCardinalDirectionFieldNumber = 6,
    kBeginHeadingFieldNumber = 7,
    kBeginShapeIndexFieldNumber = 8,
    kEndShapeIndexFieldNumber = 9,
    kRoundaboutExitCountFieldNumber = 17,
    kPortionsTollFieldNumber = 10,
    kPortionsUnpavedFieldNumber = 11,
    kVerbalMultiCueFieldNumber = 23,
    kToStayOnFieldNumber = 31,
    kTravelModeFieldNumber = 24,
    kVehicleTypeFieldNumber = 25,
    kPedestrianTypeFieldNumber = 26,
    kBicycleTypeFieldNumber = 27,
    kTransitTypeFieldNumber = 28,
    kBeginPathIndexFieldNumber = 29,
    kEndPathIndexFieldNumber = 30,
    kTurnDegreeFieldNumber = 33,
    kBssManeuverTypeFieldNumber = 36,
    kHasTimeRestrictionsFieldNumber = 34,
    kPortionsHighwayFieldNumber = 39,
    kPortionsFerryFieldNumber = 40,
  };
  // repeated .valhalla.StreetName street_name = 3;
  int street_name_size() const;
  private:
  int _internal_street_name_size() const;
  public:
  void clear_street_name();
  ::valhalla::StreetName* mutable_street_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_name();
  private:
  const ::valhalla::StreetName& _internal_street_name(int index) const;
  ::valhalla::StreetName* _internal_add_street_name();
  public:
  const ::valhalla::StreetName& street_name(int index) const;
  ::valhalla::StreetName* add_street_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      street_name() const;

  // repeated .valhalla.StreetName begin_street_name = 15;
  int begin_street_name_size() const;
  private:
  int _internal_begin_street_name_size() const;
  public:
  void clear_begin_street_name();
  ::valhalla::StreetName* mutable_begin_street_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_begin_street_name();
  private:
  const ::valhalla::StreetName& _internal_begin_street_name(int index) const;
  ::valhalla::StreetName* _internal_add_begin_street_name();
  public:
  const ::valhalla::StreetName& begin_street_name(int index) const;
  ::valhalla::StreetName* add_begin_street_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      begin_street_name() const;

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  int roundabout_exit_street_names_size() const;
  private:
  int _internal_roundabout_exit_street_names_size() const;
  public:
  void clear_roundabout_exit_street_names();
  ::valhalla::StreetName* mutable_roundabout_exit_street_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_roundabout_exit_street_names();
  private:
  const ::valhalla::StreetName& _internal_roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* _internal_add_roundabout_exit_street_names();
  public:
  const ::valhalla::StreetName& roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* add_roundabout_exit_street_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      roundabout_exit_street_names() const;

  // repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
  int guidance_views_size() const;
  private:
  int _internal_guidance_views_size() const;
  public:
  void clear_guidance_views();
  ::valhalla::DirectionsLeg_GuidanceView* mutable_guidance_views(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
      mutable_guidance_views();
  private:
  const ::valhalla::DirectionsLeg_GuidanceView& _internal_guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* _internal_add_guidance_views();
  public:
  const ::valhalla::DirectionsLeg_GuidanceView& guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* add_guidance_views();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
      guidance_views() const;

  // string text_instruction = 2;
  void clear_text_instruction();
  const std::string& text_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_instruction();
  PROTOBUF_NODISCARD std::string* release_text_instruction();
  void set_allocated_text_instruction(std::string* text_instruction);
  private:
  const std::string& _internal_text_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_instruction(const std::string& value);
  std::string* _internal_mutable_text_instruction();
  public:

  // string verbal_transition_alert_instruction = 12;
  void clear_verbal_transition_alert_instruction();
  const std::string& verbal_transition_alert_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_transition_alert_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_transition_alert_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_transition_alert_instruction();
  void set_allocated_verbal_transition_alert_instruction(std::string* verbal_transition_alert_instruction);
  private:
  const std::string& _internal_verbal_transition_alert_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_transition_alert_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_transition_alert_instruction();
  public:

  // string verbal_pre_transition_instruction = 13;
  void clear_verbal_pre_transition_instruction();
  const std::string& verbal_pre_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_pre_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_pre_transition_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_pre_transition_instruction();
  void set_allocated_verbal_pre_transition_instruction(std::string* verbal_pre_transition_instruction);
  private:
  const std::string& _internal_verbal_pre_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_pre_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_pre_transition_instruction();
  public:

  // string verbal_post_transition_instruction = 14;
  void clear_verbal_post_transition_instruction();
  const std::string& verbal_post_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_post_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_post_transition_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_post_transition_instruction();
  void set_allocated_verbal_post_transition_instruction(std::string* verbal_post_transition_instruction);
  private:
  const std::string& _internal_verbal_post_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_post_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_post_transition_instruction();
  public:

  // string depart_instruction = 18;
  void clear_depart_instruction();
  const std::string& depart_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depart_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depart_instruction();
  PROTOBUF_NODISCARD std::string* release_depart_instruction();
  void set_allocated_depart_instruction(std::string* depart_instruction);
  private:
  const std::string& _internal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_depart_instruction(const std::string& value);
  std::string* _internal_mutable_depart_instruction();
  public:

  // string verbal_depart_instruction = 19;
  void clear_verbal_depart_instruction();
  const std::string& verbal_depart_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_depart_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_depart_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_depart_instruction();
  void set_allocated_verbal_depart_instruction(std::string* verbal_depart_instruction);
  private:
  const std::string& _internal_verbal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_depart_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_depart_instruction();
  public:

  // string arrive_instruction = 20;
  void clear_arrive_instruction();
  const std::string& arrive_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arrive_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arrive_instruction();
  PROTOBUF_NODISCARD std::string* release_arrive_instruction();
  void set_allocated_arrive_instruction(std::string* arrive_instruction);
  private:
  const std::string& _internal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrive_instruction(const std::string& value);
  std::string* _internal_mutable_arrive_instruction();
  public:

  // string verbal_arrive_instruction = 21;
  void clear_verbal_arrive_instruction();
  const std::string& verbal_arrive_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_arrive_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_arrive_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_arrive_instruction();
  void set_allocated_verbal_arrive_instruction(std::string* verbal_arrive_instruction);
  private:
  const std::string& _internal_verbal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_arrive_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_arrive_instruction();
  public:

  // string verbal_succinct_transition_instruction = 37;
  void clear_verbal_succinct_transition_instruction();
  const std::string& verbal_succinct_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_succinct_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_succinct_transition_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_succinct_transition_instruction();
  void set_allocated_verbal_succinct_transition_instruction(std::string* verbal_succinct_transition_instruction);
  private:
  const std::string& _internal_verbal_succinct_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_succinct_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_succinct_transition_instruction();
  public:

  // .valhalla.TripSign sign = 16;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);
  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::TripSign* sign);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  // .valhalla.TransitRouteInfo transit_info = 22;
  bool has_transit_info() const;
  private:
  bool _internal_has_transit_info() const;
  public:
  void clear_transit_info();
  const ::valhalla::TransitRouteInfo& transit_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitRouteInfo* release_transit_info();
  ::valhalla::TransitRouteInfo* mutable_transit_info();
  void set_allocated_transit_info(::valhalla::TransitRouteInfo* transit_info);
  private:
  const ::valhalla::TransitRouteInfo& _internal_transit_info() const;
  ::valhalla::TransitRouteInfo* _internal_mutable_transit_info();
  public:
  void unsafe_arena_set_allocated_transit_info(
      ::valhalla::TransitRouteInfo* transit_info);
  ::valhalla::TransitRouteInfo* unsafe_arena_release_transit_info();

  // .valhalla.BikeShareStationInfo bss_info = 38;
  bool has_bss_info() const;
  private:
  bool _internal_has_bss_info() const;
  public:
  void clear_bss_info();
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  PROTOBUF_NODISCARD ::valhalla::BikeShareStationInfo* release_bss_info();
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info);
  private:
  const ::valhalla::BikeShareStationInfo& _internal_bss_info() const;
  ::valhalla::BikeShareStationInfo* _internal_mutable_bss_info();
  public:
  void unsafe_arena_set_allocated_bss_info(
      ::valhalla::BikeShareStationInfo* bss_info);
  ::valhalla::BikeShareStationInfo* unsafe_arena_release_bss_info();

  // .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  void clear_type();
  ::valhalla::DirectionsLeg_Maneuver_Type type() const;
  void set_type(::valhalla::DirectionsLeg_Maneuver_Type value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value);
  public:

  // float length = 4;
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // double time = 5;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  void clear_begin_cardinal_direction();
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection begin_cardinal_direction() const;
  void set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection _internal_begin_cardinal_direction() const;
  void _internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);
  public:

  // uint32 begin_heading = 7;
  void clear_begin_heading();
  uint32_t begin_heading() const;
  void set_begin_heading(uint32_t value);
  private:
  uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(uint32_t value);
  public:

  // uint32 begin_shape_index = 8;
  void clear_begin_shape_index();
  uint32_t begin_shape_index() const;
  void set_begin_shape_index(uint32_t value);
  private:
  uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(uint32_t value);
  public:

  // uint32 end_shape_index = 9;
  void clear_end_shape_index();
  uint32_t end_shape_index() const;
  void set_end_shape_index(uint32_t value);
  private:
  uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(uint32_t value);
  public:

  // uint32 roundabout_exit_count = 17;
  void clear_roundabout_exit_count();
  uint32_t roundabout_exit_count() const;
  void set_roundabout_exit_count(uint32_t value);
  private:
  uint32_t _internal_roundabout_exit_count() const;
  void _internal_set_roundabout_exit_count(uint32_t value);
  public:

  // bool portions_toll = 10;
  void clear_portions_toll();
  bool portions_toll() const;
  void set_portions_toll(bool value);
  private:
  bool _internal_portions_toll() const;
  void _internal_set_portions_toll(bool value);
  public:

  // bool portions_unpaved = 11;
  void clear_portions_unpaved();
  bool portions_unpaved() const;
  void set_portions_unpaved(bool value);
  private:
  bool _internal_portions_unpaved() const;
  void _internal_set_portions_unpaved(bool value);
  public:

  // bool verbal_multi_cue = 23;
  void clear_verbal_multi_cue();
  bool verbal_multi_cue() const;
  void set_verbal_multi_cue(bool value);
  private:
  bool _internal_verbal_multi_cue() const;
  void _internal_set_verbal_multi_cue(bool value);
  public:

  // bool to_stay_on = 31;
  void clear_to_stay_on();
  bool to_stay_on() const;
  void set_to_stay_on(bool value);
  private:
  bool _internal_to_stay_on() const;
  void _internal_set_to_stay_on(bool value);
  public:

  // .valhalla.TravelMode travel_mode = 24;
  void clear_travel_mode();
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);
  private:
  ::valhalla::TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::TravelMode value);
  public:

  // .valhalla.VehicleType vehicle_type = 25;
  void clear_vehicle_type();
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);
  private:
  ::valhalla::VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::VehicleType value);
  public:

  // .valhalla.PedestrianType pedestrian_type = 26;
  void clear_pedestrian_type();
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);
  private:
  ::valhalla::PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::PedestrianType value);
  public:

  // .valhalla.BicycleType bicycle_type = 27;
  void clear_bicycle_type();
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);
  private:
  ::valhalla::BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::BicycleType value);
  public:

  // .valhalla.TransitType transit_type = 28;
  void clear_transit_type();
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);
  private:
  ::valhalla::TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::TransitType value);
  public:

  // uint32 begin_path_index = 29;
  void clear_begin_path_index();
  uint32_t begin_path_index() const;
  void set_begin_path_index(uint32_t value);
  private:
  uint32_t _internal_begin_path_index() const;
  void _internal_set_begin_path_index(uint32_t value);
  public:

  // uint32 end_path_index = 30;
  void clear_end_path_index();
  uint32_t end_path_index() const;
  void set_end_path_index(uint32_t value);
  private:
  uint32_t _internal_end_path_index() const;
  void _internal_set_end_path_index(uint32_t value);
  public:

  // uint32 turn_degree = 33;
  void clear_turn_degree();
  uint32_t turn_degree() const;
  void set_turn_degree(uint32_t value);
  private:
  uint32_t _internal_turn_degree() const;
  void _internal_set_turn_degree(uint32_t value);
  public:

  // .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
  void clear_bss_maneuver_type();
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType bss_maneuver_type() const;
  void set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType _internal_bss_maneuver_type() const;
  void _internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);
  public:

  // bool has_time_restrictions = 34;
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // bool portions_highway = 39;
  void clear_portions_highway();
  bool portions_highway() const;
  void set_portions_highway(bool value);
  private:
  bool _internal_portions_highway() const;
  void _internal_set_portions_highway(bool value);
  public:

  // bool portions_ferry = 40;
  void clear_portions_ferry();
  bool portions_ferry() const;
  void set_portions_ferry(bool value);
  private:
  bool _internal_portions_ferry() const;
  void _internal_set_portions_ferry(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > street_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > begin_street_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > roundabout_exit_street_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView > guidance_views_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_transition_alert_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_pre_transition_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_post_transition_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depart_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_depart_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arrive_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_arrive_instruction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_succinct_transition_instruction_;
    ::valhalla::TripSign* sign_;
    ::valhalla::TransitRouteInfo* transit_info_;
    ::valhalla::BikeShareStationInfo* bss_info_;
    int type_;
    float length_;
    double time_;
    int begin_cardinal_direction_;
    uint32_t begin_heading_;
    uint32_t begin_shape_index_;
    uint32_t end_shape_index_;
    uint32_t roundabout_exit_count_;
    bool portions_toll_;
    bool portions_unpaved_;
    bool verbal_multi_cue_;
    bool to_stay_on_;
    int travel_mode_;
    int vehicle_type_;
    int pedestrian_type_;
    int bicycle_type_;
    int transit_type_;
    uint32_t begin_path_index_;
    uint32_t end_path_index_;
    uint32_t turn_degree_;
    int bss_maneuver_type_;
    bool has_time_restrictions_;
    bool portions_highway_;
    bool portions_ferry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg) */ {
 public:
  inline DirectionsLeg() : DirectionsLeg(nullptr) {}
  ~DirectionsLeg() override;
  explicit PROTOBUF_CONSTEXPR DirectionsLeg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg(const DirectionsLeg& from);
  DirectionsLeg(DirectionsLeg&& from) noexcept
    : DirectionsLeg() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg& operator=(DirectionsLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg*>(
               &_DirectionsLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DirectionsLeg& a, DirectionsLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg";
  }
  protected:
  explicit DirectionsLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Summary Summary;
  typedef DirectionsLeg_GuidanceView GuidanceView;
  typedef DirectionsLeg_Maneuver Maneuver;

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 4,
    kManeuverFieldNumber = 6,
    kShapeFieldNumber = 7,
    kSummaryFieldNumber = 5,
    kTripIdFieldNumber = 1,
    kLegIdFieldNumber = 2,
    kLegCountFieldNumber = 3,
  };
  // repeated .valhalla.Location location = 4;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::valhalla::Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::valhalla::Location& _internal_location(int index) const;
  ::valhalla::Location* _internal_add_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  int maneuver_size() const;
  private:
  int _internal_maneuver_size() const;
  public:
  void clear_maneuver();
  ::valhalla::DirectionsLeg_Maneuver* mutable_maneuver(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
      mutable_maneuver();
  private:
  const ::valhalla::DirectionsLeg_Maneuver& _internal_maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* _internal_add_maneuver();
  public:
  const ::valhalla::DirectionsLeg_Maneuver& maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* add_maneuver();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
      maneuver() const;

  // string shape = 7;
  void clear_shape();
  const std::string& shape() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* shape);
  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(const std::string& value);
  std::string* _internal_mutable_shape();
  public:

  // .valhalla.DirectionsLeg.Summary summary = 5;
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const ::valhalla::DirectionsLeg_Summary& summary() const;
  PROTOBUF_NODISCARD ::valhalla::DirectionsLeg_Summary* release_summary();
  ::valhalla::DirectionsLeg_Summary* mutable_summary();
  void set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary);
  private:
  const ::valhalla::DirectionsLeg_Summary& _internal_summary() const;
  ::valhalla::DirectionsLeg_Summary* _internal_mutable_summary();
  public:
  void unsafe_arena_set_allocated_summary(
      ::valhalla::DirectionsLeg_Summary* summary);
  ::valhalla::DirectionsLeg_Summary* unsafe_arena_release_summary();

  // uint64 trip_id = 1;
  void clear_trip_id();
  uint64_t trip_id() const;
  void set_trip_id(uint64_t value);
  private:
  uint64_t _internal_trip_id() const;
  void _internal_set_trip_id(uint64_t value);
  public:

  // uint32 leg_id = 2;
  void clear_leg_id();
  uint32_t leg_id() const;
  void set_leg_id(uint32_t value);
  private:
  uint32_t _internal_leg_id() const;
  void _internal_set_leg_id(uint32_t value);
  public:

  // uint32 leg_count = 3;
  void clear_leg_count();
  uint32_t leg_count() const;
  void set_leg_count(uint32_t value);
  private:
  uint32_t _internal_leg_count() const;
  void _internal_set_leg_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > location_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver > maneuver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_;
    ::valhalla::DirectionsLeg_Summary* summary_;
    uint64_t trip_id_;
    uint32_t leg_id_;
    uint32_t leg_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsRoute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsRoute) */ {
 public:
  inline DirectionsRoute() : DirectionsRoute(nullptr) {}
  ~DirectionsRoute() override;
  explicit PROTOBUF_CONSTEXPR DirectionsRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsRoute(const DirectionsRoute& from);
  DirectionsRoute(DirectionsRoute&& from) noexcept
    : DirectionsRoute() {
    *this = ::std::move(from);
  }

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsRoute& operator=(DirectionsRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsRoute* internal_default_instance() {
    return reinterpret_cast<const DirectionsRoute*>(
               &_DirectionsRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DirectionsRoute& a, DirectionsRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsRoute";
  }
  protected:
  explicit DirectionsRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;
  public:
  void clear_legs();
  ::valhalla::DirectionsLeg* mutable_legs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >*
      mutable_legs();
  private:
  const ::valhalla::DirectionsLeg& _internal_legs(int index) const;
  ::valhalla::DirectionsLeg* _internal_add_legs();
  public:
  const ::valhalla::DirectionsLeg& legs(int index) const;
  ::valhalla::DirectionsLeg* add_legs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg > legs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class Directions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Directions) */ {
 public:
  inline Directions() : Directions(nullptr) {}
  ~Directions() override;
  explicit PROTOBUF_CONSTEXPR Directions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Directions(const Directions& from);
  Directions(Directions&& from) noexcept
    : Directions() {
    *this = ::std::move(from);
  }

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Directions& operator=(Directions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Directions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Directions* internal_default_instance() {
    return reinterpret_cast<const Directions*>(
               &_Directions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Directions& a, Directions& b) {
    a.Swap(&b);
  }
  inline void Swap(Directions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Directions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Directions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Directions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Directions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Directions";
  }
  protected:
  explicit Directions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::valhalla::DirectionsRoute* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >*
      mutable_routes();
  private:
  const ::valhalla::DirectionsRoute& _internal_routes(int index) const;
  ::valhalla::DirectionsRoute* _internal_add_routes();
  public:
  const ::valhalla::DirectionsRoute& routes(int index) const;
  ::valhalla::DirectionsRoute* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute > routes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DirectionsLeg_Summary

// float length = 1;
inline void DirectionsLeg_Summary::clear_length() {
  _impl_.length_ = 0;
}
inline float DirectionsLeg_Summary::_internal_length() const {
  return _impl_.length_;
}
inline float DirectionsLeg_Summary::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.length)
  return _internal_length();
}
inline void DirectionsLeg_Summary::_internal_set_length(float value) {
  
  _impl_.length_ = value;
}
inline void DirectionsLeg_Summary::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.length)
}

// double time = 2;
inline void DirectionsLeg_Summary::clear_time() {
  _impl_.time_ = 0;
}
inline double DirectionsLeg_Summary::_internal_time() const {
  return _impl_.time_;
}
inline double DirectionsLeg_Summary::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.time)
  return _internal_time();
}
inline void DirectionsLeg_Summary::_internal_set_time(double value) {
  
  _impl_.time_ = value;
}
inline void DirectionsLeg_Summary::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.time)
}

// .valhalla.BoundingBox bbox = 3;
inline bool DirectionsLeg_Summary::_internal_has_bbox() const {
  return this != internal_default_instance() && _impl_.bbox_ != nullptr;
}
inline bool DirectionsLeg_Summary::has_bbox() const {
  return _internal_has_bbox();
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::_internal_bbox() const {
  const ::valhalla::BoundingBox* p = _impl_.bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(
      ::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.bbox)
  return _internal_bbox();
}
inline void DirectionsLeg_Summary::unsafe_arena_set_allocated_bbox(
    ::valhalla::BoundingBox* bbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  _impl_.bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::release_bbox() {
  
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::unsafe_arena_release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Summary.bbox)
  
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::_internal_mutable_bbox() {
  
  if (_impl_.bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArenaForAllocation());
    _impl_.bbox_ = p;
  }
  return _impl_.bbox_;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::mutable_bbox() {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Summary.bbox)
  return _msg;
}
inline void DirectionsLeg_Summary::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  if (bbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox));
    if (message_arena != submessage_arena) {
      bbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}

// bool has_time_restrictions = 4;
inline void DirectionsLeg_Summary::clear_has_time_restrictions() {
  _impl_.has_time_restrictions_ = false;
}
inline bool DirectionsLeg_Summary::_internal_has_time_restrictions() const {
  return _impl_.has_time_restrictions_;
}
inline bool DirectionsLeg_Summary::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Summary::_internal_set_has_time_restrictions(bool value) {
  
  _impl_.has_time_restrictions_ = value;
}
inline void DirectionsLeg_Summary::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_time_restrictions)
}

// bool has_toll = 5;
inline void DirectionsLeg_Summary::clear_has_toll() {
  _impl_.has_toll_ = false;
}
inline bool DirectionsLeg_Summary::_internal_has_toll() const {
  return _impl_.has_toll_;
}
inline bool DirectionsLeg_Summary::has_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_toll)
  return _internal_has_toll();
}
inline void DirectionsLeg_Summary::_internal_set_has_toll(bool value) {
  
  _impl_.has_toll_ = value;
}
inline void DirectionsLeg_Summary::set_has_toll(bool value) {
  _internal_set_has_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_toll)
}

// bool has_ferry = 6;
inline void DirectionsLeg_Summary::clear_has_ferry() {
  _impl_.has_ferry_ = false;
}
inline bool DirectionsLeg_Summary::_internal_has_ferry() const {
  return _impl_.has_ferry_;
}
inline bool DirectionsLeg_Summary::has_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_ferry)
  return _internal_has_ferry();
}
inline void DirectionsLeg_Summary::_internal_set_has_ferry(bool value) {
  
  _impl_.has_ferry_ = value;
}
inline void DirectionsLeg_Summary::set_has_ferry(bool value) {
  _internal_set_has_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_ferry)
}

// bool has_highway = 7;
inline void DirectionsLeg_Summary::clear_has_highway() {
  _impl_.has_highway_ = false;
}
inline bool DirectionsLeg_Summary::_internal_has_highway() const {
  return _impl_.has_highway_;
}
inline bool DirectionsLeg_Summary::has_highway() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_highway)
  return _internal_has_highway();
}
inline void DirectionsLeg_Summary::_internal_set_has_highway(bool value) {
  
  _impl_.has_highway_ = value;
}
inline void DirectionsLeg_Summary::set_has_highway(bool value) {
  _internal_set_has_highway(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_highway)
}

// -------------------------------------------------------------------

// DirectionsLeg_GuidanceView

// string data_id = 1;
inline void DirectionsLeg_GuidanceView::clear_data_id() {
  _impl_.data_id_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_GuidanceView::data_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _internal_data_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_GuidanceView::set_data_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_data_id() {
  std::string* _s = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_data_id() const {
  return _impl_.data_id_.Get();
}
inline void DirectionsLeg_GuidanceView::_internal_set_data_id(const std::string& value) {
  
  _impl_.data_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_data_id() {
  
  return _impl_.data_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::release_data_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _impl_.data_id_.Release();
}
inline void DirectionsLeg_GuidanceView::set_allocated_data_id(std::string* data_id) {
  if (data_id != nullptr) {
    
  } else {
    
  }
  _impl_.data_id_.SetAllocated(data_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_id_.IsDefault()) {
    _impl_.data_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.data_id)
}

// .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
inline void DirectionsLeg_GuidanceView::clear_type() {
  _impl_.type_ = 0;
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::_internal_type() const {
  return static_cast< ::valhalla::DirectionsLeg_GuidanceView_Type >(_impl_.type_);
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.type)
  return _internal_type();
}
inline void DirectionsLeg_GuidanceView::_internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  
  _impl_.type_ = value;
}
inline void DirectionsLeg_GuidanceView::set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.type)
}

// string base_id = 3;
inline void DirectionsLeg_GuidanceView::clear_base_id() {
  _impl_.base_id_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_GuidanceView::base_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _internal_base_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_GuidanceView::set_base_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_base_id() {
  std::string* _s = _internal_mutable_base_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_base_id() const {
  return _impl_.base_id_.Get();
}
inline void DirectionsLeg_GuidanceView::_internal_set_base_id(const std::string& value) {
  
  _impl_.base_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_base_id() {
  
  return _impl_.base_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::release_base_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _impl_.base_id_.Release();
}
inline void DirectionsLeg_GuidanceView::set_allocated_base_id(std::string* base_id) {
  if (base_id != nullptr) {
    
  } else {
    
  }
  _impl_.base_id_.SetAllocated(base_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_id_.IsDefault()) {
    _impl_.base_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.base_id)
}

// repeated string overlay_ids = 4;
inline int DirectionsLeg_GuidanceView::_internal_overlay_ids_size() const {
  return _impl_.overlay_ids_.size();
}
inline int DirectionsLeg_GuidanceView::overlay_ids_size() const {
  return _internal_overlay_ids_size();
}
inline void DirectionsLeg_GuidanceView::clear_overlay_ids() {
  _impl_.overlay_ids_.Clear();
}
inline std::string* DirectionsLeg_GuidanceView::add_overlay_ids() {
  std::string* _s = _internal_add_overlay_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_overlay_ids(int index) const {
  return _impl_.overlay_ids_.Get(index);
}
inline const std::string& DirectionsLeg_GuidanceView::overlay_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _internal_overlay_ids(index);
}
inline std::string* DirectionsLeg_GuidanceView::mutable_overlay_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _impl_.overlay_ids_.Mutable(index);
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const std::string& value) {
  _impl_.overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, std::string&& value) {
  _impl_.overlay_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value, size_t size) {
  _impl_.overlay_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline std::string* DirectionsLeg_GuidanceView::_internal_add_overlay_ids() {
  return _impl_.overlay_ids_.Add();
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const std::string& value) {
  _impl_.overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(std::string&& value) {
  _impl_.overlay_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value, size_t size) {
  _impl_.overlay_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DirectionsLeg_GuidanceView::overlay_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _impl_.overlay_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DirectionsLeg_GuidanceView::mutable_overlay_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return &_impl_.overlay_ids_;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver

// .valhalla.DirectionsLeg.Maneuver.Type type = 1;
inline void DirectionsLeg_Maneuver::clear_type() {
  _impl_.type_ = 0;
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::_internal_type() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(_impl_.type_);
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.type)
  return _internal_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  
  _impl_.type_ = value;
}
inline void DirectionsLeg_Maneuver::set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.type)
}

// string text_instruction = 2;
inline void DirectionsLeg_Maneuver::clear_text_instruction() {
  _impl_.text_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::text_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _internal_text_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_text_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_text_instruction() {
  std::string* _s = _internal_mutable_text_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_text_instruction() const {
  return _impl_.text_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_text_instruction(const std::string& value) {
  
  _impl_.text_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_text_instruction() {
  
  return _impl_.text_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_text_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _impl_.text_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_text_instruction(std::string* text_instruction) {
  if (text_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.text_instruction_.SetAllocated(text_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_instruction_.IsDefault()) {
    _impl_.text_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.text_instruction)
}

// repeated .valhalla.StreetName street_name = 3;
inline int DirectionsLeg_Maneuver::_internal_street_name_size() const {
  return _impl_.street_name_.size();
}
inline int DirectionsLeg_Maneuver::street_name_size() const {
  return _internal_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.street_name)
  return _impl_.street_name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return &_impl_.street_name_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_street_name(int index) const {
  return _impl_.street_name_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.street_name)
  return _internal_street_name(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_street_name() {
  return _impl_.street_name_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_street_name() {
  ::valhalla::StreetName* _add = _internal_add_street_name();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.street_name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return _impl_.street_name_;
}

// float length = 4;
inline void DirectionsLeg_Maneuver::clear_length() {
  _impl_.length_ = 0;
}
inline float DirectionsLeg_Maneuver::_internal_length() const {
  return _impl_.length_;
}
inline float DirectionsLeg_Maneuver::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.length)
  return _internal_length();
}
inline void DirectionsLeg_Maneuver::_internal_set_length(float value) {
  
  _impl_.length_ = value;
}
inline void DirectionsLeg_Maneuver::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.length)
}

// double time = 5;
inline void DirectionsLeg_Maneuver::clear_time() {
  _impl_.time_ = 0;
}
inline double DirectionsLeg_Maneuver::_internal_time() const {
  return _impl_.time_;
}
inline double DirectionsLeg_Maneuver::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.time)
  return _internal_time();
}
inline void DirectionsLeg_Maneuver::_internal_set_time(double value) {
  
  _impl_.time_ = value;
}
inline void DirectionsLeg_Maneuver::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.time)
}

// .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline void DirectionsLeg_Maneuver::clear_begin_cardinal_direction() {
  _impl_.begin_cardinal_direction_ = 0;
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::_internal_begin_cardinal_direction() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(_impl_.begin_cardinal_direction_);
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::begin_cardinal_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
  return _internal_begin_cardinal_direction();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  
  _impl_.begin_cardinal_direction_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  _internal_set_begin_cardinal_direction(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
}

// uint32 begin_heading = 7;
inline void DirectionsLeg_Maneuver::clear_begin_heading() {
  _impl_.begin_heading_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_begin_heading() const {
  return _impl_.begin_heading_;
}
inline uint32_t DirectionsLeg_Maneuver::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_heading)
  return _internal_begin_heading();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_heading(uint32_t value) {
  
  _impl_.begin_heading_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_heading(uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_heading)
}

// uint32 begin_shape_index = 8;
inline void DirectionsLeg_Maneuver::clear_begin_shape_index() {
  _impl_.begin_shape_index_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_begin_shape_index() const {
  return _impl_.begin_shape_index_;
}
inline uint32_t DirectionsLeg_Maneuver::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_shape_index(uint32_t value) {
  
  _impl_.begin_shape_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_shape_index(uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
}

// uint32 end_shape_index = 9;
inline void DirectionsLeg_Maneuver::clear_end_shape_index() {
  _impl_.end_shape_index_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_end_shape_index() const {
  return _impl_.end_shape_index_;
}
inline uint32_t DirectionsLeg_Maneuver::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_shape_index)
  return _internal_end_shape_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_end_shape_index(uint32_t value) {
  
  _impl_.end_shape_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_end_shape_index(uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_shape_index)
}

// bool portions_toll = 10;
inline void DirectionsLeg_Maneuver::clear_portions_toll() {
  _impl_.portions_toll_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_portions_toll() const {
  return _impl_.portions_toll_;
}
inline bool DirectionsLeg_Maneuver::portions_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_toll)
  return _internal_portions_toll();
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_toll(bool value) {
  
  _impl_.portions_toll_ = value;
}
inline void DirectionsLeg_Maneuver::set_portions_toll(bool value) {
  _internal_set_portions_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_toll)
}

// bool portions_unpaved = 11;
inline void DirectionsLeg_Maneuver::clear_portions_unpaved() {
  _impl_.portions_unpaved_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_portions_unpaved() const {
  return _impl_.portions_unpaved_;
}
inline bool DirectionsLeg_Maneuver::portions_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
  return _internal_portions_unpaved();
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_unpaved(bool value) {
  
  _impl_.portions_unpaved_ = value;
}
inline void DirectionsLeg_Maneuver::set_portions_unpaved(bool value) {
  _internal_set_portions_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
}

// string verbal_transition_alert_instruction = 12;
inline void DirectionsLeg_Maneuver::clear_verbal_transition_alert_instruction() {
  _impl_.verbal_transition_alert_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_transition_alert_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _internal_verbal_transition_alert_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verbal_transition_alert_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_transition_alert_instruction() {
  std::string* _s = _internal_mutable_verbal_transition_alert_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_transition_alert_instruction() const {
  return _impl_.verbal_transition_alert_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_transition_alert_instruction(const std::string& value) {
  
  _impl_.verbal_transition_alert_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_transition_alert_instruction() {
  
  return _impl_.verbal_transition_alert_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_transition_alert_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _impl_.verbal_transition_alert_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_transition_alert_instruction(std::string* verbal_transition_alert_instruction) {
  if (verbal_transition_alert_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.verbal_transition_alert_instruction_.SetAllocated(verbal_transition_alert_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verbal_transition_alert_instruction_.IsDefault()) {
    _impl_.verbal_transition_alert_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}

// string verbal_pre_transition_instruction = 13;
inline void DirectionsLeg_Maneuver::clear_verbal_pre_transition_instruction() {
  _impl_.verbal_pre_transition_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_pre_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _internal_verbal_pre_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verbal_pre_transition_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_pre_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_pre_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_pre_transition_instruction() const {
  return _impl_.verbal_pre_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_pre_transition_instruction(const std::string& value) {
  
  _impl_.verbal_pre_transition_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_pre_transition_instruction() {
  
  return _impl_.verbal_pre_transition_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_pre_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _impl_.verbal_pre_transition_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_pre_transition_instruction(std::string* verbal_pre_transition_instruction) {
  if (verbal_pre_transition_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.verbal_pre_transition_instruction_.SetAllocated(verbal_pre_transition_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verbal_pre_transition_instruction_.IsDefault()) {
    _impl_.verbal_pre_transition_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}

// string verbal_post_transition_instruction = 14;
inline void DirectionsLeg_Maneuver::clear_verbal_post_transition_instruction() {
  _impl_.verbal_post_transition_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_post_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _internal_verbal_post_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verbal_post_transition_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_post_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_post_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_post_transition_instruction() const {
  return _impl_.verbal_post_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_post_transition_instruction(const std::string& value) {
  
  _impl_.verbal_post_transition_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_post_transition_instruction() {
  
  return _impl_.verbal_post_transition_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_post_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _impl_.verbal_post_transition_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_post_transition_instruction(std::string* verbal_post_transition_instruction) {
  if (verbal_post_transition_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.verbal_post_transition_instruction_.SetAllocated(verbal_post_transition_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verbal_post_transition_instruction_.IsDefault()) {
    _impl_.verbal_post_transition_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}

// repeated .valhalla.StreetName begin_street_name = 15;
inline int DirectionsLeg_Maneuver::_internal_begin_street_name_size() const {
  return _impl_.begin_street_name_.size();
}
inline int DirectionsLeg_Maneuver::begin_street_name_size() const {
  return _internal_begin_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_begin_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _impl_.begin_street_name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_begin_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return &_impl_.begin_street_name_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_begin_street_name(int index) const {
  return _impl_.begin_street_name_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::begin_street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _internal_begin_street_name(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_begin_street_name() {
  return _impl_.begin_street_name_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_begin_street_name() {
  ::valhalla::StreetName* _add = _internal_add_begin_street_name();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::begin_street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _impl_.begin_street_name_;
}

// .valhalla.TripSign sign = 16;
inline bool DirectionsLeg_Maneuver::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool DirectionsLeg_Maneuver::has_sign() const {
  return _internal_has_sign();
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::_internal_sign() const {
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(
      ::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.sign)
  return _internal_sign();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_sign(
    ::valhalla::TripSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::release_sign() {
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.sign)
  
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::mutable_sign() {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.sign)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_sign(::valhalla::TripSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}

// uint32 roundabout_exit_count = 17;
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_count() {
  _impl_.roundabout_exit_count_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_roundabout_exit_count() const {
  return _impl_.roundabout_exit_count_;
}
inline uint32_t DirectionsLeg_Maneuver::roundabout_exit_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
  return _internal_roundabout_exit_count();
}
inline void DirectionsLeg_Maneuver::_internal_set_roundabout_exit_count(uint32_t value) {
  
  _impl_.roundabout_exit_count_ = value;
}
inline void DirectionsLeg_Maneuver::set_roundabout_exit_count(uint32_t value) {
  _internal_set_roundabout_exit_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
}

// string depart_instruction = 18;
inline void DirectionsLeg_Maneuver::clear_depart_instruction() {
  _impl_.depart_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _internal_depart_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_depart_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.depart_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_depart_instruction() {
  std::string* _s = _internal_mutable_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_depart_instruction() const {
  return _impl_.depart_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_depart_instruction(const std::string& value) {
  
  _impl_.depart_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_depart_instruction() {
  
  return _impl_.depart_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _impl_.depart_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_depart_instruction(std::string* depart_instruction) {
  if (depart_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.depart_instruction_.SetAllocated(depart_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.depart_instruction_.IsDefault()) {
    _impl_.depart_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}

// string verbal_depart_instruction = 19;
inline void DirectionsLeg_Maneuver::clear_verbal_depart_instruction() {
  _impl_.verbal_depart_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _internal_verbal_depart_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_depart_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verbal_depart_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_depart_instruction() {
  std::string* _s = _internal_mutable_verbal_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_depart_instruction() const {
  return _impl_.verbal_depart_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_depart_instruction(const std::string& value) {
  
  _impl_.verbal_depart_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_depart_instruction() {
  
  return _impl_.verbal_depart_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _impl_.verbal_depart_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_depart_instruction(std::string* verbal_depart_instruction) {
  if (verbal_depart_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.verbal_depart_instruction_.SetAllocated(verbal_depart_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verbal_depart_instruction_.IsDefault()) {
    _impl_.verbal_depart_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}

// string arrive_instruction = 20;
inline void DirectionsLeg_Maneuver::clear_arrive_instruction() {
  _impl_.arrive_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _internal_arrive_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_arrive_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arrive_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_arrive_instruction() {
  std::string* _s = _internal_mutable_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_arrive_instruction() const {
  return _impl_.arrive_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_arrive_instruction(const std::string& value) {
  
  _impl_.arrive_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_arrive_instruction() {
  
  return _impl_.arrive_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _impl_.arrive_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_arrive_instruction(std::string* arrive_instruction) {
  if (arrive_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.arrive_instruction_.SetAllocated(arrive_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arrive_instruction_.IsDefault()) {
    _impl_.arrive_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}

// string verbal_arrive_instruction = 21;
inline void DirectionsLeg_Maneuver::clear_verbal_arrive_instruction() {
  _impl_.verbal_arrive_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _internal_verbal_arrive_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verbal_arrive_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_arrive_instruction() {
  std::string* _s = _internal_mutable_verbal_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_arrive_instruction() const {
  return _impl_.verbal_arrive_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_arrive_instruction(const std::string& value) {
  
  _impl_.verbal_arrive_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_arrive_instruction() {
  
  return _impl_.verbal_arrive_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _impl_.verbal_arrive_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_arrive_instruction(std::string* verbal_arrive_instruction) {
  if (verbal_arrive_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.verbal_arrive_instruction_.SetAllocated(verbal_arrive_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verbal_arrive_instruction_.IsDefault()) {
    _impl_.verbal_arrive_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}

// .valhalla.TransitRouteInfo transit_info = 22;
inline bool DirectionsLeg_Maneuver::_internal_has_transit_info() const {
  return this != internal_default_instance() && _impl_.transit_info_ != nullptr;
}
inline bool DirectionsLeg_Maneuver::has_transit_info() const {
  return _internal_has_transit_info();
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::_internal_transit_info() const {
  const ::valhalla::TransitRouteInfo* p = _impl_.transit_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitRouteInfo&>(
      ::valhalla::_TransitRouteInfo_default_instance_);
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::transit_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _internal_transit_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_transit_info(
    ::valhalla::TransitRouteInfo* transit_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_info_);
  }
  _impl_.transit_info_ = transit_info;
  if (transit_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::release_transit_info() {
  
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_info_;
  _impl_.transit_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::unsafe_arena_release_transit_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.transit_info)
  
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_info_;
  _impl_.transit_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::_internal_mutable_transit_info() {
  
  if (_impl_.transit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitRouteInfo>(GetArenaForAllocation());
    _impl_.transit_info_ = p;
  }
  return _impl_.transit_info_;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::mutable_transit_info() {
  ::valhalla::TransitRouteInfo* _msg = _internal_mutable_transit_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_transit_info(::valhalla::TransitRouteInfo* transit_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transit_info_);
  }
  if (transit_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_info));
    if (message_arena != submessage_arena) {
      transit_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transit_info_ = transit_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}

// bool verbal_multi_cue = 23;
inline void DirectionsLeg_Maneuver::clear_verbal_multi_cue() {
  _impl_.verbal_multi_cue_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_verbal_multi_cue() const {
  return _impl_.verbal_multi_cue_;
}
inline bool DirectionsLeg_Maneuver::verbal_multi_cue() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
  return _internal_verbal_multi_cue();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_multi_cue(bool value) {
  
  _impl_.verbal_multi_cue_ = value;
}
inline void DirectionsLeg_Maneuver::set_verbal_multi_cue(bool value) {
  _internal_set_verbal_multi_cue(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
}

// .valhalla.TravelMode travel_mode = 24;
inline void DirectionsLeg_Maneuver::clear_travel_mode() {
  _impl_.travel_mode_ = 0;
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::_internal_travel_mode() const {
  return static_cast< ::valhalla::TravelMode >(_impl_.travel_mode_);
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.travel_mode)
  return _internal_travel_mode();
}
inline void DirectionsLeg_Maneuver::_internal_set_travel_mode(::valhalla::TravelMode value) {
  
  _impl_.travel_mode_ = value;
}
inline void DirectionsLeg_Maneuver::set_travel_mode(::valhalla::TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.travel_mode)
}

// .valhalla.VehicleType vehicle_type = 25;
inline void DirectionsLeg_Maneuver::clear_vehicle_type() {
  _impl_.vehicle_type_ = 0;
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::_internal_vehicle_type() const {
  return static_cast< ::valhalla::VehicleType >(_impl_.vehicle_type_);
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.vehicle_type)
  return _internal_vehicle_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_vehicle_type(::valhalla::VehicleType value) {
  
  _impl_.vehicle_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_vehicle_type(::valhalla::VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.vehicle_type)
}

// .valhalla.PedestrianType pedestrian_type = 26;
inline void DirectionsLeg_Maneuver::clear_pedestrian_type() {
  _impl_.pedestrian_type_ = 0;
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::_internal_pedestrian_type() const {
  return static_cast< ::valhalla::PedestrianType >(_impl_.pedestrian_type_);
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_pedestrian_type(::valhalla::PedestrianType value) {
  
  _impl_.pedestrian_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_pedestrian_type(::valhalla::PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
}

// .valhalla.BicycleType bicycle_type = 27;
inline void DirectionsLeg_Maneuver::clear_bicycle_type() {
  _impl_.bicycle_type_ = 0;
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::_internal_bicycle_type() const {
  return static_cast< ::valhalla::BicycleType >(_impl_.bicycle_type_);
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bicycle_type)
  return _internal_bicycle_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_bicycle_type(::valhalla::BicycleType value) {
  
  _impl_.bicycle_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_bicycle_type(::valhalla::BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bicycle_type)
}

// .valhalla.TransitType transit_type = 28;
inline void DirectionsLeg_Maneuver::clear_transit_type() {
  _impl_.transit_type_ = 0;
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::_internal_transit_type() const {
  return static_cast< ::valhalla::TransitType >(_impl_.transit_type_);
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_type)
  return _internal_transit_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_transit_type(::valhalla::TransitType value) {
  
  _impl_.transit_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_transit_type(::valhalla::TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.transit_type)
}

// uint32 begin_path_index = 29;
inline void DirectionsLeg_Maneuver::clear_begin_path_index() {
  _impl_.begin_path_index_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_begin_path_index() const {
  return _impl_.begin_path_index_;
}
inline uint32_t DirectionsLeg_Maneuver::begin_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_path_index)
  return _internal_begin_path_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_path_index(uint32_t value) {
  
  _impl_.begin_path_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_path_index(uint32_t value) {
  _internal_set_begin_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_path_index)
}

// uint32 end_path_index = 30;
inline void DirectionsLeg_Maneuver::clear_end_path_index() {
  _impl_.end_path_index_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_end_path_index() const {
  return _impl_.end_path_index_;
}
inline uint32_t DirectionsLeg_Maneuver::end_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_path_index)
  return _internal_end_path_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_end_path_index(uint32_t value) {
  
  _impl_.end_path_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_end_path_index(uint32_t value) {
  _internal_set_end_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_path_index)
}

// bool to_stay_on = 31;
inline void DirectionsLeg_Maneuver::clear_to_stay_on() {
  _impl_.to_stay_on_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_to_stay_on() const {
  return _impl_.to_stay_on_;
}
inline bool DirectionsLeg_Maneuver::to_stay_on() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.to_stay_on)
  return _internal_to_stay_on();
}
inline void DirectionsLeg_Maneuver::_internal_set_to_stay_on(bool value) {
  
  _impl_.to_stay_on_ = value;
}
inline void DirectionsLeg_Maneuver::set_to_stay_on(bool value) {
  _internal_set_to_stay_on(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.to_stay_on)
}

// repeated .valhalla.StreetName roundabout_exit_street_names = 32;
inline int DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names_size() const {
  return _impl_.roundabout_exit_street_names_.size();
}
inline int DirectionsLeg_Maneuver::roundabout_exit_street_names_size() const {
  return _internal_roundabout_exit_street_names_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _impl_.roundabout_exit_street_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return &_impl_.roundabout_exit_street_names_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names(int index) const {
  return _impl_.roundabout_exit_street_names_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::roundabout_exit_street_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _internal_roundabout_exit_street_names(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_roundabout_exit_street_names() {
  return _impl_.roundabout_exit_street_names_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_roundabout_exit_street_names() {
  ::valhalla::StreetName* _add = _internal_add_roundabout_exit_street_names();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::roundabout_exit_street_names() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _impl_.roundabout_exit_street_names_;
}

// uint32 turn_degree = 33;
inline void DirectionsLeg_Maneuver::clear_turn_degree() {
  _impl_.turn_degree_ = 0u;
}
inline uint32_t DirectionsLeg_Maneuver::_internal_turn_degree() const {
  return _impl_.turn_degree_;
}
inline uint32_t DirectionsLeg_Maneuver::turn_degree() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.turn_degree)
  return _internal_turn_degree();
}
inline void DirectionsLeg_Maneuver::_internal_set_turn_degree(uint32_t value) {
  
  _impl_.turn_degree_ = value;
}
inline void DirectionsLeg_Maneuver::set_turn_degree(uint32_t value) {
  _internal_set_turn_degree(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.turn_degree)
}

// bool has_time_restrictions = 34;
inline void DirectionsLeg_Maneuver::clear_has_time_restrictions() {
  _impl_.has_time_restrictions_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_has_time_restrictions() const {
  return _impl_.has_time_restrictions_;
}
inline bool DirectionsLeg_Maneuver::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Maneuver::_internal_set_has_time_restrictions(bool value) {
  
  _impl_.has_time_restrictions_ = value;
}
inline void DirectionsLeg_Maneuver::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
}

// repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
inline int DirectionsLeg_Maneuver::_internal_guidance_views_size() const {
  return _impl_.guidance_views_.size();
}
inline int DirectionsLeg_Maneuver::guidance_views_size() const {
  return _internal_guidance_views_size();
}
inline void DirectionsLeg_Maneuver::clear_guidance_views() {
  _impl_.guidance_views_.Clear();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::mutable_guidance_views(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _impl_.guidance_views_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
DirectionsLeg_Maneuver::mutable_guidance_views() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return &_impl_.guidance_views_;
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::_internal_guidance_views(int index) const {
  return _impl_.guidance_views_.Get(index);
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::guidance_views(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _internal_guidance_views(index);
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::_internal_add_guidance_views() {
  return _impl_.guidance_views_.Add();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::add_guidance_views() {
  ::valhalla::DirectionsLeg_GuidanceView* _add = _internal_add_guidance_views();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
DirectionsLeg_Maneuver::guidance_views() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _impl_.guidance_views_;
}

// .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
inline void DirectionsLeg_Maneuver::clear_bss_maneuver_type() {
  _impl_.bss_maneuver_type_ = 0;
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::_internal_bss_maneuver_type() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType >(_impl_.bss_maneuver_type_);
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::bss_maneuver_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
  return _internal_bss_maneuver_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  
  _impl_.bss_maneuver_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  _internal_set_bss_maneuver_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
}

// string verbal_succinct_transition_instruction = 37;
inline void DirectionsLeg_Maneuver::clear_verbal_succinct_transition_instruction() {
  _impl_.verbal_succinct_transition_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_succinct_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _internal_verbal_succinct_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_succinct_transition_instruction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verbal_succinct_transition_instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_succinct_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_succinct_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_succinct_transition_instruction() const {
  return _impl_.verbal_succinct_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_succinct_transition_instruction(const std::string& value) {
  
  _impl_.verbal_succinct_transition_instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_succinct_transition_instruction() {
  
  return _impl_.verbal_succinct_transition_instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_succinct_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _impl_.verbal_succinct_transition_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_succinct_transition_instruction(std::string* verbal_succinct_transition_instruction) {
  if (verbal_succinct_transition_instruction != nullptr) {
    
  } else {
    
  }
  _impl_.verbal_succinct_transition_instruction_.SetAllocated(verbal_succinct_transition_instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verbal_succinct_transition_instruction_.IsDefault()) {
    _impl_.verbal_succinct_transition_instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}

// .valhalla.BikeShareStationInfo bss_info = 38;
inline bool DirectionsLeg_Maneuver::_internal_has_bss_info() const {
  return this != internal_default_instance() && _impl_.bss_info_ != nullptr;
}
inline bool DirectionsLeg_Maneuver::has_bss_info() const {
  return _internal_has_bss_info();
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::_internal_bss_info() const {
  const ::valhalla::BikeShareStationInfo* p = _impl_.bss_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BikeShareStationInfo&>(
      ::valhalla::_BikeShareStationInfo_default_instance_);
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_info)
  return _internal_bss_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_bss_info(
    ::valhalla::BikeShareStationInfo* bss_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bss_info_);
  }
  _impl_.bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::release_bss_info() {
  
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::unsafe_arena_release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
  return temp;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::_internal_mutable_bss_info() {
  
  if (_impl_.bss_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BikeShareStationInfo>(GetArenaForAllocation());
    _impl_.bss_info_ = p;
  }
  return _impl_.bss_info_;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::mutable_bss_info() {
  ::valhalla::BikeShareStationInfo* _msg = _internal_mutable_bss_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.bss_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bss_info_);
  }
  if (bss_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bss_info));
    if (message_arena != submessage_arena) {
      bss_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bss_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bss_info_ = bss_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}

// bool portions_highway = 39;
inline void DirectionsLeg_Maneuver::clear_portions_highway() {
  _impl_.portions_highway_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_portions_highway() const {
  return _impl_.portions_highway_;
}
inline bool DirectionsLeg_Maneuver::portions_highway() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_highway)
  return _internal_portions_highway();
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_highway(bool value) {
  
  _impl_.portions_highway_ = value;
}
inline void DirectionsLeg_Maneuver::set_portions_highway(bool value) {
  _internal_set_portions_highway(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_highway)
}

// bool portions_ferry = 40;
inline void DirectionsLeg_Maneuver::clear_portions_ferry() {
  _impl_.portions_ferry_ = false;
}
inline bool DirectionsLeg_Maneuver::_internal_portions_ferry() const {
  return _impl_.portions_ferry_;
}
inline bool DirectionsLeg_Maneuver::portions_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_ferry)
  return _internal_portions_ferry();
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_ferry(bool value) {
  
  _impl_.portions_ferry_ = value;
}
inline void DirectionsLeg_Maneuver::set_portions_ferry(bool value) {
  _internal_set_portions_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_ferry)
}

// -------------------------------------------------------------------

// DirectionsLeg

// uint64 trip_id = 1;
inline void DirectionsLeg::clear_trip_id() {
  _impl_.trip_id_ = uint64_t{0u};
}
inline uint64_t DirectionsLeg::_internal_trip_id() const {
  return _impl_.trip_id_;
}
inline uint64_t DirectionsLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.trip_id)
  return _internal_trip_id();
}
inline void DirectionsLeg::_internal_set_trip_id(uint64_t value) {
  
  _impl_.trip_id_ = value;
}
inline void DirectionsLeg::set_trip_id(uint64_t value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.trip_id)
}

// uint32 leg_id = 2;
inline void DirectionsLeg::clear_leg_id() {
  _impl_.leg_id_ = 0u;
}
inline uint32_t DirectionsLeg::_internal_leg_id() const {
  return _impl_.leg_id_;
}
inline uint32_t DirectionsLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_id)
  return _internal_leg_id();
}
inline void DirectionsLeg::_internal_set_leg_id(uint32_t value) {
  
  _impl_.leg_id_ = value;
}
inline void DirectionsLeg::set_leg_id(uint32_t value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_id)
}

// uint32 leg_count = 3;
inline void DirectionsLeg::clear_leg_count() {
  _impl_.leg_count_ = 0u;
}
inline uint32_t DirectionsLeg::_internal_leg_count() const {
  return _impl_.leg_count_;
}
inline uint32_t DirectionsLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_count)
  return _internal_leg_count();
}
inline void DirectionsLeg::_internal_set_leg_count(uint32_t value) {
  
  _impl_.leg_count_ = value;
}
inline void DirectionsLeg::set_leg_count(uint32_t value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_count)
}

// repeated .valhalla.Location location = 4;
inline int DirectionsLeg::_internal_location_size() const {
  return _impl_.location_.size();
}
inline int DirectionsLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* DirectionsLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.location)
  return _impl_.location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
DirectionsLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.location)
  return &_impl_.location_;
}
inline const ::valhalla::Location& DirectionsLeg::_internal_location(int index) const {
  return _impl_.location_.Get(index);
}
inline const ::valhalla::Location& DirectionsLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.location)
  return _internal_location(index);
}
inline ::valhalla::Location* DirectionsLeg::_internal_add_location() {
  return _impl_.location_.Add();
}
inline ::valhalla::Location* DirectionsLeg::add_location() {
  ::valhalla::Location* _add = _internal_add_location();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.location)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
DirectionsLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.location)
  return _impl_.location_;
}

// .valhalla.DirectionsLeg.Summary summary = 5;
inline bool DirectionsLeg::_internal_has_summary() const {
  return this != internal_default_instance() && _impl_.summary_ != nullptr;
}
inline bool DirectionsLeg::has_summary() const {
  return _internal_has_summary();
}
inline void DirectionsLeg::clear_summary() {
  if (GetArenaForAllocation() == nullptr && _impl_.summary_ != nullptr) {
    delete _impl_.summary_;
  }
  _impl_.summary_ = nullptr;
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::_internal_summary() const {
  const ::valhalla::DirectionsLeg_Summary* p = _impl_.summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::DirectionsLeg_Summary&>(
      ::valhalla::_DirectionsLeg_Summary_default_instance_);
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::summary() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.summary)
  return _internal_summary();
}
inline void DirectionsLeg::unsafe_arena_set_allocated_summary(
    ::valhalla::DirectionsLeg_Summary* summary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.summary_);
  }
  _impl_.summary_ = summary;
  if (summary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.summary)
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::release_summary() {
  
  ::valhalla::DirectionsLeg_Summary* temp = _impl_.summary_;
  _impl_.summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::unsafe_arena_release_summary() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.summary)
  
  ::valhalla::DirectionsLeg_Summary* temp = _impl_.summary_;
  _impl_.summary_ = nullptr;
  return temp;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::_internal_mutable_summary() {
  
  if (_impl_.summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::DirectionsLeg_Summary>(GetArenaForAllocation());
    _impl_.summary_ = p;
  }
  return _impl_.summary_;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::mutable_summary() {
  ::valhalla::DirectionsLeg_Summary* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.summary)
  return _msg;
}
inline void DirectionsLeg::set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.summary_;
  }
  if (summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(summary);
    if (message_arena != submessage_arena) {
      summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.summary_ = summary;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.summary)
}

// repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
inline int DirectionsLeg::_internal_maneuver_size() const {
  return _impl_.maneuver_.size();
}
inline int DirectionsLeg::maneuver_size() const {
  return _internal_maneuver_size();
}
inline void DirectionsLeg::clear_maneuver() {
  _impl_.maneuver_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::mutable_maneuver(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.maneuver)
  return _impl_.maneuver_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
DirectionsLeg::mutable_maneuver() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.maneuver)
  return &_impl_.maneuver_;
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::_internal_maneuver(int index) const {
  return _impl_.maneuver_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::maneuver(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.maneuver)
  return _internal_maneuver(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::_internal_add_maneuver() {
  return _impl_.maneuver_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::add_maneuver() {
  ::valhalla::DirectionsLeg_Maneuver* _add = _internal_add_maneuver();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.maneuver)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
DirectionsLeg::maneuver() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.maneuver)
  return _impl_.maneuver_;
}

// string shape = 7;
inline void DirectionsLeg::clear_shape() {
  _impl_.shape_.ClearToEmpty();
}
inline const std::string& DirectionsLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.shape)
  return _internal_shape();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg::set_shape(ArgT0&& arg0, ArgT... args) {
 
 _impl_.shape_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.shape)
}
inline std::string* DirectionsLeg::mutable_shape() {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.shape)
  return _s;
}
inline const std::string& DirectionsLeg::_internal_shape() const {
  return _impl_.shape_.Get();
}
inline void DirectionsLeg::_internal_set_shape(const std::string& value) {
  
  _impl_.shape_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg::_internal_mutable_shape() {
  
  return _impl_.shape_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectionsLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.shape)
  return _impl_.shape_.Release();
}
inline void DirectionsLeg::set_allocated_shape(std::string* shape) {
  if (shape != nullptr) {
    
  } else {
    
  }
  _impl_.shape_.SetAllocated(shape, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shape_.IsDefault()) {
    _impl_.shape_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.shape)
}

// -------------------------------------------------------------------

// DirectionsRoute

// repeated .valhalla.DirectionsLeg legs = 1;
inline int DirectionsRoute::_internal_legs_size() const {
  return _impl_.legs_.size();
}
inline int DirectionsRoute::legs_size() const {
  return _internal_legs_size();
}
inline void DirectionsRoute::clear_legs() {
  _impl_.legs_.Clear();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsRoute.legs)
  return _impl_.legs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >*
DirectionsRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsRoute.legs)
  return &_impl_.legs_;
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::_internal_legs(int index) const {
  return _impl_.legs_.Get(index);
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsRoute.legs)
  return _internal_legs(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::_internal_add_legs() {
  return _impl_.legs_.Add();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::add_legs() {
  ::valhalla::DirectionsLeg* _add = _internal_add_legs();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsRoute.legs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >&
DirectionsRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsRoute.legs)
  return _impl_.legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.DirectionsRoute routes = 1;
inline int Directions::_internal_routes_size() const {
  return _impl_.routes_.size();
}
inline int Directions::routes_size() const {
  return _internal_routes_size();
}
inline void Directions::clear_routes() {
  _impl_.routes_.Clear();
}
inline ::valhalla::DirectionsRoute* Directions::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.routes)
  return _impl_.routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >*
Directions::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.routes)
  return &_impl_.routes_;
}
inline const ::valhalla::DirectionsRoute& Directions::_internal_routes(int index) const {
  return _impl_.routes_.Get(index);
}
inline const ::valhalla::DirectionsRoute& Directions::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.routes)
  return _internal_routes(index);
}
inline ::valhalla::DirectionsRoute* Directions::_internal_add_routes() {
  return _impl_.routes_.Add();
}
inline ::valhalla::DirectionsRoute* Directions::add_routes() {
  ::valhalla::DirectionsRoute* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:valhalla.Directions.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >&
Directions::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Directions.routes)
  return _impl_.routes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::DirectionsLeg_GuidanceView_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_directions_2eproto
