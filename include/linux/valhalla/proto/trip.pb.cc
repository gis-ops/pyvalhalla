// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#include "trip.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace valhalla {
PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_from_way_id_)*/{}
  , /*decltype(_impl_.has_from_lanes_)*/{}
  , /*decltype(_impl_.has_to_lanes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_LaneConnectivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_LaneConnectivityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_LaneConnectivityDefaultTypeInternal() {}
  union {
    TripLeg_LaneConnectivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_TrafficSegment::TripLeg_TrafficSegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_segment_id_)*/{}
  , /*decltype(_impl_.has_begin_percent_)*/{}
  , /*decltype(_impl_.has_end_percent_)*/{}
  , /*decltype(_impl_.has_starts_segment_)*/{}
  , /*decltype(_impl_.has_ends_segment_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_TrafficSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_TrafficSegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_TrafficSegmentDefaultTypeInternal() {}
  union {
    TripLeg_TrafficSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Restriction::TripLeg_Restriction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_RestrictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_RestrictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_RestrictionDefaultTypeInternal() {}
  union {
    TripLeg_Restriction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Edge::TripLeg_Edge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{}
  , /*decltype(_impl_.lane_connectivity_)*/{}
  , /*decltype(_impl_.traffic_segment_)*/{}
  , /*decltype(_impl_.turn_lanes_)*/{}
  , /*decltype(_impl_.tagged_value_)*/{}
  , /*decltype(_impl_.sign_)*/nullptr
  , /*decltype(_impl_.transit_route_info_)*/nullptr
  , /*decltype(_impl_.restriction_)*/nullptr
  , /*decltype(_impl_.has_length_km_)*/{}
  , /*decltype(_impl_.has_speed_)*/{}
  , /*decltype(_impl_.has_road_class_)*/{}
  , /*decltype(_impl_.has_begin_heading_)*/{}
  , /*decltype(_impl_.has_end_heading_)*/{}
  , /*decltype(_impl_.has_begin_shape_index_)*/{}
  , /*decltype(_impl_.has_end_shape_index_)*/{}
  , /*decltype(_impl_.has_traversability_)*/{}
  , /*decltype(_impl_.has_use_)*/{}
  , /*decltype(_impl_.has_toll_)*/{}
  , /*decltype(_impl_.has_unpaved_)*/{}
  , /*decltype(_impl_.has_tunnel_)*/{}
  , /*decltype(_impl_.has_bridge_)*/{}
  , /*decltype(_impl_.has_roundabout_)*/{}
  , /*decltype(_impl_.has_internal_intersection_)*/{}
  , /*decltype(_impl_.has_drive_on_left_)*/{}
  , /*decltype(_impl_.has_surface_)*/{}
  , /*decltype(_impl_.has_travel_mode_)*/{}
  , /*decltype(_impl_.has_vehicle_type_)*/{}
  , /*decltype(_impl_.has_pedestrian_type_)*/{}
  , /*decltype(_impl_.has_bicycle_type_)*/{}
  , /*decltype(_impl_.has_transit_type_)*/{}
  , /*decltype(_impl_.has_id_)*/{}
  , /*decltype(_impl_.has_way_id_)*/{}
  , /*decltype(_impl_.has_weighted_grade_)*/{}
  , /*decltype(_impl_.has_max_upward_grade_)*/{}
  , /*decltype(_impl_.has_max_downward_grade_)*/{}
  , /*decltype(_impl_.has_lane_count_)*/{}
  , /*decltype(_impl_.has_cycle_lane_)*/{}
  , /*decltype(_impl_.has_bicycle_network_)*/{}
  , /*decltype(_impl_.has_sidewalk_)*/{}
  , /*decltype(_impl_.has_density_)*/{}
  , /*decltype(_impl_.has_speed_limit_)*/{}
  , /*decltype(_impl_.has_truck_speed_)*/{}
  , /*decltype(_impl_.has_truck_route_)*/{}
  , /*decltype(_impl_.has_mean_elevation_)*/{}
  , /*decltype(_impl_.has_has_time_restrictions_)*/{}
  , /*decltype(_impl_.has_default_speed_)*/{}
  , /*decltype(_impl_.has_destination_only_)*/{}
  , /*decltype(_impl_.has_is_urban_)*/{}
  , /*decltype(_impl_.has_source_along_edge_)*/{}
  , /*decltype(_impl_.has_target_along_edge_)*/{}
  , /*decltype(_impl_.has_sac_scale_)*/{}
  , /*decltype(_impl_.has_shoulder_)*/{}
  , /*decltype(_impl_.has_total_length_km_)*/{}
  , /*decltype(_impl_.has_shortcut_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_EdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_EdgeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_EdgeDefaultTypeInternal() {}
  union {
    TripLeg_Edge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sign_)*/nullptr
  , /*decltype(_impl_.has_begin_heading_)*/{}
  , /*decltype(_impl_.has_prev_name_consistency_)*/{}
  , /*decltype(_impl_.has_curr_name_consistency_)*/{}
  , /*decltype(_impl_.has_driveability_)*/{}
  , /*decltype(_impl_.has_cyclability_)*/{}
  , /*decltype(_impl_.has_walkability_)*/{}
  , /*decltype(_impl_.has_use_)*/{}
  , /*decltype(_impl_.has_road_class_)*/{}
  , /*decltype(_impl_.has_lane_count_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_IntersectingEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IntersectingEdgeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IntersectingEdgeDefaultTypeInternal() {}
  union {
    TripLeg_IntersectingEdge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Cost::TripLeg_Cost(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_seconds_)*/{}
  , /*decltype(_impl_.has_cost_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_CostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_CostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_CostDefaultTypeInternal() {}
  union {
    TripLeg_Cost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_PathCost::TripLeg_PathCost(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.elapsed_cost_)*/nullptr
  , /*decltype(_impl_.transition_cost_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_PathCostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_PathCostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_PathCostDefaultTypeInternal() {}
  union {
    TripLeg_PathCost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Node::TripLeg_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.intersecting_edge_)*/{}
  , /*decltype(_impl_.recosts_)*/{}
  , /*decltype(_impl_.edge_)*/nullptr
  , /*decltype(_impl_.transit_platform_info_)*/nullptr
  , /*decltype(_impl_.transit_station_info_)*/nullptr
  , /*decltype(_impl_.transit_egress_info_)*/nullptr
  , /*decltype(_impl_.cost_)*/nullptr
  , /*decltype(_impl_.bss_info_)*/nullptr
  , /*decltype(_impl_.has_admin_index_)*/{}
  , /*decltype(_impl_.has_type_)*/{}
  , /*decltype(_impl_.has_fork_)*/{}
  , /*decltype(_impl_.has_time_zone_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_NodeDefaultTypeInternal() {}
  union {
    TripLeg_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Admin::TripLeg_Admin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_country_code_)*/{}
  , /*decltype(_impl_.has_country_text_)*/{}
  , /*decltype(_impl_.has_state_code_)*/{}
  , /*decltype(_impl_.has_state_text_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_AdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_AdminDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_AdminDefaultTypeInternal() {}
  union {
    TripLeg_Admin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.time_)*/{}
  , /*decltype(_impl_._time_cached_byte_size_)*/{0}
  , /*decltype(_impl_.length_)*/{}
  , /*decltype(_impl_._length_cached_byte_size_)*/{0}
  , /*decltype(_impl_.speed_)*/{}
  , /*decltype(_impl_._speed_cached_byte_size_)*/{0}
  , /*decltype(_impl_.speed_limit_)*/{}
  , /*decltype(_impl_._speed_limit_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripLeg_ShapeAttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ShapeAttributesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ShapeAttributesDefaultTypeInternal() {}
  union {
    TripLeg_ShapeAttributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Incident::TripLeg_Incident(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.has_begin_shape_index_)*/{}
  , /*decltype(_impl_.has_end_shape_index_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_IncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IncidentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IncidentDefaultTypeInternal() {}
  union {
    TripLeg_Incident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
PROTOBUF_CONSTEXPR TripLeg_Closure::TripLeg_Closure(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.has_begin_shape_index_)*/{}
  , /*decltype(_impl_.has_end_shape_index_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLeg_ClosureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ClosureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ClosureDefaultTypeInternal() {}
  union {
    TripLeg_Closure _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
PROTOBUF_CONSTEXPR TripLeg::TripLeg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/{}
  , /*decltype(_impl_.node_)*/{}
  , /*decltype(_impl_.admin_)*/{}
  , /*decltype(_impl_.incidents_)*/{}
  , /*decltype(_impl_.algorithms_)*/{}
  , /*decltype(_impl_.closures_)*/{}
  , /*decltype(_impl_.bbox_)*/nullptr
  , /*decltype(_impl_.shape_attributes_)*/nullptr
  , /*decltype(_impl_.has_osm_changeset_)*/{}
  , /*decltype(_impl_.has_trip_id_)*/{}
  , /*decltype(_impl_.has_leg_id_)*/{}
  , /*decltype(_impl_.has_leg_count_)*/{}
  , /*decltype(_impl_.has_shape_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TripLegDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLegDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLegDefaultTypeInternal() {}
  union {
    TripLeg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLegDefaultTypeInternal _TripLeg_default_instance_;
PROTOBUF_CONSTEXPR TripRoute::TripRoute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.legs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripRouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripRouteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripRouteDefaultTypeInternal() {}
  union {
    TripRoute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripRouteDefaultTypeInternal _TripRoute_default_instance_;
PROTOBUF_CONSTEXPR Trip::Trip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.routes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripDefaultTypeInternal() {}
  union {
    Trip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool TripLeg_Node_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Node_Type_strings[13] = {};

static const char TripLeg_Node_Type_names[] =
  "kBikeShare"
  "kBollard"
  "kBorderControl"
  "kGate"
  "kMotorwayJunction"
  "kParking"
  "kStreetIntersection"
  "kSumpBuster"
  "kTollBooth"
  "kTollGantry"
  "kTransitEgress"
  "kTransitPlatform"
  "kTransitStation";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Node_Type_entries[] = {
  { {TripLeg_Node_Type_names + 0, 10}, 7 },
  { {TripLeg_Node_Type_names + 10, 8}, 2 },
  { {TripLeg_Node_Type_names + 18, 14}, 10 },
  { {TripLeg_Node_Type_names + 32, 5}, 1 },
  { {TripLeg_Node_Type_names + 37, 17}, 9 },
  { {TripLeg_Node_Type_names + 54, 8}, 8 },
  { {TripLeg_Node_Type_names + 62, 19}, 0 },
  { {TripLeg_Node_Type_names + 81, 11}, 12 },
  { {TripLeg_Node_Type_names + 92, 10}, 3 },
  { {TripLeg_Node_Type_names + 102, 11}, 11 },
  { {TripLeg_Node_Type_names + 113, 14}, 4 },
  { {TripLeg_Node_Type_names + 127, 16}, 6 },
  { {TripLeg_Node_Type_names + 143, 15}, 5 },
};

static const int TripLeg_Node_Type_entries_by_number[] = {
  6, // 0 -> kStreetIntersection
  3, // 1 -> kGate
  1, // 2 -> kBollard
  8, // 3 -> kTollBooth
  10, // 4 -> kTransitEgress
  12, // 5 -> kTransitStation
  11, // 6 -> kTransitPlatform
  0, // 7 -> kBikeShare
  5, // 8 -> kParking
  4, // 9 -> kMotorwayJunction
  2, // 10 -> kBorderControl
  9, // 11 -> kTollGantry
  7, // 12 -> kSumpBuster
};

const std::string& TripLeg_Node_Type_Name(
    TripLeg_Node_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Node_Type_entries,
          TripLeg_Node_Type_entries_by_number,
          13, TripLeg_Node_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Node_Type_entries,
      TripLeg_Node_Type_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Node_Type_strings[idx].get();
}
bool TripLeg_Node_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Node_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Node_Type_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Node_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node::kGate;
constexpr TripLeg_Node_Type TripLeg_Node::kBollard;
constexpr TripLeg_Node_Type TripLeg_Node::kTollBooth;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitEgress;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitStation;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
constexpr TripLeg_Node_Type TripLeg_Node::kBikeShare;
constexpr TripLeg_Node_Type TripLeg_Node::kParking;
constexpr TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
constexpr TripLeg_Node_Type TripLeg_Node::kBorderControl;
constexpr TripLeg_Node_Type TripLeg_Node::kTollGantry;
constexpr TripLeg_Node_Type TripLeg_Node::kSumpBuster;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MIN;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MAX;
constexpr int TripLeg_Node::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Traversability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Traversability_strings[4] = {};

static const char TripLeg_Traversability_names[] =
  "kBackward"
  "kBoth"
  "kForward"
  "kNone";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Traversability_entries[] = {
  { {TripLeg_Traversability_names + 0, 9}, 2 },
  { {TripLeg_Traversability_names + 9, 5}, 3 },
  { {TripLeg_Traversability_names + 14, 8}, 1 },
  { {TripLeg_Traversability_names + 22, 5}, 0 },
};

static const int TripLeg_Traversability_entries_by_number[] = {
  3, // 0 -> kNone
  2, // 1 -> kForward
  0, // 2 -> kBackward
  1, // 3 -> kBoth
};

const std::string& TripLeg_Traversability_Name(
    TripLeg_Traversability value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Traversability_entries,
          TripLeg_Traversability_entries_by_number,
          4, TripLeg_Traversability_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Traversability_entries,
      TripLeg_Traversability_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Traversability_strings[idx].get();
}
bool TripLeg_Traversability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Traversability* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Traversability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Traversability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Traversability TripLeg::kNone;
constexpr TripLeg_Traversability TripLeg::kForward;
constexpr TripLeg_Traversability TripLeg::kBackward;
constexpr TripLeg_Traversability TripLeg::kBoth;
constexpr TripLeg_Traversability TripLeg::Traversability_MIN;
constexpr TripLeg_Traversability TripLeg::Traversability_MAX;
constexpr int TripLeg::Traversability_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Use_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 40:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Use_strings[31] = {};

static const char TripLeg_Use_names[] =
  "kAlleyUse"
  "kBridlewayUse"
  "kBusUse"
  "kCuldesacUse"
  "kCyclewayUse"
  "kDriveThruUse"
  "kDrivewayUse"
  "kEgressConnectionUse"
  "kEmergencyAccessUse"
  "kFerryUse"
  "kFootwayUse"
  "kLivingStreetUse"
  "kMountainBikeUse"
  "kOtherUse"
  "kParkingAisleUse"
  "kPathUse"
  "kPedestrianCrossingUse"
  "kPedestrianUse"
  "kPlatformConnectionUse"
  "kRailFerryUse"
  "kRailUse"
  "kRampUse"
  "kRestAreaUse"
  "kRoadUse"
  "kServiceAreaUse"
  "kServiceRoadUse"
  "kSidewalkUse"
  "kStepsUse"
  "kTrackUse"
  "kTransitConnectionUse"
  "kTurnChannelUse";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Use_entries[] = {
  { {TripLeg_Use_names + 0, 9}, 5 },
  { {TripLeg_Use_names + 9, 13}, 29 },
  { {TripLeg_Use_names + 22, 7}, 51 },
  { {TripLeg_Use_names + 29, 12}, 9 },
  { {TripLeg_Use_names + 41, 12}, 20 },
  { {TripLeg_Use_names + 53, 13}, 8 },
  { {TripLeg_Use_names + 66, 12}, 4 },
  { {TripLeg_Use_names + 78, 20}, 52 },
  { {TripLeg_Use_names + 98, 19}, 7 },
  { {TripLeg_Use_names + 117, 9}, 41 },
  { {TripLeg_Use_names + 126, 11}, 25 },
  { {TripLeg_Use_names + 137, 16}, 10 },
  { {TripLeg_Use_names + 153, 16}, 21 },
  { {TripLeg_Use_names + 169, 9}, 40 },
  { {TripLeg_Use_names + 178, 16}, 6 },
  { {TripLeg_Use_names + 194, 8}, 27 },
  { {TripLeg_Use_names + 202, 22}, 32 },
  { {TripLeg_Use_names + 224, 14}, 28 },
  { {TripLeg_Use_names + 238, 22}, 53 },
  { {TripLeg_Use_names + 260, 13}, 42 },
  { {TripLeg_Use_names + 273, 8}, 50 },
  { {TripLeg_Use_names + 281, 8}, 1 },
  { {TripLeg_Use_names + 289, 12}, 30 },
  { {TripLeg_Use_names + 301, 8}, 0 },
  { {TripLeg_Use_names + 309, 15}, 31 },
  { {TripLeg_Use_names + 324, 15}, 11 },
  { {TripLeg_Use_names + 339, 12}, 24 },
  { {TripLeg_Use_names + 351, 9}, 26 },
  { {TripLeg_Use_names + 360, 9}, 3 },
  { {TripLeg_Use_names + 369, 21}, 54 },
  { {TripLeg_Use_names + 390, 15}, 2 },
};

static const int TripLeg_Use_entries_by_number[] = {
  23, // 0 -> kRoadUse
  21, // 1 -> kRampUse
  30, // 2 -> kTurnChannelUse
  28, // 3 -> kTrackUse
  6, // 4 -> kDrivewayUse
  0, // 5 -> kAlleyUse
  14, // 6 -> kParkingAisleUse
  8, // 7 -> kEmergencyAccessUse
  5, // 8 -> kDriveThruUse
  3, // 9 -> kCuldesacUse
  11, // 10 -> kLivingStreetUse
  25, // 11 -> kServiceRoadUse
  4, // 20 -> kCyclewayUse
  12, // 21 -> kMountainBikeUse
  26, // 24 -> kSidewalkUse
  10, // 25 -> kFootwayUse
  27, // 26 -> kStepsUse
  15, // 27 -> kPathUse
  17, // 28 -> kPedestrianUse
  1, // 29 -> kBridlewayUse
  22, // 30 -> kRestAreaUse
  24, // 31 -> kServiceAreaUse
  16, // 32 -> kPedestrianCrossingUse
  13, // 40 -> kOtherUse
  9, // 41 -> kFerryUse
  19, // 42 -> kRailFerryUse
  20, // 50 -> kRailUse
  2, // 51 -> kBusUse
  7, // 52 -> kEgressConnectionUse
  18, // 53 -> kPlatformConnectionUse
  29, // 54 -> kTransitConnectionUse
};

const std::string& TripLeg_Use_Name(
    TripLeg_Use value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Use_entries,
          TripLeg_Use_entries_by_number,
          31, TripLeg_Use_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Use_entries,
      TripLeg_Use_entries_by_number,
      31, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Use_strings[idx].get();
}
bool TripLeg_Use_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Use* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Use_entries, 31, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Use>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Use TripLeg::kRoadUse;
constexpr TripLeg_Use TripLeg::kRampUse;
constexpr TripLeg_Use TripLeg::kTurnChannelUse;
constexpr TripLeg_Use TripLeg::kTrackUse;
constexpr TripLeg_Use TripLeg::kDrivewayUse;
constexpr TripLeg_Use TripLeg::kAlleyUse;
constexpr TripLeg_Use TripLeg::kParkingAisleUse;
constexpr TripLeg_Use TripLeg::kEmergencyAccessUse;
constexpr TripLeg_Use TripLeg::kDriveThruUse;
constexpr TripLeg_Use TripLeg::kCuldesacUse;
constexpr TripLeg_Use TripLeg::kLivingStreetUse;
constexpr TripLeg_Use TripLeg::kServiceRoadUse;
constexpr TripLeg_Use TripLeg::kCyclewayUse;
constexpr TripLeg_Use TripLeg::kMountainBikeUse;
constexpr TripLeg_Use TripLeg::kSidewalkUse;
constexpr TripLeg_Use TripLeg::kFootwayUse;
constexpr TripLeg_Use TripLeg::kStepsUse;
constexpr TripLeg_Use TripLeg::kPathUse;
constexpr TripLeg_Use TripLeg::kPedestrianUse;
constexpr TripLeg_Use TripLeg::kBridlewayUse;
constexpr TripLeg_Use TripLeg::kPedestrianCrossingUse;
constexpr TripLeg_Use TripLeg::kRestAreaUse;
constexpr TripLeg_Use TripLeg::kServiceAreaUse;
constexpr TripLeg_Use TripLeg::kOtherUse;
constexpr TripLeg_Use TripLeg::kFerryUse;
constexpr TripLeg_Use TripLeg::kRailFerryUse;
constexpr TripLeg_Use TripLeg::kRailUse;
constexpr TripLeg_Use TripLeg::kBusUse;
constexpr TripLeg_Use TripLeg::kEgressConnectionUse;
constexpr TripLeg_Use TripLeg::kPlatformConnectionUse;
constexpr TripLeg_Use TripLeg::kTransitConnectionUse;
constexpr TripLeg_Use TripLeg::Use_MIN;
constexpr TripLeg_Use TripLeg::Use_MAX;
constexpr int TripLeg::Use_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Surface_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Surface_strings[8] = {};

static const char TripLeg_Surface_names[] =
  "kCompacted"
  "kDirt"
  "kGravel"
  "kImpassable"
  "kPath"
  "kPaved"
  "kPavedRough"
  "kPavedSmooth";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Surface_entries[] = {
  { {TripLeg_Surface_names + 0, 10}, 3 },
  { {TripLeg_Surface_names + 10, 5}, 4 },
  { {TripLeg_Surface_names + 15, 7}, 5 },
  { {TripLeg_Surface_names + 22, 11}, 7 },
  { {TripLeg_Surface_names + 33, 5}, 6 },
  { {TripLeg_Surface_names + 38, 6}, 1 },
  { {TripLeg_Surface_names + 44, 11}, 2 },
  { {TripLeg_Surface_names + 55, 12}, 0 },
};

static const int TripLeg_Surface_entries_by_number[] = {
  7, // 0 -> kPavedSmooth
  5, // 1 -> kPaved
  6, // 2 -> kPavedRough
  0, // 3 -> kCompacted
  1, // 4 -> kDirt
  2, // 5 -> kGravel
  4, // 6 -> kPath
  3, // 7 -> kImpassable
};

const std::string& TripLeg_Surface_Name(
    TripLeg_Surface value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Surface_entries,
          TripLeg_Surface_entries_by_number,
          8, TripLeg_Surface_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Surface_entries,
      TripLeg_Surface_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Surface_strings[idx].get();
}
bool TripLeg_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Surface* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Surface_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Surface>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Surface TripLeg::kPavedSmooth;
constexpr TripLeg_Surface TripLeg::kPaved;
constexpr TripLeg_Surface TripLeg::kPavedRough;
constexpr TripLeg_Surface TripLeg::kCompacted;
constexpr TripLeg_Surface TripLeg::kDirt;
constexpr TripLeg_Surface TripLeg::kGravel;
constexpr TripLeg_Surface TripLeg::kPath;
constexpr TripLeg_Surface TripLeg::kImpassable;
constexpr TripLeg_Surface TripLeg::Surface_MIN;
constexpr TripLeg_Surface TripLeg::Surface_MAX;
constexpr int TripLeg::Surface_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_CycleLane_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_CycleLane_strings[4] = {};

static const char TripLeg_CycleLane_names[] =
  "kDedicated"
  "kNoCycleLane"
  "kSeparated"
  "kShared";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_CycleLane_entries[] = {
  { {TripLeg_CycleLane_names + 0, 10}, 2 },
  { {TripLeg_CycleLane_names + 10, 12}, 0 },
  { {TripLeg_CycleLane_names + 22, 10}, 3 },
  { {TripLeg_CycleLane_names + 32, 7}, 1 },
};

static const int TripLeg_CycleLane_entries_by_number[] = {
  1, // 0 -> kNoCycleLane
  3, // 1 -> kShared
  0, // 2 -> kDedicated
  2, // 3 -> kSeparated
};

const std::string& TripLeg_CycleLane_Name(
    TripLeg_CycleLane value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_CycleLane_entries,
          TripLeg_CycleLane_entries_by_number,
          4, TripLeg_CycleLane_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_CycleLane_entries,
      TripLeg_CycleLane_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_CycleLane_strings[idx].get();
}
bool TripLeg_CycleLane_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_CycleLane* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_CycleLane_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_CycleLane>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_CycleLane TripLeg::kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg::kShared;
constexpr TripLeg_CycleLane TripLeg::kDedicated;
constexpr TripLeg_CycleLane TripLeg::kSeparated;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MIN;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MAX;
constexpr int TripLeg::CycleLane_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_SacScale_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_SacScale_strings[7] = {};

static const char TripLeg_SacScale_names[] =
  "kAlpineHiking"
  "kDemandingAlpineHiking"
  "kDemandingMountainHiking"
  "kDifficultAlpineHiking"
  "kHiking"
  "kMountainHiking"
  "kNoSacScale";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_SacScale_entries[] = {
  { {TripLeg_SacScale_names + 0, 13}, 4 },
  { {TripLeg_SacScale_names + 13, 22}, 5 },
  { {TripLeg_SacScale_names + 35, 24}, 3 },
  { {TripLeg_SacScale_names + 59, 22}, 6 },
  { {TripLeg_SacScale_names + 81, 7}, 1 },
  { {TripLeg_SacScale_names + 88, 15}, 2 },
  { {TripLeg_SacScale_names + 103, 11}, 0 },
};

static const int TripLeg_SacScale_entries_by_number[] = {
  6, // 0 -> kNoSacScale
  4, // 1 -> kHiking
  5, // 2 -> kMountainHiking
  2, // 3 -> kDemandingMountainHiking
  0, // 4 -> kAlpineHiking
  1, // 5 -> kDemandingAlpineHiking
  3, // 6 -> kDifficultAlpineHiking
};

const std::string& TripLeg_SacScale_Name(
    TripLeg_SacScale value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_SacScale_entries,
          TripLeg_SacScale_entries_by_number,
          7, TripLeg_SacScale_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_SacScale_entries,
      TripLeg_SacScale_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_SacScale_strings[idx].get();
}
bool TripLeg_SacScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_SacScale* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_SacScale_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_SacScale>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_SacScale TripLeg::kNoSacScale;
constexpr TripLeg_SacScale TripLeg::kHiking;
constexpr TripLeg_SacScale TripLeg::kMountainHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingMountainHiking;
constexpr TripLeg_SacScale TripLeg::kAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
constexpr TripLeg_SacScale TripLeg::SacScale_MIN;
constexpr TripLeg_SacScale TripLeg::SacScale_MAX;
constexpr int TripLeg::SacScale_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Sidewalk_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Sidewalk_strings[4] = {};

static const char TripLeg_Sidewalk_names[] =
  "kBothSides"
  "kLeft"
  "kNoSidewalk"
  "kRight";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Sidewalk_entries[] = {
  { {TripLeg_Sidewalk_names + 0, 10}, 3 },
  { {TripLeg_Sidewalk_names + 10, 5}, 1 },
  { {TripLeg_Sidewalk_names + 15, 11}, 0 },
  { {TripLeg_Sidewalk_names + 26, 6}, 2 },
};

static const int TripLeg_Sidewalk_entries_by_number[] = {
  2, // 0 -> kNoSidewalk
  1, // 1 -> kLeft
  3, // 2 -> kRight
  0, // 3 -> kBothSides
};

const std::string& TripLeg_Sidewalk_Name(
    TripLeg_Sidewalk value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Sidewalk_entries,
          TripLeg_Sidewalk_entries_by_number,
          4, TripLeg_Sidewalk_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Sidewalk_entries,
      TripLeg_Sidewalk_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Sidewalk_strings[idx].get();
}
bool TripLeg_Sidewalk_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Sidewalk* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Sidewalk_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Sidewalk>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Sidewalk TripLeg::kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg::kLeft;
constexpr TripLeg_Sidewalk TripLeg::kRight;
constexpr TripLeg_Sidewalk TripLeg::kBothSides;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
constexpr int TripLeg::Sidewalk_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class TripLeg_LaneConnectivity::_Internal {
 public:
};

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.LaneConnectivity)
}
TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_LaneConnectivity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_from_way_id_){}
    , decltype(_impl_.has_from_lanes_){}
    , decltype(_impl_.has_to_lanes_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_from_way_id();
  switch (from.has_from_way_id_case()) {
    case kFromWayId: {
      _this->_internal_set_from_way_id(from._internal_from_way_id());
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_from_lanes();
  switch (from.has_from_lanes_case()) {
    case kFromLanes: {
      _this->_internal_set_from_lanes(from._internal_from_lanes());
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  clear_has_has_to_lanes();
  switch (from.has_to_lanes_case()) {
    case kToLanes: {
      _this->_internal_set_to_lanes(from._internal_to_lanes());
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}

inline void TripLeg_LaneConnectivity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_from_way_id_){}
    , decltype(_impl_.has_from_lanes_){}
    , decltype(_impl_.has_to_lanes_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_from_way_id();
  clear_has_has_from_lanes();
  clear_has_has_to_lanes();
}

TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_LaneConnectivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_from_way_id()) {
    clear_has_from_way_id();
  }
  if (has_has_from_lanes()) {
    clear_has_from_lanes();
  }
  if (has_has_to_lanes()) {
    clear_has_to_lanes();
  }
}

void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_LaneConnectivity::clear_has_from_way_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.LaneConnectivity)
  switch (has_from_way_id_case()) {
    case kFromWayId: {
      // No need to clear
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_FROM_WAY_ID_NOT_SET;
}

void TripLeg_LaneConnectivity::clear_has_from_lanes() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.LaneConnectivity)
  switch (has_from_lanes_case()) {
    case kFromLanes: {
      _impl_.has_from_lanes_.from_lanes_.Destroy();
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_FROM_LANES_NOT_SET;
}

void TripLeg_LaneConnectivity::clear_has_to_lanes() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.LaneConnectivity)
  switch (has_to_lanes_case()) {
    case kToLanes: {
      _impl_.has_to_lanes_.to_lanes_.Destroy();
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_TO_LANES_NOT_SET;
}


void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_from_way_id();
  clear_has_from_lanes();
  clear_has_to_lanes();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_LaneConnectivity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 from_way_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_from_way_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string from_lanes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_from_lanes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string to_lanes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_to_lanes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_LaneConnectivity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.LaneConnectivity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 from_way_id = 1;
  if (_internal_has_from_way_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_from_way_id(), target);
  }

  // string from_lanes = 2;
  if (_internal_has_from_lanes()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_from_lanes().data(), static_cast<int>(this->_internal_from_lanes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.from_lanes");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_from_lanes(), target);
  }

  // string to_lanes = 3;
  if (_internal_has_to_lanes()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_to_lanes().data(), static_cast<int>(this->_internal_to_lanes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.to_lanes");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_to_lanes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.LaneConnectivity)
  return target;
}

size_t TripLeg_LaneConnectivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_from_way_id_case()) {
    // uint64 from_way_id = 1;
    case kFromWayId: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from_way_id());
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (has_from_lanes_case()) {
    // string from_lanes = 2;
    case kFromLanes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from_lanes());
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  switch (has_to_lanes_case()) {
    // string to_lanes = 3;
    case kToLanes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_to_lanes());
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_LaneConnectivity*>(
      &from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
  TripLeg_LaneConnectivity* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_from_way_id_case()) {
    case kFromWayId: {
      _this->_internal_set_from_way_id(from._internal_from_way_id());
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_from_lanes_case()) {
    case kFromLanes: {
      _this->_internal_set_from_lanes(from._internal_from_lanes());
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  switch (from.has_to_lanes_case()) {
    case kToLanes: {
      _this->_internal_set_to_lanes(from._internal_to_lanes());
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_LaneConnectivity::IsInitialized() const {
  return true;
}

void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_from_way_id_, other->_impl_.has_from_way_id_);
  swap(_impl_.has_from_lanes_, other->_impl_.has_from_lanes_);
  swap(_impl_.has_to_lanes_, other->_impl_.has_to_lanes_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
}

std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}


// ===================================================================

class TripLeg_TrafficSegment::_Internal {
 public:
};

TripLeg_TrafficSegment::TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TrafficSegment)
}
TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_TrafficSegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_segment_id_){}
    , decltype(_impl_.has_begin_percent_){}
    , decltype(_impl_.has_end_percent_){}
    , decltype(_impl_.has_starts_segment_){}
    , decltype(_impl_.has_ends_segment_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_segment_id();
  switch (from.has_segment_id_case()) {
    case kSegmentId: {
      _this->_internal_set_segment_id(from._internal_segment_id());
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_begin_percent();
  switch (from.has_begin_percent_case()) {
    case kBeginPercent: {
      _this->_internal_set_begin_percent(from._internal_begin_percent());
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_percent();
  switch (from.has_end_percent_case()) {
    case kEndPercent: {
      _this->_internal_set_end_percent(from._internal_end_percent());
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  clear_has_has_starts_segment();
  switch (from.has_starts_segment_case()) {
    case kStartsSegment: {
      _this->_internal_set_starts_segment(from._internal_starts_segment());
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  clear_has_has_ends_segment();
  switch (from.has_ends_segment_case()) {
    case kEndsSegment: {
      _this->_internal_set_ends_segment(from._internal_ends_segment());
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TrafficSegment)
}

inline void TripLeg_TrafficSegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_segment_id_){}
    , decltype(_impl_.has_begin_percent_){}
    , decltype(_impl_.has_end_percent_){}
    , decltype(_impl_.has_starts_segment_){}
    , decltype(_impl_.has_ends_segment_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_segment_id();
  clear_has_has_begin_percent();
  clear_has_has_end_percent();
  clear_has_has_starts_segment();
  clear_has_has_ends_segment();
}

TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_TrafficSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_segment_id()) {
    clear_has_segment_id();
  }
  if (has_has_begin_percent()) {
    clear_has_begin_percent();
  }
  if (has_has_end_percent()) {
    clear_has_end_percent();
  }
  if (has_has_starts_segment()) {
    clear_has_starts_segment();
  }
  if (has_has_ends_segment()) {
    clear_has_ends_segment();
  }
}

void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_TrafficSegment::clear_has_segment_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch (has_segment_id_case()) {
    case kSegmentId: {
      // No need to clear
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_SEGMENT_ID_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_begin_percent() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch (has_begin_percent_case()) {
    case kBeginPercent: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_BEGIN_PERCENT_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_end_percent() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch (has_end_percent_case()) {
    case kEndPercent: {
      // No need to clear
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_END_PERCENT_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_starts_segment() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch (has_starts_segment_case()) {
    case kStartsSegment: {
      // No need to clear
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_STARTS_SEGMENT_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_ends_segment() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch (has_ends_segment_case()) {
    case kEndsSegment: {
      // No need to clear
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_ENDS_SEGMENT_NOT_SET;
}


void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_segment_id();
  clear_has_begin_percent();
  clear_has_end_percent();
  clear_has_starts_segment();
  clear_has_ends_segment();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_TrafficSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 segment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_segment_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float begin_percent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_begin_percent(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_percent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _internal_set_end_percent(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool starts_segment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_starts_segment(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ends_segment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_ends_segment(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_TrafficSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TrafficSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 segment_id = 1;
  if (_internal_has_segment_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_segment_id(), target);
  }

  // float begin_percent = 2;
  if (_internal_has_begin_percent()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_begin_percent(), target);
  }

  // float end_percent = 3;
  if (_internal_has_end_percent()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_end_percent(), target);
  }

  // bool starts_segment = 4;
  if (_internal_has_starts_segment()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_starts_segment(), target);
  }

  // bool ends_segment = 5;
  if (_internal_has_ends_segment()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_ends_segment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TrafficSegment)
  return target;
}

size_t TripLeg_TrafficSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_segment_id_case()) {
    // uint64 segment_id = 1;
    case kSegmentId: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_segment_id());
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  switch (has_begin_percent_case()) {
    // float begin_percent = 2;
    case kBeginPercent: {
      total_size += 1 + 4;
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (has_end_percent_case()) {
    // float end_percent = 3;
    case kEndPercent: {
      total_size += 1 + 4;
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (has_starts_segment_case()) {
    // bool starts_segment = 4;
    case kStartsSegment: {
      total_size += 1 + 1;
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  switch (has_ends_segment_case()) {
    // bool ends_segment = 5;
    case kEndsSegment: {
      total_size += 1 + 1;
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_TrafficSegment*>(
      &from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
  TripLeg_TrafficSegment* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_segment_id_case()) {
    case kSegmentId: {
      _this->_internal_set_segment_id(from._internal_segment_id());
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_begin_percent_case()) {
    case kBeginPercent: {
      _this->_internal_set_begin_percent(from._internal_begin_percent());
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_percent_case()) {
    case kEndPercent: {
      _this->_internal_set_end_percent(from._internal_end_percent());
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (from.has_starts_segment_case()) {
    case kStartsSegment: {
      _this->_internal_set_starts_segment(from._internal_starts_segment());
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  switch (from.has_ends_segment_case()) {
    case kEndsSegment: {
      _this->_internal_set_ends_segment(from._internal_ends_segment());
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TrafficSegment::IsInitialized() const {
  return true;
}

void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_segment_id_, other->_impl_.has_segment_id_);
  swap(_impl_.has_begin_percent_, other->_impl_.has_begin_percent_);
  swap(_impl_.has_end_percent_, other->_impl_.has_end_percent_);
  swap(_impl_.has_starts_segment_, other->_impl_.has_starts_segment_);
  swap(_impl_.has_ends_segment_, other->_impl_.has_ends_segment_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
}

std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}


// ===================================================================

class TripLeg_Restriction::_Internal {
 public:
};

TripLeg_Restriction::TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Restriction)
}
TripLeg_Restriction::TripLeg_Restriction(const TripLeg_Restriction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Restriction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_type();
  switch (from.has_type_case()) {
    case kType: {
      _this->_internal_set_type(from._internal_type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Restriction)
}

inline void TripLeg_Restriction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_type();
}

TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Restriction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_type()) {
    clear_has_type();
  }
}

void TripLeg_Restriction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Restriction::clear_has_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Restriction)
  switch (has_type_case()) {
    case kType: {
      // No need to clear
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_TYPE_NOT_SET;
}


void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_type();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Restriction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Restriction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Restriction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 type = 1;
  if (_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Restriction)
  return target;
}

size_t TripLeg_Restriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_type_case()) {
    // uint32 type = 1;
    case kType: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Restriction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Restriction*>(
      &from));
}

void TripLeg_Restriction::MergeFrom(const TripLeg_Restriction& from) {
  TripLeg_Restriction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_type_case()) {
    case kType: {
      _this->_internal_set_type(from._internal_type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Restriction::IsInitialized() const {
  return true;
}

void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_type_, other->_impl_.has_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string TripLeg_Restriction::GetTypeName() const {
  return "valhalla.TripLeg.Restriction";
}


// ===================================================================

class TripLeg_Edge::_Internal {
 public:
  static const ::valhalla::TripSign& sign(const TripLeg_Edge* msg);
  static const ::valhalla::TransitRouteInfo& transit_route_info(const TripLeg_Edge* msg);
  static const ::valhalla::TripLeg_Restriction& restriction(const TripLeg_Edge* msg);
};

const ::valhalla::TripSign&
TripLeg_Edge::_Internal::sign(const TripLeg_Edge* msg) {
  return *msg->_impl_.sign_;
}
const ::valhalla::TransitRouteInfo&
TripLeg_Edge::_Internal::transit_route_info(const TripLeg_Edge* msg) {
  return *msg->_impl_.transit_route_info_;
}
const ::valhalla::TripLeg_Restriction&
TripLeg_Edge::_Internal::restriction(const TripLeg_Edge* msg) {
  return *msg->_impl_.restriction_;
}
void TripLeg_Edge::clear_name() {
  _impl_.name_.Clear();
}
void TripLeg_Edge::clear_sign() {
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
}
void TripLeg_Edge::clear_transit_route_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_route_info_ != nullptr) {
    delete _impl_.transit_route_info_;
  }
  _impl_.transit_route_info_ = nullptr;
}
void TripLeg_Edge::clear_turn_lanes() {
  _impl_.turn_lanes_.Clear();
}
void TripLeg_Edge::clear_tagged_value() {
  _impl_.tagged_value_.Clear();
}
TripLeg_Edge::TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge)
}
TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Edge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){from._impl_.name_}
    , decltype(_impl_.lane_connectivity_){from._impl_.lane_connectivity_}
    , decltype(_impl_.traffic_segment_){from._impl_.traffic_segment_}
    , decltype(_impl_.turn_lanes_){from._impl_.turn_lanes_}
    , decltype(_impl_.tagged_value_){from._impl_.tagged_value_}
    , decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.transit_route_info_){nullptr}
    , decltype(_impl_.restriction_){nullptr}
    , decltype(_impl_.has_length_km_){}
    , decltype(_impl_.has_speed_){}
    , decltype(_impl_.has_road_class_){}
    , decltype(_impl_.has_begin_heading_){}
    , decltype(_impl_.has_end_heading_){}
    , decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , decltype(_impl_.has_traversability_){}
    , decltype(_impl_.has_use_){}
    , decltype(_impl_.has_toll_){}
    , decltype(_impl_.has_unpaved_){}
    , decltype(_impl_.has_tunnel_){}
    , decltype(_impl_.has_bridge_){}
    , decltype(_impl_.has_roundabout_){}
    , decltype(_impl_.has_internal_intersection_){}
    , decltype(_impl_.has_drive_on_left_){}
    , decltype(_impl_.has_surface_){}
    , decltype(_impl_.has_travel_mode_){}
    , decltype(_impl_.has_vehicle_type_){}
    , decltype(_impl_.has_pedestrian_type_){}
    , decltype(_impl_.has_bicycle_type_){}
    , decltype(_impl_.has_transit_type_){}
    , decltype(_impl_.has_id_){}
    , decltype(_impl_.has_way_id_){}
    , decltype(_impl_.has_weighted_grade_){}
    , decltype(_impl_.has_max_upward_grade_){}
    , decltype(_impl_.has_max_downward_grade_){}
    , decltype(_impl_.has_lane_count_){}
    , decltype(_impl_.has_cycle_lane_){}
    , decltype(_impl_.has_bicycle_network_){}
    , decltype(_impl_.has_sidewalk_){}
    , decltype(_impl_.has_density_){}
    , decltype(_impl_.has_speed_limit_){}
    , decltype(_impl_.has_truck_speed_){}
    , decltype(_impl_.has_truck_route_){}
    , decltype(_impl_.has_mean_elevation_){}
    , decltype(_impl_.has_has_time_restrictions_){}
    , decltype(_impl_.has_default_speed_){}
    , decltype(_impl_.has_destination_only_){}
    , decltype(_impl_.has_is_urban_){}
    , decltype(_impl_.has_source_along_edge_){}
    , decltype(_impl_.has_target_along_edge_){}
    , decltype(_impl_.has_sac_scale_){}
    , decltype(_impl_.has_shoulder_){}
    , decltype(_impl_.has_total_length_km_){}
    , decltype(_impl_.has_shortcut_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    _this->_impl_.sign_ = new ::valhalla::TripSign(*from._impl_.sign_);
  }
  if (from._internal_has_transit_route_info()) {
    _this->_impl_.transit_route_info_ = new ::valhalla::TransitRouteInfo(*from._impl_.transit_route_info_);
  }
  if (from._internal_has_restriction()) {
    _this->_impl_.restriction_ = new ::valhalla::TripLeg_Restriction(*from._impl_.restriction_);
  }
  clear_has_has_length_km();
  switch (from.has_length_km_case()) {
    case kLengthKm: {
      _this->_internal_set_length_km(from._internal_length_km());
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  clear_has_has_speed();
  switch (from.has_speed_case()) {
    case kSpeed: {
      _this->_internal_set_speed(from._internal_speed());
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  clear_has_has_road_class();
  switch (from.has_road_class_case()) {
    case kRoadClass: {
      _this->_internal_set_road_class(from._internal_road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  clear_has_has_begin_heading();
  switch (from.has_begin_heading_case()) {
    case kBeginHeading: {
      _this->_internal_set_begin_heading(from._internal_begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_heading();
  switch (from.has_end_heading_case()) {
    case kEndHeading: {
      _this->_internal_set_end_heading(from._internal_end_heading());
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  clear_has_has_begin_shape_index();
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_shape_index();
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_traversability();
  switch (from.has_traversability_case()) {
    case kTraversability: {
      _this->_internal_set_traversability(from._internal_traversability());
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  clear_has_has_use();
  switch (from.has_use_case()) {
    case kUse: {
      _this->_internal_set_use(from._internal_use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  clear_has_has_toll();
  switch (from.has_toll_case()) {
    case kToll: {
      _this->_internal_set_toll(from._internal_toll());
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  clear_has_has_unpaved();
  switch (from.has_unpaved_case()) {
    case kUnpaved: {
      _this->_internal_set_unpaved(from._internal_unpaved());
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  clear_has_has_tunnel();
  switch (from.has_tunnel_case()) {
    case kTunnel: {
      _this->_internal_set_tunnel(from._internal_tunnel());
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  clear_has_has_bridge();
  switch (from.has_bridge_case()) {
    case kBridge: {
      _this->_internal_set_bridge(from._internal_bridge());
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  clear_has_has_roundabout();
  switch (from.has_roundabout_case()) {
    case kRoundabout: {
      _this->_internal_set_roundabout(from._internal_roundabout());
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  clear_has_has_internal_intersection();
  switch (from.has_internal_intersection_case()) {
    case kInternalIntersection: {
      _this->_internal_set_internal_intersection(from._internal_internal_intersection());
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  clear_has_has_drive_on_left();
  switch (from.has_drive_on_left_case()) {
    case kDriveOnLeft: {
      _this->_internal_set_drive_on_left(from._internal_drive_on_left());
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  clear_has_has_surface();
  switch (from.has_surface_case()) {
    case kSurface: {
      _this->_internal_set_surface(from._internal_surface());
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  clear_has_has_travel_mode();
  switch (from.has_travel_mode_case()) {
    case kTravelMode: {
      _this->_internal_set_travel_mode(from._internal_travel_mode());
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  clear_has_has_vehicle_type();
  switch (from.has_vehicle_type_case()) {
    case kVehicleType: {
      _this->_internal_set_vehicle_type(from._internal_vehicle_type());
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_has_pedestrian_type();
  switch (from.has_pedestrian_type_case()) {
    case kPedestrianType: {
      _this->_internal_set_pedestrian_type(from._internal_pedestrian_type());
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_has_bicycle_type();
  switch (from.has_bicycle_type_case()) {
    case kBicycleType: {
      _this->_internal_set_bicycle_type(from._internal_bicycle_type());
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_has_transit_type();
  switch (from.has_transit_type_case()) {
    case kTransitType: {
      _this->_internal_set_transit_type(from._internal_transit_type());
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_has_id();
  switch (from.has_id_case()) {
    case kId: {
      _this->_internal_set_id(from._internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_way_id();
  switch (from.has_way_id_case()) {
    case kWayId: {
      _this->_internal_set_way_id(from._internal_way_id());
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_weighted_grade();
  switch (from.has_weighted_grade_case()) {
    case kWeightedGrade: {
      _this->_internal_set_weighted_grade(from._internal_weighted_grade());
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  clear_has_has_max_upward_grade();
  switch (from.has_max_upward_grade_case()) {
    case kMaxUpwardGrade: {
      _this->_internal_set_max_upward_grade(from._internal_max_upward_grade());
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  clear_has_has_max_downward_grade();
  switch (from.has_max_downward_grade_case()) {
    case kMaxDownwardGrade: {
      _this->_internal_set_max_downward_grade(from._internal_max_downward_grade());
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  clear_has_has_lane_count();
  switch (from.has_lane_count_case()) {
    case kLaneCount: {
      _this->_internal_set_lane_count(from._internal_lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  clear_has_has_cycle_lane();
  switch (from.has_cycle_lane_case()) {
    case kCycleLane: {
      _this->_internal_set_cycle_lane(from._internal_cycle_lane());
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  clear_has_has_bicycle_network();
  switch (from.has_bicycle_network_case()) {
    case kBicycleNetwork: {
      _this->_internal_set_bicycle_network(from._internal_bicycle_network());
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  clear_has_has_sidewalk();
  switch (from.has_sidewalk_case()) {
    case kSidewalk: {
      _this->_internal_set_sidewalk(from._internal_sidewalk());
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  clear_has_has_density();
  switch (from.has_density_case()) {
    case kDensity: {
      _this->_internal_set_density(from._internal_density());
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  clear_has_has_speed_limit();
  switch (from.has_speed_limit_case()) {
    case kSpeedLimit: {
      _this->_internal_set_speed_limit(from._internal_speed_limit());
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  clear_has_has_truck_speed();
  switch (from.has_truck_speed_case()) {
    case kTruckSpeed: {
      _this->_internal_set_truck_speed(from._internal_truck_speed());
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  clear_has_has_truck_route();
  switch (from.has_truck_route_case()) {
    case kTruckRoute: {
      _this->_internal_set_truck_route(from._internal_truck_route());
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  clear_has_has_mean_elevation();
  switch (from.has_mean_elevation_case()) {
    case kMeanElevation: {
      _this->_internal_set_mean_elevation(from._internal_mean_elevation());
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  clear_has_has_has_time_restrictions();
  switch (from.has_has_time_restrictions_case()) {
    case kHasTimeRestrictions: {
      _this->_internal_set_has_time_restrictions(from._internal_has_time_restrictions());
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  clear_has_has_default_speed();
  switch (from.has_default_speed_case()) {
    case kDefaultSpeed: {
      _this->_internal_set_default_speed(from._internal_default_speed());
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  clear_has_has_destination_only();
  switch (from.has_destination_only_case()) {
    case kDestinationOnly: {
      _this->_internal_set_destination_only(from._internal_destination_only());
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  clear_has_has_is_urban();
  switch (from.has_is_urban_case()) {
    case kIsUrban: {
      _this->_internal_set_is_urban(from._internal_is_urban());
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  clear_has_has_source_along_edge();
  switch (from.has_source_along_edge_case()) {
    case kSourceAlongEdge: {
      _this->_internal_set_source_along_edge(from._internal_source_along_edge());
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  clear_has_has_target_along_edge();
  switch (from.has_target_along_edge_case()) {
    case kTargetAlongEdge: {
      _this->_internal_set_target_along_edge(from._internal_target_along_edge());
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  clear_has_has_sac_scale();
  switch (from.has_sac_scale_case()) {
    case kSacScale: {
      _this->_internal_set_sac_scale(from._internal_sac_scale());
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  clear_has_has_shoulder();
  switch (from.has_shoulder_case()) {
    case kShoulder: {
      _this->_internal_set_shoulder(from._internal_shoulder());
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  clear_has_has_total_length_km();
  switch (from.has_total_length_km_case()) {
    case kTotalLengthKm: {
      _this->_internal_set_total_length_km(from._internal_total_length_km());
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  clear_has_has_shortcut_id();
  switch (from.has_shortcut_id_case()) {
    case kShortcutId: {
      _this->_internal_set_shortcut_id(from._internal_shortcut_id());
      break;
    }
    case HAS_SHORTCUT_ID_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}

inline void TripLeg_Edge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){arena}
    , decltype(_impl_.lane_connectivity_){arena}
    , decltype(_impl_.traffic_segment_){arena}
    , decltype(_impl_.turn_lanes_){arena}
    , decltype(_impl_.tagged_value_){arena}
    , decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.transit_route_info_){nullptr}
    , decltype(_impl_.restriction_){nullptr}
    , decltype(_impl_.has_length_km_){}
    , decltype(_impl_.has_speed_){}
    , decltype(_impl_.has_road_class_){}
    , decltype(_impl_.has_begin_heading_){}
    , decltype(_impl_.has_end_heading_){}
    , decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , decltype(_impl_.has_traversability_){}
    , decltype(_impl_.has_use_){}
    , decltype(_impl_.has_toll_){}
    , decltype(_impl_.has_unpaved_){}
    , decltype(_impl_.has_tunnel_){}
    , decltype(_impl_.has_bridge_){}
    , decltype(_impl_.has_roundabout_){}
    , decltype(_impl_.has_internal_intersection_){}
    , decltype(_impl_.has_drive_on_left_){}
    , decltype(_impl_.has_surface_){}
    , decltype(_impl_.has_travel_mode_){}
    , decltype(_impl_.has_vehicle_type_){}
    , decltype(_impl_.has_pedestrian_type_){}
    , decltype(_impl_.has_bicycle_type_){}
    , decltype(_impl_.has_transit_type_){}
    , decltype(_impl_.has_id_){}
    , decltype(_impl_.has_way_id_){}
    , decltype(_impl_.has_weighted_grade_){}
    , decltype(_impl_.has_max_upward_grade_){}
    , decltype(_impl_.has_max_downward_grade_){}
    , decltype(_impl_.has_lane_count_){}
    , decltype(_impl_.has_cycle_lane_){}
    , decltype(_impl_.has_bicycle_network_){}
    , decltype(_impl_.has_sidewalk_){}
    , decltype(_impl_.has_density_){}
    , decltype(_impl_.has_speed_limit_){}
    , decltype(_impl_.has_truck_speed_){}
    , decltype(_impl_.has_truck_route_){}
    , decltype(_impl_.has_mean_elevation_){}
    , decltype(_impl_.has_has_time_restrictions_){}
    , decltype(_impl_.has_default_speed_){}
    , decltype(_impl_.has_destination_only_){}
    , decltype(_impl_.has_is_urban_){}
    , decltype(_impl_.has_source_along_edge_){}
    , decltype(_impl_.has_target_along_edge_){}
    , decltype(_impl_.has_sac_scale_){}
    , decltype(_impl_.has_shoulder_){}
    , decltype(_impl_.has_total_length_km_){}
    , decltype(_impl_.has_shortcut_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_length_km();
  clear_has_has_speed();
  clear_has_has_road_class();
  clear_has_has_begin_heading();
  clear_has_has_end_heading();
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
  clear_has_has_traversability();
  clear_has_has_use();
  clear_has_has_toll();
  clear_has_has_unpaved();
  clear_has_has_tunnel();
  clear_has_has_bridge();
  clear_has_has_roundabout();
  clear_has_has_internal_intersection();
  clear_has_has_drive_on_left();
  clear_has_has_surface();
  clear_has_has_travel_mode();
  clear_has_has_vehicle_type();
  clear_has_has_pedestrian_type();
  clear_has_has_bicycle_type();
  clear_has_has_transit_type();
  clear_has_has_id();
  clear_has_has_way_id();
  clear_has_has_weighted_grade();
  clear_has_has_max_upward_grade();
  clear_has_has_max_downward_grade();
  clear_has_has_lane_count();
  clear_has_has_cycle_lane();
  clear_has_has_bicycle_network();
  clear_has_has_sidewalk();
  clear_has_has_density();
  clear_has_has_speed_limit();
  clear_has_has_truck_speed();
  clear_has_has_truck_route();
  clear_has_has_mean_elevation();
  clear_has_has_has_time_restrictions();
  clear_has_has_default_speed();
  clear_has_has_destination_only();
  clear_has_has_is_urban();
  clear_has_has_source_along_edge();
  clear_has_has_target_along_edge();
  clear_has_has_sac_scale();
  clear_has_has_shoulder();
  clear_has_has_total_length_km();
  clear_has_has_shortcut_id();
}

TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Edge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.~RepeatedPtrField();
  _impl_.lane_connectivity_.~RepeatedPtrField();
  _impl_.traffic_segment_.~RepeatedPtrField();
  _impl_.turn_lanes_.~RepeatedPtrField();
  _impl_.tagged_value_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.sign_;
  if (this != internal_default_instance()) delete _impl_.transit_route_info_;
  if (this != internal_default_instance()) delete _impl_.restriction_;
  if (has_has_length_km()) {
    clear_has_length_km();
  }
  if (has_has_speed()) {
    clear_has_speed();
  }
  if (has_has_road_class()) {
    clear_has_road_class();
  }
  if (has_has_begin_heading()) {
    clear_has_begin_heading();
  }
  if (has_has_end_heading()) {
    clear_has_end_heading();
  }
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
  if (has_has_traversability()) {
    clear_has_traversability();
  }
  if (has_has_use()) {
    clear_has_use();
  }
  if (has_has_toll()) {
    clear_has_toll();
  }
  if (has_has_unpaved()) {
    clear_has_unpaved();
  }
  if (has_has_tunnel()) {
    clear_has_tunnel();
  }
  if (has_has_bridge()) {
    clear_has_bridge();
  }
  if (has_has_roundabout()) {
    clear_has_roundabout();
  }
  if (has_has_internal_intersection()) {
    clear_has_internal_intersection();
  }
  if (has_has_drive_on_left()) {
    clear_has_drive_on_left();
  }
  if (has_has_surface()) {
    clear_has_surface();
  }
  if (has_has_travel_mode()) {
    clear_has_travel_mode();
  }
  if (has_has_vehicle_type()) {
    clear_has_vehicle_type();
  }
  if (has_has_pedestrian_type()) {
    clear_has_pedestrian_type();
  }
  if (has_has_bicycle_type()) {
    clear_has_bicycle_type();
  }
  if (has_has_transit_type()) {
    clear_has_transit_type();
  }
  if (has_has_id()) {
    clear_has_id();
  }
  if (has_has_way_id()) {
    clear_has_way_id();
  }
  if (has_has_weighted_grade()) {
    clear_has_weighted_grade();
  }
  if (has_has_max_upward_grade()) {
    clear_has_max_upward_grade();
  }
  if (has_has_max_downward_grade()) {
    clear_has_max_downward_grade();
  }
  if (has_has_lane_count()) {
    clear_has_lane_count();
  }
  if (has_has_cycle_lane()) {
    clear_has_cycle_lane();
  }
  if (has_has_bicycle_network()) {
    clear_has_bicycle_network();
  }
  if (has_has_sidewalk()) {
    clear_has_sidewalk();
  }
  if (has_has_density()) {
    clear_has_density();
  }
  if (has_has_speed_limit()) {
    clear_has_speed_limit();
  }
  if (has_has_truck_speed()) {
    clear_has_truck_speed();
  }
  if (has_has_truck_route()) {
    clear_has_truck_route();
  }
  if (has_has_mean_elevation()) {
    clear_has_mean_elevation();
  }
  if (has_has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
  }
  if (has_has_default_speed()) {
    clear_has_default_speed();
  }
  if (has_has_destination_only()) {
    clear_has_destination_only();
  }
  if (has_has_is_urban()) {
    clear_has_is_urban();
  }
  if (has_has_source_along_edge()) {
    clear_has_source_along_edge();
  }
  if (has_has_target_along_edge()) {
    clear_has_target_along_edge();
  }
  if (has_has_sac_scale()) {
    clear_has_sac_scale();
  }
  if (has_has_shoulder()) {
    clear_has_shoulder();
  }
  if (has_has_total_length_km()) {
    clear_has_total_length_km();
  }
  if (has_has_shortcut_id()) {
    clear_has_shortcut_id();
  }
}

void TripLeg_Edge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Edge::clear_has_length_km() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_length_km_case()) {
    case kLengthKm: {
      // No need to clear
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_LENGTH_KM_NOT_SET;
}

void TripLeg_Edge::clear_has_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_speed_case()) {
    case kSpeed: {
      // No need to clear
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_SPEED_NOT_SET;
}

void TripLeg_Edge::clear_has_road_class() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_road_class_case()) {
    case kRoadClass: {
      // No need to clear
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_ROAD_CLASS_NOT_SET;
}

void TripLeg_Edge::clear_has_begin_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_begin_heading_case()) {
    case kBeginHeading: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_BEGIN_HEADING_NOT_SET;
}

void TripLeg_Edge::clear_has_end_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_end_heading_case()) {
    case kEndHeading: {
      // No need to clear
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_END_HEADING_NOT_SET;
}

void TripLeg_Edge::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Edge::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_END_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Edge::clear_has_traversability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_traversability_case()) {
    case kTraversability: {
      // No need to clear
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_TRAVERSABILITY_NOT_SET;
}

void TripLeg_Edge::clear_has_use() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_use_case()) {
    case kUse: {
      // No need to clear
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_USE_NOT_SET;
}

void TripLeg_Edge::clear_has_toll() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_toll_case()) {
    case kToll: {
      // No need to clear
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = HAS_TOLL_NOT_SET;
}

void TripLeg_Edge::clear_has_unpaved() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_unpaved_case()) {
    case kUnpaved: {
      // No need to clear
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = HAS_UNPAVED_NOT_SET;
}

void TripLeg_Edge::clear_has_tunnel() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_tunnel_case()) {
    case kTunnel: {
      // No need to clear
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = HAS_TUNNEL_NOT_SET;
}

void TripLeg_Edge::clear_has_bridge() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_bridge_case()) {
    case kBridge: {
      // No need to clear
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[12] = HAS_BRIDGE_NOT_SET;
}

void TripLeg_Edge::clear_has_roundabout() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_roundabout_case()) {
    case kRoundabout: {
      // No need to clear
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[13] = HAS_ROUNDABOUT_NOT_SET;
}

void TripLeg_Edge::clear_has_internal_intersection() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_internal_intersection_case()) {
    case kInternalIntersection: {
      // No need to clear
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[14] = HAS_INTERNAL_INTERSECTION_NOT_SET;
}

void TripLeg_Edge::clear_has_drive_on_left() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_drive_on_left_case()) {
    case kDriveOnLeft: {
      // No need to clear
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[15] = HAS_DRIVE_ON_LEFT_NOT_SET;
}

void TripLeg_Edge::clear_has_surface() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_surface_case()) {
    case kSurface: {
      // No need to clear
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[16] = HAS_SURFACE_NOT_SET;
}

void TripLeg_Edge::clear_has_travel_mode() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_travel_mode_case()) {
    case kTravelMode: {
      // No need to clear
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[17] = HAS_TRAVEL_MODE_NOT_SET;
}

void TripLeg_Edge::clear_has_vehicle_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_vehicle_type_case()) {
    case kVehicleType: {
      // No need to clear
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[18] = HAS_VEHICLE_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_pedestrian_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_pedestrian_type_case()) {
    case kPedestrianType: {
      // No need to clear
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[19] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_bicycle_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_bicycle_type_case()) {
    case kBicycleType: {
      // No need to clear
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[20] = HAS_BICYCLE_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_transit_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_transit_type_case()) {
    case kTransitType: {
      // No need to clear
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[21] = HAS_TRANSIT_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_id_case()) {
    case kId: {
      // No need to clear
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[22] = HAS_ID_NOT_SET;
}

void TripLeg_Edge::clear_has_way_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_way_id_case()) {
    case kWayId: {
      // No need to clear
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[23] = HAS_WAY_ID_NOT_SET;
}

void TripLeg_Edge::clear_has_weighted_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_weighted_grade_case()) {
    case kWeightedGrade: {
      // No need to clear
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[24] = HAS_WEIGHTED_GRADE_NOT_SET;
}

void TripLeg_Edge::clear_has_max_upward_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_max_upward_grade_case()) {
    case kMaxUpwardGrade: {
      // No need to clear
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[25] = HAS_MAX_UPWARD_GRADE_NOT_SET;
}

void TripLeg_Edge::clear_has_max_downward_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_max_downward_grade_case()) {
    case kMaxDownwardGrade: {
      // No need to clear
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[26] = HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}

void TripLeg_Edge::clear_has_lane_count() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_lane_count_case()) {
    case kLaneCount: {
      // No need to clear
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[27] = HAS_LANE_COUNT_NOT_SET;
}

void TripLeg_Edge::clear_has_cycle_lane() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_cycle_lane_case()) {
    case kCycleLane: {
      // No need to clear
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[28] = HAS_CYCLE_LANE_NOT_SET;
}

void TripLeg_Edge::clear_has_bicycle_network() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_bicycle_network_case()) {
    case kBicycleNetwork: {
      // No need to clear
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[29] = HAS_BICYCLE_NETWORK_NOT_SET;
}

void TripLeg_Edge::clear_has_sidewalk() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_sidewalk_case()) {
    case kSidewalk: {
      // No need to clear
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[30] = HAS_SIDEWALK_NOT_SET;
}

void TripLeg_Edge::clear_has_density() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_density_case()) {
    case kDensity: {
      // No need to clear
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[31] = HAS_DENSITY_NOT_SET;
}

void TripLeg_Edge::clear_has_speed_limit() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_speed_limit_case()) {
    case kSpeedLimit: {
      // No need to clear
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[32] = HAS_SPEED_LIMIT_NOT_SET;
}

void TripLeg_Edge::clear_has_truck_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_truck_speed_case()) {
    case kTruckSpeed: {
      // No need to clear
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[33] = HAS_TRUCK_SPEED_NOT_SET;
}

void TripLeg_Edge::clear_has_truck_route() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_truck_route_case()) {
    case kTruckRoute: {
      // No need to clear
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[34] = HAS_TRUCK_ROUTE_NOT_SET;
}

void TripLeg_Edge::clear_has_mean_elevation() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_mean_elevation_case()) {
    case kMeanElevation: {
      // No need to clear
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[35] = HAS_MEAN_ELEVATION_NOT_SET;
}

void TripLeg_Edge::clear_has_has_time_restrictions() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_has_time_restrictions_case()) {
    case kHasTimeRestrictions: {
      // No need to clear
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[36] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}

void TripLeg_Edge::clear_has_default_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_default_speed_case()) {
    case kDefaultSpeed: {
      // No need to clear
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[37] = HAS_DEFAULT_SPEED_NOT_SET;
}

void TripLeg_Edge::clear_has_destination_only() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_destination_only_case()) {
    case kDestinationOnly: {
      // No need to clear
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[38] = HAS_DESTINATION_ONLY_NOT_SET;
}

void TripLeg_Edge::clear_has_is_urban() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_is_urban_case()) {
    case kIsUrban: {
      // No need to clear
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[39] = HAS_IS_URBAN_NOT_SET;
}

void TripLeg_Edge::clear_has_source_along_edge() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_source_along_edge_case()) {
    case kSourceAlongEdge: {
      // No need to clear
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[40] = HAS_SOURCE_ALONG_EDGE_NOT_SET;
}

void TripLeg_Edge::clear_has_target_along_edge() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_target_along_edge_case()) {
    case kTargetAlongEdge: {
      // No need to clear
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[41] = HAS_TARGET_ALONG_EDGE_NOT_SET;
}

void TripLeg_Edge::clear_has_sac_scale() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_sac_scale_case()) {
    case kSacScale: {
      // No need to clear
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[42] = HAS_SAC_SCALE_NOT_SET;
}

void TripLeg_Edge::clear_has_shoulder() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_shoulder_case()) {
    case kShoulder: {
      // No need to clear
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[43] = HAS_SHOULDER_NOT_SET;
}

void TripLeg_Edge::clear_has_total_length_km() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_total_length_km_case()) {
    case kTotalLengthKm: {
      // No need to clear
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[44] = HAS_TOTAL_LENGTH_KM_NOT_SET;
}

void TripLeg_Edge::clear_has_shortcut_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch (has_shortcut_id_case()) {
    case kShortcutId: {
      // No need to clear
      break;
    }
    case HAS_SHORTCUT_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[45] = HAS_SHORTCUT_ID_NOT_SET;
}


void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.Clear();
  _impl_.lane_connectivity_.Clear();
  _impl_.traffic_segment_.Clear();
  _impl_.turn_lanes_.Clear();
  _impl_.tagged_value_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_route_info_ != nullptr) {
    delete _impl_.transit_route_info_;
  }
  _impl_.transit_route_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.restriction_ != nullptr) {
    delete _impl_.restriction_;
  }
  _impl_.restriction_ = nullptr;
  clear_has_length_km();
  clear_has_speed();
  clear_has_road_class();
  clear_has_begin_heading();
  clear_has_end_heading();
  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  clear_has_traversability();
  clear_has_use();
  clear_has_toll();
  clear_has_unpaved();
  clear_has_tunnel();
  clear_has_bridge();
  clear_has_roundabout();
  clear_has_internal_intersection();
  clear_has_drive_on_left();
  clear_has_surface();
  clear_has_travel_mode();
  clear_has_vehicle_type();
  clear_has_pedestrian_type();
  clear_has_bicycle_type();
  clear_has_transit_type();
  clear_has_id();
  clear_has_way_id();
  clear_has_weighted_grade();
  clear_has_max_upward_grade();
  clear_has_max_downward_grade();
  clear_has_lane_count();
  clear_has_cycle_lane();
  clear_has_bicycle_network();
  clear_has_sidewalk();
  clear_has_density();
  clear_has_speed_limit();
  clear_has_truck_speed();
  clear_has_truck_route();
  clear_has_mean_elevation();
  clear_has_has_time_restrictions();
  clear_has_default_speed();
  clear_has_destination_only();
  clear_has_is_urban();
  clear_has_source_along_edge();
  clear_has_target_along_edge();
  clear_has_sac_scale();
  clear_has_shoulder();
  clear_has_total_length_km();
  clear_has_shortcut_id();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Edge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.StreetName name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_name(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float length_km = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_length_km(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _internal_set_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.RoadClass road_class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_heading = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_begin_heading(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_heading = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _internal_set_end_heading(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_shape_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability traversability = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_traversability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Use use = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
        } else
          goto handle_unusual;
        continue;
      // bool toll = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_toll(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool unpaved = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_unpaved(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool tunnel = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _internal_set_tunnel(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bridge = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _internal_set_bridge(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool roundabout = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _internal_set_roundabout(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool internal_intersection = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _internal_set_internal_intersection(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool drive_on_left = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _internal_set_drive_on_left(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Surface surface = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_surface(static_cast<::valhalla::TripLeg_Surface>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripSign sign = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TravelMode travel_mode = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_travel_mode(static_cast<::valhalla::TravelMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.VehicleType vehicle_type = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_vehicle_type(static_cast<::valhalla::VehicleType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.PedestrianType pedestrian_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pedestrian_type(static_cast<::valhalla::PedestrianType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BicycleType bicycle_type = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_bicycle_type(static_cast<::valhalla::BicycleType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitType transit_type = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_transit_type(static_cast<::valhalla::TransitType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitRouteInfo transit_route_info = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_route_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 id = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _internal_set_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 way_id = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _internal_set_way_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float weighted_grade = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 229)) {
          _internal_set_weighted_grade(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 max_upward_grade = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _internal_set_max_upward_grade(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_downward_grade = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _internal_set_max_downward_grade(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 lane_count = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _internal_set_lane_count(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.CycleLane cycle_lane = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cycle_lane(static_cast<::valhalla::TripLeg_CycleLane>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 bicycle_network = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_bicycle_network(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Sidewalk sidewalk = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sidewalk(static_cast<::valhalla::TripLeg_Sidewalk>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 density = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_density(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 speed_limit = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_speed_limit(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float truck_speed = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _internal_set_truck_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool truck_route = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _internal_set_truck_route(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_lane_connectivity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<314>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 mean_elevation = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_mean_elevation(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_traffic_segment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<330>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TurnLane turn_lanes = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_turn_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<338>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool has_time_restrictions = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_has_time_restrictions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float default_speed = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _internal_set_default_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Restriction restriction = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_restriction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool destination_only = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _internal_set_destination_only(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_urban = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _internal_set_is_urban(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TaggedValue tagged_value = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tagged_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<386>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float source_along_edge = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _internal_set_source_along_edge(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float target_along_edge = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _internal_set_target_along_edge(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.SacScale sac_scale = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sac_scale(static_cast<::valhalla::TripLeg_SacScale>(val));
        } else
          goto handle_unusual;
        continue;
      // bool shoulder = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _internal_set_shoulder(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float total_length_km = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _internal_set_total_length_km(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int64 shortcut_id = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _internal_set_shortcut_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Edge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_name_size()); i < n; i++) {
    const auto& repfield = this->_internal_name(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float length_km = 2;
  if (_internal_has_length_km()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_length_km(), target);
  }

  // float speed = 3;
  if (_internal_has_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_speed(), target);
  }

  // .valhalla.RoadClass road_class = 4;
  if (_internal_has_road_class()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_road_class(), target);
  }

  // uint32 begin_heading = 5;
  if (_internal_has_begin_heading()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_begin_heading(), target);
  }

  // uint32 end_heading = 6;
  if (_internal_has_end_heading()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_end_heading(), target);
  }

  // uint32 begin_shape_index = 7;
  if (_internal_has_begin_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 8;
  if (_internal_has_end_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_end_shape_index(), target);
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (_internal_has_traversability()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_traversability(), target);
  }

  // .valhalla.TripLeg.Use use = 10;
  if (_internal_has_use()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_use(), target);
  }

  // bool toll = 11;
  if (_internal_has_toll()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_toll(), target);
  }

  // bool unpaved = 12;
  if (_internal_has_unpaved()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_unpaved(), target);
  }

  // bool tunnel = 13;
  if (_internal_has_tunnel()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_tunnel(), target);
  }

  // bool bridge = 14;
  if (_internal_has_bridge()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_bridge(), target);
  }

  // bool roundabout = 15;
  if (_internal_has_roundabout()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_roundabout(), target);
  }

  // bool internal_intersection = 16;
  if (_internal_has_internal_intersection()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_internal_intersection(), target);
  }

  // bool drive_on_left = 17;
  if (_internal_has_drive_on_left()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_drive_on_left(), target);
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (_internal_has_surface()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_surface(), target);
  }

  // .valhalla.TripSign sign = 19;
  if (this->_internal_has_sign()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::sign(this),
        _Internal::sign(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (_internal_has_travel_mode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_travel_mode(), target);
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (_internal_has_vehicle_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      21, this->_internal_vehicle_type(), target);
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (_internal_has_pedestrian_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_pedestrian_type(), target);
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (_internal_has_bicycle_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      23, this->_internal_bicycle_type(), target);
  }

  // .valhalla.TransitType transit_type = 24;
  if (_internal_has_transit_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      24, this->_internal_transit_type(), target);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->_internal_has_transit_route_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::transit_route_info(this),
        _Internal::transit_route_info(this).GetCachedSize(), target, stream);
  }

  // uint64 id = 26;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(26, this->_internal_id(), target);
  }

  // uint64 way_id = 27;
  if (_internal_has_way_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(27, this->_internal_way_id(), target);
  }

  // float weighted_grade = 28;
  if (_internal_has_weighted_grade()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(28, this->_internal_weighted_grade(), target);
  }

  // int32 max_upward_grade = 29;
  if (_internal_has_max_upward_grade()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_max_upward_grade(), target);
  }

  // int32 max_downward_grade = 30;
  if (_internal_has_max_downward_grade()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(30, this->_internal_max_downward_grade(), target);
  }

  // uint32 lane_count = 31;
  if (_internal_has_lane_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_lane_count(), target);
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (_internal_has_cycle_lane()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      32, this->_internal_cycle_lane(), target);
  }

  // uint32 bicycle_network = 33;
  if (_internal_has_bicycle_network()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(33, this->_internal_bicycle_network(), target);
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (_internal_has_sidewalk()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      34, this->_internal_sidewalk(), target);
  }

  // uint32 density = 35;
  if (_internal_has_density()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_density(), target);
  }

  // uint32 speed_limit = 36;
  if (_internal_has_speed_limit()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_speed_limit(), target);
  }

  // float truck_speed = 37;
  if (_internal_has_truck_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(37, this->_internal_truck_speed(), target);
  }

  // bool truck_route = 38;
  if (_internal_has_truck_route()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(38, this->_internal_truck_route(), target);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lane_connectivity_size()); i < n; i++) {
    const auto& repfield = this->_internal_lane_connectivity(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(39, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 mean_elevation = 40;
  if (_internal_has_mean_elevation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(40, this->_internal_mean_elevation(), target);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_traffic_segment_size()); i < n; i++) {
    const auto& repfield = this->_internal_traffic_segment(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(41, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_turn_lanes_size()); i < n; i++) {
    const auto& repfield = this->_internal_turn_lanes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(42, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool has_time_restrictions = 43;
  if (_internal_has_has_time_restrictions()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(43, this->_internal_has_time_restrictions(), target);
  }

  // float default_speed = 44;
  if (_internal_has_default_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(44, this->_internal_default_speed(), target);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (this->_internal_has_restriction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(45, _Internal::restriction(this),
        _Internal::restriction(this).GetCachedSize(), target, stream);
  }

  // bool destination_only = 46;
  if (_internal_has_destination_only()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(46, this->_internal_destination_only(), target);
  }

  // bool is_urban = 47;
  if (_internal_has_is_urban()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(47, this->_internal_is_urban(), target);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tagged_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_tagged_value(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(48, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float source_along_edge = 49;
  if (_internal_has_source_along_edge()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(49, this->_internal_source_along_edge(), target);
  }

  // float target_along_edge = 50;
  if (_internal_has_target_along_edge()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(50, this->_internal_target_along_edge(), target);
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (_internal_has_sac_scale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      51, this->_internal_sac_scale(), target);
  }

  // bool shoulder = 52;
  if (_internal_has_shoulder()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(52, this->_internal_shoulder(), target);
  }

  // float total_length_km = 53;
  if (_internal_has_total_length_km()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(53, this->_internal_total_length_km(), target);
  }

  // int64 shortcut_id = 54;
  if (_internal_has_shortcut_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(54, this->_internal_shortcut_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge)
  return target;
}

size_t TripLeg_Edge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  total_size += 1UL * this->_internal_name_size();
  for (const auto& msg : this->_impl_.name_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2UL * this->_internal_lane_connectivity_size();
  for (const auto& msg : this->_impl_.lane_connectivity_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2UL * this->_internal_traffic_segment_size();
  for (const auto& msg : this->_impl_.traffic_segment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2UL * this->_internal_turn_lanes_size();
  for (const auto& msg : this->_impl_.turn_lanes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  total_size += 2UL * this->_internal_tagged_value_size();
  for (const auto& msg : this->_impl_.tagged_value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .valhalla.TripSign sign = 19;
  if (this->_internal_has_sign()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sign_);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->_internal_has_transit_route_info()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_route_info_);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (this->_internal_has_restriction()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.restriction_);
  }

  switch (has_length_km_case()) {
    // float length_km = 2;
    case kLengthKm: {
      total_size += 1 + 4;
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  switch (has_speed_case()) {
    // float speed = 3;
    case kSpeed: {
      total_size += 1 + 4;
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_road_class_case()) {
    // .valhalla.RoadClass road_class = 4;
    case kRoadClass: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (has_begin_heading_case()) {
    // uint32 begin_heading = 5;
    case kBeginHeading: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (has_end_heading_case()) {
    // uint32 end_heading = 6;
    case kEndHeading: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_heading());
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  switch (has_begin_shape_index_case()) {
    // uint32 begin_shape_index = 7;
    case kBeginShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // uint32 end_shape_index = 8;
    case kEndShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_traversability_case()) {
    // .valhalla.TripLeg.Traversability traversability = 9;
    case kTraversability: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_traversability());
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_use_case()) {
    // .valhalla.TripLeg.Use use = 10;
    case kUse: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (has_toll_case()) {
    // bool toll = 11;
    case kToll: {
      total_size += 1 + 1;
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  switch (has_unpaved_case()) {
    // bool unpaved = 12;
    case kUnpaved: {
      total_size += 1 + 1;
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  switch (has_tunnel_case()) {
    // bool tunnel = 13;
    case kTunnel: {
      total_size += 1 + 1;
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  switch (has_bridge_case()) {
    // bool bridge = 14;
    case kBridge: {
      total_size += 1 + 1;
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  switch (has_roundabout_case()) {
    // bool roundabout = 15;
    case kRoundabout: {
      total_size += 1 + 1;
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  switch (has_internal_intersection_case()) {
    // bool internal_intersection = 16;
    case kInternalIntersection: {
      total_size += 2 + 1;
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  switch (has_drive_on_left_case()) {
    // bool drive_on_left = 17;
    case kDriveOnLeft: {
      total_size += 2 + 1;
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  switch (has_surface_case()) {
    // .valhalla.TripLeg.Surface surface = 18;
    case kSurface: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_surface());
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  switch (has_travel_mode_case()) {
    // .valhalla.TravelMode travel_mode = 20;
    case kTravelMode: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_travel_mode());
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  switch (has_vehicle_type_case()) {
    // .valhalla.VehicleType vehicle_type = 21;
    case kVehicleType: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_vehicle_type());
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_pedestrian_type_case()) {
    // .valhalla.PedestrianType pedestrian_type = 22;
    case kPedestrianType: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pedestrian_type());
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_bicycle_type_case()) {
    // .valhalla.BicycleType bicycle_type = 23;
    case kBicycleType: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_bicycle_type());
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_transit_type_case()) {
    // .valhalla.TransitType transit_type = 24;
    case kTransitType: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_transit_type());
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_id_case()) {
    // uint64 id = 26;
    case kId: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (has_way_id_case()) {
    // uint64 way_id = 27;
    case kWayId: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_way_id());
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (has_weighted_grade_case()) {
    // float weighted_grade = 28;
    case kWeightedGrade: {
      total_size += 2 + 4;
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_max_upward_grade_case()) {
    // int32 max_upward_grade = 29;
    case kMaxUpwardGrade: {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_max_upward_grade());
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_max_downward_grade_case()) {
    // int32 max_downward_grade = 30;
    case kMaxDownwardGrade: {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_max_downward_grade());
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_lane_count_case()) {
    // uint32 lane_count = 31;
    case kLaneCount: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  switch (has_cycle_lane_case()) {
    // .valhalla.TripLeg.CycleLane cycle_lane = 32;
    case kCycleLane: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cycle_lane());
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  switch (has_bicycle_network_case()) {
    // uint32 bicycle_network = 33;
    case kBicycleNetwork: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_bicycle_network());
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  switch (has_sidewalk_case()) {
    // .valhalla.TripLeg.Sidewalk sidewalk = 34;
    case kSidewalk: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sidewalk());
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  switch (has_density_case()) {
    // uint32 density = 35;
    case kDensity: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_density());
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  switch (has_speed_limit_case()) {
    // uint32 speed_limit = 36;
    case kSpeedLimit: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_speed_limit());
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  switch (has_truck_speed_case()) {
    // float truck_speed = 37;
    case kTruckSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_truck_route_case()) {
    // bool truck_route = 38;
    case kTruckRoute: {
      total_size += 2 + 1;
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  switch (has_mean_elevation_case()) {
    // int32 mean_elevation = 40;
    case kMeanElevation: {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mean_elevation());
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  switch (has_has_time_restrictions_case()) {
    // bool has_time_restrictions = 43;
    case kHasTimeRestrictions: {
      total_size += 2 + 1;
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  switch (has_default_speed_case()) {
    // float default_speed = 44;
    case kDefaultSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_destination_only_case()) {
    // bool destination_only = 46;
    case kDestinationOnly: {
      total_size += 2 + 1;
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  switch (has_is_urban_case()) {
    // bool is_urban = 47;
    case kIsUrban: {
      total_size += 2 + 1;
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  switch (has_source_along_edge_case()) {
    // float source_along_edge = 49;
    case kSourceAlongEdge: {
      total_size += 2 + 4;
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (has_target_along_edge_case()) {
    // float target_along_edge = 50;
    case kTargetAlongEdge: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (has_sac_scale_case()) {
    // .valhalla.TripLeg.SacScale sac_scale = 51;
    case kSacScale: {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sac_scale());
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  switch (has_shoulder_case()) {
    // bool shoulder = 52;
    case kShoulder: {
      total_size += 2 + 1;
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  switch (has_total_length_km_case()) {
    // float total_length_km = 53;
    case kTotalLengthKm: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  switch (has_shortcut_id_case()) {
    // int64 shortcut_id = 54;
    case kShortcutId: {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_shortcut_id());
      break;
    }
    case HAS_SHORTCUT_ID_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Edge*>(
      &from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
  TripLeg_Edge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.name_.MergeFrom(from._impl_.name_);
  _this->_impl_.lane_connectivity_.MergeFrom(from._impl_.lane_connectivity_);
  _this->_impl_.traffic_segment_.MergeFrom(from._impl_.traffic_segment_);
  _this->_impl_.turn_lanes_.MergeFrom(from._impl_.turn_lanes_);
  _this->_impl_.tagged_value_.MergeFrom(from._impl_.tagged_value_);
  if (from._internal_has_sign()) {
    _this->_internal_mutable_sign()->::valhalla::TripSign::MergeFrom(
        from._internal_sign());
  }
  if (from._internal_has_transit_route_info()) {
    _this->_internal_mutable_transit_route_info()->::valhalla::TransitRouteInfo::MergeFrom(
        from._internal_transit_route_info());
  }
  if (from._internal_has_restriction()) {
    _this->_internal_mutable_restriction()->::valhalla::TripLeg_Restriction::MergeFrom(
        from._internal_restriction());
  }
  switch (from.has_length_km_case()) {
    case kLengthKm: {
      _this->_internal_set_length_km(from._internal_length_km());
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  switch (from.has_speed_case()) {
    case kSpeed: {
      _this->_internal_set_speed(from._internal_speed());
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_road_class_case()) {
    case kRoadClass: {
      _this->_internal_set_road_class(from._internal_road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (from.has_begin_heading_case()) {
    case kBeginHeading: {
      _this->_internal_set_begin_heading(from._internal_begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_heading_case()) {
    case kEndHeading: {
      _this->_internal_set_end_heading(from._internal_end_heading());
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_traversability_case()) {
    case kTraversability: {
      _this->_internal_set_traversability(from._internal_traversability());
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_case()) {
    case kUse: {
      _this->_internal_set_use(from._internal_use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (from.has_toll_case()) {
    case kToll: {
      _this->_internal_set_toll(from._internal_toll());
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  switch (from.has_unpaved_case()) {
    case kUnpaved: {
      _this->_internal_set_unpaved(from._internal_unpaved());
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  switch (from.has_tunnel_case()) {
    case kTunnel: {
      _this->_internal_set_tunnel(from._internal_tunnel());
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  switch (from.has_bridge_case()) {
    case kBridge: {
      _this->_internal_set_bridge(from._internal_bridge());
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_roundabout_case()) {
    case kRoundabout: {
      _this->_internal_set_roundabout(from._internal_roundabout());
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  switch (from.has_internal_intersection_case()) {
    case kInternalIntersection: {
      _this->_internal_set_internal_intersection(from._internal_internal_intersection());
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  switch (from.has_drive_on_left_case()) {
    case kDriveOnLeft: {
      _this->_internal_set_drive_on_left(from._internal_drive_on_left());
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  switch (from.has_surface_case()) {
    case kSurface: {
      _this->_internal_set_surface(from._internal_surface());
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  switch (from.has_travel_mode_case()) {
    case kTravelMode: {
      _this->_internal_set_travel_mode(from._internal_travel_mode());
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  switch (from.has_vehicle_type_case()) {
    case kVehicleType: {
      _this->_internal_set_vehicle_type(from._internal_vehicle_type());
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_pedestrian_type_case()) {
    case kPedestrianType: {
      _this->_internal_set_pedestrian_type(from._internal_pedestrian_type());
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_bicycle_type_case()) {
    case kBicycleType: {
      _this->_internal_set_bicycle_type(from._internal_bicycle_type());
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_transit_type_case()) {
    case kTransitType: {
      _this->_internal_set_transit_type(from._internal_transit_type());
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_id_case()) {
    case kId: {
      _this->_internal_set_id(from._internal_id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_way_id_case()) {
    case kWayId: {
      _this->_internal_set_way_id(from._internal_way_id());
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_weighted_grade_case()) {
    case kWeightedGrade: {
      _this->_internal_set_weighted_grade(from._internal_weighted_grade());
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_upward_grade_case()) {
    case kMaxUpwardGrade: {
      _this->_internal_set_max_upward_grade(from._internal_max_upward_grade());
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_downward_grade_case()) {
    case kMaxDownwardGrade: {
      _this->_internal_set_max_downward_grade(from._internal_max_downward_grade());
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_lane_count_case()) {
    case kLaneCount: {
      _this->_internal_set_lane_count(from._internal_lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  switch (from.has_cycle_lane_case()) {
    case kCycleLane: {
      _this->_internal_set_cycle_lane(from._internal_cycle_lane());
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  switch (from.has_bicycle_network_case()) {
    case kBicycleNetwork: {
      _this->_internal_set_bicycle_network(from._internal_bicycle_network());
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  switch (from.has_sidewalk_case()) {
    case kSidewalk: {
      _this->_internal_set_sidewalk(from._internal_sidewalk());
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  switch (from.has_density_case()) {
    case kDensity: {
      _this->_internal_set_density(from._internal_density());
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_speed_limit_case()) {
    case kSpeedLimit: {
      _this->_internal_set_speed_limit(from._internal_speed_limit());
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  switch (from.has_truck_speed_case()) {
    case kTruckSpeed: {
      _this->_internal_set_truck_speed(from._internal_truck_speed());
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_truck_route_case()) {
    case kTruckRoute: {
      _this->_internal_set_truck_route(from._internal_truck_route());
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  switch (from.has_mean_elevation_case()) {
    case kMeanElevation: {
      _this->_internal_set_mean_elevation(from._internal_mean_elevation());
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  switch (from.has_has_time_restrictions_case()) {
    case kHasTimeRestrictions: {
      _this->_internal_set_has_time_restrictions(from._internal_has_time_restrictions());
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  switch (from.has_default_speed_case()) {
    case kDefaultSpeed: {
      _this->_internal_set_default_speed(from._internal_default_speed());
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_destination_only_case()) {
    case kDestinationOnly: {
      _this->_internal_set_destination_only(from._internal_destination_only());
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  switch (from.has_is_urban_case()) {
    case kIsUrban: {
      _this->_internal_set_is_urban(from._internal_is_urban());
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  switch (from.has_source_along_edge_case()) {
    case kSourceAlongEdge: {
      _this->_internal_set_source_along_edge(from._internal_source_along_edge());
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_target_along_edge_case()) {
    case kTargetAlongEdge: {
      _this->_internal_set_target_along_edge(from._internal_target_along_edge());
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_sac_scale_case()) {
    case kSacScale: {
      _this->_internal_set_sac_scale(from._internal_sac_scale());
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  switch (from.has_shoulder_case()) {
    case kShoulder: {
      _this->_internal_set_shoulder(from._internal_shoulder());
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  switch (from.has_total_length_km_case()) {
    case kTotalLengthKm: {
      _this->_internal_set_total_length_km(from._internal_total_length_km());
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  switch (from.has_shortcut_id_case()) {
    case kShortcutId: {
      _this->_internal_set_shortcut_id(from._internal_shortcut_id());
      break;
    }
    case HAS_SHORTCUT_ID_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Edge::IsInitialized() const {
  return true;
}

void TripLeg_Edge::InternalSwap(TripLeg_Edge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.name_.InternalSwap(&other->_impl_.name_);
  _impl_.lane_connectivity_.InternalSwap(&other->_impl_.lane_connectivity_);
  _impl_.traffic_segment_.InternalSwap(&other->_impl_.traffic_segment_);
  _impl_.turn_lanes_.InternalSwap(&other->_impl_.turn_lanes_);
  _impl_.tagged_value_.InternalSwap(&other->_impl_.tagged_value_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.restriction_)
      + sizeof(TripLeg_Edge::_impl_.restriction_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
  swap(_impl_.has_length_km_, other->_impl_.has_length_km_);
  swap(_impl_.has_speed_, other->_impl_.has_speed_);
  swap(_impl_.has_road_class_, other->_impl_.has_road_class_);
  swap(_impl_.has_begin_heading_, other->_impl_.has_begin_heading_);
  swap(_impl_.has_end_heading_, other->_impl_.has_end_heading_);
  swap(_impl_.has_begin_shape_index_, other->_impl_.has_begin_shape_index_);
  swap(_impl_.has_end_shape_index_, other->_impl_.has_end_shape_index_);
  swap(_impl_.has_traversability_, other->_impl_.has_traversability_);
  swap(_impl_.has_use_, other->_impl_.has_use_);
  swap(_impl_.has_toll_, other->_impl_.has_toll_);
  swap(_impl_.has_unpaved_, other->_impl_.has_unpaved_);
  swap(_impl_.has_tunnel_, other->_impl_.has_tunnel_);
  swap(_impl_.has_bridge_, other->_impl_.has_bridge_);
  swap(_impl_.has_roundabout_, other->_impl_.has_roundabout_);
  swap(_impl_.has_internal_intersection_, other->_impl_.has_internal_intersection_);
  swap(_impl_.has_drive_on_left_, other->_impl_.has_drive_on_left_);
  swap(_impl_.has_surface_, other->_impl_.has_surface_);
  swap(_impl_.has_travel_mode_, other->_impl_.has_travel_mode_);
  swap(_impl_.has_vehicle_type_, other->_impl_.has_vehicle_type_);
  swap(_impl_.has_pedestrian_type_, other->_impl_.has_pedestrian_type_);
  swap(_impl_.has_bicycle_type_, other->_impl_.has_bicycle_type_);
  swap(_impl_.has_transit_type_, other->_impl_.has_transit_type_);
  swap(_impl_.has_id_, other->_impl_.has_id_);
  swap(_impl_.has_way_id_, other->_impl_.has_way_id_);
  swap(_impl_.has_weighted_grade_, other->_impl_.has_weighted_grade_);
  swap(_impl_.has_max_upward_grade_, other->_impl_.has_max_upward_grade_);
  swap(_impl_.has_max_downward_grade_, other->_impl_.has_max_downward_grade_);
  swap(_impl_.has_lane_count_, other->_impl_.has_lane_count_);
  swap(_impl_.has_cycle_lane_, other->_impl_.has_cycle_lane_);
  swap(_impl_.has_bicycle_network_, other->_impl_.has_bicycle_network_);
  swap(_impl_.has_sidewalk_, other->_impl_.has_sidewalk_);
  swap(_impl_.has_density_, other->_impl_.has_density_);
  swap(_impl_.has_speed_limit_, other->_impl_.has_speed_limit_);
  swap(_impl_.has_truck_speed_, other->_impl_.has_truck_speed_);
  swap(_impl_.has_truck_route_, other->_impl_.has_truck_route_);
  swap(_impl_.has_mean_elevation_, other->_impl_.has_mean_elevation_);
  swap(_impl_.has_has_time_restrictions_, other->_impl_.has_has_time_restrictions_);
  swap(_impl_.has_default_speed_, other->_impl_.has_default_speed_);
  swap(_impl_.has_destination_only_, other->_impl_.has_destination_only_);
  swap(_impl_.has_is_urban_, other->_impl_.has_is_urban_);
  swap(_impl_.has_source_along_edge_, other->_impl_.has_source_along_edge_);
  swap(_impl_.has_target_along_edge_, other->_impl_.has_target_along_edge_);
  swap(_impl_.has_sac_scale_, other->_impl_.has_sac_scale_);
  swap(_impl_.has_shoulder_, other->_impl_.has_shoulder_);
  swap(_impl_.has_total_length_km_, other->_impl_.has_total_length_km_);
  swap(_impl_.has_shortcut_id_, other->_impl_.has_shortcut_id_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
  swap(_impl_._oneof_case_[12], other->_impl_._oneof_case_[12]);
  swap(_impl_._oneof_case_[13], other->_impl_._oneof_case_[13]);
  swap(_impl_._oneof_case_[14], other->_impl_._oneof_case_[14]);
  swap(_impl_._oneof_case_[15], other->_impl_._oneof_case_[15]);
  swap(_impl_._oneof_case_[16], other->_impl_._oneof_case_[16]);
  swap(_impl_._oneof_case_[17], other->_impl_._oneof_case_[17]);
  swap(_impl_._oneof_case_[18], other->_impl_._oneof_case_[18]);
  swap(_impl_._oneof_case_[19], other->_impl_._oneof_case_[19]);
  swap(_impl_._oneof_case_[20], other->_impl_._oneof_case_[20]);
  swap(_impl_._oneof_case_[21], other->_impl_._oneof_case_[21]);
  swap(_impl_._oneof_case_[22], other->_impl_._oneof_case_[22]);
  swap(_impl_._oneof_case_[23], other->_impl_._oneof_case_[23]);
  swap(_impl_._oneof_case_[24], other->_impl_._oneof_case_[24]);
  swap(_impl_._oneof_case_[25], other->_impl_._oneof_case_[25]);
  swap(_impl_._oneof_case_[26], other->_impl_._oneof_case_[26]);
  swap(_impl_._oneof_case_[27], other->_impl_._oneof_case_[27]);
  swap(_impl_._oneof_case_[28], other->_impl_._oneof_case_[28]);
  swap(_impl_._oneof_case_[29], other->_impl_._oneof_case_[29]);
  swap(_impl_._oneof_case_[30], other->_impl_._oneof_case_[30]);
  swap(_impl_._oneof_case_[31], other->_impl_._oneof_case_[31]);
  swap(_impl_._oneof_case_[32], other->_impl_._oneof_case_[32]);
  swap(_impl_._oneof_case_[33], other->_impl_._oneof_case_[33]);
  swap(_impl_._oneof_case_[34], other->_impl_._oneof_case_[34]);
  swap(_impl_._oneof_case_[35], other->_impl_._oneof_case_[35]);
  swap(_impl_._oneof_case_[36], other->_impl_._oneof_case_[36]);
  swap(_impl_._oneof_case_[37], other->_impl_._oneof_case_[37]);
  swap(_impl_._oneof_case_[38], other->_impl_._oneof_case_[38]);
  swap(_impl_._oneof_case_[39], other->_impl_._oneof_case_[39]);
  swap(_impl_._oneof_case_[40], other->_impl_._oneof_case_[40]);
  swap(_impl_._oneof_case_[41], other->_impl_._oneof_case_[41]);
  swap(_impl_._oneof_case_[42], other->_impl_._oneof_case_[42]);
  swap(_impl_._oneof_case_[43], other->_impl_._oneof_case_[43]);
  swap(_impl_._oneof_case_[44], other->_impl_._oneof_case_[44]);
  swap(_impl_._oneof_case_[45], other->_impl_._oneof_case_[45]);
}

std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}


// ===================================================================

class TripLeg_IntersectingEdge::_Internal {
 public:
  static const ::valhalla::TripSign& sign(const TripLeg_IntersectingEdge* msg);
};

const ::valhalla::TripSign&
TripLeg_IntersectingEdge::_Internal::sign(const TripLeg_IntersectingEdge* msg) {
  return *msg->_impl_.sign_;
}
void TripLeg_IntersectingEdge::clear_sign() {
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.IntersectingEdge)
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_IntersectingEdge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.has_begin_heading_){}
    , decltype(_impl_.has_prev_name_consistency_){}
    , decltype(_impl_.has_curr_name_consistency_){}
    , decltype(_impl_.has_driveability_){}
    , decltype(_impl_.has_cyclability_){}
    , decltype(_impl_.has_walkability_){}
    , decltype(_impl_.has_use_){}
    , decltype(_impl_.has_road_class_){}
    , decltype(_impl_.has_lane_count_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    _this->_impl_.sign_ = new ::valhalla::TripSign(*from._impl_.sign_);
  }
  clear_has_has_begin_heading();
  switch (from.has_begin_heading_case()) {
    case kBeginHeading: {
      _this->_internal_set_begin_heading(from._internal_begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  clear_has_has_prev_name_consistency();
  switch (from.has_prev_name_consistency_case()) {
    case kPrevNameConsistency: {
      _this->_internal_set_prev_name_consistency(from._internal_prev_name_consistency());
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  clear_has_has_curr_name_consistency();
  switch (from.has_curr_name_consistency_case()) {
    case kCurrNameConsistency: {
      _this->_internal_set_curr_name_consistency(from._internal_curr_name_consistency());
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  clear_has_has_driveability();
  switch (from.has_driveability_case()) {
    case kDriveability: {
      _this->_internal_set_driveability(from._internal_driveability());
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  clear_has_has_cyclability();
  switch (from.has_cyclability_case()) {
    case kCyclability: {
      _this->_internal_set_cyclability(from._internal_cyclability());
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  clear_has_has_walkability();
  switch (from.has_walkability_case()) {
    case kWalkability: {
      _this->_internal_set_walkability(from._internal_walkability());
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  clear_has_has_use();
  switch (from.has_use_case()) {
    case kUse: {
      _this->_internal_set_use(from._internal_use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  clear_has_has_road_class();
  switch (from.has_road_class_case()) {
    case kRoadClass: {
      _this->_internal_set_road_class(from._internal_road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  clear_has_has_lane_count();
  switch (from.has_lane_count_case()) {
    case kLaneCount: {
      _this->_internal_set_lane_count(from._internal_lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}

inline void TripLeg_IntersectingEdge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sign_){nullptr}
    , decltype(_impl_.has_begin_heading_){}
    , decltype(_impl_.has_prev_name_consistency_){}
    , decltype(_impl_.has_curr_name_consistency_){}
    , decltype(_impl_.has_driveability_){}
    , decltype(_impl_.has_cyclability_){}
    , decltype(_impl_.has_walkability_){}
    , decltype(_impl_.has_use_){}
    , decltype(_impl_.has_road_class_){}
    , decltype(_impl_.has_lane_count_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_begin_heading();
  clear_has_has_prev_name_consistency();
  clear_has_has_curr_name_consistency();
  clear_has_has_driveability();
  clear_has_has_cyclability();
  clear_has_has_walkability();
  clear_has_has_use();
  clear_has_has_road_class();
  clear_has_has_lane_count();
}

TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_IntersectingEdge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sign_;
  if (has_has_begin_heading()) {
    clear_has_begin_heading();
  }
  if (has_has_prev_name_consistency()) {
    clear_has_prev_name_consistency();
  }
  if (has_has_curr_name_consistency()) {
    clear_has_curr_name_consistency();
  }
  if (has_has_driveability()) {
    clear_has_driveability();
  }
  if (has_has_cyclability()) {
    clear_has_cyclability();
  }
  if (has_has_walkability()) {
    clear_has_walkability();
  }
  if (has_has_use()) {
    clear_has_use();
  }
  if (has_has_road_class()) {
    clear_has_road_class();
  }
  if (has_has_lane_count()) {
    clear_has_lane_count();
  }
}

void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_IntersectingEdge::clear_has_begin_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_begin_heading_case()) {
    case kBeginHeading: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_BEGIN_HEADING_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_prev_name_consistency() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_prev_name_consistency_case()) {
    case kPrevNameConsistency: {
      // No need to clear
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_curr_name_consistency() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_curr_name_consistency_case()) {
    case kCurrNameConsistency: {
      // No need to clear
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_driveability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_driveability_case()) {
    case kDriveability: {
      // No need to clear
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_DRIVEABILITY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_cyclability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_cyclability_case()) {
    case kCyclability: {
      // No need to clear
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_CYCLABILITY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_walkability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_walkability_case()) {
    case kWalkability: {
      // No need to clear
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_WALKABILITY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_use() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_use_case()) {
    case kUse: {
      // No need to clear
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_USE_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_road_class() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_road_class_case()) {
    case kRoadClass: {
      // No need to clear
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_ROAD_CLASS_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_lane_count() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch (has_lane_count_case()) {
    case kLaneCount: {
      // No need to clear
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_LANE_COUNT_NOT_SET;
}


void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
  clear_has_begin_heading();
  clear_has_prev_name_consistency();
  clear_has_curr_name_consistency();
  clear_has_driveability();
  clear_has_cyclability();
  clear_has_walkability();
  clear_has_use();
  clear_has_road_class();
  clear_has_lane_count();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_IntersectingEdge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 begin_heading = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_begin_heading(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool prev_name_consistency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_prev_name_consistency(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool curr_name_consistency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_curr_name_consistency(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability driveability = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_driveability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability cyclability = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cyclability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability walkability = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_walkability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Use use = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.RoadClass road_class = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 lane_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _internal_set_lane_count(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripSign sign = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_IntersectingEdge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.IntersectingEdge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 begin_heading = 1;
  if (_internal_has_begin_heading()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_heading(), target);
  }

  // bool prev_name_consistency = 2;
  if (_internal_has_prev_name_consistency()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_prev_name_consistency(), target);
  }

  // bool curr_name_consistency = 3;
  if (_internal_has_curr_name_consistency()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_curr_name_consistency(), target);
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (_internal_has_driveability()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_driveability(), target);
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (_internal_has_cyclability()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_cyclability(), target);
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (_internal_has_walkability()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_walkability(), target);
  }

  // .valhalla.TripLeg.Use use = 7;
  if (_internal_has_use()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_use(), target);
  }

  // .valhalla.RoadClass road_class = 8;
  if (_internal_has_road_class()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_road_class(), target);
  }

  // uint32 lane_count = 9;
  if (_internal_has_lane_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_lane_count(), target);
  }

  // .valhalla.TripSign sign = 10;
  if (this->_internal_has_sign()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sign(this),
        _Internal::sign(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.IntersectingEdge)
  return target;
}

size_t TripLeg_IntersectingEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripSign sign = 10;
  if (this->_internal_has_sign()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sign_);
  }

  switch (has_begin_heading_case()) {
    // uint32 begin_heading = 1;
    case kBeginHeading: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (has_prev_name_consistency_case()) {
    // bool prev_name_consistency = 2;
    case kPrevNameConsistency: {
      total_size += 1 + 1;
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (has_curr_name_consistency_case()) {
    // bool curr_name_consistency = 3;
    case kCurrNameConsistency: {
      total_size += 1 + 1;
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (has_driveability_case()) {
    // .valhalla.TripLeg.Traversability driveability = 4;
    case kDriveability: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_driveability());
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_cyclability_case()) {
    // .valhalla.TripLeg.Traversability cyclability = 5;
    case kCyclability: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cyclability());
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_walkability_case()) {
    // .valhalla.TripLeg.Traversability walkability = 6;
    case kWalkability: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_walkability());
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_use_case()) {
    // .valhalla.TripLeg.Use use = 7;
    case kUse: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (has_road_class_case()) {
    // .valhalla.RoadClass road_class = 8;
    case kRoadClass: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (has_lane_count_case()) {
    // uint32 lane_count = 9;
    case kLaneCount: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_IntersectingEdge*>(
      &from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
  TripLeg_IntersectingEdge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sign()) {
    _this->_internal_mutable_sign()->::valhalla::TripSign::MergeFrom(
        from._internal_sign());
  }
  switch (from.has_begin_heading_case()) {
    case kBeginHeading: {
      _this->_internal_set_begin_heading(from._internal_begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (from.has_prev_name_consistency_case()) {
    case kPrevNameConsistency: {
      _this->_internal_set_prev_name_consistency(from._internal_prev_name_consistency());
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (from.has_curr_name_consistency_case()) {
    case kCurrNameConsistency: {
      _this->_internal_set_curr_name_consistency(from._internal_curr_name_consistency());
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (from.has_driveability_case()) {
    case kDriveability: {
      _this->_internal_set_driveability(from._internal_driveability());
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_cyclability_case()) {
    case kCyclability: {
      _this->_internal_set_cyclability(from._internal_cyclability());
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_walkability_case()) {
    case kWalkability: {
      _this->_internal_set_walkability(from._internal_walkability());
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_case()) {
    case kUse: {
      _this->_internal_set_use(from._internal_use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (from.has_road_class_case()) {
    case kRoadClass: {
      _this->_internal_set_road_class(from._internal_road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (from.has_lane_count_case()) {
    case kLaneCount: {
      _this->_internal_set_lane_count(from._internal_lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_IntersectingEdge::IsInitialized() const {
  return true;
}

void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.sign_, other->_impl_.sign_);
  swap(_impl_.has_begin_heading_, other->_impl_.has_begin_heading_);
  swap(_impl_.has_prev_name_consistency_, other->_impl_.has_prev_name_consistency_);
  swap(_impl_.has_curr_name_consistency_, other->_impl_.has_curr_name_consistency_);
  swap(_impl_.has_driveability_, other->_impl_.has_driveability_);
  swap(_impl_.has_cyclability_, other->_impl_.has_cyclability_);
  swap(_impl_.has_walkability_, other->_impl_.has_walkability_);
  swap(_impl_.has_use_, other->_impl_.has_use_);
  swap(_impl_.has_road_class_, other->_impl_.has_road_class_);
  swap(_impl_.has_lane_count_, other->_impl_.has_lane_count_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
}

std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}


// ===================================================================

class TripLeg_Cost::_Internal {
 public:
};

TripLeg_Cost::TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Cost)
}
TripLeg_Cost::TripLeg_Cost(const TripLeg_Cost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Cost* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_seconds_){}
    , decltype(_impl_.has_cost_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_seconds();
  switch (from.has_seconds_case()) {
    case kSeconds: {
      _this->_internal_set_seconds(from._internal_seconds());
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  clear_has_has_cost();
  switch (from.has_cost_case()) {
    case kCost: {
      _this->_internal_set_cost(from._internal_cost());
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Cost)
}

inline void TripLeg_Cost::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_seconds_){}
    , decltype(_impl_.has_cost_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_seconds();
  clear_has_has_cost();
}

TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Cost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_seconds()) {
    clear_has_seconds();
  }
  if (has_has_cost()) {
    clear_has_cost();
  }
}

void TripLeg_Cost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Cost::clear_has_seconds() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Cost)
  switch (has_seconds_case()) {
    case kSeconds: {
      // No need to clear
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_SECONDS_NOT_SET;
}

void TripLeg_Cost::clear_has_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Cost)
  switch (has_cost_case()) {
    case kCost: {
      // No need to clear
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_COST_NOT_SET;
}


void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_seconds();
  clear_has_cost();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Cost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _internal_set_cost(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Cost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Cost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double seconds = 1;
  if (_internal_has_seconds()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_seconds(), target);
  }

  // double cost = 2;
  if (_internal_has_cost()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Cost)
  return target;
}

size_t TripLeg_Cost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_seconds_case()) {
    // double seconds = 1;
    case kSeconds: {
      total_size += 1 + 8;
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  switch (has_cost_case()) {
    // double cost = 2;
    case kCost: {
      total_size += 1 + 8;
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Cost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Cost*>(
      &from));
}

void TripLeg_Cost::MergeFrom(const TripLeg_Cost& from) {
  TripLeg_Cost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_seconds_case()) {
    case kSeconds: {
      _this->_internal_set_seconds(from._internal_seconds());
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  switch (from.has_cost_case()) {
    case kCost: {
      _this->_internal_set_cost(from._internal_cost());
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Cost::IsInitialized() const {
  return true;
}

void TripLeg_Cost::InternalSwap(TripLeg_Cost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_seconds_, other->_impl_.has_seconds_);
  swap(_impl_.has_cost_, other->_impl_.has_cost_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string TripLeg_Cost::GetTypeName() const {
  return "valhalla.TripLeg.Cost";
}


// ===================================================================

class TripLeg_PathCost::_Internal {
 public:
  static const ::valhalla::TripLeg_Cost& elapsed_cost(const TripLeg_PathCost* msg);
  static const ::valhalla::TripLeg_Cost& transition_cost(const TripLeg_PathCost* msg);
};

const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::elapsed_cost(const TripLeg_PathCost* msg) {
  return *msg->_impl_.elapsed_cost_;
}
const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::transition_cost(const TripLeg_PathCost* msg) {
  return *msg->_impl_.transition_cost_;
}
TripLeg_PathCost::TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.PathCost)
}
TripLeg_PathCost::TripLeg_PathCost(const TripLeg_PathCost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_PathCost* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.elapsed_cost_){nullptr}
    , decltype(_impl_.transition_cost_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_elapsed_cost()) {
    _this->_impl_.elapsed_cost_ = new ::valhalla::TripLeg_Cost(*from._impl_.elapsed_cost_);
  }
  if (from._internal_has_transition_cost()) {
    _this->_impl_.transition_cost_ = new ::valhalla::TripLeg_Cost(*from._impl_.transition_cost_);
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}

inline void TripLeg_PathCost::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.elapsed_cost_){nullptr}
    , decltype(_impl_.transition_cost_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_PathCost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.elapsed_cost_;
  if (this != internal_default_instance()) delete _impl_.transition_cost_;
}

void TripLeg_PathCost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.elapsed_cost_ != nullptr) {
    delete _impl_.elapsed_cost_;
  }
  _impl_.elapsed_cost_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transition_cost_ != nullptr) {
    delete _impl_.transition_cost_;
  }
  _impl_.transition_cost_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_PathCost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.TripLeg.Cost elapsed_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_elapsed_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Cost transition_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transition_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_PathCost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.PathCost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->_internal_has_elapsed_cost()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::elapsed_cost(this),
        _Internal::elapsed_cost(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->_internal_has_transition_cost()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transition_cost(this),
        _Internal::transition_cost(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.PathCost)
  return target;
}

size_t TripLeg_PathCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->_internal_has_elapsed_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.elapsed_cost_);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->_internal_has_transition_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transition_cost_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_PathCost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_PathCost*>(
      &from));
}

void TripLeg_PathCost::MergeFrom(const TripLeg_PathCost& from) {
  TripLeg_PathCost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_elapsed_cost()) {
    _this->_internal_mutable_elapsed_cost()->::valhalla::TripLeg_Cost::MergeFrom(
        from._internal_elapsed_cost());
  }
  if (from._internal_has_transition_cost()) {
    _this->_internal_mutable_transition_cost()->::valhalla::TripLeg_Cost::MergeFrom(
        from._internal_transition_cost());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_PathCost::IsInitialized() const {
  return true;
}

void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_)
      + sizeof(TripLeg_PathCost::_impl_.transition_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_)>(
          reinterpret_cast<char*>(&_impl_.elapsed_cost_),
          reinterpret_cast<char*>(&other->_impl_.elapsed_cost_));
}

std::string TripLeg_PathCost::GetTypeName() const {
  return "valhalla.TripLeg.PathCost";
}


// ===================================================================

class TripLeg_Node::_Internal {
 public:
  static const ::valhalla::TripLeg_Edge& edge(const TripLeg_Node* msg);
  static const ::valhalla::TransitPlatformInfo& transit_platform_info(const TripLeg_Node* msg);
  static const ::valhalla::TransitStationInfo& transit_station_info(const TripLeg_Node* msg);
  static const ::valhalla::TransitEgressInfo& transit_egress_info(const TripLeg_Node* msg);
  static const ::valhalla::TripLeg_PathCost& cost(const TripLeg_Node* msg);
  static const ::valhalla::BikeShareStationInfo& bss_info(const TripLeg_Node* msg);
};

const ::valhalla::TripLeg_Edge&
TripLeg_Node::_Internal::edge(const TripLeg_Node* msg) {
  return *msg->_impl_.edge_;
}
const ::valhalla::TransitPlatformInfo&
TripLeg_Node::_Internal::transit_platform_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_platform_info_;
}
const ::valhalla::TransitStationInfo&
TripLeg_Node::_Internal::transit_station_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_station_info_;
}
const ::valhalla::TransitEgressInfo&
TripLeg_Node::_Internal::transit_egress_info(const TripLeg_Node* msg) {
  return *msg->_impl_.transit_egress_info_;
}
const ::valhalla::TripLeg_PathCost&
TripLeg_Node::_Internal::cost(const TripLeg_Node* msg) {
  return *msg->_impl_.cost_;
}
const ::valhalla::BikeShareStationInfo&
TripLeg_Node::_Internal::bss_info(const TripLeg_Node* msg) {
  return *msg->_impl_.bss_info_;
}
void TripLeg_Node::clear_transit_platform_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_platform_info_ != nullptr) {
    delete _impl_.transit_platform_info_;
  }
  _impl_.transit_platform_info_ = nullptr;
}
void TripLeg_Node::clear_transit_station_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_station_info_ != nullptr) {
    delete _impl_.transit_station_info_;
  }
  _impl_.transit_station_info_ = nullptr;
}
void TripLeg_Node::clear_transit_egress_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.transit_egress_info_ != nullptr) {
    delete _impl_.transit_egress_info_;
  }
  _impl_.transit_egress_info_ = nullptr;
}
void TripLeg_Node::clear_bss_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.bss_info_ != nullptr) {
    delete _impl_.bss_info_;
  }
  _impl_.bss_info_ = nullptr;
}
TripLeg_Node::TripLeg_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Node)
}
TripLeg_Node::TripLeg_Node(const TripLeg_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.intersecting_edge_){from._impl_.intersecting_edge_}
    , decltype(_impl_.recosts_){from._impl_.recosts_}
    , decltype(_impl_.edge_){nullptr}
    , decltype(_impl_.transit_platform_info_){nullptr}
    , decltype(_impl_.transit_station_info_){nullptr}
    , decltype(_impl_.transit_egress_info_){nullptr}
    , decltype(_impl_.cost_){nullptr}
    , decltype(_impl_.bss_info_){nullptr}
    , decltype(_impl_.has_admin_index_){}
    , decltype(_impl_.has_type_){}
    , decltype(_impl_.has_fork_){}
    , decltype(_impl_.has_time_zone_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_edge()) {
    _this->_impl_.edge_ = new ::valhalla::TripLeg_Edge(*from._impl_.edge_);
  }
  if (from._internal_has_transit_platform_info()) {
    _this->_impl_.transit_platform_info_ = new ::valhalla::TransitPlatformInfo(*from._impl_.transit_platform_info_);
  }
  if (from._internal_has_transit_station_info()) {
    _this->_impl_.transit_station_info_ = new ::valhalla::TransitStationInfo(*from._impl_.transit_station_info_);
  }
  if (from._internal_has_transit_egress_info()) {
    _this->_impl_.transit_egress_info_ = new ::valhalla::TransitEgressInfo(*from._impl_.transit_egress_info_);
  }
  if (from._internal_has_cost()) {
    _this->_impl_.cost_ = new ::valhalla::TripLeg_PathCost(*from._impl_.cost_);
  }
  if (from._internal_has_bss_info()) {
    _this->_impl_.bss_info_ = new ::valhalla::BikeShareStationInfo(*from._impl_.bss_info_);
  }
  clear_has_has_admin_index();
  switch (from.has_admin_index_case()) {
    case kAdminIndex: {
      _this->_internal_set_admin_index(from._internal_admin_index());
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_type();
  switch (from.has_type_case()) {
    case kType: {
      _this->_internal_set_type(from._internal_type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_has_fork();
  switch (from.has_fork_case()) {
    case kFork: {
      _this->_internal_set_fork(from._internal_fork());
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  clear_has_has_time_zone();
  switch (from.has_time_zone_case()) {
    case kTimeZone: {
      _this->_internal_set_time_zone(from._internal_time_zone());
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}

inline void TripLeg_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.intersecting_edge_){arena}
    , decltype(_impl_.recosts_){arena}
    , decltype(_impl_.edge_){nullptr}
    , decltype(_impl_.transit_platform_info_){nullptr}
    , decltype(_impl_.transit_station_info_){nullptr}
    , decltype(_impl_.transit_egress_info_){nullptr}
    , decltype(_impl_.cost_){nullptr}
    , decltype(_impl_.bss_info_){nullptr}
    , decltype(_impl_.has_admin_index_){}
    , decltype(_impl_.has_type_){}
    , decltype(_impl_.has_fork_){}
    , decltype(_impl_.has_time_zone_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_admin_index();
  clear_has_has_type();
  clear_has_has_fork();
  clear_has_has_time_zone();
}

TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.intersecting_edge_.~RepeatedPtrField();
  _impl_.recosts_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.edge_;
  if (this != internal_default_instance()) delete _impl_.transit_platform_info_;
  if (this != internal_default_instance()) delete _impl_.transit_station_info_;
  if (this != internal_default_instance()) delete _impl_.transit_egress_info_;
  if (this != internal_default_instance()) delete _impl_.cost_;
  if (this != internal_default_instance()) delete _impl_.bss_info_;
  if (has_has_admin_index()) {
    clear_has_admin_index();
  }
  if (has_has_type()) {
    clear_has_type();
  }
  if (has_has_fork()) {
    clear_has_fork();
  }
  if (has_has_time_zone()) {
    clear_has_time_zone();
  }
}

void TripLeg_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Node::clear_has_admin_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch (has_admin_index_case()) {
    case kAdminIndex: {
      // No need to clear
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_ADMIN_INDEX_NOT_SET;
}

void TripLeg_Node::clear_has_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch (has_type_case()) {
    case kType: {
      // No need to clear
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_TYPE_NOT_SET;
}

void TripLeg_Node::clear_has_fork() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch (has_fork_case()) {
    case kFork: {
      // No need to clear
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_FORK_NOT_SET;
}

void TripLeg_Node::clear_has_time_zone() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch (has_time_zone_case()) {
    case kTimeZone: {
      _impl_.has_time_zone_.time_zone_.Destroy();
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_TIME_ZONE_NOT_SET;
}


void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intersecting_edge_.Clear();
  _impl_.recosts_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.edge_ != nullptr) {
    delete _impl_.edge_;
  }
  _impl_.edge_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_platform_info_ != nullptr) {
    delete _impl_.transit_platform_info_;
  }
  _impl_.transit_platform_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_station_info_ != nullptr) {
    delete _impl_.transit_station_info_;
  }
  _impl_.transit_station_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.transit_egress_info_ != nullptr) {
    delete _impl_.transit_egress_info_;
  }
  _impl_.transit_egress_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.cost_ != nullptr) {
    delete _impl_.cost_;
  }
  _impl_.cost_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.bss_info_ != nullptr) {
    delete _impl_.bss_info_;
  }
  _impl_.bss_info_ = nullptr;
  clear_has_admin_index();
  clear_has_type();
  clear_has_fork();
  clear_has_time_zone();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.TripLeg.Edge edge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_intersecting_edge(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 admin_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_admin_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Node.Type type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::valhalla::TripLeg_Node_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // bool fork = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_fork(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitPlatformInfo transit_platform_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_platform_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitStationInfo transit_station_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_station_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitEgressInfo transit_egress_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_egress_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string time_zone = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_time_zone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.PathCost cost = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.PathCost recosts = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_recosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BikeShareStationInfo bss_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bss_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.TripLeg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::edge(this),
        _Internal::edge(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_intersecting_edge_size()); i < n; i++) {
    const auto& repfield = this->_internal_intersecting_edge(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 admin_index = 3;
  if (_internal_has_admin_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_admin_index(), target);
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // bool fork = 5;
  if (_internal_has_fork()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_fork(), target);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->_internal_has_transit_platform_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transit_platform_info(this),
        _Internal::transit_platform_info(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->_internal_has_transit_station_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::transit_station_info(this),
        _Internal::transit_station_info(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->_internal_has_transit_egress_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::transit_egress_info(this),
        _Internal::transit_egress_info(this).GetCachedSize(), target, stream);
  }

  // string time_zone = 11;
  if (_internal_has_time_zone()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_time_zone().data(), static_cast<int>(this->_internal_time_zone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Node.time_zone");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_time_zone(), target);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (this->_internal_has_cost()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::cost(this),
        _Internal::cost(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_recosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_recosts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->_internal_has_bss_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::bss_info(this),
        _Internal::bss_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Node)
  return target;
}

size_t TripLeg_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1UL * this->_internal_intersecting_edge_size();
  for (const auto& msg : this->_impl_.intersecting_edge_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  total_size += 1UL * this->_internal_recosts_size();
  for (const auto& msg : this->_impl_.recosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .valhalla.TripLeg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.edge_);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->_internal_has_transit_platform_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_platform_info_);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->_internal_has_transit_station_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_station_info_);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->_internal_has_transit_egress_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transit_egress_info_);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (this->_internal_has_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cost_);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->_internal_has_bss_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bss_info_);
  }

  switch (has_admin_index_case()) {
    // uint32 admin_index = 3;
    case kAdminIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_admin_index());
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_type_case()) {
    // .valhalla.TripLeg.Node.Type type = 4;
    case kType: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_fork_case()) {
    // bool fork = 5;
    case kFork: {
      total_size += 1 + 1;
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  switch (has_time_zone_case()) {
    // string time_zone = 11;
    case kTimeZone: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time_zone());
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Node*>(
      &from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
  TripLeg_Node* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.intersecting_edge_.MergeFrom(from._impl_.intersecting_edge_);
  _this->_impl_.recosts_.MergeFrom(from._impl_.recosts_);
  if (from._internal_has_edge()) {
    _this->_internal_mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(
        from._internal_edge());
  }
  if (from._internal_has_transit_platform_info()) {
    _this->_internal_mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(
        from._internal_transit_platform_info());
  }
  if (from._internal_has_transit_station_info()) {
    _this->_internal_mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(
        from._internal_transit_station_info());
  }
  if (from._internal_has_transit_egress_info()) {
    _this->_internal_mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(
        from._internal_transit_egress_info());
  }
  if (from._internal_has_cost()) {
    _this->_internal_mutable_cost()->::valhalla::TripLeg_PathCost::MergeFrom(
        from._internal_cost());
  }
  if (from._internal_has_bss_info()) {
    _this->_internal_mutable_bss_info()->::valhalla::BikeShareStationInfo::MergeFrom(
        from._internal_bss_info());
  }
  switch (from.has_admin_index_case()) {
    case kAdminIndex: {
      _this->_internal_set_admin_index(from._internal_admin_index());
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_type_case()) {
    case kType: {
      _this->_internal_set_type(from._internal_type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_fork_case()) {
    case kFork: {
      _this->_internal_set_fork(from._internal_fork());
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  switch (from.has_time_zone_case()) {
    case kTimeZone: {
      _this->_internal_set_time_zone(from._internal_time_zone());
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Node::IsInitialized() const {
  return true;
}

void TripLeg_Node::InternalSwap(TripLeg_Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.intersecting_edge_.InternalSwap(&other->_impl_.intersecting_edge_);
  _impl_.recosts_.InternalSwap(&other->_impl_.recosts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.bss_info_)
      + sizeof(TripLeg_Node::_impl_.bss_info_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_)>(
          reinterpret_cast<char*>(&_impl_.edge_),
          reinterpret_cast<char*>(&other->_impl_.edge_));
  swap(_impl_.has_admin_index_, other->_impl_.has_admin_index_);
  swap(_impl_.has_type_, other->_impl_.has_type_);
  swap(_impl_.has_fork_, other->_impl_.has_fork_);
  swap(_impl_.has_time_zone_, other->_impl_.has_time_zone_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
}

std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}


// ===================================================================

class TripLeg_Admin::_Internal {
 public:
};

TripLeg_Admin::TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Admin)
}
TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Admin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_country_code_){}
    , decltype(_impl_.has_country_text_){}
    , decltype(_impl_.has_state_code_){}
    , decltype(_impl_.has_state_text_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_country_code();
  switch (from.has_country_code_case()) {
    case kCountryCode: {
      _this->_internal_set_country_code(from._internal_country_code());
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  clear_has_has_country_text();
  switch (from.has_country_text_case()) {
    case kCountryText: {
      _this->_internal_set_country_text(from._internal_country_text());
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  clear_has_has_state_code();
  switch (from.has_state_code_case()) {
    case kStateCode: {
      _this->_internal_set_state_code(from._internal_state_code());
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  clear_has_has_state_text();
  switch (from.has_state_text_case()) {
    case kStateText: {
      _this->_internal_set_state_text(from._internal_state_text());
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}

inline void TripLeg_Admin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_country_code_){}
    , decltype(_impl_.has_country_text_){}
    , decltype(_impl_.has_state_code_){}
    , decltype(_impl_.has_state_text_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_country_code();
  clear_has_has_country_text();
  clear_has_has_state_code();
  clear_has_has_state_text();
}

TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Admin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_country_code()) {
    clear_has_country_code();
  }
  if (has_has_country_text()) {
    clear_has_country_text();
  }
  if (has_has_state_code()) {
    clear_has_state_code();
  }
  if (has_has_state_text()) {
    clear_has_state_text();
  }
}

void TripLeg_Admin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Admin::clear_has_country_code() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch (has_country_code_case()) {
    case kCountryCode: {
      _impl_.has_country_code_.country_code_.Destroy();
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_COUNTRY_CODE_NOT_SET;
}

void TripLeg_Admin::clear_has_country_text() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch (has_country_text_case()) {
    case kCountryText: {
      _impl_.has_country_text_.country_text_.Destroy();
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_COUNTRY_TEXT_NOT_SET;
}

void TripLeg_Admin::clear_has_state_code() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch (has_state_code_case()) {
    case kStateCode: {
      _impl_.has_state_code_.state_code_.Destroy();
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_STATE_CODE_NOT_SET;
}

void TripLeg_Admin::clear_has_state_text() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch (has_state_text_case()) {
    case kStateText: {
      _impl_.has_state_text_.state_text_.Destroy();
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_STATE_TEXT_NOT_SET;
}


void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_country_code();
  clear_has_country_text();
  clear_has_state_code();
  clear_has_state_text();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Admin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string country_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string country_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_country_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string state_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_state_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string state_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_state_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Admin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Admin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string country_code = 1;
  if (_internal_has_country_code()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_country_code().data(), static_cast<int>(this->_internal_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_code");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country_code(), target);
  }

  // string country_text = 2;
  if (_internal_has_country_text()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_country_text().data(), static_cast<int>(this->_internal_country_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_country_text(), target);
  }

  // string state_code = 3;
  if (_internal_has_state_code()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state_code().data(), static_cast<int>(this->_internal_state_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_state_code(), target);
  }

  // string state_text = 4;
  if (_internal_has_state_text()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state_text().data(), static_cast<int>(this->_internal_state_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_text");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_state_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Admin)
  return target;
}

size_t TripLeg_Admin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_country_code_case()) {
    // string country_code = 1;
    case kCountryCode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_code());
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  switch (has_country_text_case()) {
    // string country_text = 2;
    case kCountryText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_text());
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  switch (has_state_code_case()) {
    // string state_code = 3;
    case kStateCode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state_code());
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  switch (has_state_text_case()) {
    // string state_text = 4;
    case kStateText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state_text());
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Admin*>(
      &from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
  TripLeg_Admin* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_country_code_case()) {
    case kCountryCode: {
      _this->_internal_set_country_code(from._internal_country_code());
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  switch (from.has_country_text_case()) {
    case kCountryText: {
      _this->_internal_set_country_text(from._internal_country_text());
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  switch (from.has_state_code_case()) {
    case kStateCode: {
      _this->_internal_set_state_code(from._internal_state_code());
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  switch (from.has_state_text_case()) {
    case kStateText: {
      _this->_internal_set_state_text(from._internal_state_text());
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Admin::IsInitialized() const {
  return true;
}

void TripLeg_Admin::InternalSwap(TripLeg_Admin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_country_code_, other->_impl_.has_country_code_);
  swap(_impl_.has_country_text_, other->_impl_.has_country_text_);
  swap(_impl_.has_state_code_, other->_impl_.has_state_code_);
  swap(_impl_.has_state_text_, other->_impl_.has_state_text_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
}

std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}


// ===================================================================

class TripLeg_ShapeAttributes::_Internal {
 public:
};

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ShapeAttributes)
}
TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_ShapeAttributes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){from._impl_.time_}
    , /*decltype(_impl_._time_cached_byte_size_)*/{0}
    , decltype(_impl_.length_){from._impl_.length_}
    , /*decltype(_impl_._length_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_){from._impl_.speed_}
    , /*decltype(_impl_._speed_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_limit_){from._impl_.speed_limit_}
    , /*decltype(_impl_._speed_limit_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}

inline void TripLeg_ShapeAttributes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){arena}
    , /*decltype(_impl_._time_cached_byte_size_)*/{0}
    , decltype(_impl_.length_){arena}
    , /*decltype(_impl_._length_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_){arena}
    , /*decltype(_impl_._speed_cached_byte_size_)*/{0}
    , decltype(_impl_.speed_limit_){arena}
    , /*decltype(_impl_._speed_limit_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_ShapeAttributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.time_.~RepeatedField();
  _impl_.length_.~RepeatedField();
  _impl_.speed_.~RepeatedField();
  _impl_.speed_limit_.~RepeatedField();
}

void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.time_.Clear();
  _impl_.length_.Clear();
  _impl_.speed_.Clear();
  _impl_.speed_limit_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_ShapeAttributes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 time = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_time(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_time(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 length = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_length(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 speed = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_speed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 speed_limit = 5 [packed = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed_limit(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_speed_limit(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_ShapeAttributes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ShapeAttributes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    int byte_size = _impl_._time_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_time(), byte_size, target);
    }
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int byte_size = _impl_._length_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_length(), byte_size, target);
    }
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int byte_size = _impl_._speed_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_speed(), byte_size, target);
    }
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    int byte_size = _impl_._speed_limit_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          5, _internal_speed_limit(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ShapeAttributes)
  return target;
}

size_t TripLeg_ShapeAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.time_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._time_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 length = 2 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.length_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._length_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.speed_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._speed_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.speed_limit_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._speed_limit_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_ShapeAttributes*>(
      &from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
  TripLeg_ShapeAttributes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.time_.MergeFrom(from._impl_.time_);
  _this->_impl_.length_.MergeFrom(from._impl_.length_);
  _this->_impl_.speed_.MergeFrom(from._impl_.speed_);
  _this->_impl_.speed_limit_.MergeFrom(from._impl_.speed_limit_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_ShapeAttributes::IsInitialized() const {
  return true;
}

void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.time_.InternalSwap(&other->_impl_.time_);
  _impl_.length_.InternalSwap(&other->_impl_.length_);
  _impl_.speed_.InternalSwap(&other->_impl_.speed_);
  _impl_.speed_limit_.InternalSwap(&other->_impl_.speed_limit_);
}

std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}


// ===================================================================

class TripLeg_Incident::_Internal {
 public:
  static const ::valhalla::IncidentsTile_Metadata& metadata(const TripLeg_Incident* msg);
};

const ::valhalla::IncidentsTile_Metadata&
TripLeg_Incident::_Internal::metadata(const TripLeg_Incident* msg) {
  return *msg->_impl_.metadata_;
}
void TripLeg_Incident::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
TripLeg_Incident::TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Incident)
}
TripLeg_Incident::TripLeg_Incident(const TripLeg_Incident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Incident* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::valhalla::IncidentsTile_Metadata(*from._impl_.metadata_);
  }
  clear_has_has_begin_shape_index();
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_shape_index();
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}

inline void TripLeg_Incident::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
}

TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Incident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
}

void TripLeg_Incident::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Incident::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Incident)
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Incident::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Incident)
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Incident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.IncidentsTile.Metadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_shape_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Incident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Incident)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->_internal_has_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // uint32 begin_shape_index = 3;
  if (_internal_has_begin_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 4;
  if (_internal_has_end_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Incident)
  return target;
}

size_t TripLeg_Incident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->_internal_has_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  switch (has_begin_shape_index_case()) {
    // uint32 begin_shape_index = 3;
    case kBeginShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // uint32 end_shape_index = 4;
    case kEndShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Incident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Incident*>(
      &from));
}

void TripLeg_Incident::MergeFrom(const TripLeg_Incident& from) {
  TripLeg_Incident* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::valhalla::IncidentsTile_Metadata::MergeFrom(
        from._internal_metadata());
  }
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Incident::IsInitialized() const {
  return true;
}

void TripLeg_Incident::InternalSwap(TripLeg_Incident* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
  swap(_impl_.has_begin_shape_index_, other->_impl_.has_begin_shape_index_);
  swap(_impl_.has_end_shape_index_, other->_impl_.has_end_shape_index_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string TripLeg_Incident::GetTypeName() const {
  return "valhalla.TripLeg.Incident";
}


// ===================================================================

class TripLeg_Closure::_Internal {
 public:
};

TripLeg_Closure::TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Closure)
}
TripLeg_Closure::TripLeg_Closure(const TripLeg_Closure& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg_Closure* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_begin_shape_index();
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_shape_index();
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}

inline void TripLeg_Closure::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.has_begin_shape_index_){}
    , decltype(_impl_.has_end_shape_index_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
}

TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg_Closure::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
}

void TripLeg_Closure::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg_Closure::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Closure::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Closure::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 begin_shape_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Closure::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Closure)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 begin_shape_index = 1;
  if (_internal_has_begin_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 2;
  if (_internal_has_end_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Closure)
  return target;
}

size_t TripLeg_Closure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_begin_shape_index_case()) {
    // uint32 begin_shape_index = 1;
    case kBeginShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // uint32 end_shape_index = 2;
    case kEndShapeIndex: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Closure::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg_Closure*>(
      &from));
}

void TripLeg_Closure::MergeFrom(const TripLeg_Closure& from) {
  TripLeg_Closure* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _this->_internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _this->_internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Closure::IsInitialized() const {
  return true;
}

void TripLeg_Closure::InternalSwap(TripLeg_Closure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_begin_shape_index_, other->_impl_.has_begin_shape_index_);
  swap(_impl_.has_end_shape_index_, other->_impl_.has_end_shape_index_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string TripLeg_Closure::GetTypeName() const {
  return "valhalla.TripLeg.Closure";
}


// ===================================================================

class TripLeg::_Internal {
 public:
  static const ::valhalla::BoundingBox& bbox(const TripLeg* msg);
  static const ::valhalla::TripLeg_ShapeAttributes& shape_attributes(const TripLeg* msg);
};

const ::valhalla::BoundingBox&
TripLeg::_Internal::bbox(const TripLeg* msg) {
  return *msg->_impl_.bbox_;
}
const ::valhalla::TripLeg_ShapeAttributes&
TripLeg::_Internal::shape_attributes(const TripLeg* msg) {
  return *msg->_impl_.shape_attributes_;
}
void TripLeg::clear_location() {
  _impl_.location_.Clear();
}
void TripLeg::clear_bbox() {
  if (GetArenaForAllocation() == nullptr && _impl_.bbox_ != nullptr) {
    delete _impl_.bbox_;
  }
  _impl_.bbox_ = nullptr;
}
TripLeg::TripLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg)
}
TripLeg::TripLeg(const TripLeg& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripLeg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){from._impl_.location_}
    , decltype(_impl_.node_){from._impl_.node_}
    , decltype(_impl_.admin_){from._impl_.admin_}
    , decltype(_impl_.incidents_){from._impl_.incidents_}
    , decltype(_impl_.algorithms_){from._impl_.algorithms_}
    , decltype(_impl_.closures_){from._impl_.closures_}
    , decltype(_impl_.bbox_){nullptr}
    , decltype(_impl_.shape_attributes_){nullptr}
    , decltype(_impl_.has_osm_changeset_){}
    , decltype(_impl_.has_trip_id_){}
    , decltype(_impl_.has_leg_id_){}
    , decltype(_impl_.has_leg_count_){}
    , decltype(_impl_.has_shape_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_bbox()) {
    _this->_impl_.bbox_ = new ::valhalla::BoundingBox(*from._impl_.bbox_);
  }
  if (from._internal_has_shape_attributes()) {
    _this->_impl_.shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes(*from._impl_.shape_attributes_);
  }
  clear_has_has_osm_changeset();
  switch (from.has_osm_changeset_case()) {
    case kOsmChangeset: {
      _this->_internal_set_osm_changeset(from._internal_osm_changeset());
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  clear_has_has_trip_id();
  switch (from.has_trip_id_case()) {
    case kTripId: {
      _this->_internal_set_trip_id(from._internal_trip_id());
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_leg_id();
  switch (from.has_leg_id_case()) {
    case kLegId: {
      _this->_internal_set_leg_id(from._internal_leg_id());
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  clear_has_has_leg_count();
  switch (from.has_leg_count_case()) {
    case kLegCount: {
      _this->_internal_set_leg_count(from._internal_leg_count());
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  clear_has_has_shape();
  switch (from.has_shape_case()) {
    case kShape: {
      _this->_internal_set_shape(from._internal_shape());
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}

inline void TripLeg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){arena}
    , decltype(_impl_.node_){arena}
    , decltype(_impl_.admin_){arena}
    , decltype(_impl_.incidents_){arena}
    , decltype(_impl_.algorithms_){arena}
    , decltype(_impl_.closures_){arena}
    , decltype(_impl_.bbox_){nullptr}
    , decltype(_impl_.shape_attributes_){nullptr}
    , decltype(_impl_.has_osm_changeset_){}
    , decltype(_impl_.has_trip_id_){}
    , decltype(_impl_.has_leg_id_){}
    , decltype(_impl_.has_leg_count_){}
    , decltype(_impl_.has_shape_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_has_osm_changeset();
  clear_has_has_trip_id();
  clear_has_has_leg_id();
  clear_has_has_leg_count();
  clear_has_has_shape();
}

TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripLeg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.location_.~RepeatedPtrField();
  _impl_.node_.~RepeatedPtrField();
  _impl_.admin_.~RepeatedPtrField();
  _impl_.incidents_.~RepeatedPtrField();
  _impl_.algorithms_.~RepeatedPtrField();
  _impl_.closures_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.bbox_;
  if (this != internal_default_instance()) delete _impl_.shape_attributes_;
  if (has_has_osm_changeset()) {
    clear_has_osm_changeset();
  }
  if (has_has_trip_id()) {
    clear_has_trip_id();
  }
  if (has_has_leg_id()) {
    clear_has_leg_id();
  }
  if (has_has_leg_count()) {
    clear_has_leg_count();
  }
  if (has_has_shape()) {
    clear_has_shape();
  }
}

void TripLeg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripLeg::clear_has_osm_changeset() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch (has_osm_changeset_case()) {
    case kOsmChangeset: {
      // No need to clear
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_OSM_CHANGESET_NOT_SET;
}

void TripLeg::clear_has_trip_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch (has_trip_id_case()) {
    case kTripId: {
      // No need to clear
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_TRIP_ID_NOT_SET;
}

void TripLeg::clear_has_leg_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch (has_leg_id_case()) {
    case kLegId: {
      // No need to clear
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_LEG_ID_NOT_SET;
}

void TripLeg::clear_has_leg_count() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch (has_leg_count_case()) {
    case kLegCount: {
      // No need to clear
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_LEG_COUNT_NOT_SET;
}

void TripLeg::clear_has_shape() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch (has_shape_case()) {
    case kShape: {
      _impl_.has_shape_.shape_.Destroy();
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_SHAPE_NOT_SET;
}


void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.location_.Clear();
  _impl_.node_.Clear();
  _impl_.admin_.Clear();
  _impl_.incidents_.Clear();
  _impl_.algorithms_.Clear();
  _impl_.closures_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.bbox_ != nullptr) {
    delete _impl_.bbox_;
  }
  _impl_.bbox_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.shape_attributes_ != nullptr) {
    delete _impl_.shape_attributes_;
  }
  _impl_.shape_attributes_ = nullptr;
  clear_has_osm_changeset();
  clear_has_trip_id();
  clear_has_leg_id();
  clear_has_leg_count();
  clear_has_shape();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 osm_changeset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_osm_changeset(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 trip_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_trip_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 leg_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_leg_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 leg_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_leg_count(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_location(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Node node = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Admin admin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_admin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string shape = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_shape();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BoundingBox bbox = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bbox(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_attributes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Incident incidents = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incidents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string algorithms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_algorithms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Closure closures = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_closures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 osm_changeset = 1;
  if (_internal_has_osm_changeset()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_osm_changeset(), target);
  }

  // uint64 trip_id = 2;
  if (_internal_has_trip_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_trip_id(), target);
  }

  // uint32 leg_id = 3;
  if (_internal_has_leg_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_leg_id(), target);
  }

  // uint32 leg_count = 4;
  if (_internal_has_leg_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_leg_count(), target);
  }

  // repeated .valhalla.Location location = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_location_size()); i < n; i++) {
    const auto& repfield = this->_internal_location(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_size()); i < n; i++) {
    const auto& repfield = this->_internal_node(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_admin_size()); i < n; i++) {
    const auto& repfield = this->_internal_admin(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string shape = 8;
  if (_internal_has_shape()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_shape().data(), static_cast<int>(this->_internal_shape().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.shape");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_shape(), target);
  }

  // .valhalla.BoundingBox bbox = 9;
  if (this->_internal_has_bbox()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::bbox(this),
        _Internal::bbox(this).GetCachedSize(), target, stream);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->_internal_has_shape_attributes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::shape_attributes(this),
        _Internal::shape_attributes(this).GetCachedSize(), target, stream);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incidents_size()); i < n; i++) {
    const auto& repfield = this->_internal_incidents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string algorithms = 12;
  for (int i = 0, n = this->_internal_algorithms_size(); i < n; i++) {
    const auto& s = this->_internal_algorithms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.algorithms");
    target = stream->WriteString(12, s, target);
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_closures_size()); i < n; i++) {
    const auto& repfield = this->_internal_closures(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg)
  return target;
}

size_t TripLeg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.Location location = 5;
  total_size += 1UL * this->_internal_location_size();
  for (const auto& msg : this->_impl_.location_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->_impl_.node_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1UL * this->_internal_admin_size();
  for (const auto& msg : this->_impl_.admin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  total_size += 1UL * this->_internal_incidents_size();
  for (const auto& msg : this->_impl_.incidents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string algorithms = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.algorithms_.size());
  for (int i = 0, n = _impl_.algorithms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.algorithms_.Get(i));
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  total_size += 1UL * this->_internal_closures_size();
  for (const auto& msg : this->_impl_.closures_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .valhalla.BoundingBox bbox = 9;
  if (this->_internal_has_bbox()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bbox_);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->_internal_has_shape_attributes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.shape_attributes_);
  }

  switch (has_osm_changeset_case()) {
    // uint64 osm_changeset = 1;
    case kOsmChangeset: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_osm_changeset());
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  switch (has_trip_id_case()) {
    // uint64 trip_id = 2;
    case kTripId: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_trip_id());
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  switch (has_leg_id_case()) {
    // uint32 leg_id = 3;
    case kLegId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leg_id());
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  switch (has_leg_count_case()) {
    // uint32 leg_count = 4;
    case kLegCount: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leg_count());
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  switch (has_shape_case()) {
    // string shape = 8;
    case kShape: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shape());
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripLeg*>(
      &from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
  TripLeg* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.location_.MergeFrom(from._impl_.location_);
  _this->_impl_.node_.MergeFrom(from._impl_.node_);
  _this->_impl_.admin_.MergeFrom(from._impl_.admin_);
  _this->_impl_.incidents_.MergeFrom(from._impl_.incidents_);
  _this->_impl_.algorithms_.MergeFrom(from._impl_.algorithms_);
  _this->_impl_.closures_.MergeFrom(from._impl_.closures_);
  if (from._internal_has_bbox()) {
    _this->_internal_mutable_bbox()->::valhalla::BoundingBox::MergeFrom(
        from._internal_bbox());
  }
  if (from._internal_has_shape_attributes()) {
    _this->_internal_mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(
        from._internal_shape_attributes());
  }
  switch (from.has_osm_changeset_case()) {
    case kOsmChangeset: {
      _this->_internal_set_osm_changeset(from._internal_osm_changeset());
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  switch (from.has_trip_id_case()) {
    case kTripId: {
      _this->_internal_set_trip_id(from._internal_trip_id());
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_leg_id_case()) {
    case kLegId: {
      _this->_internal_set_leg_id(from._internal_leg_id());
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_leg_count_case()) {
    case kLegCount: {
      _this->_internal_set_leg_count(from._internal_leg_count());
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  switch (from.has_shape_case()) {
    case kShape: {
      _this->_internal_set_shape(from._internal_shape());
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg::IsInitialized() const {
  return true;
}

void TripLeg::InternalSwap(TripLeg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.location_.InternalSwap(&other->_impl_.location_);
  _impl_.node_.InternalSwap(&other->_impl_.node_);
  _impl_.admin_.InternalSwap(&other->_impl_.admin_);
  _impl_.incidents_.InternalSwap(&other->_impl_.incidents_);
  _impl_.algorithms_.InternalSwap(&other->_impl_.algorithms_);
  _impl_.closures_.InternalSwap(&other->_impl_.closures_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_attributes_)
      + sizeof(TripLeg::_impl_.shape_attributes_)
      - PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_)>(
          reinterpret_cast<char*>(&_impl_.bbox_),
          reinterpret_cast<char*>(&other->_impl_.bbox_));
  swap(_impl_.has_osm_changeset_, other->_impl_.has_osm_changeset_);
  swap(_impl_.has_trip_id_, other->_impl_.has_trip_id_);
  swap(_impl_.has_leg_id_, other->_impl_.has_leg_id_);
  swap(_impl_.has_leg_count_, other->_impl_.has_leg_count_);
  swap(_impl_.has_shape_, other->_impl_.has_shape_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
}

std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}


// ===================================================================

class TripRoute::_Internal {
 public:
};

TripRoute::TripRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripRoute)
}
TripRoute::TripRoute(const TripRoute& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TripRoute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.legs_){from._impl_.legs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}

inline void TripRoute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.legs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripRoute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.legs_.~RepeatedPtrField();
}

void TripRoute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.legs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripRoute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripLeg legs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_legs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripRoute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripRoute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_legs_size()); i < n; i++) {
    const auto& repfield = this->_internal_legs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripRoute)
  return target;
}

size_t TripRoute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1UL * this->_internal_legs_size();
  for (const auto& msg : this->_impl_.legs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TripRoute*>(
      &from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
  TripRoute* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.legs_.MergeFrom(from._impl_.legs_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripRoute::IsInitialized() const {
  return true;
}

void TripRoute::InternalSwap(TripRoute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.legs_.InternalSwap(&other->_impl_.legs_);
}

std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}


// ===================================================================

class Trip::_Internal {
 public:
};

Trip::Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:valhalla.Trip)
}
Trip::Trip(const Trip& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Trip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.routes_){from._impl_.routes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}

inline void Trip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.routes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Trip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.routes_.~RepeatedPtrField();
}

void Trip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.routes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Trip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripRoute routes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_routes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Trip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_routes_size()); i < n; i++) {
    const auto& repfield = this->_internal_routes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Trip)
  return target;
}

size_t Trip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->_impl_.routes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Trip*>(
      &from));
}

void Trip::MergeFrom(const Trip& from) {
  Trip* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.routes_.MergeFrom(from._impl_.routes_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trip::IsInitialized() const {
  return true;
}

void Trip::InternalSwap(Trip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.routes_.InternalSwap(&other->_impl_.routes_);
}

std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_LaneConnectivity*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_LaneConnectivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_LaneConnectivity >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_TrafficSegment*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_TrafficSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_TrafficSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Restriction*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Restriction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Restriction >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Edge*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Edge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Edge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_IntersectingEdge*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_IntersectingEdge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_IntersectingEdge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Cost*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Cost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Cost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_PathCost*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_PathCost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_PathCost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Node*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Admin*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Admin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Admin >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_ShapeAttributes*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_ShapeAttributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_ShapeAttributes >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Incident*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Incident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Incident >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Closure*
Arena::CreateMaybeMessage< ::valhalla::TripLeg_Closure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Closure >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg*
Arena::CreateMaybeMessage< ::valhalla::TripLeg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripRoute*
Arena::CreateMaybeMessage< ::valhalla::TripRoute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripRoute >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Trip*
Arena::CreateMaybeMessage< ::valhalla::Trip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Trip >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
