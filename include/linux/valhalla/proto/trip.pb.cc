// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "trip.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

void protobuf_ShutdownFile_trip_2eproto() {
  delete TripLeg::default_instance_;
  delete TripLeg_LaneConnectivity::default_instance_;
  delete TripLeg_TrafficSegment::default_instance_;
  delete TripLeg_Restriction::default_instance_;
  delete TripLeg_Edge::default_instance_;
  delete TripLeg_IntersectingEdge::default_instance_;
  delete TripLeg_Cost::default_instance_;
  delete TripLeg_PathCost::default_instance_;
  delete TripLeg_Node::default_instance_;
  delete TripLeg_Admin::default_instance_;
  delete TripLeg_ShapeAttributes::default_instance_;
  delete TripLeg_Incident::default_instance_;
  delete TripLeg_Closure::default_instance_;
  delete TripRoute::default_instance_;
  delete Trip::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_trip_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_trip_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_trip_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::valhalla::protobuf_AddDesc_tripcommon_2eproto();
  ::valhalla::protobuf_AddDesc_sign_2eproto();
  ::valhalla::protobuf_AddDesc_incidents_2eproto();
  TripLeg::default_instance_ = new TripLeg();
  TripLeg_LaneConnectivity::default_instance_ = new TripLeg_LaneConnectivity();
  TripLeg_TrafficSegment::default_instance_ = new TripLeg_TrafficSegment();
  TripLeg_Restriction::default_instance_ = new TripLeg_Restriction();
  TripLeg_Edge::default_instance_ = new TripLeg_Edge();
  TripLeg_IntersectingEdge::default_instance_ = new TripLeg_IntersectingEdge();
  TripLeg_Cost::default_instance_ = new TripLeg_Cost();
  TripLeg_PathCost::default_instance_ = new TripLeg_PathCost();
  TripLeg_Node::default_instance_ = new TripLeg_Node();
  TripLeg_Admin::default_instance_ = new TripLeg_Admin();
  TripLeg_ShapeAttributes::default_instance_ = new TripLeg_ShapeAttributes();
  TripLeg_Incident::default_instance_ = new TripLeg_Incident();
  TripLeg_Closure::default_instance_ = new TripLeg_Closure();
  TripRoute::default_instance_ = new TripRoute();
  Trip::default_instance_ = new Trip();
  TripLeg::default_instance_->InitAsDefaultInstance();
  TripLeg_LaneConnectivity::default_instance_->InitAsDefaultInstance();
  TripLeg_TrafficSegment::default_instance_->InitAsDefaultInstance();
  TripLeg_Restriction::default_instance_->InitAsDefaultInstance();
  TripLeg_Edge::default_instance_->InitAsDefaultInstance();
  TripLeg_IntersectingEdge::default_instance_->InitAsDefaultInstance();
  TripLeg_Cost::default_instance_->InitAsDefaultInstance();
  TripLeg_PathCost::default_instance_->InitAsDefaultInstance();
  TripLeg_Node::default_instance_->InitAsDefaultInstance();
  TripLeg_Admin::default_instance_->InitAsDefaultInstance();
  TripLeg_ShapeAttributes::default_instance_->InitAsDefaultInstance();
  TripLeg_Incident::default_instance_->InitAsDefaultInstance();
  TripLeg_Closure::default_instance_->InitAsDefaultInstance();
  TripRoute::default_instance_->InitAsDefaultInstance();
  Trip::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_trip_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_trip_2eproto_once_);
void protobuf_AddDesc_trip_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_trip_2eproto_once_,
                 &protobuf_AddDesc_trip_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_trip_2eproto {
  StaticDescriptorInitializer_trip_2eproto() {
    protobuf_AddDesc_trip_2eproto();
  }
} static_descriptor_initializer_trip_2eproto_;
#endif

// ===================================================================

bool TripLeg_Traversability_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_Traversability TripLeg::kNone;
const TripLeg_Traversability TripLeg::kForward;
const TripLeg_Traversability TripLeg::kBackward;
const TripLeg_Traversability TripLeg::kBoth;
const TripLeg_Traversability TripLeg::Traversability_MIN;
const TripLeg_Traversability TripLeg::Traversability_MAX;
const int TripLeg::Traversability_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool TripLeg_Use_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 40:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_Use TripLeg::kRoadUse;
const TripLeg_Use TripLeg::kRampUse;
const TripLeg_Use TripLeg::kTurnChannelUse;
const TripLeg_Use TripLeg::kTrackUse;
const TripLeg_Use TripLeg::kDrivewayUse;
const TripLeg_Use TripLeg::kAlleyUse;
const TripLeg_Use TripLeg::kParkingAisleUse;
const TripLeg_Use TripLeg::kEmergencyAccessUse;
const TripLeg_Use TripLeg::kDriveThruUse;
const TripLeg_Use TripLeg::kCuldesacUse;
const TripLeg_Use TripLeg::kLivingStreetUse;
const TripLeg_Use TripLeg::kServiceRoadUse;
const TripLeg_Use TripLeg::kCyclewayUse;
const TripLeg_Use TripLeg::kMountainBikeUse;
const TripLeg_Use TripLeg::kSidewalkUse;
const TripLeg_Use TripLeg::kFootwayUse;
const TripLeg_Use TripLeg::kStepsUse;
const TripLeg_Use TripLeg::kPathUse;
const TripLeg_Use TripLeg::kPedestrianUse;
const TripLeg_Use TripLeg::kBridlewayUse;
const TripLeg_Use TripLeg::kPedestrianCrossingUse;
const TripLeg_Use TripLeg::kRestAreaUse;
const TripLeg_Use TripLeg::kServiceAreaUse;
const TripLeg_Use TripLeg::kOtherUse;
const TripLeg_Use TripLeg::kFerryUse;
const TripLeg_Use TripLeg::kRailFerryUse;
const TripLeg_Use TripLeg::kRailUse;
const TripLeg_Use TripLeg::kBusUse;
const TripLeg_Use TripLeg::kEgressConnectionUse;
const TripLeg_Use TripLeg::kPlatformConnectionUse;
const TripLeg_Use TripLeg::kTransitConnectionUse;
const TripLeg_Use TripLeg::Use_MIN;
const TripLeg_Use TripLeg::Use_MAX;
const int TripLeg::Use_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool TripLeg_Surface_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_Surface TripLeg::kPavedSmooth;
const TripLeg_Surface TripLeg::kPaved;
const TripLeg_Surface TripLeg::kPavedRough;
const TripLeg_Surface TripLeg::kCompacted;
const TripLeg_Surface TripLeg::kDirt;
const TripLeg_Surface TripLeg::kGravel;
const TripLeg_Surface TripLeg::kPath;
const TripLeg_Surface TripLeg::kImpassable;
const TripLeg_Surface TripLeg::Surface_MIN;
const TripLeg_Surface TripLeg::Surface_MAX;
const int TripLeg::Surface_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool TripLeg_CycleLane_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_CycleLane TripLeg::kNoCycleLane;
const TripLeg_CycleLane TripLeg::kShared;
const TripLeg_CycleLane TripLeg::kDedicated;
const TripLeg_CycleLane TripLeg::kSeparated;
const TripLeg_CycleLane TripLeg::CycleLane_MIN;
const TripLeg_CycleLane TripLeg::CycleLane_MAX;
const int TripLeg::CycleLane_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool TripLeg_SacScale_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_SacScale TripLeg::kNoSacScale;
const TripLeg_SacScale TripLeg::kHiking;
const TripLeg_SacScale TripLeg::kMountainHiking;
const TripLeg_SacScale TripLeg::kDemandingMountainHiking;
const TripLeg_SacScale TripLeg::kAlpineHiking;
const TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
const TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
const TripLeg_SacScale TripLeg::SacScale_MIN;
const TripLeg_SacScale TripLeg::SacScale_MAX;
const int TripLeg::SacScale_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool TripLeg_Sidewalk_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_Sidewalk TripLeg::kNoSidewalk;
const TripLeg_Sidewalk TripLeg::kLeft;
const TripLeg_Sidewalk TripLeg::kRight;
const TripLeg_Sidewalk TripLeg::kBothSides;
const TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
const TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
const int TripLeg::Sidewalk_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_LaneConnectivity::kFromWayIdFieldNumber;
const int TripLeg_LaneConnectivity::kFromLanesFieldNumber;
const int TripLeg_LaneConnectivity::kToLanesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.LaneConnectivity)
}

void TripLeg_LaneConnectivity::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}

void TripLeg_LaneConnectivity::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  clear_has_has_from_way_id();
  clear_has_has_from_lanes();
  clear_has_has_to_lanes();
}

TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  SharedDtor();
}

void TripLeg_LaneConnectivity::SharedDtor() {
  if (has_has_from_way_id()) {
    clear_has_from_way_id();
  }
  if (has_has_from_lanes()) {
    clear_has_from_lanes();
  }
  if (has_has_to_lanes()) {
    clear_has_to_lanes();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_LaneConnectivity& TripLeg_LaneConnectivity::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_LaneConnectivity* TripLeg_LaneConnectivity::default_instance_ = NULL;

TripLeg_LaneConnectivity* TripLeg_LaneConnectivity::New(::google::protobuf::Arena* arena) const {
  TripLeg_LaneConnectivity* n = new TripLeg_LaneConnectivity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_LaneConnectivity::clear_has_from_way_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.LaneConnectivity)
  switch(has_from_way_id_case()) {
    case kFromWayId: {
      // No need to clear
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_FROM_WAY_ID_NOT_SET;
}

void TripLeg_LaneConnectivity::clear_has_from_lanes() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.LaneConnectivity)
  switch(has_from_lanes_case()) {
    case kFromLanes: {
      has_from_lanes_.from_lanes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_FROM_LANES_NOT_SET;
}

void TripLeg_LaneConnectivity::clear_has_to_lanes() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.LaneConnectivity)
  switch(has_to_lanes_case()) {
    case kToLanes: {
      has_to_lanes_.to_lanes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_TO_LANES_NOT_SET;
}


void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  clear_has_from_way_id();
  clear_has_from_lanes();
  clear_has_to_lanes();
}

bool TripLeg_LaneConnectivity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.LaneConnectivity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 from_way_id = 1;
      case 1: {
        if (tag == 8) {
          clear_has_from_way_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &has_from_way_id_.from_way_id_)));
          set_has_from_way_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_from_lanes;
        break;
      }

      // optional string from_lanes = 2;
      case 2: {
        if (tag == 18) {
         parse_from_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from_lanes()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->from_lanes().data(), this->from_lanes().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.LaneConnectivity.from_lanes"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_to_lanes;
        break;
      }

      // optional string to_lanes = 3;
      case 3: {
        if (tag == 26) {
         parse_to_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to_lanes()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->to_lanes().data(), this->to_lanes().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.LaneConnectivity.to_lanes"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.LaneConnectivity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.LaneConnectivity)
  return false;
#undef DO_
}

void TripLeg_LaneConnectivity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.LaneConnectivity)
  // optional uint64 from_way_id = 1;
  if (has_from_way_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->from_way_id(), output);
  }

  // optional string from_lanes = 2;
  if (has_from_lanes()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->from_lanes().data(), this->from_lanes().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.from_lanes");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->from_lanes(), output);
  }

  // optional string to_lanes = 3;
  if (has_to_lanes()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->to_lanes().data(), this->to_lanes().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.to_lanes");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->to_lanes(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.LaneConnectivity)
}

int TripLeg_LaneConnectivity::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
  int total_size = 0;

  switch (has_from_way_id_case()) {
    // optional uint64 from_way_id = 1;
    case kFromWayId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->from_way_id());
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (has_from_lanes_case()) {
    // optional string from_lanes = 2;
    case kFromLanes: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from_lanes());
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  switch (has_to_lanes_case()) {
    // optional string to_lanes = 3;
    case kToLanes: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to_lanes());
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_LaneConnectivity*>(&from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_from_way_id_case()) {
    case kFromWayId: {
      set_from_way_id(from.from_way_id());
      break;
    }
    case HAS_FROM_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_from_lanes_case()) {
    case kFromLanes: {
      set_from_lanes(from.from_lanes());
      break;
    }
    case HAS_FROM_LANES_NOT_SET: {
      break;
    }
  }
  switch (from.has_to_lanes_case()) {
    case kToLanes: {
      set_to_lanes(from.to_lanes());
      break;
    }
    case HAS_TO_LANES_NOT_SET: {
      break;
    }
  }
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_LaneConnectivity::IsInitialized() const {

  return true;
}

void TripLeg_LaneConnectivity::Swap(TripLeg_LaneConnectivity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* other) {
  std::swap(has_from_way_id_, other->has_from_way_id_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_from_lanes_, other->has_from_lanes_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_to_lanes_, other->has_to_lanes_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_TrafficSegment::kSegmentIdFieldNumber;
const int TripLeg_TrafficSegment::kBeginPercentFieldNumber;
const int TripLeg_TrafficSegment::kEndPercentFieldNumber;
const int TripLeg_TrafficSegment::kStartsSegmentFieldNumber;
const int TripLeg_TrafficSegment::kEndsSegmentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_TrafficSegment::TripLeg_TrafficSegment()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.TrafficSegment)
}

void TripLeg_TrafficSegment::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TrafficSegment)
}

void TripLeg_TrafficSegment::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  clear_has_has_segment_id();
  clear_has_has_begin_percent();
  clear_has_has_end_percent();
  clear_has_has_starts_segment();
  clear_has_has_ends_segment();
}

TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  SharedDtor();
}

void TripLeg_TrafficSegment::SharedDtor() {
  if (has_has_segment_id()) {
    clear_has_segment_id();
  }
  if (has_has_begin_percent()) {
    clear_has_begin_percent();
  }
  if (has_has_end_percent()) {
    clear_has_end_percent();
  }
  if (has_has_starts_segment()) {
    clear_has_starts_segment();
  }
  if (has_has_ends_segment()) {
    clear_has_ends_segment();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_TrafficSegment& TripLeg_TrafficSegment::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_TrafficSegment* TripLeg_TrafficSegment::default_instance_ = NULL;

TripLeg_TrafficSegment* TripLeg_TrafficSegment::New(::google::protobuf::Arena* arena) const {
  TripLeg_TrafficSegment* n = new TripLeg_TrafficSegment;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_TrafficSegment::clear_has_segment_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch(has_segment_id_case()) {
    case kSegmentId: {
      // No need to clear
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_SEGMENT_ID_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_begin_percent() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch(has_begin_percent_case()) {
    case kBeginPercent: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_BEGIN_PERCENT_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_end_percent() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch(has_end_percent_case()) {
    case kEndPercent: {
      // No need to clear
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_END_PERCENT_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_starts_segment() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch(has_starts_segment_case()) {
    case kStartsSegment: {
      // No need to clear
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_STARTS_SEGMENT_NOT_SET;
}

void TripLeg_TrafficSegment::clear_has_ends_segment() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.TrafficSegment)
  switch(has_ends_segment_case()) {
    case kEndsSegment: {
      // No need to clear
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[4] = HAS_ENDS_SEGMENT_NOT_SET;
}


void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  clear_has_segment_id();
  clear_has_begin_percent();
  clear_has_end_percent();
  clear_has_starts_segment();
  clear_has_ends_segment();
}

bool TripLeg_TrafficSegment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.TrafficSegment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 segment_id = 1;
      case 1: {
        if (tag == 8) {
          clear_has_segment_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &has_segment_id_.segment_id_)));
          set_has_segment_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_begin_percent;
        break;
      }

      // optional float begin_percent = 2;
      case 2: {
        if (tag == 21) {
         parse_begin_percent:
          clear_has_begin_percent();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_begin_percent_.begin_percent_)));
          set_has_begin_percent();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_end_percent;
        break;
      }

      // optional float end_percent = 3;
      case 3: {
        if (tag == 29) {
         parse_end_percent:
          clear_has_end_percent();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_end_percent_.end_percent_)));
          set_has_end_percent();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_starts_segment;
        break;
      }

      // optional bool starts_segment = 4;
      case 4: {
        if (tag == 32) {
         parse_starts_segment:
          clear_has_starts_segment();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_starts_segment_.starts_segment_)));
          set_has_starts_segment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ends_segment;
        break;
      }

      // optional bool ends_segment = 5;
      case 5: {
        if (tag == 40) {
         parse_ends_segment:
          clear_has_ends_segment();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_ends_segment_.ends_segment_)));
          set_has_ends_segment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.TrafficSegment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.TrafficSegment)
  return false;
#undef DO_
}

void TripLeg_TrafficSegment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.TrafficSegment)
  // optional uint64 segment_id = 1;
  if (has_segment_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->segment_id(), output);
  }

  // optional float begin_percent = 2;
  if (has_begin_percent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->begin_percent(), output);
  }

  // optional float end_percent = 3;
  if (has_end_percent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->end_percent(), output);
  }

  // optional bool starts_segment = 4;
  if (has_starts_segment()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->starts_segment(), output);
  }

  // optional bool ends_segment = 5;
  if (has_ends_segment()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->ends_segment(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.TrafficSegment)
}

int TripLeg_TrafficSegment::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
  int total_size = 0;

  switch (has_segment_id_case()) {
    // optional uint64 segment_id = 1;
    case kSegmentId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->segment_id());
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  switch (has_begin_percent_case()) {
    // optional float begin_percent = 2;
    case kBeginPercent: {
      total_size += 1 + 4;
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (has_end_percent_case()) {
    // optional float end_percent = 3;
    case kEndPercent: {
      total_size += 1 + 4;
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (has_starts_segment_case()) {
    // optional bool starts_segment = 4;
    case kStartsSegment: {
      total_size += 1 + 1;
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  switch (has_ends_segment_case()) {
    // optional bool ends_segment = 5;
    case kEndsSegment: {
      total_size += 1 + 1;
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_TrafficSegment*>(&from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_segment_id_case()) {
    case kSegmentId: {
      set_segment_id(from.segment_id());
      break;
    }
    case HAS_SEGMENT_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_begin_percent_case()) {
    case kBeginPercent: {
      set_begin_percent(from.begin_percent());
      break;
    }
    case HAS_BEGIN_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_percent_case()) {
    case kEndPercent: {
      set_end_percent(from.end_percent());
      break;
    }
    case HAS_END_PERCENT_NOT_SET: {
      break;
    }
  }
  switch (from.has_starts_segment_case()) {
    case kStartsSegment: {
      set_starts_segment(from.starts_segment());
      break;
    }
    case HAS_STARTS_SEGMENT_NOT_SET: {
      break;
    }
  }
  switch (from.has_ends_segment_case()) {
    case kEndsSegment: {
      set_ends_segment(from.ends_segment());
      break;
    }
    case HAS_ENDS_SEGMENT_NOT_SET: {
      break;
    }
  }
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TrafficSegment::IsInitialized() const {

  return true;
}

void TripLeg_TrafficSegment::Swap(TripLeg_TrafficSegment* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* other) {
  std::swap(has_segment_id_, other->has_segment_id_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_begin_percent_, other->has_begin_percent_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_end_percent_, other->has_end_percent_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_starts_segment_, other->has_starts_segment_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  std::swap(has_ends_segment_, other->has_ends_segment_);
  std::swap(_oneof_case_[4], other->_oneof_case_[4]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Restriction::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Restriction::TripLeg_Restriction()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Restriction)
}

void TripLeg_Restriction::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_Restriction::TripLeg_Restriction(const TripLeg_Restriction& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Restriction)
}

void TripLeg_Restriction::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  clear_has_has_type();
}

TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  SharedDtor();
}

void TripLeg_Restriction::SharedDtor() {
  if (has_has_type()) {
    clear_has_type();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_Restriction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Restriction& TripLeg_Restriction::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Restriction* TripLeg_Restriction::default_instance_ = NULL;

TripLeg_Restriction* TripLeg_Restriction::New(::google::protobuf::Arena* arena) const {
  TripLeg_Restriction* n = new TripLeg_Restriction;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Restriction::clear_has_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Restriction)
  switch(has_type_case()) {
    case kType: {
      // No need to clear
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_TYPE_NOT_SET;
}


void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  clear_has_type();
}

bool TripLeg_Restriction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Restriction)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 type = 1;
      case 1: {
        if (tag == 8) {
          clear_has_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_type_.type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Restriction)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Restriction)
  return false;
#undef DO_
}

void TripLeg_Restriction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Restriction)
  // optional uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Restriction)
}

int TripLeg_Restriction::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
  int total_size = 0;

  switch (has_type_case()) {
    // optional uint32 type = 1;
    case kType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Restriction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Restriction*>(&from));
}

void TripLeg_Restriction::MergeFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_type_case()) {
    case kType: {
      set_type(from.type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Restriction::IsInitialized() const {

  return true;
}

void TripLeg_Restriction::Swap(TripLeg_Restriction* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* other) {
  std::swap(has_type_, other->has_type_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Restriction::GetTypeName() const {
  return "valhalla.TripLeg.Restriction";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Edge::kNameFieldNumber;
const int TripLeg_Edge::kLengthKmFieldNumber;
const int TripLeg_Edge::kSpeedFieldNumber;
const int TripLeg_Edge::kRoadClassFieldNumber;
const int TripLeg_Edge::kBeginHeadingFieldNumber;
const int TripLeg_Edge::kEndHeadingFieldNumber;
const int TripLeg_Edge::kBeginShapeIndexFieldNumber;
const int TripLeg_Edge::kEndShapeIndexFieldNumber;
const int TripLeg_Edge::kTraversabilityFieldNumber;
const int TripLeg_Edge::kUseFieldNumber;
const int TripLeg_Edge::kTollFieldNumber;
const int TripLeg_Edge::kUnpavedFieldNumber;
const int TripLeg_Edge::kTunnelFieldNumber;
const int TripLeg_Edge::kBridgeFieldNumber;
const int TripLeg_Edge::kRoundaboutFieldNumber;
const int TripLeg_Edge::kInternalIntersectionFieldNumber;
const int TripLeg_Edge::kDriveOnLeftFieldNumber;
const int TripLeg_Edge::kSurfaceFieldNumber;
const int TripLeg_Edge::kSignFieldNumber;
const int TripLeg_Edge::kTravelModeFieldNumber;
const int TripLeg_Edge::kVehicleTypeFieldNumber;
const int TripLeg_Edge::kPedestrianTypeFieldNumber;
const int TripLeg_Edge::kBicycleTypeFieldNumber;
const int TripLeg_Edge::kTransitTypeFieldNumber;
const int TripLeg_Edge::kTransitRouteInfoFieldNumber;
const int TripLeg_Edge::kIdFieldNumber;
const int TripLeg_Edge::kWayIdFieldNumber;
const int TripLeg_Edge::kWeightedGradeFieldNumber;
const int TripLeg_Edge::kMaxUpwardGradeFieldNumber;
const int TripLeg_Edge::kMaxDownwardGradeFieldNumber;
const int TripLeg_Edge::kLaneCountFieldNumber;
const int TripLeg_Edge::kCycleLaneFieldNumber;
const int TripLeg_Edge::kBicycleNetworkFieldNumber;
const int TripLeg_Edge::kSidewalkFieldNumber;
const int TripLeg_Edge::kDensityFieldNumber;
const int TripLeg_Edge::kSpeedLimitFieldNumber;
const int TripLeg_Edge::kTruckSpeedFieldNumber;
const int TripLeg_Edge::kTruckRouteFieldNumber;
const int TripLeg_Edge::kLaneConnectivityFieldNumber;
const int TripLeg_Edge::kMeanElevationFieldNumber;
const int TripLeg_Edge::kTrafficSegmentFieldNumber;
const int TripLeg_Edge::kTurnLanesFieldNumber;
const int TripLeg_Edge::kHasTimeRestrictionsFieldNumber;
const int TripLeg_Edge::kDefaultSpeedFieldNumber;
const int TripLeg_Edge::kRestrictionFieldNumber;
const int TripLeg_Edge::kDestinationOnlyFieldNumber;
const int TripLeg_Edge::kIsUrbanFieldNumber;
const int TripLeg_Edge::kTaggedValueFieldNumber;
const int TripLeg_Edge::kSourceAlongEdgeFieldNumber;
const int TripLeg_Edge::kTargetAlongEdgeFieldNumber;
const int TripLeg_Edge::kSacScaleFieldNumber;
const int TripLeg_Edge::kShoulderFieldNumber;
const int TripLeg_Edge::kTotalLengthKmFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Edge::TripLeg_Edge()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Edge)
}

void TripLeg_Edge::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_ = const_cast< ::valhalla::TripSign*>(
      ::valhalla::TripSign::internal_default_instance());
#else
  sign_ = const_cast< ::valhalla::TripSign*>(&::valhalla::TripSign::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_route_info_ = const_cast< ::valhalla::TransitRouteInfo*>(
      ::valhalla::TransitRouteInfo::internal_default_instance());
#else
  transit_route_info_ = const_cast< ::valhalla::TransitRouteInfo*>(&::valhalla::TransitRouteInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  restriction_ = const_cast< ::valhalla::TripLeg_Restriction*>(
      ::valhalla::TripLeg_Restriction::internal_default_instance());
#else
  restriction_ = const_cast< ::valhalla::TripLeg_Restriction*>(&::valhalla::TripLeg_Restriction::default_instance());
#endif
}

TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}

void TripLeg_Edge::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  sign_ = NULL;
  transit_route_info_ = NULL;
  restriction_ = NULL;
  clear_has_has_length_km();
  clear_has_has_speed();
  clear_has_has_road_class();
  clear_has_has_begin_heading();
  clear_has_has_end_heading();
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
  clear_has_has_traversability();
  clear_has_has_use();
  clear_has_has_toll();
  clear_has_has_unpaved();
  clear_has_has_tunnel();
  clear_has_has_bridge();
  clear_has_has_roundabout();
  clear_has_has_internal_intersection();
  clear_has_has_drive_on_left();
  clear_has_has_surface();
  clear_has_has_travel_mode();
  clear_has_has_vehicle_type();
  clear_has_has_pedestrian_type();
  clear_has_has_bicycle_type();
  clear_has_has_transit_type();
  clear_has_has_id();
  clear_has_has_way_id();
  clear_has_has_weighted_grade();
  clear_has_has_max_upward_grade();
  clear_has_has_max_downward_grade();
  clear_has_has_lane_count();
  clear_has_has_cycle_lane();
  clear_has_has_bicycle_network();
  clear_has_has_sidewalk();
  clear_has_has_density();
  clear_has_has_speed_limit();
  clear_has_has_truck_speed();
  clear_has_has_truck_route();
  clear_has_has_mean_elevation();
  clear_has_has_has_time_restrictions();
  clear_has_has_default_speed();
  clear_has_has_destination_only();
  clear_has_has_is_urban();
  clear_has_has_source_along_edge();
  clear_has_has_target_along_edge();
  clear_has_has_sac_scale();
  clear_has_has_shoulder();
  clear_has_has_total_length_km();
}

TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  SharedDtor();
}

void TripLeg_Edge::SharedDtor() {
  if (has_has_length_km()) {
    clear_has_length_km();
  }
  if (has_has_speed()) {
    clear_has_speed();
  }
  if (has_has_road_class()) {
    clear_has_road_class();
  }
  if (has_has_begin_heading()) {
    clear_has_begin_heading();
  }
  if (has_has_end_heading()) {
    clear_has_end_heading();
  }
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
  if (has_has_traversability()) {
    clear_has_traversability();
  }
  if (has_has_use()) {
    clear_has_use();
  }
  if (has_has_toll()) {
    clear_has_toll();
  }
  if (has_has_unpaved()) {
    clear_has_unpaved();
  }
  if (has_has_tunnel()) {
    clear_has_tunnel();
  }
  if (has_has_bridge()) {
    clear_has_bridge();
  }
  if (has_has_roundabout()) {
    clear_has_roundabout();
  }
  if (has_has_internal_intersection()) {
    clear_has_internal_intersection();
  }
  if (has_has_drive_on_left()) {
    clear_has_drive_on_left();
  }
  if (has_has_surface()) {
    clear_has_surface();
  }
  if (has_has_travel_mode()) {
    clear_has_travel_mode();
  }
  if (has_has_vehicle_type()) {
    clear_has_vehicle_type();
  }
  if (has_has_pedestrian_type()) {
    clear_has_pedestrian_type();
  }
  if (has_has_bicycle_type()) {
    clear_has_bicycle_type();
  }
  if (has_has_transit_type()) {
    clear_has_transit_type();
  }
  if (has_has_id()) {
    clear_has_id();
  }
  if (has_has_way_id()) {
    clear_has_way_id();
  }
  if (has_has_weighted_grade()) {
    clear_has_weighted_grade();
  }
  if (has_has_max_upward_grade()) {
    clear_has_max_upward_grade();
  }
  if (has_has_max_downward_grade()) {
    clear_has_max_downward_grade();
  }
  if (has_has_lane_count()) {
    clear_has_lane_count();
  }
  if (has_has_cycle_lane()) {
    clear_has_cycle_lane();
  }
  if (has_has_bicycle_network()) {
    clear_has_bicycle_network();
  }
  if (has_has_sidewalk()) {
    clear_has_sidewalk();
  }
  if (has_has_density()) {
    clear_has_density();
  }
  if (has_has_speed_limit()) {
    clear_has_speed_limit();
  }
  if (has_has_truck_speed()) {
    clear_has_truck_speed();
  }
  if (has_has_truck_route()) {
    clear_has_truck_route();
  }
  if (has_has_mean_elevation()) {
    clear_has_mean_elevation();
  }
  if (has_has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
  }
  if (has_has_default_speed()) {
    clear_has_default_speed();
  }
  if (has_has_destination_only()) {
    clear_has_destination_only();
  }
  if (has_has_is_urban()) {
    clear_has_is_urban();
  }
  if (has_has_source_along_edge()) {
    clear_has_source_along_edge();
  }
  if (has_has_target_along_edge()) {
    clear_has_target_along_edge();
  }
  if (has_has_sac_scale()) {
    clear_has_sac_scale();
  }
  if (has_has_shoulder()) {
    clear_has_shoulder();
  }
  if (has_has_total_length_km()) {
    clear_has_total_length_km();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_;
    delete transit_route_info_;
    delete restriction_;
  }
}

void TripLeg_Edge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Edge& TripLeg_Edge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Edge* TripLeg_Edge::default_instance_ = NULL;

TripLeg_Edge* TripLeg_Edge::New(::google::protobuf::Arena* arena) const {
  TripLeg_Edge* n = new TripLeg_Edge;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Edge::clear_has_length_km() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_length_km_case()) {
    case kLengthKm: {
      // No need to clear
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_LENGTH_KM_NOT_SET;
}

void TripLeg_Edge::clear_has_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_speed_case()) {
    case kSpeed: {
      // No need to clear
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_SPEED_NOT_SET;
}

void TripLeg_Edge::clear_has_road_class() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_road_class_case()) {
    case kRoadClass: {
      // No need to clear
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_ROAD_CLASS_NOT_SET;
}

void TripLeg_Edge::clear_has_begin_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_begin_heading_case()) {
    case kBeginHeading: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_BEGIN_HEADING_NOT_SET;
}

void TripLeg_Edge::clear_has_end_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_end_heading_case()) {
    case kEndHeading: {
      // No need to clear
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  _oneof_case_[4] = HAS_END_HEADING_NOT_SET;
}

void TripLeg_Edge::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[5] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Edge::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[6] = HAS_END_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Edge::clear_has_traversability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_traversability_case()) {
    case kTraversability: {
      // No need to clear
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[7] = HAS_TRAVERSABILITY_NOT_SET;
}

void TripLeg_Edge::clear_has_use() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_use_case()) {
    case kUse: {
      // No need to clear
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[8] = HAS_USE_NOT_SET;
}

void TripLeg_Edge::clear_has_toll() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_toll_case()) {
    case kToll: {
      // No need to clear
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[9] = HAS_TOLL_NOT_SET;
}

void TripLeg_Edge::clear_has_unpaved() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_unpaved_case()) {
    case kUnpaved: {
      // No need to clear
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  _oneof_case_[10] = HAS_UNPAVED_NOT_SET;
}

void TripLeg_Edge::clear_has_tunnel() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_tunnel_case()) {
    case kTunnel: {
      // No need to clear
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[11] = HAS_TUNNEL_NOT_SET;
}

void TripLeg_Edge::clear_has_bridge() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_bridge_case()) {
    case kBridge: {
      // No need to clear
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[12] = HAS_BRIDGE_NOT_SET;
}

void TripLeg_Edge::clear_has_roundabout() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_roundabout_case()) {
    case kRoundabout: {
      // No need to clear
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[13] = HAS_ROUNDABOUT_NOT_SET;
}

void TripLeg_Edge::clear_has_internal_intersection() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_internal_intersection_case()) {
    case kInternalIntersection: {
      // No need to clear
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[14] = HAS_INTERNAL_INTERSECTION_NOT_SET;
}

void TripLeg_Edge::clear_has_drive_on_left() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_drive_on_left_case()) {
    case kDriveOnLeft: {
      // No need to clear
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[15] = HAS_DRIVE_ON_LEFT_NOT_SET;
}

void TripLeg_Edge::clear_has_surface() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_surface_case()) {
    case kSurface: {
      // No need to clear
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[16] = HAS_SURFACE_NOT_SET;
}

void TripLeg_Edge::clear_has_travel_mode() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_travel_mode_case()) {
    case kTravelMode: {
      // No need to clear
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[17] = HAS_TRAVEL_MODE_NOT_SET;
}

void TripLeg_Edge::clear_has_vehicle_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_vehicle_type_case()) {
    case kVehicleType: {
      // No need to clear
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[18] = HAS_VEHICLE_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_pedestrian_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_pedestrian_type_case()) {
    case kPedestrianType: {
      // No need to clear
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[19] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_bicycle_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_bicycle_type_case()) {
    case kBicycleType: {
      // No need to clear
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[20] = HAS_BICYCLE_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_transit_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_transit_type_case()) {
    case kTransitType: {
      // No need to clear
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[21] = HAS_TRANSIT_TYPE_NOT_SET;
}

void TripLeg_Edge::clear_has_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_id_case()) {
    case kId: {
      // No need to clear
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[22] = HAS_ID_NOT_SET;
}

void TripLeg_Edge::clear_has_way_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_way_id_case()) {
    case kWayId: {
      // No need to clear
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[23] = HAS_WAY_ID_NOT_SET;
}

void TripLeg_Edge::clear_has_weighted_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_weighted_grade_case()) {
    case kWeightedGrade: {
      // No need to clear
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[24] = HAS_WEIGHTED_GRADE_NOT_SET;
}

void TripLeg_Edge::clear_has_max_upward_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_max_upward_grade_case()) {
    case kMaxUpwardGrade: {
      // No need to clear
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[25] = HAS_MAX_UPWARD_GRADE_NOT_SET;
}

void TripLeg_Edge::clear_has_max_downward_grade() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_max_downward_grade_case()) {
    case kMaxDownwardGrade: {
      // No need to clear
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[26] = HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}

void TripLeg_Edge::clear_has_lane_count() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_lane_count_case()) {
    case kLaneCount: {
      // No need to clear
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[27] = HAS_LANE_COUNT_NOT_SET;
}

void TripLeg_Edge::clear_has_cycle_lane() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_cycle_lane_case()) {
    case kCycleLane: {
      // No need to clear
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[28] = HAS_CYCLE_LANE_NOT_SET;
}

void TripLeg_Edge::clear_has_bicycle_network() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_bicycle_network_case()) {
    case kBicycleNetwork: {
      // No need to clear
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  _oneof_case_[29] = HAS_BICYCLE_NETWORK_NOT_SET;
}

void TripLeg_Edge::clear_has_sidewalk() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_sidewalk_case()) {
    case kSidewalk: {
      // No need to clear
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  _oneof_case_[30] = HAS_SIDEWALK_NOT_SET;
}

void TripLeg_Edge::clear_has_density() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_density_case()) {
    case kDensity: {
      // No need to clear
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[31] = HAS_DENSITY_NOT_SET;
}

void TripLeg_Edge::clear_has_speed_limit() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_speed_limit_case()) {
    case kSpeedLimit: {
      // No need to clear
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[32] = HAS_SPEED_LIMIT_NOT_SET;
}

void TripLeg_Edge::clear_has_truck_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_truck_speed_case()) {
    case kTruckSpeed: {
      // No need to clear
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  _oneof_case_[33] = HAS_TRUCK_SPEED_NOT_SET;
}

void TripLeg_Edge::clear_has_truck_route() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_truck_route_case()) {
    case kTruckRoute: {
      // No need to clear
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[34] = HAS_TRUCK_ROUTE_NOT_SET;
}

void TripLeg_Edge::clear_has_mean_elevation() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_mean_elevation_case()) {
    case kMeanElevation: {
      // No need to clear
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[35] = HAS_MEAN_ELEVATION_NOT_SET;
}

void TripLeg_Edge::clear_has_has_time_restrictions() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_has_time_restrictions_case()) {
    case kHasTimeRestrictions: {
      // No need to clear
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[36] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}

void TripLeg_Edge::clear_has_default_speed() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_default_speed_case()) {
    case kDefaultSpeed: {
      // No need to clear
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  _oneof_case_[37] = HAS_DEFAULT_SPEED_NOT_SET;
}

void TripLeg_Edge::clear_has_destination_only() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_destination_only_case()) {
    case kDestinationOnly: {
      // No need to clear
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[38] = HAS_DESTINATION_ONLY_NOT_SET;
}

void TripLeg_Edge::clear_has_is_urban() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_is_urban_case()) {
    case kIsUrban: {
      // No need to clear
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[39] = HAS_IS_URBAN_NOT_SET;
}

void TripLeg_Edge::clear_has_source_along_edge() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_source_along_edge_case()) {
    case kSourceAlongEdge: {
      // No need to clear
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[40] = HAS_SOURCE_ALONG_EDGE_NOT_SET;
}

void TripLeg_Edge::clear_has_target_along_edge() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_target_along_edge_case()) {
    case kTargetAlongEdge: {
      // No need to clear
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[41] = HAS_TARGET_ALONG_EDGE_NOT_SET;
}

void TripLeg_Edge::clear_has_sac_scale() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_sac_scale_case()) {
    case kSacScale: {
      // No need to clear
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[42] = HAS_SAC_SCALE_NOT_SET;
}

void TripLeg_Edge::clear_has_shoulder() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_shoulder_case()) {
    case kShoulder: {
      // No need to clear
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[43] = HAS_SHOULDER_NOT_SET;
}

void TripLeg_Edge::clear_has_total_length_km() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Edge)
  switch(has_total_length_km_case()) {
    case kTotalLengthKm: {
      // No need to clear
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  _oneof_case_[44] = HAS_TOTAL_LENGTH_KM_NOT_SET;
}


void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
  if (GetArenaNoVirtual() == NULL && transit_route_info_ != NULL) delete transit_route_info_;
  transit_route_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && restriction_ != NULL) delete restriction_;
  restriction_ = NULL;
  name_.Clear();
  lane_connectivity_.Clear();
  traffic_segment_.Clear();
  turn_lanes_.Clear();
  tagged_value_.Clear();
  clear_has_length_km();
  clear_has_speed();
  clear_has_road_class();
  clear_has_begin_heading();
  clear_has_end_heading();
  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  clear_has_traversability();
  clear_has_use();
  clear_has_toll();
  clear_has_unpaved();
  clear_has_tunnel();
  clear_has_bridge();
  clear_has_roundabout();
  clear_has_internal_intersection();
  clear_has_drive_on_left();
  clear_has_surface();
  clear_has_travel_mode();
  clear_has_vehicle_type();
  clear_has_pedestrian_type();
  clear_has_bicycle_type();
  clear_has_transit_type();
  clear_has_id();
  clear_has_way_id();
  clear_has_weighted_grade();
  clear_has_max_upward_grade();
  clear_has_max_downward_grade();
  clear_has_lane_count();
  clear_has_cycle_lane();
  clear_has_bicycle_network();
  clear_has_sidewalk();
  clear_has_density();
  clear_has_speed_limit();
  clear_has_truck_speed();
  clear_has_truck_route();
  clear_has_mean_elevation();
  clear_has_has_time_restrictions();
  clear_has_default_speed();
  clear_has_destination_only();
  clear_has_is_urban();
  clear_has_source_along_edge();
  clear_has_target_along_edge();
  clear_has_sac_scale();
  clear_has_shoulder();
  clear_has_total_length_km();
}

bool TripLeg_Edge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Edge)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.StreetName name = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_name;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(21)) goto parse_length_km;
        break;
      }

      // optional float length_km = 2;
      case 2: {
        if (tag == 21) {
         parse_length_km:
          clear_has_length_km();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_length_km_.length_km_)));
          set_has_length_km();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_speed;
        break;
      }

      // optional float speed = 3;
      case 3: {
        if (tag == 29) {
         parse_speed:
          clear_has_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_speed_.speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_road_class;
        break;
      }

      // optional .valhalla.RoadClass road_class = 4;
      case 4: {
        if (tag == 32) {
         parse_road_class:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_road_class(static_cast< ::valhalla::RoadClass >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_begin_heading;
        break;
      }

      // optional uint32 begin_heading = 5;
      case 5: {
        if (tag == 40) {
         parse_begin_heading:
          clear_has_begin_heading();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_begin_heading_.begin_heading_)));
          set_has_begin_heading();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_end_heading;
        break;
      }

      // optional uint32 end_heading = 6;
      case 6: {
        if (tag == 48) {
         parse_end_heading:
          clear_has_end_heading();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_end_heading_.end_heading_)));
          set_has_end_heading();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_begin_shape_index;
        break;
      }

      // optional uint32 begin_shape_index = 7;
      case 7: {
        if (tag == 56) {
         parse_begin_shape_index:
          clear_has_begin_shape_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_begin_shape_index_.begin_shape_index_)));
          set_has_begin_shape_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_end_shape_index;
        break;
      }

      // optional uint32 end_shape_index = 8;
      case 8: {
        if (tag == 64) {
         parse_end_shape_index:
          clear_has_end_shape_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_end_shape_index_.end_shape_index_)));
          set_has_end_shape_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_traversability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability traversability = 9;
      case 9: {
        if (tag == 72) {
         parse_traversability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_traversability(static_cast< ::valhalla::TripLeg_Traversability >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_use;
        break;
      }

      // optional .valhalla.TripLeg.Use use = 10;
      case 10: {
        if (tag == 80) {
         parse_use:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_use(static_cast< ::valhalla::TripLeg_Use >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_toll;
        break;
      }

      // optional bool toll = 11;
      case 11: {
        if (tag == 88) {
         parse_toll:
          clear_has_toll();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_toll_.toll_)));
          set_has_toll();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_unpaved;
        break;
      }

      // optional bool unpaved = 12;
      case 12: {
        if (tag == 96) {
         parse_unpaved:
          clear_has_unpaved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_unpaved_.unpaved_)));
          set_has_unpaved();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_tunnel;
        break;
      }

      // optional bool tunnel = 13;
      case 13: {
        if (tag == 104) {
         parse_tunnel:
          clear_has_tunnel();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_tunnel_.tunnel_)));
          set_has_tunnel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_bridge;
        break;
      }

      // optional bool bridge = 14;
      case 14: {
        if (tag == 112) {
         parse_bridge:
          clear_has_bridge();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_bridge_.bridge_)));
          set_has_bridge();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_roundabout;
        break;
      }

      // optional bool roundabout = 15;
      case 15: {
        if (tag == 120) {
         parse_roundabout:
          clear_has_roundabout();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_roundabout_.roundabout_)));
          set_has_roundabout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_internal_intersection;
        break;
      }

      // optional bool internal_intersection = 16;
      case 16: {
        if (tag == 128) {
         parse_internal_intersection:
          clear_has_internal_intersection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_internal_intersection_.internal_intersection_)));
          set_has_internal_intersection();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_drive_on_left;
        break;
      }

      // optional bool drive_on_left = 17;
      case 17: {
        if (tag == 136) {
         parse_drive_on_left:
          clear_has_drive_on_left();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_drive_on_left_.drive_on_left_)));
          set_has_drive_on_left();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_surface;
        break;
      }

      // optional .valhalla.TripLeg.Surface surface = 18;
      case 18: {
        if (tag == 144) {
         parse_surface:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_surface(static_cast< ::valhalla::TripLeg_Surface >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_sign;
        break;
      }

      // optional .valhalla.TripSign sign = 19;
      case 19: {
        if (tag == 154) {
         parse_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_travel_mode;
        break;
      }

      // optional .valhalla.TravelMode travel_mode = 20;
      case 20: {
        if (tag == 160) {
         parse_travel_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_travel_mode(static_cast< ::valhalla::TravelMode >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_vehicle_type;
        break;
      }

      // optional .valhalla.VehicleType vehicle_type = 21;
      case 21: {
        if (tag == 168) {
         parse_vehicle_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_vehicle_type(static_cast< ::valhalla::VehicleType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_pedestrian_type;
        break;
      }

      // optional .valhalla.PedestrianType pedestrian_type = 22;
      case 22: {
        if (tag == 176) {
         parse_pedestrian_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_pedestrian_type(static_cast< ::valhalla::PedestrianType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_bicycle_type;
        break;
      }

      // optional .valhalla.BicycleType bicycle_type = 23;
      case 23: {
        if (tag == 184) {
         parse_bicycle_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_bicycle_type(static_cast< ::valhalla::BicycleType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_transit_type;
        break;
      }

      // optional .valhalla.TransitType transit_type = 24;
      case 24: {
        if (tag == 192) {
         parse_transit_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_transit_type(static_cast< ::valhalla::TransitType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_transit_route_info;
        break;
      }

      // optional .valhalla.TransitRouteInfo transit_route_info = 25;
      case 25: {
        if (tag == 202) {
         parse_transit_route_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_route_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_id;
        break;
      }

      // optional uint64 id = 26;
      case 26: {
        if (tag == 208) {
         parse_id:
          clear_has_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &has_id_.id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_way_id;
        break;
      }

      // optional uint64 way_id = 27;
      case 27: {
        if (tag == 216) {
         parse_way_id:
          clear_has_way_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &has_way_id_.way_id_)));
          set_has_way_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(229)) goto parse_weighted_grade;
        break;
      }

      // optional float weighted_grade = 28;
      case 28: {
        if (tag == 229) {
         parse_weighted_grade:
          clear_has_weighted_grade();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_weighted_grade_.weighted_grade_)));
          set_has_weighted_grade();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_max_upward_grade;
        break;
      }

      // optional int32 max_upward_grade = 29;
      case 29: {
        if (tag == 232) {
         parse_max_upward_grade:
          clear_has_max_upward_grade();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_max_upward_grade_.max_upward_grade_)));
          set_has_max_upward_grade();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_max_downward_grade;
        break;
      }

      // optional int32 max_downward_grade = 30;
      case 30: {
        if (tag == 240) {
         parse_max_downward_grade:
          clear_has_max_downward_grade();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_max_downward_grade_.max_downward_grade_)));
          set_has_max_downward_grade();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_lane_count;
        break;
      }

      // optional uint32 lane_count = 31;
      case 31: {
        if (tag == 248) {
         parse_lane_count:
          clear_has_lane_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_lane_count_.lane_count_)));
          set_has_lane_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_cycle_lane;
        break;
      }

      // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
      case 32: {
        if (tag == 256) {
         parse_cycle_lane:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_cycle_lane(static_cast< ::valhalla::TripLeg_CycleLane >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_bicycle_network;
        break;
      }

      // optional uint32 bicycle_network = 33;
      case 33: {
        if (tag == 264) {
         parse_bicycle_network:
          clear_has_bicycle_network();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_bicycle_network_.bicycle_network_)));
          set_has_bicycle_network();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_sidewalk;
        break;
      }

      // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
      case 34: {
        if (tag == 272) {
         parse_sidewalk:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_sidewalk(static_cast< ::valhalla::TripLeg_Sidewalk >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(280)) goto parse_density;
        break;
      }

      // optional uint32 density = 35;
      case 35: {
        if (tag == 280) {
         parse_density:
          clear_has_density();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_density_.density_)));
          set_has_density();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_speed_limit;
        break;
      }

      // optional uint32 speed_limit = 36;
      case 36: {
        if (tag == 288) {
         parse_speed_limit:
          clear_has_speed_limit();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_speed_limit_.speed_limit_)));
          set_has_speed_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(301)) goto parse_truck_speed;
        break;
      }

      // optional float truck_speed = 37;
      case 37: {
        if (tag == 301) {
         parse_truck_speed:
          clear_has_truck_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_truck_speed_.truck_speed_)));
          set_has_truck_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_truck_route;
        break;
      }

      // optional bool truck_route = 38;
      case 38: {
        if (tag == 304) {
         parse_truck_route:
          clear_has_truck_route();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_truck_route_.truck_route_)));
          set_has_truck_route();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(314)) goto parse_lane_connectivity;
        break;
      }

      // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
      case 39: {
        if (tag == 314) {
         parse_lane_connectivity:
          DO_(input->IncrementRecursionDepth());
         parse_loop_lane_connectivity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_lane_connectivity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(314)) goto parse_loop_lane_connectivity;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(320)) goto parse_mean_elevation;
        break;
      }

      // optional int32 mean_elevation = 40;
      case 40: {
        if (tag == 320) {
         parse_mean_elevation:
          clear_has_mean_elevation();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_mean_elevation_.mean_elevation_)));
          set_has_mean_elevation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(330)) goto parse_traffic_segment;
        break;
      }

      // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
      case 41: {
        if (tag == 330) {
         parse_traffic_segment:
          DO_(input->IncrementRecursionDepth());
         parse_loop_traffic_segment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_traffic_segment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(330)) goto parse_loop_traffic_segment;
        if (input->ExpectTag(338)) goto parse_loop_turn_lanes;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .valhalla.TurnLane turn_lanes = 42;
      case 42: {
        if (tag == 338) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_turn_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_turn_lanes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(338)) goto parse_loop_turn_lanes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(344)) goto parse_has_time_restrictions;
        break;
      }

      // optional bool has_time_restrictions = 43;
      case 43: {
        if (tag == 344) {
         parse_has_time_restrictions:
          clear_has_has_time_restrictions();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_has_time_restrictions_.has_time_restrictions_)));
          set_has_has_time_restrictions();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(357)) goto parse_default_speed;
        break;
      }

      // optional float default_speed = 44;
      case 44: {
        if (tag == 357) {
         parse_default_speed:
          clear_has_default_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_default_speed_.default_speed_)));
          set_has_default_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(362)) goto parse_restriction;
        break;
      }

      // optional .valhalla.TripLeg.Restriction restriction = 45;
      case 45: {
        if (tag == 362) {
         parse_restriction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_restriction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(368)) goto parse_destination_only;
        break;
      }

      // optional bool destination_only = 46;
      case 46: {
        if (tag == 368) {
         parse_destination_only:
          clear_has_destination_only();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_destination_only_.destination_only_)));
          set_has_destination_only();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(376)) goto parse_is_urban;
        break;
      }

      // optional bool is_urban = 47;
      case 47: {
        if (tag == 376) {
         parse_is_urban:
          clear_has_is_urban();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_is_urban_.is_urban_)));
          set_has_is_urban();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(386)) goto parse_tagged_value;
        break;
      }

      // repeated .valhalla.TaggedValue tagged_value = 48;
      case 48: {
        if (tag == 386) {
         parse_tagged_value:
          DO_(input->IncrementRecursionDepth());
         parse_loop_tagged_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_tagged_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(386)) goto parse_loop_tagged_value;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(397)) goto parse_source_along_edge;
        break;
      }

      // optional float source_along_edge = 49;
      case 49: {
        if (tag == 397) {
         parse_source_along_edge:
          clear_has_source_along_edge();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_source_along_edge_.source_along_edge_)));
          set_has_source_along_edge();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(405)) goto parse_target_along_edge;
        break;
      }

      // optional float target_along_edge = 50;
      case 50: {
        if (tag == 405) {
         parse_target_along_edge:
          clear_has_target_along_edge();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_target_along_edge_.target_along_edge_)));
          set_has_target_along_edge();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(408)) goto parse_sac_scale;
        break;
      }

      // optional .valhalla.TripLeg.SacScale sac_scale = 51;
      case 51: {
        if (tag == 408) {
         parse_sac_scale:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_sac_scale(static_cast< ::valhalla::TripLeg_SacScale >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(416)) goto parse_shoulder;
        break;
      }

      // optional bool shoulder = 52;
      case 52: {
        if (tag == 416) {
         parse_shoulder:
          clear_has_shoulder();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_shoulder_.shoulder_)));
          set_has_shoulder();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(429)) goto parse_total_length_km;
        break;
      }

      // optional float total_length_km = 53;
      case 53: {
        if (tag == 429) {
         parse_total_length_km:
          clear_has_total_length_km();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &has_total_length_km_.total_length_km_)));
          set_has_total_length_km();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Edge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Edge)
  return false;
#undef DO_
}

void TripLeg_Edge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Edge)
  // repeated .valhalla.StreetName name = 1;
  for (unsigned int i = 0, n = this->name_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->name(i), output);
  }

  // optional float length_km = 2;
  if (has_length_km()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->length_km(), output);
  }

  // optional float speed = 3;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->speed(), output);
  }

  // optional .valhalla.RoadClass road_class = 4;
  if (has_road_class()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->road_class(), output);
  }

  // optional uint32 begin_heading = 5;
  if (has_begin_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->begin_heading(), output);
  }

  // optional uint32 end_heading = 6;
  if (has_end_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->end_heading(), output);
  }

  // optional uint32 begin_shape_index = 7;
  if (has_begin_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->begin_shape_index(), output);
  }

  // optional uint32 end_shape_index = 8;
  if (has_end_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->end_shape_index(), output);
  }

  // optional .valhalla.TripLeg.Traversability traversability = 9;
  if (has_traversability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->traversability(), output);
  }

  // optional .valhalla.TripLeg.Use use = 10;
  if (has_use()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->use(), output);
  }

  // optional bool toll = 11;
  if (has_toll()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->toll(), output);
  }

  // optional bool unpaved = 12;
  if (has_unpaved()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->unpaved(), output);
  }

  // optional bool tunnel = 13;
  if (has_tunnel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->tunnel(), output);
  }

  // optional bool bridge = 14;
  if (has_bridge()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->bridge(), output);
  }

  // optional bool roundabout = 15;
  if (has_roundabout()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->roundabout(), output);
  }

  // optional bool internal_intersection = 16;
  if (has_internal_intersection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->internal_intersection(), output);
  }

  // optional bool drive_on_left = 17;
  if (has_drive_on_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->drive_on_left(), output);
  }

  // optional .valhalla.TripLeg.Surface surface = 18;
  if (has_surface()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      18, this->surface(), output);
  }

  // optional .valhalla.TripSign sign = 19;
  if (this->has_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      19, *this->sign_, output);
  }

  // optional .valhalla.TravelMode travel_mode = 20;
  if (has_travel_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->travel_mode(), output);
  }

  // optional .valhalla.VehicleType vehicle_type = 21;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      21, this->vehicle_type(), output);
  }

  // optional .valhalla.PedestrianType pedestrian_type = 22;
  if (has_pedestrian_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      22, this->pedestrian_type(), output);
  }

  // optional .valhalla.BicycleType bicycle_type = 23;
  if (has_bicycle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      23, this->bicycle_type(), output);
  }

  // optional .valhalla.TransitType transit_type = 24;
  if (has_transit_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      24, this->transit_type(), output);
  }

  // optional .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->has_transit_route_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      25, *this->transit_route_info_, output);
  }

  // optional uint64 id = 26;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->id(), output);
  }

  // optional uint64 way_id = 27;
  if (has_way_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(27, this->way_id(), output);
  }

  // optional float weighted_grade = 28;
  if (has_weighted_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(28, this->weighted_grade(), output);
  }

  // optional int32 max_upward_grade = 29;
  if (has_max_upward_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(29, this->max_upward_grade(), output);
  }

  // optional int32 max_downward_grade = 30;
  if (has_max_downward_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(30, this->max_downward_grade(), output);
  }

  // optional uint32 lane_count = 31;
  if (has_lane_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->lane_count(), output);
  }

  // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (has_cycle_lane()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      32, this->cycle_lane(), output);
  }

  // optional uint32 bicycle_network = 33;
  if (has_bicycle_network()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(33, this->bicycle_network(), output);
  }

  // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (has_sidewalk()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      34, this->sidewalk(), output);
  }

  // optional uint32 density = 35;
  if (has_density()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(35, this->density(), output);
  }

  // optional uint32 speed_limit = 36;
  if (has_speed_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(36, this->speed_limit(), output);
  }

  // optional float truck_speed = 37;
  if (has_truck_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(37, this->truck_speed(), output);
  }

  // optional bool truck_route = 38;
  if (has_truck_route()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->truck_route(), output);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (unsigned int i = 0, n = this->lane_connectivity_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      39, this->lane_connectivity(i), output);
  }

  // optional int32 mean_elevation = 40;
  if (has_mean_elevation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(40, this->mean_elevation(), output);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (unsigned int i = 0, n = this->traffic_segment_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      41, this->traffic_segment(i), output);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (unsigned int i = 0, n = this->turn_lanes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      42, this->turn_lanes(i), output);
  }

  // optional bool has_time_restrictions = 43;
  if (has_has_time_restrictions()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(43, this->has_time_restrictions(), output);
  }

  // optional float default_speed = 44;
  if (has_default_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(44, this->default_speed(), output);
  }

  // optional .valhalla.TripLeg.Restriction restriction = 45;
  if (this->has_restriction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      45, *this->restriction_, output);
  }

  // optional bool destination_only = 46;
  if (has_destination_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(46, this->destination_only(), output);
  }

  // optional bool is_urban = 47;
  if (has_is_urban()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(47, this->is_urban(), output);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  for (unsigned int i = 0, n = this->tagged_value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      48, this->tagged_value(i), output);
  }

  // optional float source_along_edge = 49;
  if (has_source_along_edge()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(49, this->source_along_edge(), output);
  }

  // optional float target_along_edge = 50;
  if (has_target_along_edge()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(50, this->target_along_edge(), output);
  }

  // optional .valhalla.TripLeg.SacScale sac_scale = 51;
  if (has_sac_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      51, this->sac_scale(), output);
  }

  // optional bool shoulder = 52;
  if (has_shoulder()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(52, this->shoulder(), output);
  }

  // optional float total_length_km = 53;
  if (has_total_length_km()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(53, this->total_length_km(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Edge)
}

int TripLeg_Edge::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
  int total_size = 0;

  // optional .valhalla.TripSign sign = 19;
  if (this->has_sign()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->sign_);
  }

  // optional .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->has_transit_route_info()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transit_route_info_);
  }

  // optional .valhalla.TripLeg.Restriction restriction = 45;
  if (this->has_restriction()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->restriction_);
  }

  // repeated .valhalla.StreetName name = 1;
  total_size += 1 * this->name_size();
  for (int i = 0; i < this->name_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->name(i));
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2 * this->lane_connectivity_size();
  for (int i = 0; i < this->lane_connectivity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lane_connectivity(i));
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2 * this->traffic_segment_size();
  for (int i = 0; i < this->traffic_segment_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->traffic_segment(i));
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2 * this->turn_lanes_size();
  for (int i = 0; i < this->turn_lanes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->turn_lanes(i));
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  total_size += 2 * this->tagged_value_size();
  for (int i = 0; i < this->tagged_value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tagged_value(i));
  }

  switch (has_length_km_case()) {
    // optional float length_km = 2;
    case kLengthKm: {
      total_size += 1 + 4;
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  switch (has_speed_case()) {
    // optional float speed = 3;
    case kSpeed: {
      total_size += 1 + 4;
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_road_class_case()) {
    // optional .valhalla.RoadClass road_class = 4;
    case kRoadClass: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (has_begin_heading_case()) {
    // optional uint32 begin_heading = 5;
    case kBeginHeading: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (has_end_heading_case()) {
    // optional uint32 end_heading = 6;
    case kEndHeading: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_heading());
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  switch (has_begin_shape_index_case()) {
    // optional uint32 begin_shape_index = 7;
    case kBeginShapeIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // optional uint32 end_shape_index = 8;
    case kEndShapeIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_traversability_case()) {
    // optional .valhalla.TripLeg.Traversability traversability = 9;
    case kTraversability: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->traversability());
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_use_case()) {
    // optional .valhalla.TripLeg.Use use = 10;
    case kUse: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (has_toll_case()) {
    // optional bool toll = 11;
    case kToll: {
      total_size += 1 + 1;
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  switch (has_unpaved_case()) {
    // optional bool unpaved = 12;
    case kUnpaved: {
      total_size += 1 + 1;
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  switch (has_tunnel_case()) {
    // optional bool tunnel = 13;
    case kTunnel: {
      total_size += 1 + 1;
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  switch (has_bridge_case()) {
    // optional bool bridge = 14;
    case kBridge: {
      total_size += 1 + 1;
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  switch (has_roundabout_case()) {
    // optional bool roundabout = 15;
    case kRoundabout: {
      total_size += 1 + 1;
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  switch (has_internal_intersection_case()) {
    // optional bool internal_intersection = 16;
    case kInternalIntersection: {
      total_size += 2 + 1;
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  switch (has_drive_on_left_case()) {
    // optional bool drive_on_left = 17;
    case kDriveOnLeft: {
      total_size += 2 + 1;
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  switch (has_surface_case()) {
    // optional .valhalla.TripLeg.Surface surface = 18;
    case kSurface: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->surface());
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  switch (has_travel_mode_case()) {
    // optional .valhalla.TravelMode travel_mode = 20;
    case kTravelMode: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->travel_mode());
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  switch (has_vehicle_type_case()) {
    // optional .valhalla.VehicleType vehicle_type = 21;
    case kVehicleType: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->vehicle_type());
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_pedestrian_type_case()) {
    // optional .valhalla.PedestrianType pedestrian_type = 22;
    case kPedestrianType: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pedestrian_type());
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_bicycle_type_case()) {
    // optional .valhalla.BicycleType bicycle_type = 23;
    case kBicycleType: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->bicycle_type());
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_transit_type_case()) {
    // optional .valhalla.TransitType transit_type = 24;
    case kTransitType: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transit_type());
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_id_case()) {
    // optional uint64 id = 26;
    case kId: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (has_way_id_case()) {
    // optional uint64 way_id = 27;
    case kWayId: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->way_id());
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (has_weighted_grade_case()) {
    // optional float weighted_grade = 28;
    case kWeightedGrade: {
      total_size += 2 + 4;
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_max_upward_grade_case()) {
    // optional int32 max_upward_grade = 29;
    case kMaxUpwardGrade: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_upward_grade());
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_max_downward_grade_case()) {
    // optional int32 max_downward_grade = 30;
    case kMaxDownwardGrade: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_downward_grade());
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (has_lane_count_case()) {
    // optional uint32 lane_count = 31;
    case kLaneCount: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  switch (has_cycle_lane_case()) {
    // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
    case kCycleLane: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cycle_lane());
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  switch (has_bicycle_network_case()) {
    // optional uint32 bicycle_network = 33;
    case kBicycleNetwork: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bicycle_network());
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  switch (has_sidewalk_case()) {
    // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
    case kSidewalk: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sidewalk());
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  switch (has_density_case()) {
    // optional uint32 density = 35;
    case kDensity: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->density());
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  switch (has_speed_limit_case()) {
    // optional uint32 speed_limit = 36;
    case kSpeedLimit: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->speed_limit());
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  switch (has_truck_speed_case()) {
    // optional float truck_speed = 37;
    case kTruckSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_truck_route_case()) {
    // optional bool truck_route = 38;
    case kTruckRoute: {
      total_size += 2 + 1;
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  switch (has_mean_elevation_case()) {
    // optional int32 mean_elevation = 40;
    case kMeanElevation: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mean_elevation());
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  switch (has_has_time_restrictions_case()) {
    // optional bool has_time_restrictions = 43;
    case kHasTimeRestrictions: {
      total_size += 2 + 1;
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  switch (has_default_speed_case()) {
    // optional float default_speed = 44;
    case kDefaultSpeed: {
      total_size += 2 + 4;
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  switch (has_destination_only_case()) {
    // optional bool destination_only = 46;
    case kDestinationOnly: {
      total_size += 2 + 1;
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  switch (has_is_urban_case()) {
    // optional bool is_urban = 47;
    case kIsUrban: {
      total_size += 2 + 1;
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  switch (has_source_along_edge_case()) {
    // optional float source_along_edge = 49;
    case kSourceAlongEdge: {
      total_size += 2 + 4;
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (has_target_along_edge_case()) {
    // optional float target_along_edge = 50;
    case kTargetAlongEdge: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (has_sac_scale_case()) {
    // optional .valhalla.TripLeg.SacScale sac_scale = 51;
    case kSacScale: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sac_scale());
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  switch (has_shoulder_case()) {
    // optional bool shoulder = 52;
    case kShoulder: {
      total_size += 2 + 1;
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  switch (has_total_length_km_case()) {
    // optional float total_length_km = 53;
    case kTotalLengthKm: {
      total_size += 2 + 4;
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Edge*>(&from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  name_.MergeFrom(from.name_);
  lane_connectivity_.MergeFrom(from.lane_connectivity_);
  traffic_segment_.MergeFrom(from.traffic_segment_);
  turn_lanes_.MergeFrom(from.turn_lanes_);
  tagged_value_.MergeFrom(from.tagged_value_);
  switch (from.has_length_km_case()) {
    case kLengthKm: {
      set_length_km(from.length_km());
      break;
    }
    case HAS_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  switch (from.has_speed_case()) {
    case kSpeed: {
      set_speed(from.speed());
      break;
    }
    case HAS_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_road_class_case()) {
    case kRoadClass: {
      set_road_class(from.road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (from.has_begin_heading_case()) {
    case kBeginHeading: {
      set_begin_heading(from.begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_heading_case()) {
    case kEndHeading: {
      set_end_heading(from.end_heading());
      break;
    }
    case HAS_END_HEADING_NOT_SET: {
      break;
    }
  }
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      set_begin_shape_index(from.begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      set_end_shape_index(from.end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_traversability_case()) {
    case kTraversability: {
      set_traversability(from.traversability());
      break;
    }
    case HAS_TRAVERSABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_case()) {
    case kUse: {
      set_use(from.use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (from.has_toll_case()) {
    case kToll: {
      set_toll(from.toll());
      break;
    }
    case HAS_TOLL_NOT_SET: {
      break;
    }
  }
  switch (from.has_unpaved_case()) {
    case kUnpaved: {
      set_unpaved(from.unpaved());
      break;
    }
    case HAS_UNPAVED_NOT_SET: {
      break;
    }
  }
  switch (from.has_tunnel_case()) {
    case kTunnel: {
      set_tunnel(from.tunnel());
      break;
    }
    case HAS_TUNNEL_NOT_SET: {
      break;
    }
  }
  switch (from.has_bridge_case()) {
    case kBridge: {
      set_bridge(from.bridge());
      break;
    }
    case HAS_BRIDGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_roundabout_case()) {
    case kRoundabout: {
      set_roundabout(from.roundabout());
      break;
    }
    case HAS_ROUNDABOUT_NOT_SET: {
      break;
    }
  }
  switch (from.has_internal_intersection_case()) {
    case kInternalIntersection: {
      set_internal_intersection(from.internal_intersection());
      break;
    }
    case HAS_INTERNAL_INTERSECTION_NOT_SET: {
      break;
    }
  }
  switch (from.has_drive_on_left_case()) {
    case kDriveOnLeft: {
      set_drive_on_left(from.drive_on_left());
      break;
    }
    case HAS_DRIVE_ON_LEFT_NOT_SET: {
      break;
    }
  }
  switch (from.has_surface_case()) {
    case kSurface: {
      set_surface(from.surface());
      break;
    }
    case HAS_SURFACE_NOT_SET: {
      break;
    }
  }
  switch (from.has_travel_mode_case()) {
    case kTravelMode: {
      set_travel_mode(from.travel_mode());
      break;
    }
    case HAS_TRAVEL_MODE_NOT_SET: {
      break;
    }
  }
  switch (from.has_vehicle_type_case()) {
    case kVehicleType: {
      set_vehicle_type(from.vehicle_type());
      break;
    }
    case HAS_VEHICLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_pedestrian_type_case()) {
    case kPedestrianType: {
      set_pedestrian_type(from.pedestrian_type());
      break;
    }
    case HAS_PEDESTRIAN_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_bicycle_type_case()) {
    case kBicycleType: {
      set_bicycle_type(from.bicycle_type());
      break;
    }
    case HAS_BICYCLE_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_transit_type_case()) {
    case kTransitType: {
      set_transit_type(from.transit_type());
      break;
    }
    case HAS_TRANSIT_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_id_case()) {
    case kId: {
      set_id(from.id());
      break;
    }
    case HAS_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_way_id_case()) {
    case kWayId: {
      set_way_id(from.way_id());
      break;
    }
    case HAS_WAY_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_weighted_grade_case()) {
    case kWeightedGrade: {
      set_weighted_grade(from.weighted_grade());
      break;
    }
    case HAS_WEIGHTED_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_upward_grade_case()) {
    case kMaxUpwardGrade: {
      set_max_upward_grade(from.max_upward_grade());
      break;
    }
    case HAS_MAX_UPWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_max_downward_grade_case()) {
    case kMaxDownwardGrade: {
      set_max_downward_grade(from.max_downward_grade());
      break;
    }
    case HAS_MAX_DOWNWARD_GRADE_NOT_SET: {
      break;
    }
  }
  switch (from.has_lane_count_case()) {
    case kLaneCount: {
      set_lane_count(from.lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  switch (from.has_cycle_lane_case()) {
    case kCycleLane: {
      set_cycle_lane(from.cycle_lane());
      break;
    }
    case HAS_CYCLE_LANE_NOT_SET: {
      break;
    }
  }
  switch (from.has_bicycle_network_case()) {
    case kBicycleNetwork: {
      set_bicycle_network(from.bicycle_network());
      break;
    }
    case HAS_BICYCLE_NETWORK_NOT_SET: {
      break;
    }
  }
  switch (from.has_sidewalk_case()) {
    case kSidewalk: {
      set_sidewalk(from.sidewalk());
      break;
    }
    case HAS_SIDEWALK_NOT_SET: {
      break;
    }
  }
  switch (from.has_density_case()) {
    case kDensity: {
      set_density(from.density());
      break;
    }
    case HAS_DENSITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_speed_limit_case()) {
    case kSpeedLimit: {
      set_speed_limit(from.speed_limit());
      break;
    }
    case HAS_SPEED_LIMIT_NOT_SET: {
      break;
    }
  }
  switch (from.has_truck_speed_case()) {
    case kTruckSpeed: {
      set_truck_speed(from.truck_speed());
      break;
    }
    case HAS_TRUCK_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_truck_route_case()) {
    case kTruckRoute: {
      set_truck_route(from.truck_route());
      break;
    }
    case HAS_TRUCK_ROUTE_NOT_SET: {
      break;
    }
  }
  switch (from.has_mean_elevation_case()) {
    case kMeanElevation: {
      set_mean_elevation(from.mean_elevation());
      break;
    }
    case HAS_MEAN_ELEVATION_NOT_SET: {
      break;
    }
  }
  switch (from.has_has_time_restrictions_case()) {
    case kHasTimeRestrictions: {
      set_has_time_restrictions(from.has_time_restrictions());
      break;
    }
    case HAS_HAS_TIME_RESTRICTIONS_NOT_SET: {
      break;
    }
  }
  switch (from.has_default_speed_case()) {
    case kDefaultSpeed: {
      set_default_speed(from.default_speed());
      break;
    }
    case HAS_DEFAULT_SPEED_NOT_SET: {
      break;
    }
  }
  switch (from.has_destination_only_case()) {
    case kDestinationOnly: {
      set_destination_only(from.destination_only());
      break;
    }
    case HAS_DESTINATION_ONLY_NOT_SET: {
      break;
    }
  }
  switch (from.has_is_urban_case()) {
    case kIsUrban: {
      set_is_urban(from.is_urban());
      break;
    }
    case HAS_IS_URBAN_NOT_SET: {
      break;
    }
  }
  switch (from.has_source_along_edge_case()) {
    case kSourceAlongEdge: {
      set_source_along_edge(from.source_along_edge());
      break;
    }
    case HAS_SOURCE_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_target_along_edge_case()) {
    case kTargetAlongEdge: {
      set_target_along_edge(from.target_along_edge());
      break;
    }
    case HAS_TARGET_ALONG_EDGE_NOT_SET: {
      break;
    }
  }
  switch (from.has_sac_scale_case()) {
    case kSacScale: {
      set_sac_scale(from.sac_scale());
      break;
    }
    case HAS_SAC_SCALE_NOT_SET: {
      break;
    }
  }
  switch (from.has_shoulder_case()) {
    case kShoulder: {
      set_shoulder(from.shoulder());
      break;
    }
    case HAS_SHOULDER_NOT_SET: {
      break;
    }
  }
  switch (from.has_total_length_km_case()) {
    case kTotalLengthKm: {
      set_total_length_km(from.total_length_km());
      break;
    }
    case HAS_TOTAL_LENGTH_KM_NOT_SET: {
      break;
    }
  }
  if (from.has_sign()) {
    mutable_sign()->::valhalla::TripSign::MergeFrom(from.sign());
  }
  if (from.has_transit_route_info()) {
    mutable_transit_route_info()->::valhalla::TransitRouteInfo::MergeFrom(from.transit_route_info());
  }
  if (from.has_restriction()) {
    mutable_restriction()->::valhalla::TripLeg_Restriction::MergeFrom(from.restriction());
  }
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Edge::IsInitialized() const {

  return true;
}

void TripLeg_Edge::Swap(TripLeg_Edge* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Edge::InternalSwap(TripLeg_Edge* other) {
  name_.UnsafeArenaSwap(&other->name_);
  std::swap(sign_, other->sign_);
  std::swap(transit_route_info_, other->transit_route_info_);
  lane_connectivity_.UnsafeArenaSwap(&other->lane_connectivity_);
  traffic_segment_.UnsafeArenaSwap(&other->traffic_segment_);
  turn_lanes_.UnsafeArenaSwap(&other->turn_lanes_);
  std::swap(restriction_, other->restriction_);
  tagged_value_.UnsafeArenaSwap(&other->tagged_value_);
  std::swap(has_length_km_, other->has_length_km_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_speed_, other->has_speed_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_road_class_, other->has_road_class_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_begin_heading_, other->has_begin_heading_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  std::swap(has_end_heading_, other->has_end_heading_);
  std::swap(_oneof_case_[4], other->_oneof_case_[4]);
  std::swap(has_begin_shape_index_, other->has_begin_shape_index_);
  std::swap(_oneof_case_[5], other->_oneof_case_[5]);
  std::swap(has_end_shape_index_, other->has_end_shape_index_);
  std::swap(_oneof_case_[6], other->_oneof_case_[6]);
  std::swap(has_traversability_, other->has_traversability_);
  std::swap(_oneof_case_[7], other->_oneof_case_[7]);
  std::swap(has_use_, other->has_use_);
  std::swap(_oneof_case_[8], other->_oneof_case_[8]);
  std::swap(has_toll_, other->has_toll_);
  std::swap(_oneof_case_[9], other->_oneof_case_[9]);
  std::swap(has_unpaved_, other->has_unpaved_);
  std::swap(_oneof_case_[10], other->_oneof_case_[10]);
  std::swap(has_tunnel_, other->has_tunnel_);
  std::swap(_oneof_case_[11], other->_oneof_case_[11]);
  std::swap(has_bridge_, other->has_bridge_);
  std::swap(_oneof_case_[12], other->_oneof_case_[12]);
  std::swap(has_roundabout_, other->has_roundabout_);
  std::swap(_oneof_case_[13], other->_oneof_case_[13]);
  std::swap(has_internal_intersection_, other->has_internal_intersection_);
  std::swap(_oneof_case_[14], other->_oneof_case_[14]);
  std::swap(has_drive_on_left_, other->has_drive_on_left_);
  std::swap(_oneof_case_[15], other->_oneof_case_[15]);
  std::swap(has_surface_, other->has_surface_);
  std::swap(_oneof_case_[16], other->_oneof_case_[16]);
  std::swap(has_travel_mode_, other->has_travel_mode_);
  std::swap(_oneof_case_[17], other->_oneof_case_[17]);
  std::swap(has_vehicle_type_, other->has_vehicle_type_);
  std::swap(_oneof_case_[18], other->_oneof_case_[18]);
  std::swap(has_pedestrian_type_, other->has_pedestrian_type_);
  std::swap(_oneof_case_[19], other->_oneof_case_[19]);
  std::swap(has_bicycle_type_, other->has_bicycle_type_);
  std::swap(_oneof_case_[20], other->_oneof_case_[20]);
  std::swap(has_transit_type_, other->has_transit_type_);
  std::swap(_oneof_case_[21], other->_oneof_case_[21]);
  std::swap(has_id_, other->has_id_);
  std::swap(_oneof_case_[22], other->_oneof_case_[22]);
  std::swap(has_way_id_, other->has_way_id_);
  std::swap(_oneof_case_[23], other->_oneof_case_[23]);
  std::swap(has_weighted_grade_, other->has_weighted_grade_);
  std::swap(_oneof_case_[24], other->_oneof_case_[24]);
  std::swap(has_max_upward_grade_, other->has_max_upward_grade_);
  std::swap(_oneof_case_[25], other->_oneof_case_[25]);
  std::swap(has_max_downward_grade_, other->has_max_downward_grade_);
  std::swap(_oneof_case_[26], other->_oneof_case_[26]);
  std::swap(has_lane_count_, other->has_lane_count_);
  std::swap(_oneof_case_[27], other->_oneof_case_[27]);
  std::swap(has_cycle_lane_, other->has_cycle_lane_);
  std::swap(_oneof_case_[28], other->_oneof_case_[28]);
  std::swap(has_bicycle_network_, other->has_bicycle_network_);
  std::swap(_oneof_case_[29], other->_oneof_case_[29]);
  std::swap(has_sidewalk_, other->has_sidewalk_);
  std::swap(_oneof_case_[30], other->_oneof_case_[30]);
  std::swap(has_density_, other->has_density_);
  std::swap(_oneof_case_[31], other->_oneof_case_[31]);
  std::swap(has_speed_limit_, other->has_speed_limit_);
  std::swap(_oneof_case_[32], other->_oneof_case_[32]);
  std::swap(has_truck_speed_, other->has_truck_speed_);
  std::swap(_oneof_case_[33], other->_oneof_case_[33]);
  std::swap(has_truck_route_, other->has_truck_route_);
  std::swap(_oneof_case_[34], other->_oneof_case_[34]);
  std::swap(has_mean_elevation_, other->has_mean_elevation_);
  std::swap(_oneof_case_[35], other->_oneof_case_[35]);
  std::swap(has_has_time_restrictions_, other->has_has_time_restrictions_);
  std::swap(_oneof_case_[36], other->_oneof_case_[36]);
  std::swap(has_default_speed_, other->has_default_speed_);
  std::swap(_oneof_case_[37], other->_oneof_case_[37]);
  std::swap(has_destination_only_, other->has_destination_only_);
  std::swap(_oneof_case_[38], other->_oneof_case_[38]);
  std::swap(has_is_urban_, other->has_is_urban_);
  std::swap(_oneof_case_[39], other->_oneof_case_[39]);
  std::swap(has_source_along_edge_, other->has_source_along_edge_);
  std::swap(_oneof_case_[40], other->_oneof_case_[40]);
  std::swap(has_target_along_edge_, other->has_target_along_edge_);
  std::swap(_oneof_case_[41], other->_oneof_case_[41]);
  std::swap(has_sac_scale_, other->has_sac_scale_);
  std::swap(_oneof_case_[42], other->_oneof_case_[42]);
  std::swap(has_shoulder_, other->has_shoulder_);
  std::swap(_oneof_case_[43], other->_oneof_case_[43]);
  std::swap(has_total_length_km_, other->has_total_length_km_);
  std::swap(_oneof_case_[44], other->_oneof_case_[44]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_IntersectingEdge::kBeginHeadingFieldNumber;
const int TripLeg_IntersectingEdge::kPrevNameConsistencyFieldNumber;
const int TripLeg_IntersectingEdge::kCurrNameConsistencyFieldNumber;
const int TripLeg_IntersectingEdge::kDriveabilityFieldNumber;
const int TripLeg_IntersectingEdge::kCyclabilityFieldNumber;
const int TripLeg_IntersectingEdge::kWalkabilityFieldNumber;
const int TripLeg_IntersectingEdge::kUseFieldNumber;
const int TripLeg_IntersectingEdge::kRoadClassFieldNumber;
const int TripLeg_IntersectingEdge::kLaneCountFieldNumber;
const int TripLeg_IntersectingEdge::kSignFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_IntersectingEdge::TripLeg_IntersectingEdge()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.IntersectingEdge)
}

void TripLeg_IntersectingEdge::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_ = const_cast< ::valhalla::TripSign*>(
      ::valhalla::TripSign::internal_default_instance());
#else
  sign_ = const_cast< ::valhalla::TripSign*>(&::valhalla::TripSign::default_instance());
#endif
}

TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}

void TripLeg_IntersectingEdge::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  sign_ = NULL;
  clear_has_has_begin_heading();
  clear_has_has_prev_name_consistency();
  clear_has_has_curr_name_consistency();
  clear_has_has_driveability();
  clear_has_has_cyclability();
  clear_has_has_walkability();
  clear_has_has_use();
  clear_has_has_road_class();
  clear_has_has_lane_count();
}

TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  SharedDtor();
}

void TripLeg_IntersectingEdge::SharedDtor() {
  if (has_has_begin_heading()) {
    clear_has_begin_heading();
  }
  if (has_has_prev_name_consistency()) {
    clear_has_prev_name_consistency();
  }
  if (has_has_curr_name_consistency()) {
    clear_has_curr_name_consistency();
  }
  if (has_has_driveability()) {
    clear_has_driveability();
  }
  if (has_has_cyclability()) {
    clear_has_cyclability();
  }
  if (has_has_walkability()) {
    clear_has_walkability();
  }
  if (has_has_use()) {
    clear_has_use();
  }
  if (has_has_road_class()) {
    clear_has_road_class();
  }
  if (has_has_lane_count()) {
    clear_has_lane_count();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_;
  }
}

void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_IntersectingEdge& TripLeg_IntersectingEdge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_IntersectingEdge* TripLeg_IntersectingEdge::default_instance_ = NULL;

TripLeg_IntersectingEdge* TripLeg_IntersectingEdge::New(::google::protobuf::Arena* arena) const {
  TripLeg_IntersectingEdge* n = new TripLeg_IntersectingEdge;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_IntersectingEdge::clear_has_begin_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_begin_heading_case()) {
    case kBeginHeading: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_BEGIN_HEADING_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_prev_name_consistency() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_prev_name_consistency_case()) {
    case kPrevNameConsistency: {
      // No need to clear
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_curr_name_consistency() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_curr_name_consistency_case()) {
    case kCurrNameConsistency: {
      // No need to clear
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_driveability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_driveability_case()) {
    case kDriveability: {
      // No need to clear
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_DRIVEABILITY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_cyclability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_cyclability_case()) {
    case kCyclability: {
      // No need to clear
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[4] = HAS_CYCLABILITY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_walkability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_walkability_case()) {
    case kWalkability: {
      // No need to clear
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[5] = HAS_WALKABILITY_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_use() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_use_case()) {
    case kUse: {
      // No need to clear
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[6] = HAS_USE_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_road_class() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_road_class_case()) {
    case kRoadClass: {
      // No need to clear
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[7] = HAS_ROAD_CLASS_NOT_SET;
}

void TripLeg_IntersectingEdge::clear_has_lane_count() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.IntersectingEdge)
  switch(has_lane_count_case()) {
    case kLaneCount: {
      // No need to clear
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[8] = HAS_LANE_COUNT_NOT_SET;
}


void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
  clear_has_begin_heading();
  clear_has_prev_name_consistency();
  clear_has_curr_name_consistency();
  clear_has_driveability();
  clear_has_cyclability();
  clear_has_walkability();
  clear_has_use();
  clear_has_road_class();
  clear_has_lane_count();
}

bool TripLeg_IntersectingEdge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.IntersectingEdge)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 begin_heading = 1;
      case 1: {
        if (tag == 8) {
          clear_has_begin_heading();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_begin_heading_.begin_heading_)));
          set_has_begin_heading();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_prev_name_consistency;
        break;
      }

      // optional bool prev_name_consistency = 2;
      case 2: {
        if (tag == 16) {
         parse_prev_name_consistency:
          clear_has_prev_name_consistency();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_prev_name_consistency_.prev_name_consistency_)));
          set_has_prev_name_consistency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_curr_name_consistency;
        break;
      }

      // optional bool curr_name_consistency = 3;
      case 3: {
        if (tag == 24) {
         parse_curr_name_consistency:
          clear_has_curr_name_consistency();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_curr_name_consistency_.curr_name_consistency_)));
          set_has_curr_name_consistency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_driveability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability driveability = 4;
      case 4: {
        if (tag == 32) {
         parse_driveability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_driveability(static_cast< ::valhalla::TripLeg_Traversability >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_cyclability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability cyclability = 5;
      case 5: {
        if (tag == 40) {
         parse_cyclability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_cyclability(static_cast< ::valhalla::TripLeg_Traversability >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_walkability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability walkability = 6;
      case 6: {
        if (tag == 48) {
         parse_walkability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_walkability(static_cast< ::valhalla::TripLeg_Traversability >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_use;
        break;
      }

      // optional .valhalla.TripLeg.Use use = 7;
      case 7: {
        if (tag == 56) {
         parse_use:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_use(static_cast< ::valhalla::TripLeg_Use >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_road_class;
        break;
      }

      // optional .valhalla.RoadClass road_class = 8;
      case 8: {
        if (tag == 64) {
         parse_road_class:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_road_class(static_cast< ::valhalla::RoadClass >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_lane_count;
        break;
      }

      // optional uint32 lane_count = 9;
      case 9: {
        if (tag == 72) {
         parse_lane_count:
          clear_has_lane_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_lane_count_.lane_count_)));
          set_has_lane_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_sign;
        break;
      }

      // optional .valhalla.TripSign sign = 10;
      case 10: {
        if (tag == 82) {
         parse_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.IntersectingEdge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.IntersectingEdge)
  return false;
#undef DO_
}

void TripLeg_IntersectingEdge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.IntersectingEdge)
  // optional uint32 begin_heading = 1;
  if (has_begin_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->begin_heading(), output);
  }

  // optional bool prev_name_consistency = 2;
  if (has_prev_name_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->prev_name_consistency(), output);
  }

  // optional bool curr_name_consistency = 3;
  if (has_curr_name_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->curr_name_consistency(), output);
  }

  // optional .valhalla.TripLeg.Traversability driveability = 4;
  if (has_driveability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->driveability(), output);
  }

  // optional .valhalla.TripLeg.Traversability cyclability = 5;
  if (has_cyclability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->cyclability(), output);
  }

  // optional .valhalla.TripLeg.Traversability walkability = 6;
  if (has_walkability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->walkability(), output);
  }

  // optional .valhalla.TripLeg.Use use = 7;
  if (has_use()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->use(), output);
  }

  // optional .valhalla.RoadClass road_class = 8;
  if (has_road_class()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->road_class(), output);
  }

  // optional uint32 lane_count = 9;
  if (has_lane_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->lane_count(), output);
  }

  // optional .valhalla.TripSign sign = 10;
  if (this->has_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->sign_, output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.IntersectingEdge)
}

int TripLeg_IntersectingEdge::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
  int total_size = 0;

  // optional .valhalla.TripSign sign = 10;
  if (this->has_sign()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->sign_);
  }

  switch (has_begin_heading_case()) {
    // optional uint32 begin_heading = 1;
    case kBeginHeading: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (has_prev_name_consistency_case()) {
    // optional bool prev_name_consistency = 2;
    case kPrevNameConsistency: {
      total_size += 1 + 1;
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (has_curr_name_consistency_case()) {
    // optional bool curr_name_consistency = 3;
    case kCurrNameConsistency: {
      total_size += 1 + 1;
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (has_driveability_case()) {
    // optional .valhalla.TripLeg.Traversability driveability = 4;
    case kDriveability: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->driveability());
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_cyclability_case()) {
    // optional .valhalla.TripLeg.Traversability cyclability = 5;
    case kCyclability: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cyclability());
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_walkability_case()) {
    // optional .valhalla.TripLeg.Traversability walkability = 6;
    case kWalkability: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->walkability());
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  switch (has_use_case()) {
    // optional .valhalla.TripLeg.Use use = 7;
    case kUse: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (has_road_class_case()) {
    // optional .valhalla.RoadClass road_class = 8;
    case kRoadClass: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (has_lane_count_case()) {
    // optional uint32 lane_count = 9;
    case kLaneCount: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_IntersectingEdge*>(&from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_begin_heading_case()) {
    case kBeginHeading: {
      set_begin_heading(from.begin_heading());
      break;
    }
    case HAS_BEGIN_HEADING_NOT_SET: {
      break;
    }
  }
  switch (from.has_prev_name_consistency_case()) {
    case kPrevNameConsistency: {
      set_prev_name_consistency(from.prev_name_consistency());
      break;
    }
    case HAS_PREV_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (from.has_curr_name_consistency_case()) {
    case kCurrNameConsistency: {
      set_curr_name_consistency(from.curr_name_consistency());
      break;
    }
    case HAS_CURR_NAME_CONSISTENCY_NOT_SET: {
      break;
    }
  }
  switch (from.has_driveability_case()) {
    case kDriveability: {
      set_driveability(from.driveability());
      break;
    }
    case HAS_DRIVEABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_cyclability_case()) {
    case kCyclability: {
      set_cyclability(from.cyclability());
      break;
    }
    case HAS_CYCLABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_walkability_case()) {
    case kWalkability: {
      set_walkability(from.walkability());
      break;
    }
    case HAS_WALKABILITY_NOT_SET: {
      break;
    }
  }
  switch (from.has_use_case()) {
    case kUse: {
      set_use(from.use());
      break;
    }
    case HAS_USE_NOT_SET: {
      break;
    }
  }
  switch (from.has_road_class_case()) {
    case kRoadClass: {
      set_road_class(from.road_class());
      break;
    }
    case HAS_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  switch (from.has_lane_count_case()) {
    case kLaneCount: {
      set_lane_count(from.lane_count());
      break;
    }
    case HAS_LANE_COUNT_NOT_SET: {
      break;
    }
  }
  if (from.has_sign()) {
    mutable_sign()->::valhalla::TripSign::MergeFrom(from.sign());
  }
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_IntersectingEdge::IsInitialized() const {

  return true;
}

void TripLeg_IntersectingEdge::Swap(TripLeg_IntersectingEdge* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* other) {
  std::swap(sign_, other->sign_);
  std::swap(has_begin_heading_, other->has_begin_heading_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_prev_name_consistency_, other->has_prev_name_consistency_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_curr_name_consistency_, other->has_curr_name_consistency_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_driveability_, other->has_driveability_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  std::swap(has_cyclability_, other->has_cyclability_);
  std::swap(_oneof_case_[4], other->_oneof_case_[4]);
  std::swap(has_walkability_, other->has_walkability_);
  std::swap(_oneof_case_[5], other->_oneof_case_[5]);
  std::swap(has_use_, other->has_use_);
  std::swap(_oneof_case_[6], other->_oneof_case_[6]);
  std::swap(has_road_class_, other->has_road_class_);
  std::swap(_oneof_case_[7], other->_oneof_case_[7]);
  std::swap(has_lane_count_, other->has_lane_count_);
  std::swap(_oneof_case_[8], other->_oneof_case_[8]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Cost::kSecondsFieldNumber;
const int TripLeg_Cost::kCostFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Cost::TripLeg_Cost()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Cost)
}

void TripLeg_Cost::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_Cost::TripLeg_Cost(const TripLeg_Cost& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Cost)
}

void TripLeg_Cost::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  clear_has_has_seconds();
  clear_has_has_cost();
}

TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  SharedDtor();
}

void TripLeg_Cost::SharedDtor() {
  if (has_has_seconds()) {
    clear_has_seconds();
  }
  if (has_has_cost()) {
    clear_has_cost();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_Cost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Cost& TripLeg_Cost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Cost* TripLeg_Cost::default_instance_ = NULL;

TripLeg_Cost* TripLeg_Cost::New(::google::protobuf::Arena* arena) const {
  TripLeg_Cost* n = new TripLeg_Cost;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Cost::clear_has_seconds() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Cost)
  switch(has_seconds_case()) {
    case kSeconds: {
      // No need to clear
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_SECONDS_NOT_SET;
}

void TripLeg_Cost::clear_has_cost() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Cost)
  switch(has_cost_case()) {
    case kCost: {
      // No need to clear
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_COST_NOT_SET;
}


void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  clear_has_seconds();
  clear_has_cost();
}

bool TripLeg_Cost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Cost)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double seconds = 1;
      case 1: {
        if (tag == 9) {
          clear_has_seconds();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &has_seconds_.seconds_)));
          set_has_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_cost;
        break;
      }

      // optional double cost = 2;
      case 2: {
        if (tag == 17) {
         parse_cost:
          clear_has_cost();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &has_cost_.cost_)));
          set_has_cost();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Cost)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Cost)
  return false;
#undef DO_
}

void TripLeg_Cost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Cost)
  // optional double seconds = 1;
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->seconds(), output);
  }

  // optional double cost = 2;
  if (has_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->cost(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Cost)
}

int TripLeg_Cost::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
  int total_size = 0;

  switch (has_seconds_case()) {
    // optional double seconds = 1;
    case kSeconds: {
      total_size += 1 + 8;
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  switch (has_cost_case()) {
    // optional double cost = 2;
    case kCost: {
      total_size += 1 + 8;
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Cost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Cost*>(&from));
}

void TripLeg_Cost::MergeFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_seconds_case()) {
    case kSeconds: {
      set_seconds(from.seconds());
      break;
    }
    case HAS_SECONDS_NOT_SET: {
      break;
    }
  }
  switch (from.has_cost_case()) {
    case kCost: {
      set_cost(from.cost());
      break;
    }
    case HAS_COST_NOT_SET: {
      break;
    }
  }
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Cost::IsInitialized() const {

  return true;
}

void TripLeg_Cost::Swap(TripLeg_Cost* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Cost::InternalSwap(TripLeg_Cost* other) {
  std::swap(has_seconds_, other->has_seconds_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_cost_, other->has_cost_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Cost::GetTypeName() const {
  return "valhalla.TripLeg.Cost";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_PathCost::kElapsedCostFieldNumber;
const int TripLeg_PathCost::kTransitionCostFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_PathCost::TripLeg_PathCost()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.PathCost)
}

void TripLeg_PathCost::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  elapsed_cost_ = const_cast< ::valhalla::TripLeg_Cost*>(
      ::valhalla::TripLeg_Cost::internal_default_instance());
#else
  elapsed_cost_ = const_cast< ::valhalla::TripLeg_Cost*>(&::valhalla::TripLeg_Cost::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transition_cost_ = const_cast< ::valhalla::TripLeg_Cost*>(
      ::valhalla::TripLeg_Cost::internal_default_instance());
#else
  transition_cost_ = const_cast< ::valhalla::TripLeg_Cost*>(&::valhalla::TripLeg_Cost::default_instance());
#endif
}

TripLeg_PathCost::TripLeg_PathCost(const TripLeg_PathCost& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}

void TripLeg_PathCost::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  elapsed_cost_ = NULL;
  transition_cost_ = NULL;
}

TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  SharedDtor();
}

void TripLeg_PathCost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete elapsed_cost_;
    delete transition_cost_;
  }
}

void TripLeg_PathCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_PathCost& TripLeg_PathCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_PathCost* TripLeg_PathCost::default_instance_ = NULL;

TripLeg_PathCost* TripLeg_PathCost::New(::google::protobuf::Arena* arena) const {
  TripLeg_PathCost* n = new TripLeg_PathCost;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  if (GetArenaNoVirtual() == NULL && elapsed_cost_ != NULL) delete elapsed_cost_;
  elapsed_cost_ = NULL;
  if (GetArenaNoVirtual() == NULL && transition_cost_ != NULL) delete transition_cost_;
  transition_cost_ = NULL;
}

bool TripLeg_PathCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.PathCost)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_elapsed_cost()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_transition_cost;
        break;
      }

      // optional .valhalla.TripLeg.Cost transition_cost = 2;
      case 2: {
        if (tag == 18) {
         parse_transition_cost:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transition_cost()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.PathCost)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.PathCost)
  return false;
#undef DO_
}

void TripLeg_PathCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.PathCost)
  // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->has_elapsed_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->elapsed_cost_, output);
  }

  // optional .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->has_transition_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->transition_cost_, output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.PathCost)
}

int TripLeg_PathCost::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
  int total_size = 0;

  // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->has_elapsed_cost()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->elapsed_cost_);
  }

  // optional .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->has_transition_cost()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transition_cost_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_PathCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_PathCost*>(&from));
}

void TripLeg_PathCost::MergeFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has_elapsed_cost()) {
    mutable_elapsed_cost()->::valhalla::TripLeg_Cost::MergeFrom(from.elapsed_cost());
  }
  if (from.has_transition_cost()) {
    mutable_transition_cost()->::valhalla::TripLeg_Cost::MergeFrom(from.transition_cost());
  }
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_PathCost::IsInitialized() const {

  return true;
}

void TripLeg_PathCost::Swap(TripLeg_PathCost* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* other) {
  std::swap(elapsed_cost_, other->elapsed_cost_);
  std::swap(transition_cost_, other->transition_cost_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_PathCost::GetTypeName() const {
  return "valhalla.TripLeg.PathCost";
}


// -------------------------------------------------------------------

bool TripLeg_Node_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
const TripLeg_Node_Type TripLeg_Node::kGate;
const TripLeg_Node_Type TripLeg_Node::kBollard;
const TripLeg_Node_Type TripLeg_Node::kTollBooth;
const TripLeg_Node_Type TripLeg_Node::kTransitEgress;
const TripLeg_Node_Type TripLeg_Node::kTransitStation;
const TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
const TripLeg_Node_Type TripLeg_Node::kBikeShare;
const TripLeg_Node_Type TripLeg_Node::kParking;
const TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
const TripLeg_Node_Type TripLeg_Node::kBorderControl;
const TripLeg_Node_Type TripLeg_Node::kTollGantry;
const TripLeg_Node_Type TripLeg_Node::kSumpBuster;
const TripLeg_Node_Type TripLeg_Node::Type_MIN;
const TripLeg_Node_Type TripLeg_Node::Type_MAX;
const int TripLeg_Node::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Node::kEdgeFieldNumber;
const int TripLeg_Node::kIntersectingEdgeFieldNumber;
const int TripLeg_Node::kAdminIndexFieldNumber;
const int TripLeg_Node::kTypeFieldNumber;
const int TripLeg_Node::kForkFieldNumber;
const int TripLeg_Node::kTransitPlatformInfoFieldNumber;
const int TripLeg_Node::kTransitStationInfoFieldNumber;
const int TripLeg_Node::kTransitEgressInfoFieldNumber;
const int TripLeg_Node::kTimeZoneFieldNumber;
const int TripLeg_Node::kCostFieldNumber;
const int TripLeg_Node::kRecostsFieldNumber;
const int TripLeg_Node::kBssInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Node::TripLeg_Node()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Node)
}

void TripLeg_Node::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  edge_ = const_cast< ::valhalla::TripLeg_Edge*>(
      ::valhalla::TripLeg_Edge::internal_default_instance());
#else
  edge_ = const_cast< ::valhalla::TripLeg_Edge*>(&::valhalla::TripLeg_Edge::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_platform_info_ = const_cast< ::valhalla::TransitPlatformInfo*>(
      ::valhalla::TransitPlatformInfo::internal_default_instance());
#else
  transit_platform_info_ = const_cast< ::valhalla::TransitPlatformInfo*>(&::valhalla::TransitPlatformInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_station_info_ = const_cast< ::valhalla::TransitStationInfo*>(
      ::valhalla::TransitStationInfo::internal_default_instance());
#else
  transit_station_info_ = const_cast< ::valhalla::TransitStationInfo*>(&::valhalla::TransitStationInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_egress_info_ = const_cast< ::valhalla::TransitEgressInfo*>(
      ::valhalla::TransitEgressInfo::internal_default_instance());
#else
  transit_egress_info_ = const_cast< ::valhalla::TransitEgressInfo*>(&::valhalla::TransitEgressInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cost_ = const_cast< ::valhalla::TripLeg_PathCost*>(
      ::valhalla::TripLeg_PathCost::internal_default_instance());
#else
  cost_ = const_cast< ::valhalla::TripLeg_PathCost*>(&::valhalla::TripLeg_PathCost::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bss_info_ = const_cast< ::valhalla::BikeShareStationInfo*>(
      ::valhalla::BikeShareStationInfo::internal_default_instance());
#else
  bss_info_ = const_cast< ::valhalla::BikeShareStationInfo*>(&::valhalla::BikeShareStationInfo::default_instance());
#endif
}

TripLeg_Node::TripLeg_Node(const TripLeg_Node& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}

void TripLeg_Node::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  edge_ = NULL;
  transit_platform_info_ = NULL;
  transit_station_info_ = NULL;
  transit_egress_info_ = NULL;
  cost_ = NULL;
  bss_info_ = NULL;
  clear_has_has_admin_index();
  clear_has_has_type();
  clear_has_has_fork();
  clear_has_has_time_zone();
}

TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  SharedDtor();
}

void TripLeg_Node::SharedDtor() {
  if (has_has_admin_index()) {
    clear_has_admin_index();
  }
  if (has_has_type()) {
    clear_has_type();
  }
  if (has_has_fork()) {
    clear_has_fork();
  }
  if (has_has_time_zone()) {
    clear_has_time_zone();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete edge_;
    delete transit_platform_info_;
    delete transit_station_info_;
    delete transit_egress_info_;
    delete cost_;
    delete bss_info_;
  }
}

void TripLeg_Node::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Node& TripLeg_Node::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Node* TripLeg_Node::default_instance_ = NULL;

TripLeg_Node* TripLeg_Node::New(::google::protobuf::Arena* arena) const {
  TripLeg_Node* n = new TripLeg_Node;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Node::clear_has_admin_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch(has_admin_index_case()) {
    case kAdminIndex: {
      // No need to clear
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_ADMIN_INDEX_NOT_SET;
}

void TripLeg_Node::clear_has_type() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch(has_type_case()) {
    case kType: {
      // No need to clear
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_TYPE_NOT_SET;
}

void TripLeg_Node::clear_has_fork() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch(has_fork_case()) {
    case kFork: {
      // No need to clear
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_FORK_NOT_SET;
}

void TripLeg_Node::clear_has_time_zone() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Node)
  switch(has_time_zone_case()) {
    case kTimeZone: {
      has_time_zone_.time_zone_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_TIME_ZONE_NOT_SET;
}


void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) delete edge_;
  edge_ = NULL;
  if (GetArenaNoVirtual() == NULL && transit_platform_info_ != NULL) delete transit_platform_info_;
  transit_platform_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && transit_station_info_ != NULL) delete transit_station_info_;
  transit_station_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && transit_egress_info_ != NULL) delete transit_egress_info_;
  transit_egress_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && cost_ != NULL) delete cost_;
  cost_ = NULL;
  if (GetArenaNoVirtual() == NULL && bss_info_ != NULL) delete bss_info_;
  bss_info_ = NULL;
  intersecting_edge_.Clear();
  recosts_.Clear();
  clear_has_admin_index();
  clear_has_type();
  clear_has_fork();
  clear_has_time_zone();
}

bool TripLeg_Node::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Node)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .valhalla.TripLeg.Edge edge = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_edge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_intersecting_edge;
        break;
      }

      // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
      case 2: {
        if (tag == 18) {
         parse_intersecting_edge:
          DO_(input->IncrementRecursionDepth());
         parse_loop_intersecting_edge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_intersecting_edge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_intersecting_edge;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_admin_index;
        break;
      }

      // optional uint32 admin_index = 3;
      case 3: {
        if (tag == 24) {
         parse_admin_index:
          clear_has_admin_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_admin_index_.admin_index_)));
          set_has_admin_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional .valhalla.TripLeg.Node.Type type = 4;
      case 4: {
        if (tag == 32) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::valhalla::TripLeg_Node_Type >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_fork;
        break;
      }

      // optional bool fork = 5;
      case 5: {
        if (tag == 40) {
         parse_fork:
          clear_has_fork();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_fork_.fork_)));
          set_has_fork();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_transit_platform_info;
        break;
      }

      // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
      case 6: {
        if (tag == 50) {
         parse_transit_platform_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_platform_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_transit_station_info;
        break;
      }

      // optional .valhalla.TransitStationInfo transit_station_info = 7;
      case 7: {
        if (tag == 58) {
         parse_transit_station_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_station_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_transit_egress_info;
        break;
      }

      // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
      case 10: {
        if (tag == 82) {
         parse_transit_egress_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_egress_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_time_zone;
        break;
      }

      // optional string time_zone = 11;
      case 11: {
        if (tag == 90) {
         parse_time_zone:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_time_zone()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->time_zone().data(), this->time_zone().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.Node.time_zone"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_cost;
        break;
      }

      // optional .valhalla.TripLeg.PathCost cost = 12;
      case 12: {
        if (tag == 98) {
         parse_cost:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cost()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_recosts;
        break;
      }

      // repeated .valhalla.TripLeg.PathCost recosts = 13;
      case 13: {
        if (tag == 106) {
         parse_recosts:
          DO_(input->IncrementRecursionDepth());
         parse_loop_recosts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_recosts()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_loop_recosts;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(114)) goto parse_bss_info;
        break;
      }

      // optional .valhalla.BikeShareStationInfo bss_info = 14;
      case 14: {
        if (tag == 114) {
         parse_bss_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bss_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Node)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Node)
  return false;
#undef DO_
}

void TripLeg_Node::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Node)
  // optional .valhalla.TripLeg.Edge edge = 1;
  if (this->has_edge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->edge_, output);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (unsigned int i = 0, n = this->intersecting_edge_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->intersecting_edge(i), output);
  }

  // optional uint32 admin_index = 3;
  if (has_admin_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->admin_index(), output);
  }

  // optional .valhalla.TripLeg.Node.Type type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional bool fork = 5;
  if (has_fork()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->fork(), output);
  }

  // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->has_transit_platform_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->transit_platform_info_, output);
  }

  // optional .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->has_transit_station_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->transit_station_info_, output);
  }

  // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->has_transit_egress_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->transit_egress_info_, output);
  }

  // optional string time_zone = 11;
  if (has_time_zone()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->time_zone().data(), this->time_zone().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Node.time_zone");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->time_zone(), output);
  }

  // optional .valhalla.TripLeg.PathCost cost = 12;
  if (this->has_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, *this->cost_, output);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  for (unsigned int i = 0, n = this->recosts_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->recosts(i), output);
  }

  // optional .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->has_bss_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, *this->bss_info_, output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Node)
}

int TripLeg_Node::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
  int total_size = 0;

  // optional .valhalla.TripLeg.Edge edge = 1;
  if (this->has_edge()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->edge_);
  }

  // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->has_transit_platform_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transit_platform_info_);
  }

  // optional .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->has_transit_station_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transit_station_info_);
  }

  // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->has_transit_egress_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transit_egress_info_);
  }

  // optional .valhalla.TripLeg.PathCost cost = 12;
  if (this->has_cost()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->cost_);
  }

  // optional .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->has_bss_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bss_info_);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1 * this->intersecting_edge_size();
  for (int i = 0; i < this->intersecting_edge_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->intersecting_edge(i));
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  total_size += 1 * this->recosts_size();
  for (int i = 0; i < this->recosts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->recosts(i));
  }

  switch (has_admin_index_case()) {
    // optional uint32 admin_index = 3;
    case kAdminIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->admin_index());
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_type_case()) {
    // optional .valhalla.TripLeg.Node.Type type = 4;
    case kType: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  switch (has_fork_case()) {
    // optional bool fork = 5;
    case kFork: {
      total_size += 1 + 1;
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  switch (has_time_zone_case()) {
    // optional string time_zone = 11;
    case kTimeZone: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->time_zone());
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Node*>(&from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  intersecting_edge_.MergeFrom(from.intersecting_edge_);
  recosts_.MergeFrom(from.recosts_);
  switch (from.has_admin_index_case()) {
    case kAdminIndex: {
      set_admin_index(from.admin_index());
      break;
    }
    case HAS_ADMIN_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_type_case()) {
    case kType: {
      set_type(from.type());
      break;
    }
    case HAS_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.has_fork_case()) {
    case kFork: {
      set_fork(from.fork());
      break;
    }
    case HAS_FORK_NOT_SET: {
      break;
    }
  }
  switch (from.has_time_zone_case()) {
    case kTimeZone: {
      set_time_zone(from.time_zone());
      break;
    }
    case HAS_TIME_ZONE_NOT_SET: {
      break;
    }
  }
  if (from.has_edge()) {
    mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(from.edge());
  }
  if (from.has_transit_platform_info()) {
    mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(from.transit_platform_info());
  }
  if (from.has_transit_station_info()) {
    mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(from.transit_station_info());
  }
  if (from.has_transit_egress_info()) {
    mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(from.transit_egress_info());
  }
  if (from.has_cost()) {
    mutable_cost()->::valhalla::TripLeg_PathCost::MergeFrom(from.cost());
  }
  if (from.has_bss_info()) {
    mutable_bss_info()->::valhalla::BikeShareStationInfo::MergeFrom(from.bss_info());
  }
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Node::IsInitialized() const {

  return true;
}

void TripLeg_Node::Swap(TripLeg_Node* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Node::InternalSwap(TripLeg_Node* other) {
  std::swap(edge_, other->edge_);
  intersecting_edge_.UnsafeArenaSwap(&other->intersecting_edge_);
  std::swap(transit_platform_info_, other->transit_platform_info_);
  std::swap(transit_station_info_, other->transit_station_info_);
  std::swap(transit_egress_info_, other->transit_egress_info_);
  std::swap(cost_, other->cost_);
  recosts_.UnsafeArenaSwap(&other->recosts_);
  std::swap(bss_info_, other->bss_info_);
  std::swap(has_admin_index_, other->has_admin_index_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_type_, other->has_type_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_fork_, other->has_fork_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_time_zone_, other->has_time_zone_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Admin::kCountryCodeFieldNumber;
const int TripLeg_Admin::kCountryTextFieldNumber;
const int TripLeg_Admin::kStateCodeFieldNumber;
const int TripLeg_Admin::kStateTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Admin::TripLeg_Admin()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Admin)
}

void TripLeg_Admin::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}

void TripLeg_Admin::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  clear_has_has_country_code();
  clear_has_has_country_text();
  clear_has_has_state_code();
  clear_has_has_state_text();
}

TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  SharedDtor();
}

void TripLeg_Admin::SharedDtor() {
  if (has_has_country_code()) {
    clear_has_country_code();
  }
  if (has_has_country_text()) {
    clear_has_country_text();
  }
  if (has_has_state_code()) {
    clear_has_state_code();
  }
  if (has_has_state_text()) {
    clear_has_state_text();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_Admin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Admin& TripLeg_Admin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Admin* TripLeg_Admin::default_instance_ = NULL;

TripLeg_Admin* TripLeg_Admin::New(::google::protobuf::Arena* arena) const {
  TripLeg_Admin* n = new TripLeg_Admin;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Admin::clear_has_country_code() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch(has_country_code_case()) {
    case kCountryCode: {
      has_country_code_.country_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_COUNTRY_CODE_NOT_SET;
}

void TripLeg_Admin::clear_has_country_text() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch(has_country_text_case()) {
    case kCountryText: {
      has_country_text_.country_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_COUNTRY_TEXT_NOT_SET;
}

void TripLeg_Admin::clear_has_state_code() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch(has_state_code_case()) {
    case kStateCode: {
      has_state_code_.state_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_STATE_CODE_NOT_SET;
}

void TripLeg_Admin::clear_has_state_text() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Admin)
  switch(has_state_text_case()) {
    case kStateText: {
      has_state_text_.state_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_STATE_TEXT_NOT_SET;
}


void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  clear_has_country_code();
  clear_has_country_text();
  clear_has_state_code();
  clear_has_state_text();
}

bool TripLeg_Admin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Admin)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string country_code = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country_code()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->country_code().data(), this->country_code().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.Admin.country_code"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_country_text;
        break;
      }

      // optional string country_text = 2;
      case 2: {
        if (tag == 18) {
         parse_country_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->country_text().data(), this->country_text().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.Admin.country_text"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_state_code;
        break;
      }

      // optional string state_code = 3;
      case 3: {
        if (tag == 26) {
         parse_state_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state_code()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->state_code().data(), this->state_code().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.Admin.state_code"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_state_text;
        break;
      }

      // optional string state_text = 4;
      case 4: {
        if (tag == 34) {
         parse_state_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->state_text().data(), this->state_text().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.Admin.state_text"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Admin)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Admin)
  return false;
#undef DO_
}

void TripLeg_Admin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Admin)
  // optional string country_code = 1;
  if (has_country_code()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->country_code().data(), this->country_code().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_code");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->country_code(), output);
  }

  // optional string country_text = 2;
  if (has_country_text()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->country_text().data(), this->country_text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->country_text(), output);
  }

  // optional string state_code = 3;
  if (has_state_code()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->state_code().data(), this->state_code().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_code");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->state_code(), output);
  }

  // optional string state_text = 4;
  if (has_state_text()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->state_text().data(), this->state_text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->state_text(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Admin)
}

int TripLeg_Admin::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
  int total_size = 0;

  switch (has_country_code_case()) {
    // optional string country_code = 1;
    case kCountryCode: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->country_code());
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  switch (has_country_text_case()) {
    // optional string country_text = 2;
    case kCountryText: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->country_text());
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  switch (has_state_code_case()) {
    // optional string state_code = 3;
    case kStateCode: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state_code());
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  switch (has_state_text_case()) {
    // optional string state_text = 4;
    case kStateText: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state_text());
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Admin*>(&from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_country_code_case()) {
    case kCountryCode: {
      set_country_code(from.country_code());
      break;
    }
    case HAS_COUNTRY_CODE_NOT_SET: {
      break;
    }
  }
  switch (from.has_country_text_case()) {
    case kCountryText: {
      set_country_text(from.country_text());
      break;
    }
    case HAS_COUNTRY_TEXT_NOT_SET: {
      break;
    }
  }
  switch (from.has_state_code_case()) {
    case kStateCode: {
      set_state_code(from.state_code());
      break;
    }
    case HAS_STATE_CODE_NOT_SET: {
      break;
    }
  }
  switch (from.has_state_text_case()) {
    case kStateText: {
      set_state_text(from.state_text());
      break;
    }
    case HAS_STATE_TEXT_NOT_SET: {
      break;
    }
  }
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Admin::IsInitialized() const {

  return true;
}

void TripLeg_Admin::Swap(TripLeg_Admin* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Admin::InternalSwap(TripLeg_Admin* other) {
  std::swap(has_country_code_, other->has_country_code_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_country_text_, other->has_country_text_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_state_code_, other->has_state_code_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_state_text_, other->has_state_text_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_ShapeAttributes::kTimeFieldNumber;
const int TripLeg_ShapeAttributes::kLengthFieldNumber;
const int TripLeg_ShapeAttributes::kSpeedFieldNumber;
const int TripLeg_ShapeAttributes::kSpeedLimitFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.ShapeAttributes)
}

void TripLeg_ShapeAttributes::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}

void TripLeg_ShapeAttributes::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  SharedDtor();
}

void TripLeg_ShapeAttributes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_ShapeAttributes& TripLeg_ShapeAttributes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_ShapeAttributes* TripLeg_ShapeAttributes::default_instance_ = NULL;

TripLeg_ShapeAttributes* TripLeg_ShapeAttributes::New(::google::protobuf::Arena* arena) const {
  TripLeg_ShapeAttributes* n = new TripLeg_ShapeAttributes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  time_.Clear();
  length_.Clear();
  speed_.Clear();
  speed_limit_.Clear();
}

bool TripLeg_ShapeAttributes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.ShapeAttributes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 time = 1 [packed = true];
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_time())));
        } else if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_time())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_length;
        break;
      }

      // repeated uint32 length = 2 [packed = true];
      case 2: {
        if (tag == 18) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_length())));
        } else if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 18, input, this->mutable_length())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_speed;
        break;
      }

      // repeated uint32 speed = 3 [packed = true];
      case 3: {
        if (tag == 26) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_speed())));
        } else if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 26, input, this->mutable_speed())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_speed_limit;
        break;
      }

      // repeated uint32 speed_limit = 5 [packed = true];
      case 5: {
        if (tag == 42) {
         parse_speed_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_speed_limit())));
        } else if (tag == 40) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 42, input, this->mutable_speed_limit())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.ShapeAttributes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.ShapeAttributes)
  return false;
#undef DO_
}

void TripLeg_ShapeAttributes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.ShapeAttributes)
  // repeated uint32 time = 1 [packed = true];
  if (this->time_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_time_cached_byte_size_);
  }
  for (int i = 0; i < this->time_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->time(i), output);
  }

  // repeated uint32 length = 2 [packed = true];
  if (this->length_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_length_cached_byte_size_);
  }
  for (int i = 0; i < this->length_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->length(i), output);
  }

  // repeated uint32 speed = 3 [packed = true];
  if (this->speed_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_speed_cached_byte_size_);
  }
  for (int i = 0; i < this->speed_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->speed(i), output);
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  if (this->speed_limit_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_speed_limit_cached_byte_size_);
  }
  for (int i = 0; i < this->speed_limit_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->speed_limit(i), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.ShapeAttributes)
}

int TripLeg_ShapeAttributes::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
  int total_size = 0;

  // repeated uint32 time = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->time_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->time(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _time_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->length_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->length(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _length_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->speed_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->speed(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _speed_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->speed_limit_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->speed_limit(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _speed_limit_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_ShapeAttributes*>(&from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  time_.MergeFrom(from.time_);
  length_.MergeFrom(from.length_);
  speed_.MergeFrom(from.speed_);
  speed_limit_.MergeFrom(from.speed_limit_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_ShapeAttributes::IsInitialized() const {

  return true;
}

void TripLeg_ShapeAttributes::Swap(TripLeg_ShapeAttributes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* other) {
  time_.UnsafeArenaSwap(&other->time_);
  length_.UnsafeArenaSwap(&other->length_);
  speed_.UnsafeArenaSwap(&other->speed_);
  speed_limit_.UnsafeArenaSwap(&other->speed_limit_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Incident::kMetadataFieldNumber;
const int TripLeg_Incident::kBeginShapeIndexFieldNumber;
const int TripLeg_Incident::kEndShapeIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Incident::TripLeg_Incident()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Incident)
}

void TripLeg_Incident::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  metadata_ = const_cast< ::valhalla::IncidentsTile_Metadata*>(
      ::valhalla::IncidentsTile_Metadata::internal_default_instance());
#else
  metadata_ = const_cast< ::valhalla::IncidentsTile_Metadata*>(&::valhalla::IncidentsTile_Metadata::default_instance());
#endif
}

TripLeg_Incident::TripLeg_Incident(const TripLeg_Incident& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}

void TripLeg_Incident::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  metadata_ = NULL;
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
}

TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  SharedDtor();
}

void TripLeg_Incident::SharedDtor() {
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete metadata_;
  }
}

void TripLeg_Incident::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Incident& TripLeg_Incident::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Incident* TripLeg_Incident::default_instance_ = NULL;

TripLeg_Incident* TripLeg_Incident::New(::google::protobuf::Arena* arena) const {
  TripLeg_Incident* n = new TripLeg_Incident;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Incident::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Incident)
  switch(has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Incident::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Incident)
  switch(has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
  clear_has_begin_shape_index();
  clear_has_end_shape_index();
}

bool TripLeg_Incident::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Incident)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .valhalla.IncidentsTile.Metadata metadata = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_metadata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_begin_shape_index;
        break;
      }

      // optional uint32 begin_shape_index = 3;
      case 3: {
        if (tag == 24) {
         parse_begin_shape_index:
          clear_has_begin_shape_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_begin_shape_index_.begin_shape_index_)));
          set_has_begin_shape_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_end_shape_index;
        break;
      }

      // optional uint32 end_shape_index = 4;
      case 4: {
        if (tag == 32) {
         parse_end_shape_index:
          clear_has_end_shape_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_end_shape_index_.end_shape_index_)));
          set_has_end_shape_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Incident)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Incident)
  return false;
#undef DO_
}

void TripLeg_Incident::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Incident)
  // optional .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->has_metadata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->metadata_, output);
  }

  // optional uint32 begin_shape_index = 3;
  if (has_begin_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->begin_shape_index(), output);
  }

  // optional uint32 end_shape_index = 4;
  if (has_end_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->end_shape_index(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Incident)
}

int TripLeg_Incident::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
  int total_size = 0;

  // optional .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->has_metadata()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->metadata_);
  }

  switch (has_begin_shape_index_case()) {
    // optional uint32 begin_shape_index = 3;
    case kBeginShapeIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // optional uint32 end_shape_index = 4;
    case kEndShapeIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Incident::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Incident*>(&from));
}

void TripLeg_Incident::MergeFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      set_begin_shape_index(from.begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      set_end_shape_index(from.end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  if (from.has_metadata()) {
    mutable_metadata()->::valhalla::IncidentsTile_Metadata::MergeFrom(from.metadata());
  }
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Incident::IsInitialized() const {

  return true;
}

void TripLeg_Incident::Swap(TripLeg_Incident* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Incident::InternalSwap(TripLeg_Incident* other) {
  std::swap(metadata_, other->metadata_);
  std::swap(has_begin_shape_index_, other->has_begin_shape_index_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_end_shape_index_, other->has_end_shape_index_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Incident::GetTypeName() const {
  return "valhalla.TripLeg.Incident";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg_Closure::kBeginShapeIndexFieldNumber;
const int TripLeg_Closure::kEndShapeIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg_Closure::TripLeg_Closure()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg.Closure)
}

void TripLeg_Closure::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripLeg_Closure::TripLeg_Closure(const TripLeg_Closure& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}

void TripLeg_Closure::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  clear_has_has_begin_shape_index();
  clear_has_has_end_shape_index();
}

TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  SharedDtor();
}

void TripLeg_Closure::SharedDtor() {
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_Closure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Closure& TripLeg_Closure::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Closure* TripLeg_Closure::default_instance_ = NULL;

TripLeg_Closure* TripLeg_Closure::New(::google::protobuf::Arena* arena) const {
  TripLeg_Closure* n = new TripLeg_Closure;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg_Closure::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch(has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Closure::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch(has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  clear_has_begin_shape_index();
  clear_has_end_shape_index();
}

bool TripLeg_Closure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg.Closure)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 begin_shape_index = 1;
      case 1: {
        if (tag == 8) {
          clear_has_begin_shape_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_begin_shape_index_.begin_shape_index_)));
          set_has_begin_shape_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_end_shape_index;
        break;
      }

      // optional uint32 end_shape_index = 2;
      case 2: {
        if (tag == 16) {
         parse_end_shape_index:
          clear_has_end_shape_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_end_shape_index_.end_shape_index_)));
          set_has_end_shape_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg.Closure)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg.Closure)
  return false;
#undef DO_
}

void TripLeg_Closure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg.Closure)
  // optional uint32 begin_shape_index = 1;
  if (has_begin_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->begin_shape_index(), output);
  }

  // optional uint32 end_shape_index = 2;
  if (has_end_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->end_shape_index(), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg.Closure)
}

int TripLeg_Closure::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
  int total_size = 0;

  switch (has_begin_shape_index_case()) {
    // optional uint32 begin_shape_index = 1;
    case kBeginShapeIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // optional uint32 end_shape_index = 2;
    case kEndShapeIndex: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Closure::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Closure*>(&from));
}

void TripLeg_Closure::MergeFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      set_begin_shape_index(from.begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      set_end_shape_index(from.end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Closure::IsInitialized() const {

  return true;
}

void TripLeg_Closure::Swap(TripLeg_Closure* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg_Closure::InternalSwap(TripLeg_Closure* other) {
  std::swap(has_begin_shape_index_, other->has_begin_shape_index_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_end_shape_index_, other->has_end_shape_index_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg_Closure::GetTypeName() const {
  return "valhalla.TripLeg.Closure";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripLeg::kOsmChangesetFieldNumber;
const int TripLeg::kTripIdFieldNumber;
const int TripLeg::kLegIdFieldNumber;
const int TripLeg::kLegCountFieldNumber;
const int TripLeg::kLocationFieldNumber;
const int TripLeg::kNodeFieldNumber;
const int TripLeg::kAdminFieldNumber;
const int TripLeg::kShapeFieldNumber;
const int TripLeg::kBboxFieldNumber;
const int TripLeg::kShapeAttributesFieldNumber;
const int TripLeg::kIncidentsFieldNumber;
const int TripLeg::kAlgorithmsFieldNumber;
const int TripLeg::kClosuresFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripLeg::TripLeg()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripLeg)
}

void TripLeg::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bbox_ = const_cast< ::valhalla::BoundingBox*>(
      ::valhalla::BoundingBox::internal_default_instance());
#else
  bbox_ = const_cast< ::valhalla::BoundingBox*>(&::valhalla::BoundingBox::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  shape_attributes_ = const_cast< ::valhalla::TripLeg_ShapeAttributes*>(
      ::valhalla::TripLeg_ShapeAttributes::internal_default_instance());
#else
  shape_attributes_ = const_cast< ::valhalla::TripLeg_ShapeAttributes*>(&::valhalla::TripLeg_ShapeAttributes::default_instance());
#endif
}

TripLeg::TripLeg(const TripLeg& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}

void TripLeg::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  bbox_ = NULL;
  shape_attributes_ = NULL;
  clear_has_has_osm_changeset();
  clear_has_has_trip_id();
  clear_has_has_leg_id();
  clear_has_has_leg_count();
  clear_has_has_shape();
}

TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  SharedDtor();
}

void TripLeg::SharedDtor() {
  if (has_has_osm_changeset()) {
    clear_has_osm_changeset();
  }
  if (has_has_trip_id()) {
    clear_has_trip_id();
  }
  if (has_has_leg_id()) {
    clear_has_leg_id();
  }
  if (has_has_leg_count()) {
    clear_has_leg_count();
  }
  if (has_has_shape()) {
    clear_has_shape();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete bbox_;
    delete shape_attributes_;
  }
}

void TripLeg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg& TripLeg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg* TripLeg::default_instance_ = NULL;

TripLeg* TripLeg::New(::google::protobuf::Arena* arena) const {
  TripLeg* n = new TripLeg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripLeg::clear_has_osm_changeset() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch(has_osm_changeset_case()) {
    case kOsmChangeset: {
      // No need to clear
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_OSM_CHANGESET_NOT_SET;
}

void TripLeg::clear_has_trip_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch(has_trip_id_case()) {
    case kTripId: {
      // No need to clear
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_TRIP_ID_NOT_SET;
}

void TripLeg::clear_has_leg_id() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch(has_leg_id_case()) {
    case kLegId: {
      // No need to clear
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[2] = HAS_LEG_ID_NOT_SET;
}

void TripLeg::clear_has_leg_count() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch(has_leg_count_case()) {
    case kLegCount: {
      // No need to clear
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[3] = HAS_LEG_COUNT_NOT_SET;
}

void TripLeg::clear_has_shape() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg)
  switch(has_shape_case()) {
    case kShape: {
      has_shape_.shape_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[4] = HAS_SHAPE_NOT_SET;
}


void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) delete bbox_;
  bbox_ = NULL;
  if (GetArenaNoVirtual() == NULL && shape_attributes_ != NULL) delete shape_attributes_;
  shape_attributes_ = NULL;
  location_.Clear();
  node_.Clear();
  admin_.Clear();
  incidents_.Clear();
  algorithms_.Clear();
  closures_.Clear();
  clear_has_osm_changeset();
  clear_has_trip_id();
  clear_has_leg_id();
  clear_has_leg_count();
  clear_has_shape();
}

bool TripLeg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripLeg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 osm_changeset = 1;
      case 1: {
        if (tag == 8) {
          clear_has_osm_changeset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &has_osm_changeset_.osm_changeset_)));
          set_has_osm_changeset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_trip_id;
        break;
      }

      // optional uint64 trip_id = 2;
      case 2: {
        if (tag == 16) {
         parse_trip_id:
          clear_has_trip_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &has_trip_id_.trip_id_)));
          set_has_trip_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_leg_id;
        break;
      }

      // optional uint32 leg_id = 3;
      case 3: {
        if (tag == 24) {
         parse_leg_id:
          clear_has_leg_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_leg_id_.leg_id_)));
          set_has_leg_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_leg_count;
        break;
      }

      // optional uint32 leg_count = 4;
      case 4: {
        if (tag == 32) {
         parse_leg_count:
          clear_has_leg_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_leg_count_.leg_count_)));
          set_has_leg_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_location;
        break;
      }

      // repeated .valhalla.Location location = 5;
      case 5: {
        if (tag == 42) {
         parse_location:
          DO_(input->IncrementRecursionDepth());
         parse_loop_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_location;
        if (input->ExpectTag(50)) goto parse_loop_node;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .valhalla.TripLeg.Node node = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_node()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_node;
        if (input->ExpectTag(58)) goto parse_loop_admin;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .valhalla.TripLeg.Admin admin = 7;
      case 7: {
        if (tag == 58) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_admin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_admin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_admin;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(66)) goto parse_shape;
        break;
      }

      // optional string shape = 8;
      case 8: {
        if (tag == 66) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_shape()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->shape().data(), this->shape().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.shape"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_bbox;
        break;
      }

      // optional .valhalla.BoundingBox bbox = 9;
      case 9: {
        if (tag == 74) {
         parse_bbox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bbox()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_shape_attributes;
        break;
      }

      // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
      case 10: {
        if (tag == 82) {
         parse_shape_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shape_attributes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_incidents;
        break;
      }

      // repeated .valhalla.TripLeg.Incident incidents = 11;
      case 11: {
        if (tag == 90) {
         parse_incidents:
          DO_(input->IncrementRecursionDepth());
         parse_loop_incidents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_incidents()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_loop_incidents;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(98)) goto parse_algorithms;
        break;
      }

      // repeated string algorithms = 12;
      case 12: {
        if (tag == 98) {
         parse_algorithms:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_algorithms()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->algorithms(this->algorithms_size() - 1).data(),
            this->algorithms(this->algorithms_size() - 1).length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "valhalla.TripLeg.algorithms"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_algorithms;
        if (input->ExpectTag(106)) goto parse_closures;
        break;
      }

      // repeated .valhalla.TripLeg.Closure closures = 13;
      case 13: {
        if (tag == 106) {
         parse_closures:
          DO_(input->IncrementRecursionDepth());
         parse_loop_closures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_closures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_loop_closures;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripLeg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripLeg)
  return false;
#undef DO_
}

void TripLeg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripLeg)
  // optional uint64 osm_changeset = 1;
  if (has_osm_changeset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->osm_changeset(), output);
  }

  // optional uint64 trip_id = 2;
  if (has_trip_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->trip_id(), output);
  }

  // optional uint32 leg_id = 3;
  if (has_leg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->leg_id(), output);
  }

  // optional uint32 leg_count = 4;
  if (has_leg_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->leg_count(), output);
  }

  // repeated .valhalla.Location location = 5;
  for (unsigned int i = 0, n = this->location_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->location(i), output);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (unsigned int i = 0, n = this->node_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->node(i), output);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (unsigned int i = 0, n = this->admin_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->admin(i), output);
  }

  // optional string shape = 8;
  if (has_shape()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->shape().data(), this->shape().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.shape");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->shape(), output);
  }

  // optional .valhalla.BoundingBox bbox = 9;
  if (this->has_bbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, *this->bbox_, output);
  }

  // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->has_shape_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->shape_attributes_, output);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  for (unsigned int i = 0, n = this->incidents_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->incidents(i), output);
  }

  // repeated string algorithms = 12;
  for (int i = 0; i < this->algorithms_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->algorithms(i).data(), this->algorithms(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.algorithms");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->algorithms(i), output);
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  for (unsigned int i = 0, n = this->closures_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->closures(i), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripLeg)
}

int TripLeg::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
  int total_size = 0;

  // optional .valhalla.BoundingBox bbox = 9;
  if (this->has_bbox()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bbox_);
  }

  // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->has_shape_attributes()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->shape_attributes_);
  }

  // repeated .valhalla.Location location = 5;
  total_size += 1 * this->location_size();
  for (int i = 0; i < this->location_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->location(i));
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1 * this->node_size();
  for (int i = 0; i < this->node_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->node(i));
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1 * this->admin_size();
  for (int i = 0; i < this->admin_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->admin(i));
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  total_size += 1 * this->incidents_size();
  for (int i = 0; i < this->incidents_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->incidents(i));
  }

  // repeated string algorithms = 12;
  total_size += 1 * this->algorithms_size();
  for (int i = 0; i < this->algorithms_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->algorithms(i));
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  total_size += 1 * this->closures_size();
  for (int i = 0; i < this->closures_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->closures(i));
  }

  switch (has_osm_changeset_case()) {
    // optional uint64 osm_changeset = 1;
    case kOsmChangeset: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->osm_changeset());
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  switch (has_trip_id_case()) {
    // optional uint64 trip_id = 2;
    case kTripId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->trip_id());
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  switch (has_leg_id_case()) {
    // optional uint32 leg_id = 3;
    case kLegId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leg_id());
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  switch (has_leg_count_case()) {
    // optional uint32 leg_count = 4;
    case kLegCount: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leg_count());
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  switch (has_shape_case()) {
    // optional string shape = 8;
    case kShape: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->shape());
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg*>(&from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  location_.MergeFrom(from.location_);
  node_.MergeFrom(from.node_);
  admin_.MergeFrom(from.admin_);
  incidents_.MergeFrom(from.incidents_);
  algorithms_.MergeFrom(from.algorithms_);
  closures_.MergeFrom(from.closures_);
  switch (from.has_osm_changeset_case()) {
    case kOsmChangeset: {
      set_osm_changeset(from.osm_changeset());
      break;
    }
    case HAS_OSM_CHANGESET_NOT_SET: {
      break;
    }
  }
  switch (from.has_trip_id_case()) {
    case kTripId: {
      set_trip_id(from.trip_id());
      break;
    }
    case HAS_TRIP_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_leg_id_case()) {
    case kLegId: {
      set_leg_id(from.leg_id());
      break;
    }
    case HAS_LEG_ID_NOT_SET: {
      break;
    }
  }
  switch (from.has_leg_count_case()) {
    case kLegCount: {
      set_leg_count(from.leg_count());
      break;
    }
    case HAS_LEG_COUNT_NOT_SET: {
      break;
    }
  }
  switch (from.has_shape_case()) {
    case kShape: {
      set_shape(from.shape());
      break;
    }
    case HAS_SHAPE_NOT_SET: {
      break;
    }
  }
  if (from.has_bbox()) {
    mutable_bbox()->::valhalla::BoundingBox::MergeFrom(from.bbox());
  }
  if (from.has_shape_attributes()) {
    mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(from.shape_attributes());
  }
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg::IsInitialized() const {

  return true;
}

void TripLeg::Swap(TripLeg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripLeg::InternalSwap(TripLeg* other) {
  location_.UnsafeArenaSwap(&other->location_);
  node_.UnsafeArenaSwap(&other->node_);
  admin_.UnsafeArenaSwap(&other->admin_);
  std::swap(bbox_, other->bbox_);
  std::swap(shape_attributes_, other->shape_attributes_);
  incidents_.UnsafeArenaSwap(&other->incidents_);
  algorithms_.UnsafeArenaSwap(&other->algorithms_);
  closures_.UnsafeArenaSwap(&other->closures_);
  std::swap(has_osm_changeset_, other->has_osm_changeset_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(has_trip_id_, other->has_trip_id_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(has_leg_id_, other->has_leg_id_);
  std::swap(_oneof_case_[2], other->_oneof_case_[2]);
  std::swap(has_leg_count_, other->has_leg_count_);
  std::swap(_oneof_case_[3], other->_oneof_case_[3]);
  std::swap(has_shape_, other->has_shape_);
  std::swap(_oneof_case_[4], other->_oneof_case_[4]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TripLeg_LaneConnectivity

// optional uint64 from_way_id = 1;
bool TripLeg_LaneConnectivity::has_from_way_id() const {
  return has_from_way_id_case() == kFromWayId;
}
void TripLeg_LaneConnectivity::set_has_from_way_id() {
  _oneof_case_[0] = kFromWayId;
}
void TripLeg_LaneConnectivity::clear_from_way_id() {
  if (has_from_way_id()) {
    has_from_way_id_.from_way_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_from_way_id();
  }
}
 ::google::protobuf::uint64 TripLeg_LaneConnectivity::from_way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_way_id)
  if (has_from_way_id()) {
    return has_from_way_id_.from_way_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
 void TripLeg_LaneConnectivity::set_from_way_id(::google::protobuf::uint64 value) {
  if (!has_from_way_id()) {
    clear_has_from_way_id();
    set_has_from_way_id();
  }
  has_from_way_id_.from_way_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_way_id)
}

// optional string from_lanes = 2;
bool TripLeg_LaneConnectivity::has_from_lanes() const {
  return has_from_lanes_case() == kFromLanes;
}
void TripLeg_LaneConnectivity::set_has_from_lanes() {
  _oneof_case_[1] = kFromLanes;
}
void TripLeg_LaneConnectivity::clear_from_lanes() {
  if (has_from_lanes()) {
    has_from_lanes_.from_lanes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_from_lanes();
  }
}
 const ::std::string& TripLeg_LaneConnectivity::from_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (has_from_lanes()) {
    return has_from_lanes_.from_lanes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_LaneConnectivity::set_from_lanes(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_from_lanes_.from_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
 void TripLeg_LaneConnectivity::set_from_lanes(const char* value) {
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_from_lanes_.from_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
 void TripLeg_LaneConnectivity::set_from_lanes(const char* value, size_t size) {
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_from_lanes_.from_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
 ::std::string* TripLeg_LaneConnectivity::mutable_from_lanes() {
  if (!has_from_lanes()) {
    clear_has_from_lanes();
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return has_from_lanes_.from_lanes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_LaneConnectivity::release_from_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.from_lanes)
  if (has_from_lanes()) {
    clear_has_has_from_lanes();
    return has_from_lanes_.from_lanes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_LaneConnectivity::set_allocated_from_lanes(::std::string* from_lanes) {
  if (!has_from_lanes()) {
    has_from_lanes_.from_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_from_lanes();
  if (from_lanes != NULL) {
    set_has_from_lanes();
    has_from_lanes_.from_lanes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        from_lanes);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.from_lanes)
}

// optional string to_lanes = 3;
bool TripLeg_LaneConnectivity::has_to_lanes() const {
  return has_to_lanes_case() == kToLanes;
}
void TripLeg_LaneConnectivity::set_has_to_lanes() {
  _oneof_case_[2] = kToLanes;
}
void TripLeg_LaneConnectivity::clear_to_lanes() {
  if (has_to_lanes()) {
    has_to_lanes_.to_lanes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_to_lanes();
  }
}
 const ::std::string& TripLeg_LaneConnectivity::to_lanes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (has_to_lanes()) {
    return has_to_lanes_.to_lanes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_LaneConnectivity::set_to_lanes(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_to_lanes_.to_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
 void TripLeg_LaneConnectivity::set_to_lanes(const char* value) {
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_to_lanes_.to_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
 void TripLeg_LaneConnectivity::set_to_lanes(const char* value, size_t size) {
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_to_lanes_.to_lanes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
 ::std::string* TripLeg_LaneConnectivity::mutable_to_lanes() {
  if (!has_to_lanes()) {
    clear_has_to_lanes();
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return has_to_lanes_.to_lanes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_LaneConnectivity::release_to_lanes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.to_lanes)
  if (has_to_lanes()) {
    clear_has_has_to_lanes();
    return has_to_lanes_.to_lanes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_LaneConnectivity::set_allocated_to_lanes(::std::string* to_lanes) {
  if (!has_to_lanes()) {
    has_to_lanes_.to_lanes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_to_lanes();
  if (to_lanes != NULL) {
    set_has_to_lanes();
    has_to_lanes_.to_lanes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        to_lanes);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.to_lanes)
}

bool TripLeg_LaneConnectivity::has_has_from_way_id() const {
  return has_from_way_id_case() != HAS_FROM_WAY_ID_NOT_SET;
}
void TripLeg_LaneConnectivity::clear_has_has_from_way_id() {
  _oneof_case_[0] = HAS_FROM_WAY_ID_NOT_SET;
}
bool TripLeg_LaneConnectivity::has_has_from_lanes() const {
  return has_from_lanes_case() != HAS_FROM_LANES_NOT_SET;
}
void TripLeg_LaneConnectivity::clear_has_has_from_lanes() {
  _oneof_case_[1] = HAS_FROM_LANES_NOT_SET;
}
bool TripLeg_LaneConnectivity::has_has_to_lanes() const {
  return has_to_lanes_case() != HAS_TO_LANES_NOT_SET;
}
void TripLeg_LaneConnectivity::clear_has_has_to_lanes() {
  _oneof_case_[2] = HAS_TO_LANES_NOT_SET;
}
TripLeg_LaneConnectivity::HasFromWayIdCase TripLeg_LaneConnectivity::has_from_way_id_case() const {
  return TripLeg_LaneConnectivity::HasFromWayIdCase(_oneof_case_[0]);
}
TripLeg_LaneConnectivity::HasFromLanesCase TripLeg_LaneConnectivity::has_from_lanes_case() const {
  return TripLeg_LaneConnectivity::HasFromLanesCase(_oneof_case_[1]);
}
TripLeg_LaneConnectivity::HasToLanesCase TripLeg_LaneConnectivity::has_to_lanes_case() const {
  return TripLeg_LaneConnectivity::HasToLanesCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// TripLeg_TrafficSegment

// optional uint64 segment_id = 1;
bool TripLeg_TrafficSegment::has_segment_id() const {
  return has_segment_id_case() == kSegmentId;
}
void TripLeg_TrafficSegment::set_has_segment_id() {
  _oneof_case_[0] = kSegmentId;
}
void TripLeg_TrafficSegment::clear_segment_id() {
  if (has_segment_id()) {
    has_segment_id_.segment_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_segment_id();
  }
}
 ::google::protobuf::uint64 TripLeg_TrafficSegment::segment_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.segment_id)
  if (has_segment_id()) {
    return has_segment_id_.segment_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
 void TripLeg_TrafficSegment::set_segment_id(::google::protobuf::uint64 value) {
  if (!has_segment_id()) {
    clear_has_segment_id();
    set_has_segment_id();
  }
  has_segment_id_.segment_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.segment_id)
}

// optional float begin_percent = 2;
bool TripLeg_TrafficSegment::has_begin_percent() const {
  return has_begin_percent_case() == kBeginPercent;
}
void TripLeg_TrafficSegment::set_has_begin_percent() {
  _oneof_case_[1] = kBeginPercent;
}
void TripLeg_TrafficSegment::clear_begin_percent() {
  if (has_begin_percent()) {
    has_begin_percent_.begin_percent_ = 0;
    clear_has_has_begin_percent();
  }
}
 float TripLeg_TrafficSegment::begin_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.begin_percent)
  if (has_begin_percent()) {
    return has_begin_percent_.begin_percent_;
  }
  return 0;
}
 void TripLeg_TrafficSegment::set_begin_percent(float value) {
  if (!has_begin_percent()) {
    clear_has_begin_percent();
    set_has_begin_percent();
  }
  has_begin_percent_.begin_percent_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.begin_percent)
}

// optional float end_percent = 3;
bool TripLeg_TrafficSegment::has_end_percent() const {
  return has_end_percent_case() == kEndPercent;
}
void TripLeg_TrafficSegment::set_has_end_percent() {
  _oneof_case_[2] = kEndPercent;
}
void TripLeg_TrafficSegment::clear_end_percent() {
  if (has_end_percent()) {
    has_end_percent_.end_percent_ = 0;
    clear_has_has_end_percent();
  }
}
 float TripLeg_TrafficSegment::end_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.end_percent)
  if (has_end_percent()) {
    return has_end_percent_.end_percent_;
  }
  return 0;
}
 void TripLeg_TrafficSegment::set_end_percent(float value) {
  if (!has_end_percent()) {
    clear_has_end_percent();
    set_has_end_percent();
  }
  has_end_percent_.end_percent_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.end_percent)
}

// optional bool starts_segment = 4;
bool TripLeg_TrafficSegment::has_starts_segment() const {
  return has_starts_segment_case() == kStartsSegment;
}
void TripLeg_TrafficSegment::set_has_starts_segment() {
  _oneof_case_[3] = kStartsSegment;
}
void TripLeg_TrafficSegment::clear_starts_segment() {
  if (has_starts_segment()) {
    has_starts_segment_.starts_segment_ = false;
    clear_has_has_starts_segment();
  }
}
 bool TripLeg_TrafficSegment::starts_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.starts_segment)
  if (has_starts_segment()) {
    return has_starts_segment_.starts_segment_;
  }
  return false;
}
 void TripLeg_TrafficSegment::set_starts_segment(bool value) {
  if (!has_starts_segment()) {
    clear_has_starts_segment();
    set_has_starts_segment();
  }
  has_starts_segment_.starts_segment_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.starts_segment)
}

// optional bool ends_segment = 5;
bool TripLeg_TrafficSegment::has_ends_segment() const {
  return has_ends_segment_case() == kEndsSegment;
}
void TripLeg_TrafficSegment::set_has_ends_segment() {
  _oneof_case_[4] = kEndsSegment;
}
void TripLeg_TrafficSegment::clear_ends_segment() {
  if (has_ends_segment()) {
    has_ends_segment_.ends_segment_ = false;
    clear_has_has_ends_segment();
  }
}
 bool TripLeg_TrafficSegment::ends_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.ends_segment)
  if (has_ends_segment()) {
    return has_ends_segment_.ends_segment_;
  }
  return false;
}
 void TripLeg_TrafficSegment::set_ends_segment(bool value) {
  if (!has_ends_segment()) {
    clear_has_ends_segment();
    set_has_ends_segment();
  }
  has_ends_segment_.ends_segment_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.ends_segment)
}

bool TripLeg_TrafficSegment::has_has_segment_id() const {
  return has_segment_id_case() != HAS_SEGMENT_ID_NOT_SET;
}
void TripLeg_TrafficSegment::clear_has_has_segment_id() {
  _oneof_case_[0] = HAS_SEGMENT_ID_NOT_SET;
}
bool TripLeg_TrafficSegment::has_has_begin_percent() const {
  return has_begin_percent_case() != HAS_BEGIN_PERCENT_NOT_SET;
}
void TripLeg_TrafficSegment::clear_has_has_begin_percent() {
  _oneof_case_[1] = HAS_BEGIN_PERCENT_NOT_SET;
}
bool TripLeg_TrafficSegment::has_has_end_percent() const {
  return has_end_percent_case() != HAS_END_PERCENT_NOT_SET;
}
void TripLeg_TrafficSegment::clear_has_has_end_percent() {
  _oneof_case_[2] = HAS_END_PERCENT_NOT_SET;
}
bool TripLeg_TrafficSegment::has_has_starts_segment() const {
  return has_starts_segment_case() != HAS_STARTS_SEGMENT_NOT_SET;
}
void TripLeg_TrafficSegment::clear_has_has_starts_segment() {
  _oneof_case_[3] = HAS_STARTS_SEGMENT_NOT_SET;
}
bool TripLeg_TrafficSegment::has_has_ends_segment() const {
  return has_ends_segment_case() != HAS_ENDS_SEGMENT_NOT_SET;
}
void TripLeg_TrafficSegment::clear_has_has_ends_segment() {
  _oneof_case_[4] = HAS_ENDS_SEGMENT_NOT_SET;
}
TripLeg_TrafficSegment::HasSegmentIdCase TripLeg_TrafficSegment::has_segment_id_case() const {
  return TripLeg_TrafficSegment::HasSegmentIdCase(_oneof_case_[0]);
}
TripLeg_TrafficSegment::HasBeginPercentCase TripLeg_TrafficSegment::has_begin_percent_case() const {
  return TripLeg_TrafficSegment::HasBeginPercentCase(_oneof_case_[1]);
}
TripLeg_TrafficSegment::HasEndPercentCase TripLeg_TrafficSegment::has_end_percent_case() const {
  return TripLeg_TrafficSegment::HasEndPercentCase(_oneof_case_[2]);
}
TripLeg_TrafficSegment::HasStartsSegmentCase TripLeg_TrafficSegment::has_starts_segment_case() const {
  return TripLeg_TrafficSegment::HasStartsSegmentCase(_oneof_case_[3]);
}
TripLeg_TrafficSegment::HasEndsSegmentCase TripLeg_TrafficSegment::has_ends_segment_case() const {
  return TripLeg_TrafficSegment::HasEndsSegmentCase(_oneof_case_[4]);
}
// -------------------------------------------------------------------

// TripLeg_Restriction

// optional uint32 type = 1;
bool TripLeg_Restriction::has_type() const {
  return has_type_case() == kType;
}
void TripLeg_Restriction::set_has_type() {
  _oneof_case_[0] = kType;
}
void TripLeg_Restriction::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0u;
    clear_has_has_type();
  }
}
 ::google::protobuf::uint32 TripLeg_Restriction::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Restriction.type)
  if (has_type()) {
    return has_type_.type_;
  }
  return 0u;
}
 void TripLeg_Restriction::set_type(::google::protobuf::uint32 value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Restriction.type)
}

bool TripLeg_Restriction::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
void TripLeg_Restriction::clear_has_has_type() {
  _oneof_case_[0] = HAS_TYPE_NOT_SET;
}
TripLeg_Restriction::HasTypeCase TripLeg_Restriction::has_type_case() const {
  return TripLeg_Restriction::HasTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TripLeg_Edge

// repeated .valhalla.StreetName name = 1;
int TripLeg_Edge::name_size() const {
  return name_.size();
}
void TripLeg_Edge::clear_name() {
  name_.Clear();
}
const ::valhalla::StreetName& TripLeg_Edge::name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.name)
  return name_.Get(index);
}
::valhalla::StreetName* TripLeg_Edge::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.name)
  return name_.Mutable(index);
}
::valhalla::StreetName* TripLeg_Edge::add_name() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.name)
  return name_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
TripLeg_Edge::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.name)
  return &name_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
TripLeg_Edge::name() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.name)
  return name_;
}

// optional float length_km = 2;
bool TripLeg_Edge::has_length_km() const {
  return has_length_km_case() == kLengthKm;
}
void TripLeg_Edge::set_has_length_km() {
  _oneof_case_[0] = kLengthKm;
}
void TripLeg_Edge::clear_length_km() {
  if (has_length_km()) {
    has_length_km_.length_km_ = 0;
    clear_has_has_length_km();
  }
}
 float TripLeg_Edge::length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.length_km)
  if (has_length_km()) {
    return has_length_km_.length_km_;
  }
  return 0;
}
 void TripLeg_Edge::set_length_km(float value) {
  if (!has_length_km()) {
    clear_has_length_km();
    set_has_length_km();
  }
  has_length_km_.length_km_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.length_km)
}

// optional float speed = 3;
bool TripLeg_Edge::has_speed() const {
  return has_speed_case() == kSpeed;
}
void TripLeg_Edge::set_has_speed() {
  _oneof_case_[1] = kSpeed;
}
void TripLeg_Edge::clear_speed() {
  if (has_speed()) {
    has_speed_.speed_ = 0;
    clear_has_has_speed();
  }
}
 float TripLeg_Edge::speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed)
  if (has_speed()) {
    return has_speed_.speed_;
  }
  return 0;
}
 void TripLeg_Edge::set_speed(float value) {
  if (!has_speed()) {
    clear_has_speed();
    set_has_speed();
  }
  has_speed_.speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed)
}

// optional .valhalla.RoadClass road_class = 4;
bool TripLeg_Edge::has_road_class() const {
  return has_road_class_case() == kRoadClass;
}
void TripLeg_Edge::set_has_road_class() {
  _oneof_case_[2] = kRoadClass;
}
void TripLeg_Edge::clear_road_class() {
  if (has_road_class()) {
    has_road_class_.road_class_ = 0;
    clear_has_has_road_class();
  }
}
 ::valhalla::RoadClass TripLeg_Edge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.road_class)
  if (has_road_class()) {
    return static_cast< ::valhalla::RoadClass >(has_road_class_.road_class_);
  }
  return static_cast< ::valhalla::RoadClass >(0);
}
 void TripLeg_Edge::set_road_class(::valhalla::RoadClass value) {
  if (!has_road_class()) {
    clear_has_road_class();
    set_has_road_class();
  }
  has_road_class_.road_class_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.road_class)
}

// optional uint32 begin_heading = 5;
bool TripLeg_Edge::has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
void TripLeg_Edge::set_has_begin_heading() {
  _oneof_case_[3] = kBeginHeading;
}
void TripLeg_Edge::clear_begin_heading() {
  if (has_begin_heading()) {
    has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_heading)
  if (has_begin_heading()) {
    return has_begin_heading_.begin_heading_;
  }
  return 0u;
}
 void TripLeg_Edge::set_begin_heading(::google::protobuf::uint32 value) {
  if (!has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  has_begin_heading_.begin_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_heading)
}

// optional uint32 end_heading = 6;
bool TripLeg_Edge::has_end_heading() const {
  return has_end_heading_case() == kEndHeading;
}
void TripLeg_Edge::set_has_end_heading() {
  _oneof_case_[4] = kEndHeading;
}
void TripLeg_Edge::clear_end_heading() {
  if (has_end_heading()) {
    has_end_heading_.end_heading_ = 0u;
    clear_has_has_end_heading();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::end_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_heading)
  if (has_end_heading()) {
    return has_end_heading_.end_heading_;
  }
  return 0u;
}
 void TripLeg_Edge::set_end_heading(::google::protobuf::uint32 value) {
  if (!has_end_heading()) {
    clear_has_end_heading();
    set_has_end_heading();
  }
  has_end_heading_.end_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_heading)
}

// optional uint32 begin_shape_index = 7;
bool TripLeg_Edge::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
void TripLeg_Edge::set_has_begin_shape_index() {
  _oneof_case_[5] = kBeginShapeIndex;
}
void TripLeg_Edge::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
 void TripLeg_Edge::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_shape_index)
}

// optional uint32 end_shape_index = 8;
bool TripLeg_Edge::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
void TripLeg_Edge::set_has_end_shape_index() {
  _oneof_case_[6] = kEndShapeIndex;
}
void TripLeg_Edge::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
 void TripLeg_Edge::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_shape_index)
}

// optional .valhalla.TripLeg.Traversability traversability = 9;
bool TripLeg_Edge::has_traversability() const {
  return has_traversability_case() == kTraversability;
}
void TripLeg_Edge::set_has_traversability() {
  _oneof_case_[7] = kTraversability;
}
void TripLeg_Edge::clear_traversability() {
  if (has_traversability()) {
    has_traversability_.traversability_ = 0;
    clear_has_has_traversability();
  }
}
 ::valhalla::TripLeg_Traversability TripLeg_Edge::traversability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traversability)
  if (has_traversability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_traversability_.traversability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
 void TripLeg_Edge::set_traversability(::valhalla::TripLeg_Traversability value) {
  if (!has_traversability()) {
    clear_has_traversability();
    set_has_traversability();
  }
  has_traversability_.traversability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.traversability)
}

// optional .valhalla.TripLeg.Use use = 10;
bool TripLeg_Edge::has_use() const {
  return has_use_case() == kUse;
}
void TripLeg_Edge::set_has_use() {
  _oneof_case_[8] = kUse;
}
void TripLeg_Edge::clear_use() {
  if (has_use()) {
    has_use_.use_ = 0;
    clear_has_has_use();
  }
}
 ::valhalla::TripLeg_Use TripLeg_Edge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.use)
  if (has_use()) {
    return static_cast< ::valhalla::TripLeg_Use >(has_use_.use_);
  }
  return static_cast< ::valhalla::TripLeg_Use >(0);
}
 void TripLeg_Edge::set_use(::valhalla::TripLeg_Use value) {
  if (!has_use()) {
    clear_has_use();
    set_has_use();
  }
  has_use_.use_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.use)
}

// optional bool toll = 11;
bool TripLeg_Edge::has_toll() const {
  return has_toll_case() == kToll;
}
void TripLeg_Edge::set_has_toll() {
  _oneof_case_[9] = kToll;
}
void TripLeg_Edge::clear_toll() {
  if (has_toll()) {
    has_toll_.toll_ = false;
    clear_has_has_toll();
  }
}
 bool TripLeg_Edge::toll() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.toll)
  if (has_toll()) {
    return has_toll_.toll_;
  }
  return false;
}
 void TripLeg_Edge::set_toll(bool value) {
  if (!has_toll()) {
    clear_has_toll();
    set_has_toll();
  }
  has_toll_.toll_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.toll)
}

// optional bool unpaved = 12;
bool TripLeg_Edge::has_unpaved() const {
  return has_unpaved_case() == kUnpaved;
}
void TripLeg_Edge::set_has_unpaved() {
  _oneof_case_[10] = kUnpaved;
}
void TripLeg_Edge::clear_unpaved() {
  if (has_unpaved()) {
    has_unpaved_.unpaved_ = false;
    clear_has_has_unpaved();
  }
}
 bool TripLeg_Edge::unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.unpaved)
  if (has_unpaved()) {
    return has_unpaved_.unpaved_;
  }
  return false;
}
 void TripLeg_Edge::set_unpaved(bool value) {
  if (!has_unpaved()) {
    clear_has_unpaved();
    set_has_unpaved();
  }
  has_unpaved_.unpaved_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.unpaved)
}

// optional bool tunnel = 13;
bool TripLeg_Edge::has_tunnel() const {
  return has_tunnel_case() == kTunnel;
}
void TripLeg_Edge::set_has_tunnel() {
  _oneof_case_[11] = kTunnel;
}
void TripLeg_Edge::clear_tunnel() {
  if (has_tunnel()) {
    has_tunnel_.tunnel_ = false;
    clear_has_has_tunnel();
  }
}
 bool TripLeg_Edge::tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tunnel)
  if (has_tunnel()) {
    return has_tunnel_.tunnel_;
  }
  return false;
}
 void TripLeg_Edge::set_tunnel(bool value) {
  if (!has_tunnel()) {
    clear_has_tunnel();
    set_has_tunnel();
  }
  has_tunnel_.tunnel_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.tunnel)
}

// optional bool bridge = 14;
bool TripLeg_Edge::has_bridge() const {
  return has_bridge_case() == kBridge;
}
void TripLeg_Edge::set_has_bridge() {
  _oneof_case_[12] = kBridge;
}
void TripLeg_Edge::clear_bridge() {
  if (has_bridge()) {
    has_bridge_.bridge_ = false;
    clear_has_has_bridge();
  }
}
 bool TripLeg_Edge::bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bridge)
  if (has_bridge()) {
    return has_bridge_.bridge_;
  }
  return false;
}
 void TripLeg_Edge::set_bridge(bool value) {
  if (!has_bridge()) {
    clear_has_bridge();
    set_has_bridge();
  }
  has_bridge_.bridge_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bridge)
}

// optional bool roundabout = 15;
bool TripLeg_Edge::has_roundabout() const {
  return has_roundabout_case() == kRoundabout;
}
void TripLeg_Edge::set_has_roundabout() {
  _oneof_case_[13] = kRoundabout;
}
void TripLeg_Edge::clear_roundabout() {
  if (has_roundabout()) {
    has_roundabout_.roundabout_ = false;
    clear_has_has_roundabout();
  }
}
 bool TripLeg_Edge::roundabout() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.roundabout)
  if (has_roundabout()) {
    return has_roundabout_.roundabout_;
  }
  return false;
}
 void TripLeg_Edge::set_roundabout(bool value) {
  if (!has_roundabout()) {
    clear_has_roundabout();
    set_has_roundabout();
  }
  has_roundabout_.roundabout_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.roundabout)
}

// optional bool internal_intersection = 16;
bool TripLeg_Edge::has_internal_intersection() const {
  return has_internal_intersection_case() == kInternalIntersection;
}
void TripLeg_Edge::set_has_internal_intersection() {
  _oneof_case_[14] = kInternalIntersection;
}
void TripLeg_Edge::clear_internal_intersection() {
  if (has_internal_intersection()) {
    has_internal_intersection_.internal_intersection_ = false;
    clear_has_has_internal_intersection();
  }
}
 bool TripLeg_Edge::internal_intersection() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.internal_intersection)
  if (has_internal_intersection()) {
    return has_internal_intersection_.internal_intersection_;
  }
  return false;
}
 void TripLeg_Edge::set_internal_intersection(bool value) {
  if (!has_internal_intersection()) {
    clear_has_internal_intersection();
    set_has_internal_intersection();
  }
  has_internal_intersection_.internal_intersection_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.internal_intersection)
}

// optional bool drive_on_left = 17;
bool TripLeg_Edge::has_drive_on_left() const {
  return has_drive_on_left_case() == kDriveOnLeft;
}
void TripLeg_Edge::set_has_drive_on_left() {
  _oneof_case_[15] = kDriveOnLeft;
}
void TripLeg_Edge::clear_drive_on_left() {
  if (has_drive_on_left()) {
    has_drive_on_left_.drive_on_left_ = false;
    clear_has_has_drive_on_left();
  }
}
 bool TripLeg_Edge::drive_on_left() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.drive_on_left)
  if (has_drive_on_left()) {
    return has_drive_on_left_.drive_on_left_;
  }
  return false;
}
 void TripLeg_Edge::set_drive_on_left(bool value) {
  if (!has_drive_on_left()) {
    clear_has_drive_on_left();
    set_has_drive_on_left();
  }
  has_drive_on_left_.drive_on_left_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.drive_on_left)
}

// optional .valhalla.TripLeg.Surface surface = 18;
bool TripLeg_Edge::has_surface() const {
  return has_surface_case() == kSurface;
}
void TripLeg_Edge::set_has_surface() {
  _oneof_case_[16] = kSurface;
}
void TripLeg_Edge::clear_surface() {
  if (has_surface()) {
    has_surface_.surface_ = 0;
    clear_has_has_surface();
  }
}
 ::valhalla::TripLeg_Surface TripLeg_Edge::surface() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.surface)
  if (has_surface()) {
    return static_cast< ::valhalla::TripLeg_Surface >(has_surface_.surface_);
  }
  return static_cast< ::valhalla::TripLeg_Surface >(0);
}
 void TripLeg_Edge::set_surface(::valhalla::TripLeg_Surface value) {
  if (!has_surface()) {
    clear_has_surface();
    set_has_surface();
  }
  has_surface_.surface_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.surface)
}

// optional .valhalla.TripSign sign = 19;
bool TripLeg_Edge::has_sign() const {
  return !_is_default_instance_ && sign_ != NULL;
}
void TripLeg_Edge::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
}
const ::valhalla::TripSign& TripLeg_Edge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sign)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
::valhalla::TripSign* TripLeg_Edge::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::valhalla::TripSign;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.sign)
  return sign_;
}
::valhalla::TripSign* TripLeg_Edge::release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.sign)
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = NULL;
  return temp;
}
void TripLeg_Edge::set_allocated_sign(::valhalla::TripSign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.sign)
}

// optional .valhalla.TravelMode travel_mode = 20;
bool TripLeg_Edge::has_travel_mode() const {
  return has_travel_mode_case() == kTravelMode;
}
void TripLeg_Edge::set_has_travel_mode() {
  _oneof_case_[17] = kTravelMode;
}
void TripLeg_Edge::clear_travel_mode() {
  if (has_travel_mode()) {
    has_travel_mode_.travel_mode_ = 0;
    clear_has_has_travel_mode();
  }
}
 ::valhalla::TravelMode TripLeg_Edge::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.travel_mode)
  if (has_travel_mode()) {
    return static_cast< ::valhalla::TravelMode >(has_travel_mode_.travel_mode_);
  }
  return static_cast< ::valhalla::TravelMode >(0);
}
 void TripLeg_Edge::set_travel_mode(::valhalla::TravelMode value) {
  if (!has_travel_mode()) {
    clear_has_travel_mode();
    set_has_travel_mode();
  }
  has_travel_mode_.travel_mode_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.travel_mode)
}

// optional .valhalla.VehicleType vehicle_type = 21;
bool TripLeg_Edge::has_vehicle_type() const {
  return has_vehicle_type_case() == kVehicleType;
}
void TripLeg_Edge::set_has_vehicle_type() {
  _oneof_case_[18] = kVehicleType;
}
void TripLeg_Edge::clear_vehicle_type() {
  if (has_vehicle_type()) {
    has_vehicle_type_.vehicle_type_ = 0;
    clear_has_has_vehicle_type();
  }
}
 ::valhalla::VehicleType TripLeg_Edge::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.vehicle_type)
  if (has_vehicle_type()) {
    return static_cast< ::valhalla::VehicleType >(has_vehicle_type_.vehicle_type_);
  }
  return static_cast< ::valhalla::VehicleType >(0);
}
 void TripLeg_Edge::set_vehicle_type(::valhalla::VehicleType value) {
  if (!has_vehicle_type()) {
    clear_has_vehicle_type();
    set_has_vehicle_type();
  }
  has_vehicle_type_.vehicle_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.vehicle_type)
}

// optional .valhalla.PedestrianType pedestrian_type = 22;
bool TripLeg_Edge::has_pedestrian_type() const {
  return has_pedestrian_type_case() == kPedestrianType;
}
void TripLeg_Edge::set_has_pedestrian_type() {
  _oneof_case_[19] = kPedestrianType;
}
void TripLeg_Edge::clear_pedestrian_type() {
  if (has_pedestrian_type()) {
    has_pedestrian_type_.pedestrian_type_ = 0;
    clear_has_has_pedestrian_type();
  }
}
 ::valhalla::PedestrianType TripLeg_Edge::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.pedestrian_type)
  if (has_pedestrian_type()) {
    return static_cast< ::valhalla::PedestrianType >(has_pedestrian_type_.pedestrian_type_);
  }
  return static_cast< ::valhalla::PedestrianType >(0);
}
 void TripLeg_Edge::set_pedestrian_type(::valhalla::PedestrianType value) {
  if (!has_pedestrian_type()) {
    clear_has_pedestrian_type();
    set_has_pedestrian_type();
  }
  has_pedestrian_type_.pedestrian_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.pedestrian_type)
}

// optional .valhalla.BicycleType bicycle_type = 23;
bool TripLeg_Edge::has_bicycle_type() const {
  return has_bicycle_type_case() == kBicycleType;
}
void TripLeg_Edge::set_has_bicycle_type() {
  _oneof_case_[20] = kBicycleType;
}
void TripLeg_Edge::clear_bicycle_type() {
  if (has_bicycle_type()) {
    has_bicycle_type_.bicycle_type_ = 0;
    clear_has_has_bicycle_type();
  }
}
 ::valhalla::BicycleType TripLeg_Edge::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_type)
  if (has_bicycle_type()) {
    return static_cast< ::valhalla::BicycleType >(has_bicycle_type_.bicycle_type_);
  }
  return static_cast< ::valhalla::BicycleType >(0);
}
 void TripLeg_Edge::set_bicycle_type(::valhalla::BicycleType value) {
  if (!has_bicycle_type()) {
    clear_has_bicycle_type();
    set_has_bicycle_type();
  }
  has_bicycle_type_.bicycle_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_type)
}

// optional .valhalla.TransitType transit_type = 24;
bool TripLeg_Edge::has_transit_type() const {
  return has_transit_type_case() == kTransitType;
}
void TripLeg_Edge::set_has_transit_type() {
  _oneof_case_[21] = kTransitType;
}
void TripLeg_Edge::clear_transit_type() {
  if (has_transit_type()) {
    has_transit_type_.transit_type_ = 0;
    clear_has_has_transit_type();
  }
}
 ::valhalla::TransitType TripLeg_Edge::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_type)
  if (has_transit_type()) {
    return static_cast< ::valhalla::TransitType >(has_transit_type_.transit_type_);
  }
  return static_cast< ::valhalla::TransitType >(0);
}
 void TripLeg_Edge::set_transit_type(::valhalla::TransitType value) {
  if (!has_transit_type()) {
    clear_has_transit_type();
    set_has_transit_type();
  }
  has_transit_type_.transit_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.transit_type)
}

// optional .valhalla.TransitRouteInfo transit_route_info = 25;
bool TripLeg_Edge::has_transit_route_info() const {
  return !_is_default_instance_ && transit_route_info_ != NULL;
}
void TripLeg_Edge::clear_transit_route_info() {
  if (GetArenaNoVirtual() == NULL && transit_route_info_ != NULL) delete transit_route_info_;
  transit_route_info_ = NULL;
}
const ::valhalla::TransitRouteInfo& TripLeg_Edge::transit_route_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_route_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance().transit_route_info_;
#else
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance_->transit_route_info_;
#endif
}
::valhalla::TransitRouteInfo* TripLeg_Edge::mutable_transit_route_info() {
  
  if (transit_route_info_ == NULL) {
    transit_route_info_ = new ::valhalla::TransitRouteInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.transit_route_info)
  return transit_route_info_;
}
::valhalla::TransitRouteInfo* TripLeg_Edge::release_transit_route_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.transit_route_info)
  
  ::valhalla::TransitRouteInfo* temp = transit_route_info_;
  transit_route_info_ = NULL;
  return temp;
}
void TripLeg_Edge::set_allocated_transit_route_info(::valhalla::TransitRouteInfo* transit_route_info) {
  delete transit_route_info_;
  transit_route_info_ = transit_route_info;
  if (transit_route_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}

// optional uint64 id = 26;
bool TripLeg_Edge::has_id() const {
  return has_id_case() == kId;
}
void TripLeg_Edge::set_has_id() {
  _oneof_case_[22] = kId;
}
void TripLeg_Edge::clear_id() {
  if (has_id()) {
    has_id_.id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_id();
  }
}
 ::google::protobuf::uint64 TripLeg_Edge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.id)
  if (has_id()) {
    return has_id_.id_;
  }
  return GOOGLE_ULONGLONG(0);
}
 void TripLeg_Edge::set_id(::google::protobuf::uint64 value) {
  if (!has_id()) {
    clear_has_id();
    set_has_id();
  }
  has_id_.id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.id)
}

// optional uint64 way_id = 27;
bool TripLeg_Edge::has_way_id() const {
  return has_way_id_case() == kWayId;
}
void TripLeg_Edge::set_has_way_id() {
  _oneof_case_[23] = kWayId;
}
void TripLeg_Edge::clear_way_id() {
  if (has_way_id()) {
    has_way_id_.way_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_way_id();
  }
}
 ::google::protobuf::uint64 TripLeg_Edge::way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.way_id)
  if (has_way_id()) {
    return has_way_id_.way_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
 void TripLeg_Edge::set_way_id(::google::protobuf::uint64 value) {
  if (!has_way_id()) {
    clear_has_way_id();
    set_has_way_id();
  }
  has_way_id_.way_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.way_id)
}

// optional float weighted_grade = 28;
bool TripLeg_Edge::has_weighted_grade() const {
  return has_weighted_grade_case() == kWeightedGrade;
}
void TripLeg_Edge::set_has_weighted_grade() {
  _oneof_case_[24] = kWeightedGrade;
}
void TripLeg_Edge::clear_weighted_grade() {
  if (has_weighted_grade()) {
    has_weighted_grade_.weighted_grade_ = 0;
    clear_has_has_weighted_grade();
  }
}
 float TripLeg_Edge::weighted_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.weighted_grade)
  if (has_weighted_grade()) {
    return has_weighted_grade_.weighted_grade_;
  }
  return 0;
}
 void TripLeg_Edge::set_weighted_grade(float value) {
  if (!has_weighted_grade()) {
    clear_has_weighted_grade();
    set_has_weighted_grade();
  }
  has_weighted_grade_.weighted_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.weighted_grade)
}

// optional int32 max_upward_grade = 29;
bool TripLeg_Edge::has_max_upward_grade() const {
  return has_max_upward_grade_case() == kMaxUpwardGrade;
}
void TripLeg_Edge::set_has_max_upward_grade() {
  _oneof_case_[25] = kMaxUpwardGrade;
}
void TripLeg_Edge::clear_max_upward_grade() {
  if (has_max_upward_grade()) {
    has_max_upward_grade_.max_upward_grade_ = 0;
    clear_has_has_max_upward_grade();
  }
}
 ::google::protobuf::int32 TripLeg_Edge::max_upward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_upward_grade)
  if (has_max_upward_grade()) {
    return has_max_upward_grade_.max_upward_grade_;
  }
  return 0;
}
 void TripLeg_Edge::set_max_upward_grade(::google::protobuf::int32 value) {
  if (!has_max_upward_grade()) {
    clear_has_max_upward_grade();
    set_has_max_upward_grade();
  }
  has_max_upward_grade_.max_upward_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_upward_grade)
}

// optional int32 max_downward_grade = 30;
bool TripLeg_Edge::has_max_downward_grade() const {
  return has_max_downward_grade_case() == kMaxDownwardGrade;
}
void TripLeg_Edge::set_has_max_downward_grade() {
  _oneof_case_[26] = kMaxDownwardGrade;
}
void TripLeg_Edge::clear_max_downward_grade() {
  if (has_max_downward_grade()) {
    has_max_downward_grade_.max_downward_grade_ = 0;
    clear_has_has_max_downward_grade();
  }
}
 ::google::protobuf::int32 TripLeg_Edge::max_downward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_downward_grade)
  if (has_max_downward_grade()) {
    return has_max_downward_grade_.max_downward_grade_;
  }
  return 0;
}
 void TripLeg_Edge::set_max_downward_grade(::google::protobuf::int32 value) {
  if (!has_max_downward_grade()) {
    clear_has_max_downward_grade();
    set_has_max_downward_grade();
  }
  has_max_downward_grade_.max_downward_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_downward_grade)
}

// optional uint32 lane_count = 31;
bool TripLeg_Edge::has_lane_count() const {
  return has_lane_count_case() == kLaneCount;
}
void TripLeg_Edge::set_has_lane_count() {
  _oneof_case_[27] = kLaneCount;
}
void TripLeg_Edge::clear_lane_count() {
  if (has_lane_count()) {
    has_lane_count_.lane_count_ = 0u;
    clear_has_has_lane_count();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_count)
  if (has_lane_count()) {
    return has_lane_count_.lane_count_;
  }
  return 0u;
}
 void TripLeg_Edge::set_lane_count(::google::protobuf::uint32 value) {
  if (!has_lane_count()) {
    clear_has_lane_count();
    set_has_lane_count();
  }
  has_lane_count_.lane_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.lane_count)
}

// optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
bool TripLeg_Edge::has_cycle_lane() const {
  return has_cycle_lane_case() == kCycleLane;
}
void TripLeg_Edge::set_has_cycle_lane() {
  _oneof_case_[28] = kCycleLane;
}
void TripLeg_Edge::clear_cycle_lane() {
  if (has_cycle_lane()) {
    has_cycle_lane_.cycle_lane_ = 0;
    clear_has_has_cycle_lane();
  }
}
 ::valhalla::TripLeg_CycleLane TripLeg_Edge::cycle_lane() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.cycle_lane)
  if (has_cycle_lane()) {
    return static_cast< ::valhalla::TripLeg_CycleLane >(has_cycle_lane_.cycle_lane_);
  }
  return static_cast< ::valhalla::TripLeg_CycleLane >(0);
}
 void TripLeg_Edge::set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  if (!has_cycle_lane()) {
    clear_has_cycle_lane();
    set_has_cycle_lane();
  }
  has_cycle_lane_.cycle_lane_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.cycle_lane)
}

// optional uint32 bicycle_network = 33;
bool TripLeg_Edge::has_bicycle_network() const {
  return has_bicycle_network_case() == kBicycleNetwork;
}
void TripLeg_Edge::set_has_bicycle_network() {
  _oneof_case_[29] = kBicycleNetwork;
}
void TripLeg_Edge::clear_bicycle_network() {
  if (has_bicycle_network()) {
    has_bicycle_network_.bicycle_network_ = 0u;
    clear_has_has_bicycle_network();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::bicycle_network() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_network)
  if (has_bicycle_network()) {
    return has_bicycle_network_.bicycle_network_;
  }
  return 0u;
}
 void TripLeg_Edge::set_bicycle_network(::google::protobuf::uint32 value) {
  if (!has_bicycle_network()) {
    clear_has_bicycle_network();
    set_has_bicycle_network();
  }
  has_bicycle_network_.bicycle_network_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_network)
}

// optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
bool TripLeg_Edge::has_sidewalk() const {
  return has_sidewalk_case() == kSidewalk;
}
void TripLeg_Edge::set_has_sidewalk() {
  _oneof_case_[30] = kSidewalk;
}
void TripLeg_Edge::clear_sidewalk() {
  if (has_sidewalk()) {
    has_sidewalk_.sidewalk_ = 0;
    clear_has_has_sidewalk();
  }
}
 ::valhalla::TripLeg_Sidewalk TripLeg_Edge::sidewalk() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sidewalk)
  if (has_sidewalk()) {
    return static_cast< ::valhalla::TripLeg_Sidewalk >(has_sidewalk_.sidewalk_);
  }
  return static_cast< ::valhalla::TripLeg_Sidewalk >(0);
}
 void TripLeg_Edge::set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  if (!has_sidewalk()) {
    clear_has_sidewalk();
    set_has_sidewalk();
  }
  has_sidewalk_.sidewalk_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sidewalk)
}

// optional uint32 density = 35;
bool TripLeg_Edge::has_density() const {
  return has_density_case() == kDensity;
}
void TripLeg_Edge::set_has_density() {
  _oneof_case_[31] = kDensity;
}
void TripLeg_Edge::clear_density() {
  if (has_density()) {
    has_density_.density_ = 0u;
    clear_has_has_density();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::density() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.density)
  if (has_density()) {
    return has_density_.density_;
  }
  return 0u;
}
 void TripLeg_Edge::set_density(::google::protobuf::uint32 value) {
  if (!has_density()) {
    clear_has_density();
    set_has_density();
  }
  has_density_.density_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.density)
}

// optional uint32 speed_limit = 36;
bool TripLeg_Edge::has_speed_limit() const {
  return has_speed_limit_case() == kSpeedLimit;
}
void TripLeg_Edge::set_has_speed_limit() {
  _oneof_case_[32] = kSpeedLimit;
}
void TripLeg_Edge::clear_speed_limit() {
  if (has_speed_limit()) {
    has_speed_limit_.speed_limit_ = 0u;
    clear_has_has_speed_limit();
  }
}
 ::google::protobuf::uint32 TripLeg_Edge::speed_limit() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed_limit)
  if (has_speed_limit()) {
    return has_speed_limit_.speed_limit_;
  }
  return 0u;
}
 void TripLeg_Edge::set_speed_limit(::google::protobuf::uint32 value) {
  if (!has_speed_limit()) {
    clear_has_speed_limit();
    set_has_speed_limit();
  }
  has_speed_limit_.speed_limit_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed_limit)
}

// optional float truck_speed = 37;
bool TripLeg_Edge::has_truck_speed() const {
  return has_truck_speed_case() == kTruckSpeed;
}
void TripLeg_Edge::set_has_truck_speed() {
  _oneof_case_[33] = kTruckSpeed;
}
void TripLeg_Edge::clear_truck_speed() {
  if (has_truck_speed()) {
    has_truck_speed_.truck_speed_ = 0;
    clear_has_has_truck_speed();
  }
}
 float TripLeg_Edge::truck_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_speed)
  if (has_truck_speed()) {
    return has_truck_speed_.truck_speed_;
  }
  return 0;
}
 void TripLeg_Edge::set_truck_speed(float value) {
  if (!has_truck_speed()) {
    clear_has_truck_speed();
    set_has_truck_speed();
  }
  has_truck_speed_.truck_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_speed)
}

// optional bool truck_route = 38;
bool TripLeg_Edge::has_truck_route() const {
  return has_truck_route_case() == kTruckRoute;
}
void TripLeg_Edge::set_has_truck_route() {
  _oneof_case_[34] = kTruckRoute;
}
void TripLeg_Edge::clear_truck_route() {
  if (has_truck_route()) {
    has_truck_route_.truck_route_ = false;
    clear_has_has_truck_route();
  }
}
 bool TripLeg_Edge::truck_route() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_route)
  if (has_truck_route()) {
    return has_truck_route_.truck_route_;
  }
  return false;
}
 void TripLeg_Edge::set_truck_route(bool value) {
  if (!has_truck_route()) {
    clear_has_truck_route();
    set_has_truck_route();
  }
  has_truck_route_.truck_route_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_route)
}

// repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
int TripLeg_Edge::lane_connectivity_size() const {
  return lane_connectivity_.size();
}
void TripLeg_Edge::clear_lane_connectivity() {
  lane_connectivity_.Clear();
}
const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::lane_connectivity(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_.Get(index);
}
::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::mutable_lane_connectivity(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_.Mutable(index);
}
::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::add_lane_connectivity() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
TripLeg_Edge::mutable_lane_connectivity() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.lane_connectivity)
  return &lane_connectivity_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
TripLeg_Edge::lane_connectivity() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.lane_connectivity)
  return lane_connectivity_;
}

// optional int32 mean_elevation = 40;
bool TripLeg_Edge::has_mean_elevation() const {
  return has_mean_elevation_case() == kMeanElevation;
}
void TripLeg_Edge::set_has_mean_elevation() {
  _oneof_case_[35] = kMeanElevation;
}
void TripLeg_Edge::clear_mean_elevation() {
  if (has_mean_elevation()) {
    has_mean_elevation_.mean_elevation_ = 0;
    clear_has_has_mean_elevation();
  }
}
 ::google::protobuf::int32 TripLeg_Edge::mean_elevation() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.mean_elevation)
  if (has_mean_elevation()) {
    return has_mean_elevation_.mean_elevation_;
  }
  return 0;
}
 void TripLeg_Edge::set_mean_elevation(::google::protobuf::int32 value) {
  if (!has_mean_elevation()) {
    clear_has_mean_elevation();
    set_has_mean_elevation();
  }
  has_mean_elevation_.mean_elevation_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.mean_elevation)
}

// repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
int TripLeg_Edge::traffic_segment_size() const {
  return traffic_segment_.size();
}
void TripLeg_Edge::clear_traffic_segment() {
  traffic_segment_.Clear();
}
const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::traffic_segment(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_.Get(index);
}
::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::mutable_traffic_segment(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_.Mutable(index);
}
::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::add_traffic_segment() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
TripLeg_Edge::mutable_traffic_segment() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.traffic_segment)
  return &traffic_segment_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
TripLeg_Edge::traffic_segment() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.traffic_segment)
  return traffic_segment_;
}

// repeated .valhalla.TurnLane turn_lanes = 42;
int TripLeg_Edge::turn_lanes_size() const {
  return turn_lanes_.size();
}
void TripLeg_Edge::clear_turn_lanes() {
  turn_lanes_.Clear();
}
const ::valhalla::TurnLane& TripLeg_Edge::turn_lanes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_.Get(index);
}
::valhalla::TurnLane* TripLeg_Edge::mutable_turn_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_.Mutable(index);
}
::valhalla::TurnLane* TripLeg_Edge::add_turn_lanes() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >*
TripLeg_Edge::mutable_turn_lanes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.turn_lanes)
  return &turn_lanes_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >&
TripLeg_Edge::turn_lanes() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.turn_lanes)
  return turn_lanes_;
}

// optional bool has_time_restrictions = 43;
bool TripLeg_Edge::has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
void TripLeg_Edge::set_has_has_time_restrictions() {
  _oneof_case_[36] = kHasTimeRestrictions;
}
void TripLeg_Edge::clear_has_time_restrictions() {
  if (has_has_time_restrictions()) {
    has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
 bool TripLeg_Edge::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.has_time_restrictions)
  if (has_has_time_restrictions()) {
    return has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
 void TripLeg_Edge::set_has_time_restrictions(bool value) {
  if (!has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  has_has_time_restrictions_.has_time_restrictions_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.has_time_restrictions)
}

// optional float default_speed = 44;
bool TripLeg_Edge::has_default_speed() const {
  return has_default_speed_case() == kDefaultSpeed;
}
void TripLeg_Edge::set_has_default_speed() {
  _oneof_case_[37] = kDefaultSpeed;
}
void TripLeg_Edge::clear_default_speed() {
  if (has_default_speed()) {
    has_default_speed_.default_speed_ = 0;
    clear_has_has_default_speed();
  }
}
 float TripLeg_Edge::default_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.default_speed)
  if (has_default_speed()) {
    return has_default_speed_.default_speed_;
  }
  return 0;
}
 void TripLeg_Edge::set_default_speed(float value) {
  if (!has_default_speed()) {
    clear_has_default_speed();
    set_has_default_speed();
  }
  has_default_speed_.default_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.default_speed)
}

// optional .valhalla.TripLeg.Restriction restriction = 45;
bool TripLeg_Edge::has_restriction() const {
  return !_is_default_instance_ && restriction_ != NULL;
}
void TripLeg_Edge::clear_restriction() {
  if (GetArenaNoVirtual() == NULL && restriction_ != NULL) delete restriction_;
  restriction_ = NULL;
}
const ::valhalla::TripLeg_Restriction& TripLeg_Edge::restriction() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.restriction)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return restriction_ != NULL ? *restriction_ : *default_instance().restriction_;
#else
  return restriction_ != NULL ? *restriction_ : *default_instance_->restriction_;
#endif
}
::valhalla::TripLeg_Restriction* TripLeg_Edge::mutable_restriction() {
  
  if (restriction_ == NULL) {
    restriction_ = new ::valhalla::TripLeg_Restriction;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.restriction)
  return restriction_;
}
::valhalla::TripLeg_Restriction* TripLeg_Edge::release_restriction() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.restriction)
  
  ::valhalla::TripLeg_Restriction* temp = restriction_;
  restriction_ = NULL;
  return temp;
}
void TripLeg_Edge::set_allocated_restriction(::valhalla::TripLeg_Restriction* restriction) {
  delete restriction_;
  restriction_ = restriction;
  if (restriction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.restriction)
}

// optional bool destination_only = 46;
bool TripLeg_Edge::has_destination_only() const {
  return has_destination_only_case() == kDestinationOnly;
}
void TripLeg_Edge::set_has_destination_only() {
  _oneof_case_[38] = kDestinationOnly;
}
void TripLeg_Edge::clear_destination_only() {
  if (has_destination_only()) {
    has_destination_only_.destination_only_ = false;
    clear_has_has_destination_only();
  }
}
 bool TripLeg_Edge::destination_only() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.destination_only)
  if (has_destination_only()) {
    return has_destination_only_.destination_only_;
  }
  return false;
}
 void TripLeg_Edge::set_destination_only(bool value) {
  if (!has_destination_only()) {
    clear_has_destination_only();
    set_has_destination_only();
  }
  has_destination_only_.destination_only_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.destination_only)
}

// optional bool is_urban = 47;
bool TripLeg_Edge::has_is_urban() const {
  return has_is_urban_case() == kIsUrban;
}
void TripLeg_Edge::set_has_is_urban() {
  _oneof_case_[39] = kIsUrban;
}
void TripLeg_Edge::clear_is_urban() {
  if (has_is_urban()) {
    has_is_urban_.is_urban_ = false;
    clear_has_has_is_urban();
  }
}
 bool TripLeg_Edge::is_urban() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.is_urban)
  if (has_is_urban()) {
    return has_is_urban_.is_urban_;
  }
  return false;
}
 void TripLeg_Edge::set_is_urban(bool value) {
  if (!has_is_urban()) {
    clear_has_is_urban();
    set_has_is_urban();
  }
  has_is_urban_.is_urban_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.is_urban)
}

// repeated .valhalla.TaggedValue tagged_value = 48;
int TripLeg_Edge::tagged_value_size() const {
  return tagged_value_.size();
}
void TripLeg_Edge::clear_tagged_value() {
  tagged_value_.Clear();
}
const ::valhalla::TaggedValue& TripLeg_Edge::tagged_value(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_.Get(index);
}
::valhalla::TaggedValue* TripLeg_Edge::mutable_tagged_value(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_.Mutable(index);
}
::valhalla::TaggedValue* TripLeg_Edge::add_tagged_value() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >*
TripLeg_Edge::mutable_tagged_value() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.tagged_value)
  return &tagged_value_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >&
TripLeg_Edge::tagged_value() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.tagged_value)
  return tagged_value_;
}

// optional float source_along_edge = 49;
bool TripLeg_Edge::has_source_along_edge() const {
  return has_source_along_edge_case() == kSourceAlongEdge;
}
void TripLeg_Edge::set_has_source_along_edge() {
  _oneof_case_[40] = kSourceAlongEdge;
}
void TripLeg_Edge::clear_source_along_edge() {
  if (has_source_along_edge()) {
    has_source_along_edge_.source_along_edge_ = 0;
    clear_has_has_source_along_edge();
  }
}
 float TripLeg_Edge::source_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.source_along_edge)
  if (has_source_along_edge()) {
    return has_source_along_edge_.source_along_edge_;
  }
  return 0;
}
 void TripLeg_Edge::set_source_along_edge(float value) {
  if (!has_source_along_edge()) {
    clear_has_source_along_edge();
    set_has_source_along_edge();
  }
  has_source_along_edge_.source_along_edge_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.source_along_edge)
}

// optional float target_along_edge = 50;
bool TripLeg_Edge::has_target_along_edge() const {
  return has_target_along_edge_case() == kTargetAlongEdge;
}
void TripLeg_Edge::set_has_target_along_edge() {
  _oneof_case_[41] = kTargetAlongEdge;
}
void TripLeg_Edge::clear_target_along_edge() {
  if (has_target_along_edge()) {
    has_target_along_edge_.target_along_edge_ = 0;
    clear_has_has_target_along_edge();
  }
}
 float TripLeg_Edge::target_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.target_along_edge)
  if (has_target_along_edge()) {
    return has_target_along_edge_.target_along_edge_;
  }
  return 0;
}
 void TripLeg_Edge::set_target_along_edge(float value) {
  if (!has_target_along_edge()) {
    clear_has_target_along_edge();
    set_has_target_along_edge();
  }
  has_target_along_edge_.target_along_edge_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.target_along_edge)
}

// optional .valhalla.TripLeg.SacScale sac_scale = 51;
bool TripLeg_Edge::has_sac_scale() const {
  return has_sac_scale_case() == kSacScale;
}
void TripLeg_Edge::set_has_sac_scale() {
  _oneof_case_[42] = kSacScale;
}
void TripLeg_Edge::clear_sac_scale() {
  if (has_sac_scale()) {
    has_sac_scale_.sac_scale_ = 0;
    clear_has_has_sac_scale();
  }
}
 ::valhalla::TripLeg_SacScale TripLeg_Edge::sac_scale() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sac_scale)
  if (has_sac_scale()) {
    return static_cast< ::valhalla::TripLeg_SacScale >(has_sac_scale_.sac_scale_);
  }
  return static_cast< ::valhalla::TripLeg_SacScale >(0);
}
 void TripLeg_Edge::set_sac_scale(::valhalla::TripLeg_SacScale value) {
  if (!has_sac_scale()) {
    clear_has_sac_scale();
    set_has_sac_scale();
  }
  has_sac_scale_.sac_scale_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sac_scale)
}

// optional bool shoulder = 52;
bool TripLeg_Edge::has_shoulder() const {
  return has_shoulder_case() == kShoulder;
}
void TripLeg_Edge::set_has_shoulder() {
  _oneof_case_[43] = kShoulder;
}
void TripLeg_Edge::clear_shoulder() {
  if (has_shoulder()) {
    has_shoulder_.shoulder_ = false;
    clear_has_has_shoulder();
  }
}
 bool TripLeg_Edge::shoulder() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.shoulder)
  if (has_shoulder()) {
    return has_shoulder_.shoulder_;
  }
  return false;
}
 void TripLeg_Edge::set_shoulder(bool value) {
  if (!has_shoulder()) {
    clear_has_shoulder();
    set_has_shoulder();
  }
  has_shoulder_.shoulder_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.shoulder)
}

// optional float total_length_km = 53;
bool TripLeg_Edge::has_total_length_km() const {
  return has_total_length_km_case() == kTotalLengthKm;
}
void TripLeg_Edge::set_has_total_length_km() {
  _oneof_case_[44] = kTotalLengthKm;
}
void TripLeg_Edge::clear_total_length_km() {
  if (has_total_length_km()) {
    has_total_length_km_.total_length_km_ = 0;
    clear_has_has_total_length_km();
  }
}
 float TripLeg_Edge::total_length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.total_length_km)
  if (has_total_length_km()) {
    return has_total_length_km_.total_length_km_;
  }
  return 0;
}
 void TripLeg_Edge::set_total_length_km(float value) {
  if (!has_total_length_km()) {
    clear_has_total_length_km();
    set_has_total_length_km();
  }
  has_total_length_km_.total_length_km_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.total_length_km)
}

bool TripLeg_Edge::has_has_length_km() const {
  return has_length_km_case() != HAS_LENGTH_KM_NOT_SET;
}
void TripLeg_Edge::clear_has_has_length_km() {
  _oneof_case_[0] = HAS_LENGTH_KM_NOT_SET;
}
bool TripLeg_Edge::has_has_speed() const {
  return has_speed_case() != HAS_SPEED_NOT_SET;
}
void TripLeg_Edge::clear_has_has_speed() {
  _oneof_case_[1] = HAS_SPEED_NOT_SET;
}
bool TripLeg_Edge::has_has_road_class() const {
  return has_road_class_case() != HAS_ROAD_CLASS_NOT_SET;
}
void TripLeg_Edge::clear_has_has_road_class() {
  _oneof_case_[2] = HAS_ROAD_CLASS_NOT_SET;
}
bool TripLeg_Edge::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
void TripLeg_Edge::clear_has_has_begin_heading() {
  _oneof_case_[3] = HAS_BEGIN_HEADING_NOT_SET;
}
bool TripLeg_Edge::has_has_end_heading() const {
  return has_end_heading_case() != HAS_END_HEADING_NOT_SET;
}
void TripLeg_Edge::clear_has_has_end_heading() {
  _oneof_case_[4] = HAS_END_HEADING_NOT_SET;
}
bool TripLeg_Edge::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
void TripLeg_Edge::clear_has_has_begin_shape_index() {
  _oneof_case_[5] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
bool TripLeg_Edge::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
void TripLeg_Edge::clear_has_has_end_shape_index() {
  _oneof_case_[6] = HAS_END_SHAPE_INDEX_NOT_SET;
}
bool TripLeg_Edge::has_has_traversability() const {
  return has_traversability_case() != HAS_TRAVERSABILITY_NOT_SET;
}
void TripLeg_Edge::clear_has_has_traversability() {
  _oneof_case_[7] = HAS_TRAVERSABILITY_NOT_SET;
}
bool TripLeg_Edge::has_has_use() const {
  return has_use_case() != HAS_USE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_use() {
  _oneof_case_[8] = HAS_USE_NOT_SET;
}
bool TripLeg_Edge::has_has_toll() const {
  return has_toll_case() != HAS_TOLL_NOT_SET;
}
void TripLeg_Edge::clear_has_has_toll() {
  _oneof_case_[9] = HAS_TOLL_NOT_SET;
}
bool TripLeg_Edge::has_has_unpaved() const {
  return has_unpaved_case() != HAS_UNPAVED_NOT_SET;
}
void TripLeg_Edge::clear_has_has_unpaved() {
  _oneof_case_[10] = HAS_UNPAVED_NOT_SET;
}
bool TripLeg_Edge::has_has_tunnel() const {
  return has_tunnel_case() != HAS_TUNNEL_NOT_SET;
}
void TripLeg_Edge::clear_has_has_tunnel() {
  _oneof_case_[11] = HAS_TUNNEL_NOT_SET;
}
bool TripLeg_Edge::has_has_bridge() const {
  return has_bridge_case() != HAS_BRIDGE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_bridge() {
  _oneof_case_[12] = HAS_BRIDGE_NOT_SET;
}
bool TripLeg_Edge::has_has_roundabout() const {
  return has_roundabout_case() != HAS_ROUNDABOUT_NOT_SET;
}
void TripLeg_Edge::clear_has_has_roundabout() {
  _oneof_case_[13] = HAS_ROUNDABOUT_NOT_SET;
}
bool TripLeg_Edge::has_has_internal_intersection() const {
  return has_internal_intersection_case() != HAS_INTERNAL_INTERSECTION_NOT_SET;
}
void TripLeg_Edge::clear_has_has_internal_intersection() {
  _oneof_case_[14] = HAS_INTERNAL_INTERSECTION_NOT_SET;
}
bool TripLeg_Edge::has_has_drive_on_left() const {
  return has_drive_on_left_case() != HAS_DRIVE_ON_LEFT_NOT_SET;
}
void TripLeg_Edge::clear_has_has_drive_on_left() {
  _oneof_case_[15] = HAS_DRIVE_ON_LEFT_NOT_SET;
}
bool TripLeg_Edge::has_has_surface() const {
  return has_surface_case() != HAS_SURFACE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_surface() {
  _oneof_case_[16] = HAS_SURFACE_NOT_SET;
}
bool TripLeg_Edge::has_has_travel_mode() const {
  return has_travel_mode_case() != HAS_TRAVEL_MODE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_travel_mode() {
  _oneof_case_[17] = HAS_TRAVEL_MODE_NOT_SET;
}
bool TripLeg_Edge::has_has_vehicle_type() const {
  return has_vehicle_type_case() != HAS_VEHICLE_TYPE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_vehicle_type() {
  _oneof_case_[18] = HAS_VEHICLE_TYPE_NOT_SET;
}
bool TripLeg_Edge::has_has_pedestrian_type() const {
  return has_pedestrian_type_case() != HAS_PEDESTRIAN_TYPE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_pedestrian_type() {
  _oneof_case_[19] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}
bool TripLeg_Edge::has_has_bicycle_type() const {
  return has_bicycle_type_case() != HAS_BICYCLE_TYPE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_bicycle_type() {
  _oneof_case_[20] = HAS_BICYCLE_TYPE_NOT_SET;
}
bool TripLeg_Edge::has_has_transit_type() const {
  return has_transit_type_case() != HAS_TRANSIT_TYPE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_transit_type() {
  _oneof_case_[21] = HAS_TRANSIT_TYPE_NOT_SET;
}
bool TripLeg_Edge::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
void TripLeg_Edge::clear_has_has_id() {
  _oneof_case_[22] = HAS_ID_NOT_SET;
}
bool TripLeg_Edge::has_has_way_id() const {
  return has_way_id_case() != HAS_WAY_ID_NOT_SET;
}
void TripLeg_Edge::clear_has_has_way_id() {
  _oneof_case_[23] = HAS_WAY_ID_NOT_SET;
}
bool TripLeg_Edge::has_has_weighted_grade() const {
  return has_weighted_grade_case() != HAS_WEIGHTED_GRADE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_weighted_grade() {
  _oneof_case_[24] = HAS_WEIGHTED_GRADE_NOT_SET;
}
bool TripLeg_Edge::has_has_max_upward_grade() const {
  return has_max_upward_grade_case() != HAS_MAX_UPWARD_GRADE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_max_upward_grade() {
  _oneof_case_[25] = HAS_MAX_UPWARD_GRADE_NOT_SET;
}
bool TripLeg_Edge::has_has_max_downward_grade() const {
  return has_max_downward_grade_case() != HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_max_downward_grade() {
  _oneof_case_[26] = HAS_MAX_DOWNWARD_GRADE_NOT_SET;
}
bool TripLeg_Edge::has_has_lane_count() const {
  return has_lane_count_case() != HAS_LANE_COUNT_NOT_SET;
}
void TripLeg_Edge::clear_has_has_lane_count() {
  _oneof_case_[27] = HAS_LANE_COUNT_NOT_SET;
}
bool TripLeg_Edge::has_has_cycle_lane() const {
  return has_cycle_lane_case() != HAS_CYCLE_LANE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_cycle_lane() {
  _oneof_case_[28] = HAS_CYCLE_LANE_NOT_SET;
}
bool TripLeg_Edge::has_has_bicycle_network() const {
  return has_bicycle_network_case() != HAS_BICYCLE_NETWORK_NOT_SET;
}
void TripLeg_Edge::clear_has_has_bicycle_network() {
  _oneof_case_[29] = HAS_BICYCLE_NETWORK_NOT_SET;
}
bool TripLeg_Edge::has_has_sidewalk() const {
  return has_sidewalk_case() != HAS_SIDEWALK_NOT_SET;
}
void TripLeg_Edge::clear_has_has_sidewalk() {
  _oneof_case_[30] = HAS_SIDEWALK_NOT_SET;
}
bool TripLeg_Edge::has_has_density() const {
  return has_density_case() != HAS_DENSITY_NOT_SET;
}
void TripLeg_Edge::clear_has_has_density() {
  _oneof_case_[31] = HAS_DENSITY_NOT_SET;
}
bool TripLeg_Edge::has_has_speed_limit() const {
  return has_speed_limit_case() != HAS_SPEED_LIMIT_NOT_SET;
}
void TripLeg_Edge::clear_has_has_speed_limit() {
  _oneof_case_[32] = HAS_SPEED_LIMIT_NOT_SET;
}
bool TripLeg_Edge::has_has_truck_speed() const {
  return has_truck_speed_case() != HAS_TRUCK_SPEED_NOT_SET;
}
void TripLeg_Edge::clear_has_has_truck_speed() {
  _oneof_case_[33] = HAS_TRUCK_SPEED_NOT_SET;
}
bool TripLeg_Edge::has_has_truck_route() const {
  return has_truck_route_case() != HAS_TRUCK_ROUTE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_truck_route() {
  _oneof_case_[34] = HAS_TRUCK_ROUTE_NOT_SET;
}
bool TripLeg_Edge::has_has_mean_elevation() const {
  return has_mean_elevation_case() != HAS_MEAN_ELEVATION_NOT_SET;
}
void TripLeg_Edge::clear_has_has_mean_elevation() {
  _oneof_case_[35] = HAS_MEAN_ELEVATION_NOT_SET;
}
bool TripLeg_Edge::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
void TripLeg_Edge::clear_has_has_has_time_restrictions() {
  _oneof_case_[36] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
bool TripLeg_Edge::has_has_default_speed() const {
  return has_default_speed_case() != HAS_DEFAULT_SPEED_NOT_SET;
}
void TripLeg_Edge::clear_has_has_default_speed() {
  _oneof_case_[37] = HAS_DEFAULT_SPEED_NOT_SET;
}
bool TripLeg_Edge::has_has_destination_only() const {
  return has_destination_only_case() != HAS_DESTINATION_ONLY_NOT_SET;
}
void TripLeg_Edge::clear_has_has_destination_only() {
  _oneof_case_[38] = HAS_DESTINATION_ONLY_NOT_SET;
}
bool TripLeg_Edge::has_has_is_urban() const {
  return has_is_urban_case() != HAS_IS_URBAN_NOT_SET;
}
void TripLeg_Edge::clear_has_has_is_urban() {
  _oneof_case_[39] = HAS_IS_URBAN_NOT_SET;
}
bool TripLeg_Edge::has_has_source_along_edge() const {
  return has_source_along_edge_case() != HAS_SOURCE_ALONG_EDGE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_source_along_edge() {
  _oneof_case_[40] = HAS_SOURCE_ALONG_EDGE_NOT_SET;
}
bool TripLeg_Edge::has_has_target_along_edge() const {
  return has_target_along_edge_case() != HAS_TARGET_ALONG_EDGE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_target_along_edge() {
  _oneof_case_[41] = HAS_TARGET_ALONG_EDGE_NOT_SET;
}
bool TripLeg_Edge::has_has_sac_scale() const {
  return has_sac_scale_case() != HAS_SAC_SCALE_NOT_SET;
}
void TripLeg_Edge::clear_has_has_sac_scale() {
  _oneof_case_[42] = HAS_SAC_SCALE_NOT_SET;
}
bool TripLeg_Edge::has_has_shoulder() const {
  return has_shoulder_case() != HAS_SHOULDER_NOT_SET;
}
void TripLeg_Edge::clear_has_has_shoulder() {
  _oneof_case_[43] = HAS_SHOULDER_NOT_SET;
}
bool TripLeg_Edge::has_has_total_length_km() const {
  return has_total_length_km_case() != HAS_TOTAL_LENGTH_KM_NOT_SET;
}
void TripLeg_Edge::clear_has_has_total_length_km() {
  _oneof_case_[44] = HAS_TOTAL_LENGTH_KM_NOT_SET;
}
TripLeg_Edge::HasLengthKmCase TripLeg_Edge::has_length_km_case() const {
  return TripLeg_Edge::HasLengthKmCase(_oneof_case_[0]);
}
TripLeg_Edge::HasSpeedCase TripLeg_Edge::has_speed_case() const {
  return TripLeg_Edge::HasSpeedCase(_oneof_case_[1]);
}
TripLeg_Edge::HasRoadClassCase TripLeg_Edge::has_road_class_case() const {
  return TripLeg_Edge::HasRoadClassCase(_oneof_case_[2]);
}
TripLeg_Edge::HasBeginHeadingCase TripLeg_Edge::has_begin_heading_case() const {
  return TripLeg_Edge::HasBeginHeadingCase(_oneof_case_[3]);
}
TripLeg_Edge::HasEndHeadingCase TripLeg_Edge::has_end_heading_case() const {
  return TripLeg_Edge::HasEndHeadingCase(_oneof_case_[4]);
}
TripLeg_Edge::HasBeginShapeIndexCase TripLeg_Edge::has_begin_shape_index_case() const {
  return TripLeg_Edge::HasBeginShapeIndexCase(_oneof_case_[5]);
}
TripLeg_Edge::HasEndShapeIndexCase TripLeg_Edge::has_end_shape_index_case() const {
  return TripLeg_Edge::HasEndShapeIndexCase(_oneof_case_[6]);
}
TripLeg_Edge::HasTraversabilityCase TripLeg_Edge::has_traversability_case() const {
  return TripLeg_Edge::HasTraversabilityCase(_oneof_case_[7]);
}
TripLeg_Edge::HasUseCase TripLeg_Edge::has_use_case() const {
  return TripLeg_Edge::HasUseCase(_oneof_case_[8]);
}
TripLeg_Edge::HasTollCase TripLeg_Edge::has_toll_case() const {
  return TripLeg_Edge::HasTollCase(_oneof_case_[9]);
}
TripLeg_Edge::HasUnpavedCase TripLeg_Edge::has_unpaved_case() const {
  return TripLeg_Edge::HasUnpavedCase(_oneof_case_[10]);
}
TripLeg_Edge::HasTunnelCase TripLeg_Edge::has_tunnel_case() const {
  return TripLeg_Edge::HasTunnelCase(_oneof_case_[11]);
}
TripLeg_Edge::HasBridgeCase TripLeg_Edge::has_bridge_case() const {
  return TripLeg_Edge::HasBridgeCase(_oneof_case_[12]);
}
TripLeg_Edge::HasRoundaboutCase TripLeg_Edge::has_roundabout_case() const {
  return TripLeg_Edge::HasRoundaboutCase(_oneof_case_[13]);
}
TripLeg_Edge::HasInternalIntersectionCase TripLeg_Edge::has_internal_intersection_case() const {
  return TripLeg_Edge::HasInternalIntersectionCase(_oneof_case_[14]);
}
TripLeg_Edge::HasDriveOnLeftCase TripLeg_Edge::has_drive_on_left_case() const {
  return TripLeg_Edge::HasDriveOnLeftCase(_oneof_case_[15]);
}
TripLeg_Edge::HasSurfaceCase TripLeg_Edge::has_surface_case() const {
  return TripLeg_Edge::HasSurfaceCase(_oneof_case_[16]);
}
TripLeg_Edge::HasTravelModeCase TripLeg_Edge::has_travel_mode_case() const {
  return TripLeg_Edge::HasTravelModeCase(_oneof_case_[17]);
}
TripLeg_Edge::HasVehicleTypeCase TripLeg_Edge::has_vehicle_type_case() const {
  return TripLeg_Edge::HasVehicleTypeCase(_oneof_case_[18]);
}
TripLeg_Edge::HasPedestrianTypeCase TripLeg_Edge::has_pedestrian_type_case() const {
  return TripLeg_Edge::HasPedestrianTypeCase(_oneof_case_[19]);
}
TripLeg_Edge::HasBicycleTypeCase TripLeg_Edge::has_bicycle_type_case() const {
  return TripLeg_Edge::HasBicycleTypeCase(_oneof_case_[20]);
}
TripLeg_Edge::HasTransitTypeCase TripLeg_Edge::has_transit_type_case() const {
  return TripLeg_Edge::HasTransitTypeCase(_oneof_case_[21]);
}
TripLeg_Edge::HasIdCase TripLeg_Edge::has_id_case() const {
  return TripLeg_Edge::HasIdCase(_oneof_case_[22]);
}
TripLeg_Edge::HasWayIdCase TripLeg_Edge::has_way_id_case() const {
  return TripLeg_Edge::HasWayIdCase(_oneof_case_[23]);
}
TripLeg_Edge::HasWeightedGradeCase TripLeg_Edge::has_weighted_grade_case() const {
  return TripLeg_Edge::HasWeightedGradeCase(_oneof_case_[24]);
}
TripLeg_Edge::HasMaxUpwardGradeCase TripLeg_Edge::has_max_upward_grade_case() const {
  return TripLeg_Edge::HasMaxUpwardGradeCase(_oneof_case_[25]);
}
TripLeg_Edge::HasMaxDownwardGradeCase TripLeg_Edge::has_max_downward_grade_case() const {
  return TripLeg_Edge::HasMaxDownwardGradeCase(_oneof_case_[26]);
}
TripLeg_Edge::HasLaneCountCase TripLeg_Edge::has_lane_count_case() const {
  return TripLeg_Edge::HasLaneCountCase(_oneof_case_[27]);
}
TripLeg_Edge::HasCycleLaneCase TripLeg_Edge::has_cycle_lane_case() const {
  return TripLeg_Edge::HasCycleLaneCase(_oneof_case_[28]);
}
TripLeg_Edge::HasBicycleNetworkCase TripLeg_Edge::has_bicycle_network_case() const {
  return TripLeg_Edge::HasBicycleNetworkCase(_oneof_case_[29]);
}
TripLeg_Edge::HasSidewalkCase TripLeg_Edge::has_sidewalk_case() const {
  return TripLeg_Edge::HasSidewalkCase(_oneof_case_[30]);
}
TripLeg_Edge::HasDensityCase TripLeg_Edge::has_density_case() const {
  return TripLeg_Edge::HasDensityCase(_oneof_case_[31]);
}
TripLeg_Edge::HasSpeedLimitCase TripLeg_Edge::has_speed_limit_case() const {
  return TripLeg_Edge::HasSpeedLimitCase(_oneof_case_[32]);
}
TripLeg_Edge::HasTruckSpeedCase TripLeg_Edge::has_truck_speed_case() const {
  return TripLeg_Edge::HasTruckSpeedCase(_oneof_case_[33]);
}
TripLeg_Edge::HasTruckRouteCase TripLeg_Edge::has_truck_route_case() const {
  return TripLeg_Edge::HasTruckRouteCase(_oneof_case_[34]);
}
TripLeg_Edge::HasMeanElevationCase TripLeg_Edge::has_mean_elevation_case() const {
  return TripLeg_Edge::HasMeanElevationCase(_oneof_case_[35]);
}
TripLeg_Edge::HasHasTimeRestrictionsCase TripLeg_Edge::has_has_time_restrictions_case() const {
  return TripLeg_Edge::HasHasTimeRestrictionsCase(_oneof_case_[36]);
}
TripLeg_Edge::HasDefaultSpeedCase TripLeg_Edge::has_default_speed_case() const {
  return TripLeg_Edge::HasDefaultSpeedCase(_oneof_case_[37]);
}
TripLeg_Edge::HasDestinationOnlyCase TripLeg_Edge::has_destination_only_case() const {
  return TripLeg_Edge::HasDestinationOnlyCase(_oneof_case_[38]);
}
TripLeg_Edge::HasIsUrbanCase TripLeg_Edge::has_is_urban_case() const {
  return TripLeg_Edge::HasIsUrbanCase(_oneof_case_[39]);
}
TripLeg_Edge::HasSourceAlongEdgeCase TripLeg_Edge::has_source_along_edge_case() const {
  return TripLeg_Edge::HasSourceAlongEdgeCase(_oneof_case_[40]);
}
TripLeg_Edge::HasTargetAlongEdgeCase TripLeg_Edge::has_target_along_edge_case() const {
  return TripLeg_Edge::HasTargetAlongEdgeCase(_oneof_case_[41]);
}
TripLeg_Edge::HasSacScaleCase TripLeg_Edge::has_sac_scale_case() const {
  return TripLeg_Edge::HasSacScaleCase(_oneof_case_[42]);
}
TripLeg_Edge::HasShoulderCase TripLeg_Edge::has_shoulder_case() const {
  return TripLeg_Edge::HasShoulderCase(_oneof_case_[43]);
}
TripLeg_Edge::HasTotalLengthKmCase TripLeg_Edge::has_total_length_km_case() const {
  return TripLeg_Edge::HasTotalLengthKmCase(_oneof_case_[44]);
}
// -------------------------------------------------------------------

// TripLeg_IntersectingEdge

// optional uint32 begin_heading = 1;
bool TripLeg_IntersectingEdge::has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
void TripLeg_IntersectingEdge::set_has_begin_heading() {
  _oneof_case_[0] = kBeginHeading;
}
void TripLeg_IntersectingEdge::clear_begin_heading() {
  if (has_begin_heading()) {
    has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
 ::google::protobuf::uint32 TripLeg_IntersectingEdge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.begin_heading)
  if (has_begin_heading()) {
    return has_begin_heading_.begin_heading_;
  }
  return 0u;
}
 void TripLeg_IntersectingEdge::set_begin_heading(::google::protobuf::uint32 value) {
  if (!has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  has_begin_heading_.begin_heading_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.begin_heading)
}

// optional bool prev_name_consistency = 2;
bool TripLeg_IntersectingEdge::has_prev_name_consistency() const {
  return has_prev_name_consistency_case() == kPrevNameConsistency;
}
void TripLeg_IntersectingEdge::set_has_prev_name_consistency() {
  _oneof_case_[1] = kPrevNameConsistency;
}
void TripLeg_IntersectingEdge::clear_prev_name_consistency() {
  if (has_prev_name_consistency()) {
    has_prev_name_consistency_.prev_name_consistency_ = false;
    clear_has_has_prev_name_consistency();
  }
}
 bool TripLeg_IntersectingEdge::prev_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
  if (has_prev_name_consistency()) {
    return has_prev_name_consistency_.prev_name_consistency_;
  }
  return false;
}
 void TripLeg_IntersectingEdge::set_prev_name_consistency(bool value) {
  if (!has_prev_name_consistency()) {
    clear_has_prev_name_consistency();
    set_has_prev_name_consistency();
  }
  has_prev_name_consistency_.prev_name_consistency_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
}

// optional bool curr_name_consistency = 3;
bool TripLeg_IntersectingEdge::has_curr_name_consistency() const {
  return has_curr_name_consistency_case() == kCurrNameConsistency;
}
void TripLeg_IntersectingEdge::set_has_curr_name_consistency() {
  _oneof_case_[2] = kCurrNameConsistency;
}
void TripLeg_IntersectingEdge::clear_curr_name_consistency() {
  if (has_curr_name_consistency()) {
    has_curr_name_consistency_.curr_name_consistency_ = false;
    clear_has_has_curr_name_consistency();
  }
}
 bool TripLeg_IntersectingEdge::curr_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
  if (has_curr_name_consistency()) {
    return has_curr_name_consistency_.curr_name_consistency_;
  }
  return false;
}
 void TripLeg_IntersectingEdge::set_curr_name_consistency(bool value) {
  if (!has_curr_name_consistency()) {
    clear_has_curr_name_consistency();
    set_has_curr_name_consistency();
  }
  has_curr_name_consistency_.curr_name_consistency_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
}

// optional .valhalla.TripLeg.Traversability driveability = 4;
bool TripLeg_IntersectingEdge::has_driveability() const {
  return has_driveability_case() == kDriveability;
}
void TripLeg_IntersectingEdge::set_has_driveability() {
  _oneof_case_[3] = kDriveability;
}
void TripLeg_IntersectingEdge::clear_driveability() {
  if (has_driveability()) {
    has_driveability_.driveability_ = 0;
    clear_has_has_driveability();
  }
}
 ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::driveability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.driveability)
  if (has_driveability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_driveability_.driveability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
 void TripLeg_IntersectingEdge::set_driveability(::valhalla::TripLeg_Traversability value) {
  if (!has_driveability()) {
    clear_has_driveability();
    set_has_driveability();
  }
  has_driveability_.driveability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.driveability)
}

// optional .valhalla.TripLeg.Traversability cyclability = 5;
bool TripLeg_IntersectingEdge::has_cyclability() const {
  return has_cyclability_case() == kCyclability;
}
void TripLeg_IntersectingEdge::set_has_cyclability() {
  _oneof_case_[4] = kCyclability;
}
void TripLeg_IntersectingEdge::clear_cyclability() {
  if (has_cyclability()) {
    has_cyclability_.cyclability_ = 0;
    clear_has_has_cyclability();
  }
}
 ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::cyclability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.cyclability)
  if (has_cyclability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_cyclability_.cyclability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
 void TripLeg_IntersectingEdge::set_cyclability(::valhalla::TripLeg_Traversability value) {
  if (!has_cyclability()) {
    clear_has_cyclability();
    set_has_cyclability();
  }
  has_cyclability_.cyclability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.cyclability)
}

// optional .valhalla.TripLeg.Traversability walkability = 6;
bool TripLeg_IntersectingEdge::has_walkability() const {
  return has_walkability_case() == kWalkability;
}
void TripLeg_IntersectingEdge::set_has_walkability() {
  _oneof_case_[5] = kWalkability;
}
void TripLeg_IntersectingEdge::clear_walkability() {
  if (has_walkability()) {
    has_walkability_.walkability_ = 0;
    clear_has_has_walkability();
  }
}
 ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::walkability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.walkability)
  if (has_walkability()) {
    return static_cast< ::valhalla::TripLeg_Traversability >(has_walkability_.walkability_);
  }
  return static_cast< ::valhalla::TripLeg_Traversability >(0);
}
 void TripLeg_IntersectingEdge::set_walkability(::valhalla::TripLeg_Traversability value) {
  if (!has_walkability()) {
    clear_has_walkability();
    set_has_walkability();
  }
  has_walkability_.walkability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.walkability)
}

// optional .valhalla.TripLeg.Use use = 7;
bool TripLeg_IntersectingEdge::has_use() const {
  return has_use_case() == kUse;
}
void TripLeg_IntersectingEdge::set_has_use() {
  _oneof_case_[6] = kUse;
}
void TripLeg_IntersectingEdge::clear_use() {
  if (has_use()) {
    has_use_.use_ = 0;
    clear_has_has_use();
  }
}
 ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.use)
  if (has_use()) {
    return static_cast< ::valhalla::TripLeg_Use >(has_use_.use_);
  }
  return static_cast< ::valhalla::TripLeg_Use >(0);
}
 void TripLeg_IntersectingEdge::set_use(::valhalla::TripLeg_Use value) {
  if (!has_use()) {
    clear_has_use();
    set_has_use();
  }
  has_use_.use_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.use)
}

// optional .valhalla.RoadClass road_class = 8;
bool TripLeg_IntersectingEdge::has_road_class() const {
  return has_road_class_case() == kRoadClass;
}
void TripLeg_IntersectingEdge::set_has_road_class() {
  _oneof_case_[7] = kRoadClass;
}
void TripLeg_IntersectingEdge::clear_road_class() {
  if (has_road_class()) {
    has_road_class_.road_class_ = 0;
    clear_has_has_road_class();
  }
}
 ::valhalla::RoadClass TripLeg_IntersectingEdge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.road_class)
  if (has_road_class()) {
    return static_cast< ::valhalla::RoadClass >(has_road_class_.road_class_);
  }
  return static_cast< ::valhalla::RoadClass >(0);
}
 void TripLeg_IntersectingEdge::set_road_class(::valhalla::RoadClass value) {
  if (!has_road_class()) {
    clear_has_road_class();
    set_has_road_class();
  }
  has_road_class_.road_class_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.road_class)
}

// optional uint32 lane_count = 9;
bool TripLeg_IntersectingEdge::has_lane_count() const {
  return has_lane_count_case() == kLaneCount;
}
void TripLeg_IntersectingEdge::set_has_lane_count() {
  _oneof_case_[8] = kLaneCount;
}
void TripLeg_IntersectingEdge::clear_lane_count() {
  if (has_lane_count()) {
    has_lane_count_.lane_count_ = 0u;
    clear_has_has_lane_count();
  }
}
 ::google::protobuf::uint32 TripLeg_IntersectingEdge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.lane_count)
  if (has_lane_count()) {
    return has_lane_count_.lane_count_;
  }
  return 0u;
}
 void TripLeg_IntersectingEdge::set_lane_count(::google::protobuf::uint32 value) {
  if (!has_lane_count()) {
    clear_has_lane_count();
    set_has_lane_count();
  }
  has_lane_count_.lane_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.lane_count)
}

// optional .valhalla.TripSign sign = 10;
bool TripLeg_IntersectingEdge::has_sign() const {
  return !_is_default_instance_ && sign_ != NULL;
}
void TripLeg_IntersectingEdge::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) delete sign_;
  sign_ = NULL;
}
const ::valhalla::TripSign& TripLeg_IntersectingEdge::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.sign)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
::valhalla::TripSign* TripLeg_IntersectingEdge::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::valhalla::TripSign;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.IntersectingEdge.sign)
  return sign_;
}
::valhalla::TripSign* TripLeg_IntersectingEdge::release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.IntersectingEdge.sign)
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = NULL;
  return temp;
}
void TripLeg_IntersectingEdge::set_allocated_sign(::valhalla::TripSign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}

bool TripLeg_IntersectingEdge::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_begin_heading() {
  _oneof_case_[0] = HAS_BEGIN_HEADING_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_prev_name_consistency() const {
  return has_prev_name_consistency_case() != HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_prev_name_consistency() {
  _oneof_case_[1] = HAS_PREV_NAME_CONSISTENCY_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_curr_name_consistency() const {
  return has_curr_name_consistency_case() != HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_curr_name_consistency() {
  _oneof_case_[2] = HAS_CURR_NAME_CONSISTENCY_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_driveability() const {
  return has_driveability_case() != HAS_DRIVEABILITY_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_driveability() {
  _oneof_case_[3] = HAS_DRIVEABILITY_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_cyclability() const {
  return has_cyclability_case() != HAS_CYCLABILITY_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_cyclability() {
  _oneof_case_[4] = HAS_CYCLABILITY_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_walkability() const {
  return has_walkability_case() != HAS_WALKABILITY_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_walkability() {
  _oneof_case_[5] = HAS_WALKABILITY_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_use() const {
  return has_use_case() != HAS_USE_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_use() {
  _oneof_case_[6] = HAS_USE_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_road_class() const {
  return has_road_class_case() != HAS_ROAD_CLASS_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_road_class() {
  _oneof_case_[7] = HAS_ROAD_CLASS_NOT_SET;
}
bool TripLeg_IntersectingEdge::has_has_lane_count() const {
  return has_lane_count_case() != HAS_LANE_COUNT_NOT_SET;
}
void TripLeg_IntersectingEdge::clear_has_has_lane_count() {
  _oneof_case_[8] = HAS_LANE_COUNT_NOT_SET;
}
TripLeg_IntersectingEdge::HasBeginHeadingCase TripLeg_IntersectingEdge::has_begin_heading_case() const {
  return TripLeg_IntersectingEdge::HasBeginHeadingCase(_oneof_case_[0]);
}
TripLeg_IntersectingEdge::HasPrevNameConsistencyCase TripLeg_IntersectingEdge::has_prev_name_consistency_case() const {
  return TripLeg_IntersectingEdge::HasPrevNameConsistencyCase(_oneof_case_[1]);
}
TripLeg_IntersectingEdge::HasCurrNameConsistencyCase TripLeg_IntersectingEdge::has_curr_name_consistency_case() const {
  return TripLeg_IntersectingEdge::HasCurrNameConsistencyCase(_oneof_case_[2]);
}
TripLeg_IntersectingEdge::HasDriveabilityCase TripLeg_IntersectingEdge::has_driveability_case() const {
  return TripLeg_IntersectingEdge::HasDriveabilityCase(_oneof_case_[3]);
}
TripLeg_IntersectingEdge::HasCyclabilityCase TripLeg_IntersectingEdge::has_cyclability_case() const {
  return TripLeg_IntersectingEdge::HasCyclabilityCase(_oneof_case_[4]);
}
TripLeg_IntersectingEdge::HasWalkabilityCase TripLeg_IntersectingEdge::has_walkability_case() const {
  return TripLeg_IntersectingEdge::HasWalkabilityCase(_oneof_case_[5]);
}
TripLeg_IntersectingEdge::HasUseCase TripLeg_IntersectingEdge::has_use_case() const {
  return TripLeg_IntersectingEdge::HasUseCase(_oneof_case_[6]);
}
TripLeg_IntersectingEdge::HasRoadClassCase TripLeg_IntersectingEdge::has_road_class_case() const {
  return TripLeg_IntersectingEdge::HasRoadClassCase(_oneof_case_[7]);
}
TripLeg_IntersectingEdge::HasLaneCountCase TripLeg_IntersectingEdge::has_lane_count_case() const {
  return TripLeg_IntersectingEdge::HasLaneCountCase(_oneof_case_[8]);
}
// -------------------------------------------------------------------

// TripLeg_Cost

// optional double seconds = 1;
bool TripLeg_Cost::has_seconds() const {
  return has_seconds_case() == kSeconds;
}
void TripLeg_Cost::set_has_seconds() {
  _oneof_case_[0] = kSeconds;
}
void TripLeg_Cost::clear_seconds() {
  if (has_seconds()) {
    has_seconds_.seconds_ = 0;
    clear_has_has_seconds();
  }
}
 double TripLeg_Cost::seconds() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.seconds)
  if (has_seconds()) {
    return has_seconds_.seconds_;
  }
  return 0;
}
 void TripLeg_Cost::set_seconds(double value) {
  if (!has_seconds()) {
    clear_has_seconds();
    set_has_seconds();
  }
  has_seconds_.seconds_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.seconds)
}

// optional double cost = 2;
bool TripLeg_Cost::has_cost() const {
  return has_cost_case() == kCost;
}
void TripLeg_Cost::set_has_cost() {
  _oneof_case_[1] = kCost;
}
void TripLeg_Cost::clear_cost() {
  if (has_cost()) {
    has_cost_.cost_ = 0;
    clear_has_has_cost();
  }
}
 double TripLeg_Cost::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.cost)
  if (has_cost()) {
    return has_cost_.cost_;
  }
  return 0;
}
 void TripLeg_Cost::set_cost(double value) {
  if (!has_cost()) {
    clear_has_cost();
    set_has_cost();
  }
  has_cost_.cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.cost)
}

bool TripLeg_Cost::has_has_seconds() const {
  return has_seconds_case() != HAS_SECONDS_NOT_SET;
}
void TripLeg_Cost::clear_has_has_seconds() {
  _oneof_case_[0] = HAS_SECONDS_NOT_SET;
}
bool TripLeg_Cost::has_has_cost() const {
  return has_cost_case() != HAS_COST_NOT_SET;
}
void TripLeg_Cost::clear_has_has_cost() {
  _oneof_case_[1] = HAS_COST_NOT_SET;
}
TripLeg_Cost::HasSecondsCase TripLeg_Cost::has_seconds_case() const {
  return TripLeg_Cost::HasSecondsCase(_oneof_case_[0]);
}
TripLeg_Cost::HasCostCase TripLeg_Cost::has_cost_case() const {
  return TripLeg_Cost::HasCostCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg_PathCost

// optional .valhalla.TripLeg.Cost elapsed_cost = 1;
bool TripLeg_PathCost::has_elapsed_cost() const {
  return !_is_default_instance_ && elapsed_cost_ != NULL;
}
void TripLeg_PathCost::clear_elapsed_cost() {
  if (GetArenaNoVirtual() == NULL && elapsed_cost_ != NULL) delete elapsed_cost_;
  elapsed_cost_ = NULL;
}
const ::valhalla::TripLeg_Cost& TripLeg_PathCost::elapsed_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.elapsed_cost)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return elapsed_cost_ != NULL ? *elapsed_cost_ : *default_instance().elapsed_cost_;
#else
  return elapsed_cost_ != NULL ? *elapsed_cost_ : *default_instance_->elapsed_cost_;
#endif
}
::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_elapsed_cost() {
  
  if (elapsed_cost_ == NULL) {
    elapsed_cost_ = new ::valhalla::TripLeg_Cost;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.elapsed_cost)
  return elapsed_cost_;
}
::valhalla::TripLeg_Cost* TripLeg_PathCost::release_elapsed_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.elapsed_cost)
  
  ::valhalla::TripLeg_Cost* temp = elapsed_cost_;
  elapsed_cost_ = NULL;
  return temp;
}
void TripLeg_PathCost::set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* elapsed_cost) {
  delete elapsed_cost_;
  elapsed_cost_ = elapsed_cost;
  if (elapsed_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}

// optional .valhalla.TripLeg.Cost transition_cost = 2;
bool TripLeg_PathCost::has_transition_cost() const {
  return !_is_default_instance_ && transition_cost_ != NULL;
}
void TripLeg_PathCost::clear_transition_cost() {
  if (GetArenaNoVirtual() == NULL && transition_cost_ != NULL) delete transition_cost_;
  transition_cost_ = NULL;
}
const ::valhalla::TripLeg_Cost& TripLeg_PathCost::transition_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.transition_cost)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transition_cost_ != NULL ? *transition_cost_ : *default_instance().transition_cost_;
#else
  return transition_cost_ != NULL ? *transition_cost_ : *default_instance_->transition_cost_;
#endif
}
::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_transition_cost() {
  
  if (transition_cost_ == NULL) {
    transition_cost_ = new ::valhalla::TripLeg_Cost;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.transition_cost)
  return transition_cost_;
}
::valhalla::TripLeg_Cost* TripLeg_PathCost::release_transition_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.transition_cost)
  
  ::valhalla::TripLeg_Cost* temp = transition_cost_;
  transition_cost_ = NULL;
  return temp;
}
void TripLeg_PathCost::set_allocated_transition_cost(::valhalla::TripLeg_Cost* transition_cost) {
  delete transition_cost_;
  transition_cost_ = transition_cost;
  if (transition_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}

// -------------------------------------------------------------------

// TripLeg_Node

// optional .valhalla.TripLeg.Edge edge = 1;
bool TripLeg_Node::has_edge() const {
  return !_is_default_instance_ && edge_ != NULL;
}
void TripLeg_Node::clear_edge() {
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) delete edge_;
  edge_ = NULL;
}
const ::valhalla::TripLeg_Edge& TripLeg_Node::edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.edge)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return edge_ != NULL ? *edge_ : *default_instance().edge_;
#else
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
#endif
}
::valhalla::TripLeg_Edge* TripLeg_Node::mutable_edge() {
  
  if (edge_ == NULL) {
    edge_ = new ::valhalla::TripLeg_Edge;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.edge)
  return edge_;
}
::valhalla::TripLeg_Edge* TripLeg_Node::release_edge() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.edge)
  
  ::valhalla::TripLeg_Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
void TripLeg_Node::set_allocated_edge(::valhalla::TripLeg_Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.edge)
}

// repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
int TripLeg_Node::intersecting_edge_size() const {
  return intersecting_edge_.size();
}
void TripLeg_Node::clear_intersecting_edge() {
  intersecting_edge_.Clear();
}
const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::intersecting_edge(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_.Get(index);
}
::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::mutable_intersecting_edge(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_.Mutable(index);
}
::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::add_intersecting_edge() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
TripLeg_Node::mutable_intersecting_edge() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.intersecting_edge)
  return &intersecting_edge_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
TripLeg_Node::intersecting_edge() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.intersecting_edge)
  return intersecting_edge_;
}

// optional uint32 admin_index = 3;
bool TripLeg_Node::has_admin_index() const {
  return has_admin_index_case() == kAdminIndex;
}
void TripLeg_Node::set_has_admin_index() {
  _oneof_case_[0] = kAdminIndex;
}
void TripLeg_Node::clear_admin_index() {
  if (has_admin_index()) {
    has_admin_index_.admin_index_ = 0u;
    clear_has_has_admin_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Node::admin_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.admin_index)
  if (has_admin_index()) {
    return has_admin_index_.admin_index_;
  }
  return 0u;
}
 void TripLeg_Node::set_admin_index(::google::protobuf::uint32 value) {
  if (!has_admin_index()) {
    clear_has_admin_index();
    set_has_admin_index();
  }
  has_admin_index_.admin_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.admin_index)
}

// optional .valhalla.TripLeg.Node.Type type = 4;
bool TripLeg_Node::has_type() const {
  return has_type_case() == kType;
}
void TripLeg_Node::set_has_type() {
  _oneof_case_[1] = kType;
}
void TripLeg_Node::clear_type() {
  if (has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
 ::valhalla::TripLeg_Node_Type TripLeg_Node::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.type)
  if (has_type()) {
    return static_cast< ::valhalla::TripLeg_Node_Type >(has_type_.type_);
  }
  return static_cast< ::valhalla::TripLeg_Node_Type >(0);
}
 void TripLeg_Node::set_type(::valhalla::TripLeg_Node_Type value) {
  if (!has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.type)
}

// optional bool fork = 5;
bool TripLeg_Node::has_fork() const {
  return has_fork_case() == kFork;
}
void TripLeg_Node::set_has_fork() {
  _oneof_case_[2] = kFork;
}
void TripLeg_Node::clear_fork() {
  if (has_fork()) {
    has_fork_.fork_ = false;
    clear_has_has_fork();
  }
}
 bool TripLeg_Node::fork() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.fork)
  if (has_fork()) {
    return has_fork_.fork_;
  }
  return false;
}
 void TripLeg_Node::set_fork(bool value) {
  if (!has_fork()) {
    clear_has_fork();
    set_has_fork();
  }
  has_fork_.fork_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.fork)
}

// optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
bool TripLeg_Node::has_transit_platform_info() const {
  return !_is_default_instance_ && transit_platform_info_ != NULL;
}
void TripLeg_Node::clear_transit_platform_info() {
  if (GetArenaNoVirtual() == NULL && transit_platform_info_ != NULL) delete transit_platform_info_;
  transit_platform_info_ = NULL;
}
const ::valhalla::TransitPlatformInfo& TripLeg_Node::transit_platform_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_platform_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_platform_info_ != NULL ? *transit_platform_info_ : *default_instance().transit_platform_info_;
#else
  return transit_platform_info_ != NULL ? *transit_platform_info_ : *default_instance_->transit_platform_info_;
#endif
}
::valhalla::TransitPlatformInfo* TripLeg_Node::mutable_transit_platform_info() {
  
  if (transit_platform_info_ == NULL) {
    transit_platform_info_ = new ::valhalla::TransitPlatformInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_platform_info)
  return transit_platform_info_;
}
::valhalla::TransitPlatformInfo* TripLeg_Node::release_transit_platform_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_platform_info)
  
  ::valhalla::TransitPlatformInfo* temp = transit_platform_info_;
  transit_platform_info_ = NULL;
  return temp;
}
void TripLeg_Node::set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info) {
  delete transit_platform_info_;
  transit_platform_info_ = transit_platform_info;
  if (transit_platform_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}

// optional .valhalla.TransitStationInfo transit_station_info = 7;
bool TripLeg_Node::has_transit_station_info() const {
  return !_is_default_instance_ && transit_station_info_ != NULL;
}
void TripLeg_Node::clear_transit_station_info() {
  if (GetArenaNoVirtual() == NULL && transit_station_info_ != NULL) delete transit_station_info_;
  transit_station_info_ = NULL;
}
const ::valhalla::TransitStationInfo& TripLeg_Node::transit_station_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_station_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_station_info_ != NULL ? *transit_station_info_ : *default_instance().transit_station_info_;
#else
  return transit_station_info_ != NULL ? *transit_station_info_ : *default_instance_->transit_station_info_;
#endif
}
::valhalla::TransitStationInfo* TripLeg_Node::mutable_transit_station_info() {
  
  if (transit_station_info_ == NULL) {
    transit_station_info_ = new ::valhalla::TransitStationInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_station_info)
  return transit_station_info_;
}
::valhalla::TransitStationInfo* TripLeg_Node::release_transit_station_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_station_info)
  
  ::valhalla::TransitStationInfo* temp = transit_station_info_;
  transit_station_info_ = NULL;
  return temp;
}
void TripLeg_Node::set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info) {
  delete transit_station_info_;
  transit_station_info_ = transit_station_info;
  if (transit_station_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}

// optional .valhalla.TransitEgressInfo transit_egress_info = 10;
bool TripLeg_Node::has_transit_egress_info() const {
  return !_is_default_instance_ && transit_egress_info_ != NULL;
}
void TripLeg_Node::clear_transit_egress_info() {
  if (GetArenaNoVirtual() == NULL && transit_egress_info_ != NULL) delete transit_egress_info_;
  transit_egress_info_ = NULL;
}
const ::valhalla::TransitEgressInfo& TripLeg_Node::transit_egress_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_egress_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_egress_info_ != NULL ? *transit_egress_info_ : *default_instance().transit_egress_info_;
#else
  return transit_egress_info_ != NULL ? *transit_egress_info_ : *default_instance_->transit_egress_info_;
#endif
}
::valhalla::TransitEgressInfo* TripLeg_Node::mutable_transit_egress_info() {
  
  if (transit_egress_info_ == NULL) {
    transit_egress_info_ = new ::valhalla::TransitEgressInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_egress_info)
  return transit_egress_info_;
}
::valhalla::TransitEgressInfo* TripLeg_Node::release_transit_egress_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_egress_info)
  
  ::valhalla::TransitEgressInfo* temp = transit_egress_info_;
  transit_egress_info_ = NULL;
  return temp;
}
void TripLeg_Node::set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info) {
  delete transit_egress_info_;
  transit_egress_info_ = transit_egress_info;
  if (transit_egress_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}

// optional string time_zone = 11;
bool TripLeg_Node::has_time_zone() const {
  return has_time_zone_case() == kTimeZone;
}
void TripLeg_Node::set_has_time_zone() {
  _oneof_case_[3] = kTimeZone;
}
void TripLeg_Node::clear_time_zone() {
  if (has_time_zone()) {
    has_time_zone_.time_zone_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_time_zone();
  }
}
 const ::std::string& TripLeg_Node::time_zone() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.time_zone)
  if (has_time_zone()) {
    return has_time_zone_.time_zone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_Node::set_time_zone(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_time_zone_.time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
}
 void TripLeg_Node::set_time_zone(const char* value) {
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_time_zone_.time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Node.time_zone)
}
 void TripLeg_Node::set_time_zone(const char* value, size_t size) {
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_time_zone_.time_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Node.time_zone)
}
 ::std::string* TripLeg_Node::mutable_time_zone() {
  if (!has_time_zone()) {
    clear_has_time_zone();
    set_has_time_zone();
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.time_zone)
  return has_time_zone_.time_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_Node::release_time_zone() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.time_zone)
  if (has_time_zone()) {
    clear_has_has_time_zone();
    return has_time_zone_.time_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_Node::set_allocated_time_zone(::std::string* time_zone) {
  if (!has_time_zone()) {
    has_time_zone_.time_zone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_time_zone();
  if (time_zone != NULL) {
    set_has_time_zone();
    has_time_zone_.time_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        time_zone);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.time_zone)
}

// optional .valhalla.TripLeg.PathCost cost = 12;
bool TripLeg_Node::has_cost() const {
  return !_is_default_instance_ && cost_ != NULL;
}
void TripLeg_Node::clear_cost() {
  if (GetArenaNoVirtual() == NULL && cost_ != NULL) delete cost_;
  cost_ = NULL;
}
const ::valhalla::TripLeg_PathCost& TripLeg_Node::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.cost)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cost_ != NULL ? *cost_ : *default_instance().cost_;
#else
  return cost_ != NULL ? *cost_ : *default_instance_->cost_;
#endif
}
::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_cost() {
  
  if (cost_ == NULL) {
    cost_ = new ::valhalla::TripLeg_PathCost;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.cost)
  return cost_;
}
::valhalla::TripLeg_PathCost* TripLeg_Node::release_cost() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.cost)
  
  ::valhalla::TripLeg_PathCost* temp = cost_;
  cost_ = NULL;
  return temp;
}
void TripLeg_Node::set_allocated_cost(::valhalla::TripLeg_PathCost* cost) {
  delete cost_;
  cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.cost)
}

// repeated .valhalla.TripLeg.PathCost recosts = 13;
int TripLeg_Node::recosts_size() const {
  return recosts_.size();
}
void TripLeg_Node::clear_recosts() {
  recosts_.Clear();
}
const ::valhalla::TripLeg_PathCost& TripLeg_Node::recosts(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.recosts)
  return recosts_.Get(index);
}
::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_recosts(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.recosts)
  return recosts_.Mutable(index);
}
::valhalla::TripLeg_PathCost* TripLeg_Node::add_recosts() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.recosts)
  return recosts_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
TripLeg_Node::mutable_recosts() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.recosts)
  return &recosts_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
TripLeg_Node::recosts() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.recosts)
  return recosts_;
}

// optional .valhalla.BikeShareStationInfo bss_info = 14;
bool TripLeg_Node::has_bss_info() const {
  return !_is_default_instance_ && bss_info_ != NULL;
}
void TripLeg_Node::clear_bss_info() {
  if (GetArenaNoVirtual() == NULL && bss_info_ != NULL) delete bss_info_;
  bss_info_ = NULL;
}
const ::valhalla::BikeShareStationInfo& TripLeg_Node::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.bss_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bss_info_ != NULL ? *bss_info_ : *default_instance().bss_info_;
#else
  return bss_info_ != NULL ? *bss_info_ : *default_instance_->bss_info_;
#endif
}
::valhalla::BikeShareStationInfo* TripLeg_Node::mutable_bss_info() {
  
  if (bss_info_ == NULL) {
    bss_info_ = new ::valhalla::BikeShareStationInfo;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.bss_info)
  return bss_info_;
}
::valhalla::BikeShareStationInfo* TripLeg_Node::release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = bss_info_;
  bss_info_ = NULL;
  return temp;
}
void TripLeg_Node::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  delete bss_info_;
  bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.bss_info)
}

bool TripLeg_Node::has_has_admin_index() const {
  return has_admin_index_case() != HAS_ADMIN_INDEX_NOT_SET;
}
void TripLeg_Node::clear_has_has_admin_index() {
  _oneof_case_[0] = HAS_ADMIN_INDEX_NOT_SET;
}
bool TripLeg_Node::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
void TripLeg_Node::clear_has_has_type() {
  _oneof_case_[1] = HAS_TYPE_NOT_SET;
}
bool TripLeg_Node::has_has_fork() const {
  return has_fork_case() != HAS_FORK_NOT_SET;
}
void TripLeg_Node::clear_has_has_fork() {
  _oneof_case_[2] = HAS_FORK_NOT_SET;
}
bool TripLeg_Node::has_has_time_zone() const {
  return has_time_zone_case() != HAS_TIME_ZONE_NOT_SET;
}
void TripLeg_Node::clear_has_has_time_zone() {
  _oneof_case_[3] = HAS_TIME_ZONE_NOT_SET;
}
TripLeg_Node::HasAdminIndexCase TripLeg_Node::has_admin_index_case() const {
  return TripLeg_Node::HasAdminIndexCase(_oneof_case_[0]);
}
TripLeg_Node::HasTypeCase TripLeg_Node::has_type_case() const {
  return TripLeg_Node::HasTypeCase(_oneof_case_[1]);
}
TripLeg_Node::HasForkCase TripLeg_Node::has_fork_case() const {
  return TripLeg_Node::HasForkCase(_oneof_case_[2]);
}
TripLeg_Node::HasTimeZoneCase TripLeg_Node::has_time_zone_case() const {
  return TripLeg_Node::HasTimeZoneCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// TripLeg_Admin

// optional string country_code = 1;
bool TripLeg_Admin::has_country_code() const {
  return has_country_code_case() == kCountryCode;
}
void TripLeg_Admin::set_has_country_code() {
  _oneof_case_[0] = kCountryCode;
}
void TripLeg_Admin::clear_country_code() {
  if (has_country_code()) {
    has_country_code_.country_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_country_code();
  }
}
 const ::std::string& TripLeg_Admin::country_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_code)
  if (has_country_code()) {
    return has_country_code_.country_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_Admin::set_country_code(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_code_.country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
}
 void TripLeg_Admin::set_country_code(const char* value) {
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_code_.country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.country_code)
}
 void TripLeg_Admin::set_country_code(const char* value, size_t size) {
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_code_.country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.country_code)
}
 ::std::string* TripLeg_Admin::mutable_country_code() {
  if (!has_country_code()) {
    clear_has_country_code();
    set_has_country_code();
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_code)
  return has_country_code_.country_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_Admin::release_country_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_code)
  if (has_country_code()) {
    clear_has_has_country_code();
    return has_country_code_.country_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_Admin::set_allocated_country_code(::std::string* country_code) {
  if (!has_country_code()) {
    has_country_code_.country_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_country_code();
  if (country_code != NULL) {
    set_has_country_code();
    has_country_code_.country_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        country_code);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_code)
}

// optional string country_text = 2;
bool TripLeg_Admin::has_country_text() const {
  return has_country_text_case() == kCountryText;
}
void TripLeg_Admin::set_has_country_text() {
  _oneof_case_[1] = kCountryText;
}
void TripLeg_Admin::clear_country_text() {
  if (has_country_text()) {
    has_country_text_.country_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_country_text();
  }
}
 const ::std::string& TripLeg_Admin::country_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_text)
  if (has_country_text()) {
    return has_country_text_.country_text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_Admin::set_country_text(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_text_.country_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
}
 void TripLeg_Admin::set_country_text(const char* value) {
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_text_.country_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.country_text)
}
 void TripLeg_Admin::set_country_text(const char* value, size_t size) {
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_country_text_.country_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.country_text)
}
 ::std::string* TripLeg_Admin::mutable_country_text() {
  if (!has_country_text()) {
    clear_has_country_text();
    set_has_country_text();
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_text)
  return has_country_text_.country_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_Admin::release_country_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_text)
  if (has_country_text()) {
    clear_has_has_country_text();
    return has_country_text_.country_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_Admin::set_allocated_country_text(::std::string* country_text) {
  if (!has_country_text()) {
    has_country_text_.country_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_country_text();
  if (country_text != NULL) {
    set_has_country_text();
    has_country_text_.country_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        country_text);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_text)
}

// optional string state_code = 3;
bool TripLeg_Admin::has_state_code() const {
  return has_state_code_case() == kStateCode;
}
void TripLeg_Admin::set_has_state_code() {
  _oneof_case_[2] = kStateCode;
}
void TripLeg_Admin::clear_state_code() {
  if (has_state_code()) {
    has_state_code_.state_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_state_code();
  }
}
 const ::std::string& TripLeg_Admin::state_code() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_code)
  if (has_state_code()) {
    return has_state_code_.state_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_Admin::set_state_code(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_code_.state_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
}
 void TripLeg_Admin::set_state_code(const char* value) {
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_code_.state_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.state_code)
}
 void TripLeg_Admin::set_state_code(const char* value, size_t size) {
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_code_.state_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.state_code)
}
 ::std::string* TripLeg_Admin::mutable_state_code() {
  if (!has_state_code()) {
    clear_has_state_code();
    set_has_state_code();
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_code)
  return has_state_code_.state_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_Admin::release_state_code() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_code)
  if (has_state_code()) {
    clear_has_has_state_code();
    return has_state_code_.state_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_Admin::set_allocated_state_code(::std::string* state_code) {
  if (!has_state_code()) {
    has_state_code_.state_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_state_code();
  if (state_code != NULL) {
    set_has_state_code();
    has_state_code_.state_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        state_code);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_code)
}

// optional string state_text = 4;
bool TripLeg_Admin::has_state_text() const {
  return has_state_text_case() == kStateText;
}
void TripLeg_Admin::set_has_state_text() {
  _oneof_case_[3] = kStateText;
}
void TripLeg_Admin::clear_state_text() {
  if (has_state_text()) {
    has_state_text_.state_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_state_text();
  }
}
 const ::std::string& TripLeg_Admin::state_text() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_text)
  if (has_state_text()) {
    return has_state_text_.state_text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg_Admin::set_state_text(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_text_.state_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
}
 void TripLeg_Admin::set_state_text(const char* value) {
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_text_.state_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.Admin.state_text)
}
 void TripLeg_Admin::set_state_text(const char* value, size_t size) {
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_state_text_.state_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.Admin.state_text)
}
 ::std::string* TripLeg_Admin::mutable_state_text() {
  if (!has_state_text()) {
    clear_has_state_text();
    set_has_state_text();
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_text)
  return has_state_text_.state_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg_Admin::release_state_text() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_text)
  if (has_state_text()) {
    clear_has_has_state_text();
    return has_state_text_.state_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg_Admin::set_allocated_state_text(::std::string* state_text) {
  if (!has_state_text()) {
    has_state_text_.state_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_state_text();
  if (state_text != NULL) {
    set_has_state_text();
    has_state_text_.state_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        state_text);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_text)
}

bool TripLeg_Admin::has_has_country_code() const {
  return has_country_code_case() != HAS_COUNTRY_CODE_NOT_SET;
}
void TripLeg_Admin::clear_has_has_country_code() {
  _oneof_case_[0] = HAS_COUNTRY_CODE_NOT_SET;
}
bool TripLeg_Admin::has_has_country_text() const {
  return has_country_text_case() != HAS_COUNTRY_TEXT_NOT_SET;
}
void TripLeg_Admin::clear_has_has_country_text() {
  _oneof_case_[1] = HAS_COUNTRY_TEXT_NOT_SET;
}
bool TripLeg_Admin::has_has_state_code() const {
  return has_state_code_case() != HAS_STATE_CODE_NOT_SET;
}
void TripLeg_Admin::clear_has_has_state_code() {
  _oneof_case_[2] = HAS_STATE_CODE_NOT_SET;
}
bool TripLeg_Admin::has_has_state_text() const {
  return has_state_text_case() != HAS_STATE_TEXT_NOT_SET;
}
void TripLeg_Admin::clear_has_has_state_text() {
  _oneof_case_[3] = HAS_STATE_TEXT_NOT_SET;
}
TripLeg_Admin::HasCountryCodeCase TripLeg_Admin::has_country_code_case() const {
  return TripLeg_Admin::HasCountryCodeCase(_oneof_case_[0]);
}
TripLeg_Admin::HasCountryTextCase TripLeg_Admin::has_country_text_case() const {
  return TripLeg_Admin::HasCountryTextCase(_oneof_case_[1]);
}
TripLeg_Admin::HasStateCodeCase TripLeg_Admin::has_state_code_case() const {
  return TripLeg_Admin::HasStateCodeCase(_oneof_case_[2]);
}
TripLeg_Admin::HasStateTextCase TripLeg_Admin::has_state_text_case() const {
  return TripLeg_Admin::HasStateTextCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// TripLeg_ShapeAttributes

// repeated uint32 time = 1 [packed = true];
int TripLeg_ShapeAttributes::time_size() const {
  return time_.size();
}
void TripLeg_ShapeAttributes::clear_time() {
  time_.Clear();
}
 ::google::protobuf::uint32 TripLeg_ShapeAttributes::time(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.time)
  return time_.Get(index);
}
 void TripLeg_ShapeAttributes::set_time(int index, ::google::protobuf::uint32 value) {
  time_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.time)
}
 void TripLeg_ShapeAttributes::add_time(::google::protobuf::uint32 value) {
  time_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.time)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::time() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.time)
  return time_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_time() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.time)
  return &time_;
}

// repeated uint32 length = 2 [packed = true];
int TripLeg_ShapeAttributes::length_size() const {
  return length_.size();
}
void TripLeg_ShapeAttributes::clear_length() {
  length_.Clear();
}
 ::google::protobuf::uint32 TripLeg_ShapeAttributes::length(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.length)
  return length_.Get(index);
}
 void TripLeg_ShapeAttributes::set_length(int index, ::google::protobuf::uint32 value) {
  length_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.length)
}
 void TripLeg_ShapeAttributes::add_length(::google::protobuf::uint32 value) {
  length_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.length)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::length() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.length)
  return length_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_length() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.length)
  return &length_;
}

// repeated uint32 speed = 3 [packed = true];
int TripLeg_ShapeAttributes::speed_size() const {
  return speed_.size();
}
void TripLeg_ShapeAttributes::clear_speed() {
  speed_.Clear();
}
 ::google::protobuf::uint32 TripLeg_ShapeAttributes::speed(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed)
  return speed_.Get(index);
}
 void TripLeg_ShapeAttributes::set_speed(int index, ::google::protobuf::uint32 value) {
  speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed)
}
 void TripLeg_ShapeAttributes::add_speed(::google::protobuf::uint32 value) {
  speed_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::speed() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed)
  return speed_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_speed() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed)
  return &speed_;
}

// repeated uint32 speed_limit = 5 [packed = true];
int TripLeg_ShapeAttributes::speed_limit_size() const {
  return speed_limit_.size();
}
void TripLeg_ShapeAttributes::clear_speed_limit() {
  speed_limit_.Clear();
}
 ::google::protobuf::uint32 TripLeg_ShapeAttributes::speed_limit(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return speed_limit_.Get(index);
}
 void TripLeg_ShapeAttributes::set_speed_limit(int index, ::google::protobuf::uint32 value) {
  speed_limit_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
 void TripLeg_ShapeAttributes::add_speed_limit(::google::protobuf::uint32 value) {
  speed_limit_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::speed_limit() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return speed_limit_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_speed_limit() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return &speed_limit_;
}

// -------------------------------------------------------------------

// TripLeg_Incident

// optional .valhalla.IncidentsTile.Metadata metadata = 1;
bool TripLeg_Incident::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
void TripLeg_Incident::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::metadata() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return metadata_ != NULL ? *metadata_ : *default_instance().metadata_;
#else
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
#endif
}
::valhalla::IncidentsTile_Metadata* TripLeg_Incident::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::valhalla::IncidentsTile_Metadata;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Incident.metadata)
  return metadata_;
}
::valhalla::IncidentsTile_Metadata* TripLeg_Incident::release_metadata() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Incident.metadata)
  
  ::valhalla::IncidentsTile_Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
void TripLeg_Incident::set_allocated_metadata(::valhalla::IncidentsTile_Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Incident.metadata)
}

// optional uint32 begin_shape_index = 3;
bool TripLeg_Incident::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
void TripLeg_Incident::set_has_begin_shape_index() {
  _oneof_case_[0] = kBeginShapeIndex;
}
void TripLeg_Incident::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Incident::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
 void TripLeg_Incident::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.begin_shape_index)
}

// optional uint32 end_shape_index = 4;
bool TripLeg_Incident::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
void TripLeg_Incident::set_has_end_shape_index() {
  _oneof_case_[1] = kEndShapeIndex;
}
void TripLeg_Incident::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Incident::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
 void TripLeg_Incident::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.end_shape_index)
}

bool TripLeg_Incident::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
void TripLeg_Incident::clear_has_has_begin_shape_index() {
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
bool TripLeg_Incident::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
void TripLeg_Incident::clear_has_has_end_shape_index() {
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
TripLeg_Incident::HasBeginShapeIndexCase TripLeg_Incident::has_begin_shape_index_case() const {
  return TripLeg_Incident::HasBeginShapeIndexCase(_oneof_case_[0]);
}
TripLeg_Incident::HasEndShapeIndexCase TripLeg_Incident::has_end_shape_index_case() const {
  return TripLeg_Incident::HasEndShapeIndexCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg_Closure

// optional uint32 begin_shape_index = 1;
bool TripLeg_Closure::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
void TripLeg_Closure::set_has_begin_shape_index() {
  _oneof_case_[0] = kBeginShapeIndex;
}
void TripLeg_Closure::clear_begin_shape_index() {
  if (has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Closure::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.begin_shape_index)
  if (has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
 void TripLeg_Closure::set_begin_shape_index(::google::protobuf::uint32 value) {
  if (!has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.begin_shape_index)
}

// optional uint32 end_shape_index = 2;
bool TripLeg_Closure::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
void TripLeg_Closure::set_has_end_shape_index() {
  _oneof_case_[1] = kEndShapeIndex;
}
void TripLeg_Closure::clear_end_shape_index() {
  if (has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
 ::google::protobuf::uint32 TripLeg_Closure::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.end_shape_index)
  if (has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
 void TripLeg_Closure::set_end_shape_index(::google::protobuf::uint32 value) {
  if (!has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.end_shape_index)
}

bool TripLeg_Closure::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
void TripLeg_Closure::clear_has_has_begin_shape_index() {
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
bool TripLeg_Closure::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
void TripLeg_Closure::clear_has_has_end_shape_index() {
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
TripLeg_Closure::HasBeginShapeIndexCase TripLeg_Closure::has_begin_shape_index_case() const {
  return TripLeg_Closure::HasBeginShapeIndexCase(_oneof_case_[0]);
}
TripLeg_Closure::HasEndShapeIndexCase TripLeg_Closure::has_end_shape_index_case() const {
  return TripLeg_Closure::HasEndShapeIndexCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg

// optional uint64 osm_changeset = 1;
bool TripLeg::has_osm_changeset() const {
  return has_osm_changeset_case() == kOsmChangeset;
}
void TripLeg::set_has_osm_changeset() {
  _oneof_case_[0] = kOsmChangeset;
}
void TripLeg::clear_osm_changeset() {
  if (has_osm_changeset()) {
    has_osm_changeset_.osm_changeset_ = GOOGLE_ULONGLONG(0);
    clear_has_has_osm_changeset();
  }
}
 ::google::protobuf::uint64 TripLeg::osm_changeset() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.osm_changeset)
  if (has_osm_changeset()) {
    return has_osm_changeset_.osm_changeset_;
  }
  return GOOGLE_ULONGLONG(0);
}
 void TripLeg::set_osm_changeset(::google::protobuf::uint64 value) {
  if (!has_osm_changeset()) {
    clear_has_osm_changeset();
    set_has_osm_changeset();
  }
  has_osm_changeset_.osm_changeset_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.osm_changeset)
}

// optional uint64 trip_id = 2;
bool TripLeg::has_trip_id() const {
  return has_trip_id_case() == kTripId;
}
void TripLeg::set_has_trip_id() {
  _oneof_case_[1] = kTripId;
}
void TripLeg::clear_trip_id() {
  if (has_trip_id()) {
    has_trip_id_.trip_id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_trip_id();
  }
}
 ::google::protobuf::uint64 TripLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.trip_id)
  if (has_trip_id()) {
    return has_trip_id_.trip_id_;
  }
  return GOOGLE_ULONGLONG(0);
}
 void TripLeg::set_trip_id(::google::protobuf::uint64 value) {
  if (!has_trip_id()) {
    clear_has_trip_id();
    set_has_trip_id();
  }
  has_trip_id_.trip_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.trip_id)
}

// optional uint32 leg_id = 3;
bool TripLeg::has_leg_id() const {
  return has_leg_id_case() == kLegId;
}
void TripLeg::set_has_leg_id() {
  _oneof_case_[2] = kLegId;
}
void TripLeg::clear_leg_id() {
  if (has_leg_id()) {
    has_leg_id_.leg_id_ = 0u;
    clear_has_has_leg_id();
  }
}
 ::google::protobuf::uint32 TripLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_id)
  if (has_leg_id()) {
    return has_leg_id_.leg_id_;
  }
  return 0u;
}
 void TripLeg::set_leg_id(::google::protobuf::uint32 value) {
  if (!has_leg_id()) {
    clear_has_leg_id();
    set_has_leg_id();
  }
  has_leg_id_.leg_id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_id)
}

// optional uint32 leg_count = 4;
bool TripLeg::has_leg_count() const {
  return has_leg_count_case() == kLegCount;
}
void TripLeg::set_has_leg_count() {
  _oneof_case_[3] = kLegCount;
}
void TripLeg::clear_leg_count() {
  if (has_leg_count()) {
    has_leg_count_.leg_count_ = 0u;
    clear_has_has_leg_count();
  }
}
 ::google::protobuf::uint32 TripLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_count)
  if (has_leg_count()) {
    return has_leg_count_.leg_count_;
  }
  return 0u;
}
 void TripLeg::set_leg_count(::google::protobuf::uint32 value) {
  if (!has_leg_count()) {
    clear_has_leg_count();
    set_has_leg_count();
  }
  has_leg_count_.leg_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_count)
}

// repeated .valhalla.Location location = 5;
int TripLeg::location_size() const {
  return location_.size();
}
void TripLeg::clear_location() {
  location_.Clear();
}
const ::valhalla::Location& TripLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.location)
  return location_.Get(index);
}
::valhalla::Location* TripLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.location)
  return location_.Mutable(index);
}
::valhalla::Location* TripLeg::add_location() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.location)
  return location_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
TripLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.location)
  return &location_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
TripLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.location)
  return location_;
}

// repeated .valhalla.TripLeg.Node node = 6;
int TripLeg::node_size() const {
  return node_.size();
}
void TripLeg::clear_node() {
  node_.Clear();
}
const ::valhalla::TripLeg_Node& TripLeg::node(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.node)
  return node_.Get(index);
}
::valhalla::TripLeg_Node* TripLeg::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.node)
  return node_.Mutable(index);
}
::valhalla::TripLeg_Node* TripLeg::add_node() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.node)
  return node_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >*
TripLeg::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.node)
  return &node_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >&
TripLeg::node() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.node)
  return node_;
}

// repeated .valhalla.TripLeg.Admin admin = 7;
int TripLeg::admin_size() const {
  return admin_.size();
}
void TripLeg::clear_admin() {
  admin_.Clear();
}
const ::valhalla::TripLeg_Admin& TripLeg::admin(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.admin)
  return admin_.Get(index);
}
::valhalla::TripLeg_Admin* TripLeg::mutable_admin(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.admin)
  return admin_.Mutable(index);
}
::valhalla::TripLeg_Admin* TripLeg::add_admin() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.admin)
  return admin_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
TripLeg::mutable_admin() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.admin)
  return &admin_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
TripLeg::admin() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.admin)
  return admin_;
}

// optional string shape = 8;
bool TripLeg::has_shape() const {
  return has_shape_case() == kShape;
}
void TripLeg::set_has_shape() {
  _oneof_case_[4] = kShape;
}
void TripLeg::clear_shape() {
  if (has_shape()) {
    has_shape_.shape_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_shape();
  }
}
 const ::std::string& TripLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape)
  if (has_shape()) {
    return has_shape_.shape_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void TripLeg::set_shape(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
}
 void TripLeg::set_shape(const char* value) {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.shape)
}
 void TripLeg::set_shape(const char* value, size_t size) {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.shape)
}
 ::std::string* TripLeg::mutable_shape() {
  if (!has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape)
  return has_shape_.shape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TripLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape)
  if (has_shape()) {
    clear_has_has_shape();
    return has_shape_.shape_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void TripLeg::set_allocated_shape(::std::string* shape) {
  if (!has_shape()) {
    has_shape_.shape_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_shape();
  if (shape != NULL) {
    set_has_shape();
    has_shape_.shape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        shape);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape)
}

// optional .valhalla.BoundingBox bbox = 9;
bool TripLeg::has_bbox() const {
  return !_is_default_instance_ && bbox_ != NULL;
}
void TripLeg::clear_bbox() {
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) delete bbox_;
  bbox_ = NULL;
}
const ::valhalla::BoundingBox& TripLeg::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.bbox)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bbox_ != NULL ? *bbox_ : *default_instance().bbox_;
#else
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
#endif
}
::valhalla::BoundingBox* TripLeg::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::valhalla::BoundingBox;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.bbox)
  return bbox_;
}
::valhalla::BoundingBox* TripLeg::release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.bbox)
  
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
void TripLeg::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.bbox)
}

// optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
bool TripLeg::has_shape_attributes() const {
  return !_is_default_instance_ && shape_attributes_ != NULL;
}
void TripLeg::clear_shape_attributes() {
  if (GetArenaNoVirtual() == NULL && shape_attributes_ != NULL) delete shape_attributes_;
  shape_attributes_ = NULL;
}
const ::valhalla::TripLeg_ShapeAttributes& TripLeg::shape_attributes() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape_attributes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shape_attributes_ != NULL ? *shape_attributes_ : *default_instance().shape_attributes_;
#else
  return shape_attributes_ != NULL ? *shape_attributes_ : *default_instance_->shape_attributes_;
#endif
}
::valhalla::TripLeg_ShapeAttributes* TripLeg::mutable_shape_attributes() {
  
  if (shape_attributes_ == NULL) {
    shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape_attributes)
  return shape_attributes_;
}
::valhalla::TripLeg_ShapeAttributes* TripLeg::release_shape_attributes() {
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape_attributes)
  
  ::valhalla::TripLeg_ShapeAttributes* temp = shape_attributes_;
  shape_attributes_ = NULL;
  return temp;
}
void TripLeg::set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  delete shape_attributes_;
  shape_attributes_ = shape_attributes;
  if (shape_attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape_attributes)
}

// repeated .valhalla.TripLeg.Incident incidents = 11;
int TripLeg::incidents_size() const {
  return incidents_.size();
}
void TripLeg::clear_incidents() {
  incidents_.Clear();
}
const ::valhalla::TripLeg_Incident& TripLeg::incidents(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.incidents)
  return incidents_.Get(index);
}
::valhalla::TripLeg_Incident* TripLeg::mutable_incidents(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.incidents)
  return incidents_.Mutable(index);
}
::valhalla::TripLeg_Incident* TripLeg::add_incidents() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.incidents)
  return incidents_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
TripLeg::mutable_incidents() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.incidents)
  return &incidents_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
TripLeg::incidents() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.incidents)
  return incidents_;
}

// repeated string algorithms = 12;
int TripLeg::algorithms_size() const {
  return algorithms_.size();
}
void TripLeg::clear_algorithms() {
  algorithms_.Clear();
}
 const ::std::string& TripLeg::algorithms(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.algorithms)
  return algorithms_.Get(index);
}
 ::std::string* TripLeg::mutable_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.algorithms)
  return algorithms_.Mutable(index);
}
 void TripLeg::set_algorithms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
  algorithms_.Mutable(index)->assign(value);
}
 void TripLeg::set_algorithms(int index, const char* value) {
  algorithms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.algorithms)
}
 void TripLeg::set_algorithms(int index, const char* value, size_t size) {
  algorithms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.algorithms)
}
 ::std::string* TripLeg::add_algorithms() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.TripLeg.algorithms)
  return algorithms_.Add();
}
 void TripLeg::add_algorithms(const ::std::string& value) {
  algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
 void TripLeg::add_algorithms(const char* value) {
  algorithms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.TripLeg.algorithms)
}
 void TripLeg::add_algorithms(const char* value, size_t size) {
  algorithms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.TripLeg.algorithms)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripLeg::algorithms() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.algorithms)
  return algorithms_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
TripLeg::mutable_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.algorithms)
  return &algorithms_;
}

// repeated .valhalla.TripLeg.Closure closures = 13;
int TripLeg::closures_size() const {
  return closures_.size();
}
void TripLeg::clear_closures() {
  closures_.Clear();
}
const ::valhalla::TripLeg_Closure& TripLeg::closures(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.closures)
  return closures_.Get(index);
}
::valhalla::TripLeg_Closure* TripLeg::mutable_closures(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.closures)
  return closures_.Mutable(index);
}
::valhalla::TripLeg_Closure* TripLeg::add_closures() {
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.closures)
  return closures_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
TripLeg::mutable_closures() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.closures)
  return &closures_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
TripLeg::closures() const {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.closures)
  return closures_;
}

bool TripLeg::has_has_osm_changeset() const {
  return has_osm_changeset_case() != HAS_OSM_CHANGESET_NOT_SET;
}
void TripLeg::clear_has_has_osm_changeset() {
  _oneof_case_[0] = HAS_OSM_CHANGESET_NOT_SET;
}
bool TripLeg::has_has_trip_id() const {
  return has_trip_id_case() != HAS_TRIP_ID_NOT_SET;
}
void TripLeg::clear_has_has_trip_id() {
  _oneof_case_[1] = HAS_TRIP_ID_NOT_SET;
}
bool TripLeg::has_has_leg_id() const {
  return has_leg_id_case() != HAS_LEG_ID_NOT_SET;
}
void TripLeg::clear_has_has_leg_id() {
  _oneof_case_[2] = HAS_LEG_ID_NOT_SET;
}
bool TripLeg::has_has_leg_count() const {
  return has_leg_count_case() != HAS_LEG_COUNT_NOT_SET;
}
void TripLeg::clear_has_has_leg_count() {
  _oneof_case_[3] = HAS_LEG_COUNT_NOT_SET;
}
bool TripLeg::has_has_shape() const {
  return has_shape_case() != HAS_SHAPE_NOT_SET;
}
void TripLeg::clear_has_has_shape() {
  _oneof_case_[4] = HAS_SHAPE_NOT_SET;
}
TripLeg::HasOsmChangesetCase TripLeg::has_osm_changeset_case() const {
  return TripLeg::HasOsmChangesetCase(_oneof_case_[0]);
}
TripLeg::HasTripIdCase TripLeg::has_trip_id_case() const {
  return TripLeg::HasTripIdCase(_oneof_case_[1]);
}
TripLeg::HasLegIdCase TripLeg::has_leg_id_case() const {
  return TripLeg::HasLegIdCase(_oneof_case_[2]);
}
TripLeg::HasLegCountCase TripLeg::has_leg_count_case() const {
  return TripLeg::HasLegCountCase(_oneof_case_[3]);
}
TripLeg::HasShapeCase TripLeg::has_shape_case() const {
  return TripLeg::HasShapeCase(_oneof_case_[4]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TripRoute::kLegsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TripRoute::TripRoute()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.TripRoute)
}

void TripRoute::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TripRoute::TripRoute(const TripRoute& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}

void TripRoute::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  SharedDtor();
}

void TripRoute::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripRoute& TripRoute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripRoute* TripRoute::default_instance_ = NULL;

TripRoute* TripRoute::New(::google::protobuf::Arena* arena) const {
  TripRoute* n = new TripRoute;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  legs_.Clear();
}

bool TripRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.TripRoute)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.TripLeg legs = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_legs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_legs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_legs;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.TripRoute)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.TripRoute)
  return false;
#undef DO_
}

void TripRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.TripRoute)
  // repeated .valhalla.TripLeg legs = 1;
  for (unsigned int i = 0, n = this->legs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->legs(i), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.TripRoute)
}

int TripRoute::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
  int total_size = 0;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1 * this->legs_size();
  for (int i = 0; i < this->legs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->legs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripRoute*>(&from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  legs_.MergeFrom(from.legs_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripRoute::IsInitialized() const {

  return true;
}

void TripRoute::Swap(TripRoute* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TripRoute::InternalSwap(TripRoute* other) {
  legs_.UnsafeArenaSwap(&other->legs_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TripRoute

// repeated .valhalla.TripLeg legs = 1;
int TripRoute::legs_size() const {
  return legs_.size();
}
void TripRoute::clear_legs() {
  legs_.Clear();
}
const ::valhalla::TripLeg& TripRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripRoute.legs)
  return legs_.Get(index);
}
::valhalla::TripLeg* TripRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.TripRoute.legs)
  return legs_.Mutable(index);
}
::valhalla::TripLeg* TripRoute::add_legs() {
  // @@protoc_insertion_point(field_add:valhalla.TripRoute.legs)
  return legs_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >*
TripRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripRoute.legs)
  return &legs_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >&
TripRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.TripRoute.legs)
  return legs_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Trip::kRoutesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Trip::Trip()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:valhalla.Trip)
}

void Trip::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Trip::Trip(const Trip& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}

void Trip::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  SharedDtor();
}

void Trip::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Trip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Trip& Trip::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

Trip* Trip::default_instance_ = NULL;

Trip* Trip::New(::google::protobuf::Arena* arena) const {
  Trip* n = new Trip;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  routes_.Clear();
}

bool Trip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:valhalla.Trip)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.TripRoute routes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_routes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_routes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_routes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:valhalla.Trip)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:valhalla.Trip)
  return false;
#undef DO_
}

void Trip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:valhalla.Trip)
  // repeated .valhalla.TripRoute routes = 1;
  for (unsigned int i = 0, n = this->routes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->routes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:valhalla.Trip)
}

int Trip::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
  int total_size = 0;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1 * this->routes_size();
  for (int i = 0; i < this->routes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->routes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Trip*>(&from));
}

void Trip::MergeFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  routes_.MergeFrom(from.routes_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trip::IsInitialized() const {

  return true;
}

void Trip::Swap(Trip* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Trip::InternalSwap(Trip* other) {
  routes_.UnsafeArenaSwap(&other->routes_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Trip

// repeated .valhalla.TripRoute routes = 1;
int Trip::routes_size() const {
  return routes_.size();
}
void Trip::clear_routes() {
  routes_.Clear();
}
const ::valhalla::TripRoute& Trip::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Trip.routes)
  return routes_.Get(index);
}
::valhalla::TripRoute* Trip::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Trip.routes)
  return routes_.Mutable(index);
}
::valhalla::TripRoute* Trip::add_routes() {
  // @@protoc_insertion_point(field_add:valhalla.Trip.routes)
  return routes_.Add();
}
::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >*
Trip::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Trip.routes)
  return &routes_;
}
const ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >&
Trip::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Trip.routes)
  return routes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)
