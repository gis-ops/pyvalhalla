// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#ifndef PROTOBUF_options_2eproto__INCLUDED
#define PROTOBUF_options_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_options_2eproto();
void protobuf_AssignDesc_options_2eproto();
void protobuf_ShutdownFile_options_2eproto();

class AvoidEdge;
class Contour;
class CostingOptions;
class Options;
class Options_Ring;

enum Options_Units {
  Options_Units_kilometers = 0,
  Options_Units_miles = 1,
  Options_Units_Options_Units_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Options_Units_Options_Units_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Options_Units_IsValid(int value);
const Options_Units Options_Units_Units_MIN = Options_Units_kilometers;
const Options_Units Options_Units_Units_MAX = Options_Units_miles;
const int Options_Units_Units_ARRAYSIZE = Options_Units_Units_MAX + 1;

enum Options_Format {
  Options_Format_json = 0,
  Options_Format_gpx = 1,
  Options_Format_osrm = 2,
  Options_Format_pbf = 3,
  Options_Format_Options_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Options_Format_Options_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Options_Format_IsValid(int value);
const Options_Format Options_Format_Format_MIN = Options_Format_json;
const Options_Format Options_Format_Format_MAX = Options_Format_pbf;
const int Options_Format_Format_ARRAYSIZE = Options_Format_Format_MAX + 1;

enum Options_Action {
  Options_Action_route = 0,
  Options_Action_locate = 1,
  Options_Action_sources_to_targets = 2,
  Options_Action_optimized_route = 3,
  Options_Action_isochrone = 4,
  Options_Action_trace_route = 5,
  Options_Action_trace_attributes = 6,
  Options_Action_height = 7,
  Options_Action_transit_available = 8,
  Options_Action_expansion = 9,
  Options_Action_centroid = 10,
  Options_Action_status = 11,
  Options_Action_livespeed = 12,
  Options_Action_Options_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Options_Action_Options_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Options_Action_IsValid(int value);
const Options_Action Options_Action_Action_MIN = Options_Action_route;
const Options_Action Options_Action_Action_MAX = Options_Action_livespeed;
const int Options_Action_Action_ARRAYSIZE = Options_Action_Action_MAX + 1;

enum Options_DateTimeType {
  Options_DateTimeType_current = 0,
  Options_DateTimeType_depart_at = 1,
  Options_DateTimeType_arrive_by = 2,
  Options_DateTimeType_invariant = 3,
  Options_DateTimeType_Options_DateTimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Options_DateTimeType_Options_DateTimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Options_DateTimeType_IsValid(int value);
const Options_DateTimeType Options_DateTimeType_DateTimeType_MIN = Options_DateTimeType_current;
const Options_DateTimeType Options_DateTimeType_DateTimeType_MAX = Options_DateTimeType_invariant;
const int Options_DateTimeType_DateTimeType_ARRAYSIZE = Options_DateTimeType_DateTimeType_MAX + 1;

enum Options_ExpansionProperties {
  Options_ExpansionProperties_costs = 0,
  Options_ExpansionProperties_durations = 1,
  Options_ExpansionProperties_distances = 2,
  Options_ExpansionProperties_statuses = 3,
  Options_ExpansionProperties_edge_ids = 4,
  Options_ExpansionProperties_Options_ExpansionProperties_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Options_ExpansionProperties_Options_ExpansionProperties_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Options_ExpansionProperties_IsValid(int value);
const Options_ExpansionProperties Options_ExpansionProperties_ExpansionProperties_MIN = Options_ExpansionProperties_costs;
const Options_ExpansionProperties Options_ExpansionProperties_ExpansionProperties_MAX = Options_ExpansionProperties_edge_ids;
const int Options_ExpansionProperties_ExpansionProperties_ARRAYSIZE = Options_ExpansionProperties_ExpansionProperties_MAX + 1;

enum ShapeMatch {
  walk_or_snap = 0,
  edge_walk = 1,
  map_snap = 2,
  ShapeMatch_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShapeMatch_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShapeMatch_IsValid(int value);
const ShapeMatch ShapeMatch_MIN = walk_or_snap;
const ShapeMatch ShapeMatch_MAX = map_snap;
const int ShapeMatch_ARRAYSIZE = ShapeMatch_MAX + 1;

enum FilterAction {
  no_action = 0,
  exclude = 1,
  include = 2,
  FilterAction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FilterAction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FilterAction_IsValid(int value);
const FilterAction FilterAction_MIN = no_action;
const FilterAction FilterAction_MAX = include;
const int FilterAction_ARRAYSIZE = FilterAction_MAX + 1;

enum DirectionsType {
  instructions = 0,
  none = 1,
  maneuvers = 2,
  DirectionsType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DirectionsType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DirectionsType_IsValid(int value);
const DirectionsType DirectionsType_MIN = instructions;
const DirectionsType DirectionsType_MAX = maneuvers;
const int DirectionsType_ARRAYSIZE = DirectionsType_MAX + 1;

enum ShapeFormat {
  polyline6 = 0,
  polyline5 = 1,
  geojson = 2,
  ShapeFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShapeFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShapeFormat_IsValid(int value);
const ShapeFormat ShapeFormat_MIN = polyline6;
const ShapeFormat ShapeFormat_MAX = geojson;
const int ShapeFormat_ARRAYSIZE = ShapeFormat_MAX + 1;

enum Costing {
  auto_ = 0,
  bicycle = 1,
  bus = 2,
  motor_scooter = 3,
  multimodal = 4,
  pedestrian = 5,
  transit = 6,
  truck = 7,
  motorcycle = 8,
  taxi = 9,
  none_ = 10,
  bikeshare = 11,
  Costing_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Costing_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Costing_IsValid(int value);
const Costing Costing_MIN = auto_;
const Costing Costing_MAX = bikeshare;
const int Costing_ARRAYSIZE = Costing_MAX + 1;

// ===================================================================

class Contour : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Contour) */ {
 public:
  Contour();
  virtual ~Contour();

  Contour(const Contour& from);

  inline Contour& operator=(const Contour& from) {
    CopyFrom(from);
    return *this;
  }

  static const Contour& default_instance();

  enum HasTimeCase {
    kTime = 1,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasColorCase {
    kColor = 2,
    HAS_COLOR_NOT_SET = 0,
  };

  enum HasDistanceCase {
    kDistance = 3,
    HAS_DISTANCE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Contour* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Contour* other);

  // implements Message ----------------------------------------------

  inline Contour* New() const { return New(NULL); }

  Contour* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Contour& from);
  void MergeFrom(const Contour& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contour* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  private:
  bool has_time() const;
  public:
  void clear_time();
  static const int kTimeFieldNumber = 1;
  float time() const;
  void set_time(float value);

  // optional string color = 2;
  private:
  bool has_color() const;
  public:
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // optional float distance = 3;
  private:
  bool has_distance() const;
  public:
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  float distance() const;
  void set_distance(float value);

  HasTimeCase has_time_case() const;
  HasColorCase has_color_case() const;
  HasDistanceCase has_distance_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Contour)
 private:
  inline void set_has_time();
  inline void set_has_color();
  inline void set_has_distance();

  inline bool has_has_time() const;
  void clear_has_time();
  inline void clear_has_has_time();

  inline bool has_has_color() const;
  void clear_has_color();
  inline void clear_has_has_color();

  inline bool has_has_distance() const;
  void clear_has_distance();
  inline void clear_has_has_distance();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasTimeUnion {
    HasTimeUnion() {}
    float time_;
  } has_time_;
  union HasColorUnion {
    HasColorUnion() {}
    ::google::protobuf::internal::ArenaStringPtr color_;
  } has_color_;
  union HasDistanceUnion {
    HasDistanceUnion() {}
    float distance_;
  } has_distance_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static Contour* default_instance_;
};
// -------------------------------------------------------------------

class AvoidEdge : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.AvoidEdge) */ {
 public:
  AvoidEdge();
  virtual ~AvoidEdge();

  AvoidEdge(const AvoidEdge& from);

  inline AvoidEdge& operator=(const AvoidEdge& from) {
    CopyFrom(from);
    return *this;
  }

  static const AvoidEdge& default_instance();

  enum HasIdCase {
    kId = 1,
    HAS_ID_NOT_SET = 0,
  };

  enum HasPercentAlongCase {
    kPercentAlong = 2,
    HAS_PERCENT_ALONG_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvoidEdge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvoidEdge* other);

  // implements Message ----------------------------------------------

  inline AvoidEdge* New() const { return New(NULL); }

  AvoidEdge* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvoidEdge& from);
  void MergeFrom(const AvoidEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvoidEdge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional float percent_along = 2;
  private:
  bool has_percent_along() const;
  public:
  void clear_percent_along();
  static const int kPercentAlongFieldNumber = 2;
  float percent_along() const;
  void set_percent_along(float value);

  HasIdCase has_id_case() const;
  HasPercentAlongCase has_percent_along_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.AvoidEdge)
 private:
  inline void set_has_id();
  inline void set_has_percent_along();

  inline bool has_has_id() const;
  void clear_has_id();
  inline void clear_has_has_id();

  inline bool has_has_percent_along() const;
  void clear_has_percent_along();
  inline void clear_has_has_percent_along();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  union HasIdUnion {
    HasIdUnion() {}
    ::google::protobuf::uint64 id_;
  } has_id_;
  union HasPercentAlongUnion {
    HasPercentAlongUnion() {}
    float percent_along_;
  } has_percent_along_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static AvoidEdge* default_instance_;
};
// -------------------------------------------------------------------

class CostingOptions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.CostingOptions) */ {
 public:
  CostingOptions();
  virtual ~CostingOptions();

  CostingOptions(const CostingOptions& from);

  inline CostingOptions& operator=(const CostingOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const CostingOptions& default_instance();

  enum HasManeuverPenaltyCase {
    kManeuverPenalty = 1,
    HAS_MANEUVER_PENALTY_NOT_SET = 0,
  };

  enum HasDestinationOnlyPenaltyCase {
    kDestinationOnlyPenalty = 2,
    HAS_DESTINATION_ONLY_PENALTY_NOT_SET = 0,
  };

  enum HasGateCostCase {
    kGateCost = 3,
    HAS_GATE_COST_NOT_SET = 0,
  };

  enum HasGatePenaltyCase {
    kGatePenalty = 4,
    HAS_GATE_PENALTY_NOT_SET = 0,
  };

  enum HasTollBoothCostCase {
    kTollBoothCost = 5,
    HAS_TOLL_BOOTH_COST_NOT_SET = 0,
  };

  enum HasTollBoothPenaltyCase {
    kTollBoothPenalty = 6,
    HAS_TOLL_BOOTH_PENALTY_NOT_SET = 0,
  };

  enum HasAlleyPenaltyCase {
    kAlleyPenalty = 7,
    HAS_ALLEY_PENALTY_NOT_SET = 0,
  };

  enum HasCountryCrossingCostCase {
    kCountryCrossingCost = 8,
    HAS_COUNTRY_CROSSING_COST_NOT_SET = 0,
  };

  enum HasCountryCrossingPenaltyCase {
    kCountryCrossingPenalty = 9,
    HAS_COUNTRY_CROSSING_PENALTY_NOT_SET = 0,
  };

  enum HasFerryCostCase {
    kFerryCost = 10,
    HAS_FERRY_COST_NOT_SET = 0,
  };

  enum HasAvoidBadSurfacesCase {
    kAvoidBadSurfaces = 11,
    HAS_AVOID_BAD_SURFACES_NOT_SET = 0,
  };

  enum HasUseFerryCase {
    kUseFerry = 12,
    HAS_USE_FERRY_NOT_SET = 0,
  };

  enum HasUseHighwaysCase {
    kUseHighways = 13,
    HAS_USE_HIGHWAYS_NOT_SET = 0,
  };

  enum HasUseTollsCase {
    kUseTolls = 14,
    HAS_USE_TOLLS_NOT_SET = 0,
  };

  enum HasUseRoadsCase {
    kUseRoads = 15,
    HAS_USE_ROADS_NOT_SET = 0,
  };

  enum HasMaxDistanceCase {
    kMaxDistance = 16,
    HAS_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasWalkingSpeedCase {
    kWalkingSpeed = 17,
    HAS_WALKING_SPEED_NOT_SET = 0,
  };

  enum HasStepPenaltyCase {
    kStepPenalty = 18,
    HAS_STEP_PENALTY_NOT_SET = 0,
  };

  enum HasMaxGradeCase {
    kMaxGrade = 19,
    HAS_MAX_GRADE_NOT_SET = 0,
  };

  enum HasMaxHikingDifficultyCase {
    kMaxHikingDifficulty = 20,
    HAS_MAX_HIKING_DIFFICULTY_NOT_SET = 0,
  };

  enum HasModeFactorCase {
    kModeFactor = 21,
    HAS_MODE_FACTOR_NOT_SET = 0,
  };

  enum HasWalkwayFactorCase {
    kWalkwayFactor = 22,
    HAS_WALKWAY_FACTOR_NOT_SET = 0,
  };

  enum HasSidewalkFactorCase {
    kSidewalkFactor = 23,
    HAS_SIDEWALK_FACTOR_NOT_SET = 0,
  };

  enum HasAlleyFactorCase {
    kAlleyFactor = 24,
    HAS_ALLEY_FACTOR_NOT_SET = 0,
  };

  enum HasDrivewayFactorCase {
    kDrivewayFactor = 25,
    HAS_DRIVEWAY_FACTOR_NOT_SET = 0,
  };

  enum HasDrivewayPenaltyCase {
    kDrivewayPenalty = 26,
    HAS_DRIVEWAY_PENALTY_NOT_SET = 0,
  };

  enum HasTransitStartEndMaxDistanceCase {
    kTransitStartEndMaxDistance = 27,
    HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasTransitTransferMaxDistanceCase {
    kTransitTransferMaxDistance = 28,
    HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasTransportTypeCase {
    kTransportType = 29,
    HAS_TRANSPORT_TYPE_NOT_SET = 0,
  };

  enum HasTopSpeedCase {
    kTopSpeed = 30,
    HAS_TOP_SPEED_NOT_SET = 0,
  };

  enum HasUseHillsCase {
    kUseHills = 31,
    HAS_USE_HILLS_NOT_SET = 0,
  };

  enum HasUsePrimaryCase {
    kUsePrimary = 32,
    HAS_USE_PRIMARY_NOT_SET = 0,
  };

  enum HasUseTrailsCase {
    kUseTrails = 33,
    HAS_USE_TRAILS_NOT_SET = 0,
  };

  enum HasLowClassPenaltyCase {
    kLowClassPenalty = 34,
    HAS_LOW_CLASS_PENALTY_NOT_SET = 0,
  };

  enum HasHazmatCase {
    kHazmat = 35,
    HAS_HAZMAT_NOT_SET = 0,
  };

  enum HasWeightCase {
    kWeight = 36,
    HAS_WEIGHT_NOT_SET = 0,
  };

  enum HasAxleLoadCase {
    kAxleLoad = 37,
    HAS_AXLE_LOAD_NOT_SET = 0,
  };

  enum HasHeightCase {
    kHeight = 38,
    HAS_HEIGHT_NOT_SET = 0,
  };

  enum HasWidthCase {
    kWidth = 39,
    HAS_WIDTH_NOT_SET = 0,
  };

  enum HasLengthCase {
    kLength = 40,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasCyclingSpeedCase {
    kCyclingSpeed = 41,
    HAS_CYCLING_SPEED_NOT_SET = 0,
  };

  enum HasWheelchairCase {
    kWheelchair = 42,
    HAS_WHEELCHAIR_NOT_SET = 0,
  };

  enum HasBicycleCase {
    kBicycle = 43,
    HAS_BICYCLE_NOT_SET = 0,
  };

  enum HasUseBusCase {
    kUseBus = 44,
    HAS_USE_BUS_NOT_SET = 0,
  };

  enum HasUseRailCase {
    kUseRail = 45,
    HAS_USE_RAIL_NOT_SET = 0,
  };

  enum HasUseTransfersCase {
    kUseTransfers = 46,
    HAS_USE_TRANSFERS_NOT_SET = 0,
  };

  enum HasTransferCostCase {
    kTransferCost = 47,
    HAS_TRANSFER_COST_NOT_SET = 0,
  };

  enum HasTransferPenaltyCase {
    kTransferPenalty = 48,
    HAS_TRANSFER_PENALTY_NOT_SET = 0,
  };

  enum HasFlowMaskCase {
    kFlowMask = 55,
    HAS_FLOW_MASK_NOT_SET = 0,
  };

  enum HasBikeShareCostCase {
    kBikeShareCost = 56,
    HAS_BIKE_SHARE_COST_NOT_SET = 0,
  };

  enum HasBikeSharePenaltyCase {
    kBikeSharePenalty = 57,
    HAS_BIKE_SHARE_PENALTY_NOT_SET = 0,
  };

  enum HasRailFerryCostCase {
    kRailFerryCost = 58,
    HAS_RAIL_FERRY_COST_NOT_SET = 0,
  };

  enum HasUseRailFerryCase {
    kUseRailFerry = 59,
    HAS_USE_RAIL_FERRY_NOT_SET = 0,
  };

  enum HasIgnoreRestrictionsCase {
    kIgnoreRestrictions = 60,
    HAS_IGNORE_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasIgnoreOnewaysCase {
    kIgnoreOneways = 61,
    HAS_IGNORE_ONEWAYS_NOT_SET = 0,
  };

  enum HasIgnoreAccessCase {
    kIgnoreAccess = 62,
    HAS_IGNORE_ACCESS_NOT_SET = 0,
  };

  enum HasIgnoreClosuresCase {
    kIgnoreClosures = 63,
    HAS_IGNORE_CLOSURES_NOT_SET = 0,
  };

  enum HasShortestCase {
    kShortest = 64,
    HAS_SHORTEST_NOT_SET = 0,
  };

  enum HasServicePenaltyCase {
    kServicePenalty = 65,
    HAS_SERVICE_PENALTY_NOT_SET = 0,
  };

  enum HasUseTracksCase {
    kUseTracks = 66,
    HAS_USE_TRACKS_NOT_SET = 0,
  };

  enum HasUseDistanceCase {
    kUseDistance = 67,
    HAS_USE_DISTANCE_NOT_SET = 0,
  };

  enum HasUseLivingStreetsCase {
    kUseLivingStreets = 68,
    HAS_USE_LIVING_STREETS_NOT_SET = 0,
  };

  enum HasServiceFactorCase {
    kServiceFactor = 69,
    HAS_SERVICE_FACTOR_NOT_SET = 0,
  };

  enum HasClosureFactorCase {
    kClosureFactor = 70,
    HAS_CLOSURE_FACTOR_NOT_SET = 0,
  };

  enum HasPrivateAccessPenaltyCase {
    kPrivateAccessPenalty = 71,
    HAS_PRIVATE_ACCESS_PENALTY_NOT_SET = 0,
  };

  enum HasExcludeUnpavedCase {
    kExcludeUnpaved = 72,
    HAS_EXCLUDE_UNPAVED_NOT_SET = 0,
  };

  enum HasIncludeHotCase {
    kIncludeHot = 73,
    HAS_INCLUDE_HOT_NOT_SET = 0,
  };

  enum HasIncludeHov2Case {
    kIncludeHov2 = 74,
    HAS_INCLUDE_HOV2_NOT_SET = 0,
  };

  enum HasIncludeHov3Case {
    kIncludeHov3 = 75,
    HAS_INCLUDE_HOV3_NOT_SET = 0,
  };

  enum HasExcludeCashOnlyTollsCase {
    kExcludeCashOnlyTolls = 76,
    HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET = 0,
  };

  enum HasRestrictionProbabilityCase {
    kRestrictionProbability = 77,
    HAS_RESTRICTION_PROBABILITY_NOT_SET = 0,
  };

  enum HasCostingCase {
    kCosting = 90,
    HAS_COSTING_NOT_SET = 0,
  };

  enum HasNameCase {
    kName = 91,
    HAS_NAME_NOT_SET = 0,
  };

  enum HasFilterClosuresCase {
    kFilterClosures = 93,
    HAS_FILTER_CLOSURES_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CostingOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CostingOptions* other);

  // implements Message ----------------------------------------------

  inline CostingOptions* New() const { return New(NULL); }

  CostingOptions* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CostingOptions& from);
  void MergeFrom(const CostingOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CostingOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float maneuver_penalty = 1;
  private:
  bool has_maneuver_penalty() const;
  public:
  void clear_maneuver_penalty();
  static const int kManeuverPenaltyFieldNumber = 1;
  float maneuver_penalty() const;
  void set_maneuver_penalty(float value);

  // optional float destination_only_penalty = 2;
  private:
  bool has_destination_only_penalty() const;
  public:
  void clear_destination_only_penalty();
  static const int kDestinationOnlyPenaltyFieldNumber = 2;
  float destination_only_penalty() const;
  void set_destination_only_penalty(float value);

  // optional float gate_cost = 3;
  private:
  bool has_gate_cost() const;
  public:
  void clear_gate_cost();
  static const int kGateCostFieldNumber = 3;
  float gate_cost() const;
  void set_gate_cost(float value);

  // optional float gate_penalty = 4;
  private:
  bool has_gate_penalty() const;
  public:
  void clear_gate_penalty();
  static const int kGatePenaltyFieldNumber = 4;
  float gate_penalty() const;
  void set_gate_penalty(float value);

  // optional float toll_booth_cost = 5;
  private:
  bool has_toll_booth_cost() const;
  public:
  void clear_toll_booth_cost();
  static const int kTollBoothCostFieldNumber = 5;
  float toll_booth_cost() const;
  void set_toll_booth_cost(float value);

  // optional float toll_booth_penalty = 6;
  private:
  bool has_toll_booth_penalty() const;
  public:
  void clear_toll_booth_penalty();
  static const int kTollBoothPenaltyFieldNumber = 6;
  float toll_booth_penalty() const;
  void set_toll_booth_penalty(float value);

  // optional float alley_penalty = 7;
  private:
  bool has_alley_penalty() const;
  public:
  void clear_alley_penalty();
  static const int kAlleyPenaltyFieldNumber = 7;
  float alley_penalty() const;
  void set_alley_penalty(float value);

  // optional float country_crossing_cost = 8;
  private:
  bool has_country_crossing_cost() const;
  public:
  void clear_country_crossing_cost();
  static const int kCountryCrossingCostFieldNumber = 8;
  float country_crossing_cost() const;
  void set_country_crossing_cost(float value);

  // optional float country_crossing_penalty = 9;
  private:
  bool has_country_crossing_penalty() const;
  public:
  void clear_country_crossing_penalty();
  static const int kCountryCrossingPenaltyFieldNumber = 9;
  float country_crossing_penalty() const;
  void set_country_crossing_penalty(float value);

  // optional float ferry_cost = 10;
  private:
  bool has_ferry_cost() const;
  public:
  void clear_ferry_cost();
  static const int kFerryCostFieldNumber = 10;
  float ferry_cost() const;
  void set_ferry_cost(float value);

  // optional float avoid_bad_surfaces = 11;
  private:
  bool has_avoid_bad_surfaces() const;
  public:
  void clear_avoid_bad_surfaces();
  static const int kAvoidBadSurfacesFieldNumber = 11;
  float avoid_bad_surfaces() const;
  void set_avoid_bad_surfaces(float value);

  // optional float use_ferry = 12;
  private:
  bool has_use_ferry() const;
  public:
  void clear_use_ferry();
  static const int kUseFerryFieldNumber = 12;
  float use_ferry() const;
  void set_use_ferry(float value);

  // optional float use_highways = 13;
  private:
  bool has_use_highways() const;
  public:
  void clear_use_highways();
  static const int kUseHighwaysFieldNumber = 13;
  float use_highways() const;
  void set_use_highways(float value);

  // optional float use_tolls = 14;
  private:
  bool has_use_tolls() const;
  public:
  void clear_use_tolls();
  static const int kUseTollsFieldNumber = 14;
  float use_tolls() const;
  void set_use_tolls(float value);

  // optional float use_roads = 15;
  private:
  bool has_use_roads() const;
  public:
  void clear_use_roads();
  static const int kUseRoadsFieldNumber = 15;
  float use_roads() const;
  void set_use_roads(float value);

  // optional uint32 max_distance = 16;
  private:
  bool has_max_distance() const;
  public:
  void clear_max_distance();
  static const int kMaxDistanceFieldNumber = 16;
  ::google::protobuf::uint32 max_distance() const;
  void set_max_distance(::google::protobuf::uint32 value);

  // optional float walking_speed = 17;
  private:
  bool has_walking_speed() const;
  public:
  void clear_walking_speed();
  static const int kWalkingSpeedFieldNumber = 17;
  float walking_speed() const;
  void set_walking_speed(float value);

  // optional float step_penalty = 18;
  private:
  bool has_step_penalty() const;
  public:
  void clear_step_penalty();
  static const int kStepPenaltyFieldNumber = 18;
  float step_penalty() const;
  void set_step_penalty(float value);

  // optional uint32 max_grade = 19;
  private:
  bool has_max_grade() const;
  public:
  void clear_max_grade();
  static const int kMaxGradeFieldNumber = 19;
  ::google::protobuf::uint32 max_grade() const;
  void set_max_grade(::google::protobuf::uint32 value);

  // optional uint32 max_hiking_difficulty = 20;
  private:
  bool has_max_hiking_difficulty() const;
  public:
  void clear_max_hiking_difficulty();
  static const int kMaxHikingDifficultyFieldNumber = 20;
  ::google::protobuf::uint32 max_hiking_difficulty() const;
  void set_max_hiking_difficulty(::google::protobuf::uint32 value);

  // optional float mode_factor = 21;
  private:
  bool has_mode_factor() const;
  public:
  void clear_mode_factor();
  static const int kModeFactorFieldNumber = 21;
  float mode_factor() const;
  void set_mode_factor(float value);

  // optional float walkway_factor = 22;
  private:
  bool has_walkway_factor() const;
  public:
  void clear_walkway_factor();
  static const int kWalkwayFactorFieldNumber = 22;
  float walkway_factor() const;
  void set_walkway_factor(float value);

  // optional float sidewalk_factor = 23;
  private:
  bool has_sidewalk_factor() const;
  public:
  void clear_sidewalk_factor();
  static const int kSidewalkFactorFieldNumber = 23;
  float sidewalk_factor() const;
  void set_sidewalk_factor(float value);

  // optional float alley_factor = 24;
  private:
  bool has_alley_factor() const;
  public:
  void clear_alley_factor();
  static const int kAlleyFactorFieldNumber = 24;
  float alley_factor() const;
  void set_alley_factor(float value);

  // optional float driveway_factor = 25;
  private:
  bool has_driveway_factor() const;
  public:
  void clear_driveway_factor();
  static const int kDrivewayFactorFieldNumber = 25;
  float driveway_factor() const;
  void set_driveway_factor(float value);

  // optional float driveway_penalty = 26;
  private:
  bool has_driveway_penalty() const;
  public:
  void clear_driveway_penalty();
  static const int kDrivewayPenaltyFieldNumber = 26;
  float driveway_penalty() const;
  void set_driveway_penalty(float value);

  // optional uint32 transit_start_end_max_distance = 27;
  private:
  bool has_transit_start_end_max_distance() const;
  public:
  void clear_transit_start_end_max_distance();
  static const int kTransitStartEndMaxDistanceFieldNumber = 27;
  ::google::protobuf::uint32 transit_start_end_max_distance() const;
  void set_transit_start_end_max_distance(::google::protobuf::uint32 value);

  // optional uint32 transit_transfer_max_distance = 28;
  private:
  bool has_transit_transfer_max_distance() const;
  public:
  void clear_transit_transfer_max_distance();
  static const int kTransitTransferMaxDistanceFieldNumber = 28;
  ::google::protobuf::uint32 transit_transfer_max_distance() const;
  void set_transit_transfer_max_distance(::google::protobuf::uint32 value);

  // optional string transport_type = 29;
  private:
  bool has_transport_type() const;
  public:
  void clear_transport_type();
  static const int kTransportTypeFieldNumber = 29;
  const ::std::string& transport_type() const;
  void set_transport_type(const ::std::string& value);
  void set_transport_type(const char* value);
  void set_transport_type(const char* value, size_t size);
  ::std::string* mutable_transport_type();
  ::std::string* release_transport_type();
  void set_allocated_transport_type(::std::string* transport_type);

  // optional float top_speed = 30;
  private:
  bool has_top_speed() const;
  public:
  void clear_top_speed();
  static const int kTopSpeedFieldNumber = 30;
  float top_speed() const;
  void set_top_speed(float value);

  // optional float use_hills = 31;
  private:
  bool has_use_hills() const;
  public:
  void clear_use_hills();
  static const int kUseHillsFieldNumber = 31;
  float use_hills() const;
  void set_use_hills(float value);

  // optional float use_primary = 32;
  private:
  bool has_use_primary() const;
  public:
  void clear_use_primary();
  static const int kUsePrimaryFieldNumber = 32;
  float use_primary() const;
  void set_use_primary(float value);

  // optional float use_trails = 33;
  private:
  bool has_use_trails() const;
  public:
  void clear_use_trails();
  static const int kUseTrailsFieldNumber = 33;
  float use_trails() const;
  void set_use_trails(float value);

  // optional float low_class_penalty = 34;
  private:
  bool has_low_class_penalty() const;
  public:
  void clear_low_class_penalty();
  static const int kLowClassPenaltyFieldNumber = 34;
  float low_class_penalty() const;
  void set_low_class_penalty(float value);

  // optional bool hazmat = 35;
  private:
  bool has_hazmat() const;
  public:
  void clear_hazmat();
  static const int kHazmatFieldNumber = 35;
  bool hazmat() const;
  void set_hazmat(bool value);

  // optional float weight = 36;
  private:
  bool has_weight() const;
  public:
  void clear_weight();
  static const int kWeightFieldNumber = 36;
  float weight() const;
  void set_weight(float value);

  // optional float axle_load = 37;
  private:
  bool has_axle_load() const;
  public:
  void clear_axle_load();
  static const int kAxleLoadFieldNumber = 37;
  float axle_load() const;
  void set_axle_load(float value);

  // optional float height = 38;
  private:
  bool has_height() const;
  public:
  void clear_height();
  static const int kHeightFieldNumber = 38;
  float height() const;
  void set_height(float value);

  // optional float width = 39;
  private:
  bool has_width() const;
  public:
  void clear_width();
  static const int kWidthFieldNumber = 39;
  float width() const;
  void set_width(float value);

  // optional float length = 40;
  private:
  bool has_length() const;
  public:
  void clear_length();
  static const int kLengthFieldNumber = 40;
  float length() const;
  void set_length(float value);

  // optional float cycling_speed = 41;
  private:
  bool has_cycling_speed() const;
  public:
  void clear_cycling_speed();
  static const int kCyclingSpeedFieldNumber = 41;
  float cycling_speed() const;
  void set_cycling_speed(float value);

  // optional bool wheelchair = 42;
  private:
  bool has_wheelchair() const;
  public:
  void clear_wheelchair();
  static const int kWheelchairFieldNumber = 42;
  bool wheelchair() const;
  void set_wheelchair(bool value);

  // optional bool bicycle = 43;
  private:
  bool has_bicycle() const;
  public:
  void clear_bicycle();
  static const int kBicycleFieldNumber = 43;
  bool bicycle() const;
  void set_bicycle(bool value);

  // optional float use_bus = 44;
  private:
  bool has_use_bus() const;
  public:
  void clear_use_bus();
  static const int kUseBusFieldNumber = 44;
  float use_bus() const;
  void set_use_bus(float value);

  // optional float use_rail = 45;
  private:
  bool has_use_rail() const;
  public:
  void clear_use_rail();
  static const int kUseRailFieldNumber = 45;
  float use_rail() const;
  void set_use_rail(float value);

  // optional float use_transfers = 46;
  private:
  bool has_use_transfers() const;
  public:
  void clear_use_transfers();
  static const int kUseTransfersFieldNumber = 46;
  float use_transfers() const;
  void set_use_transfers(float value);

  // optional float transfer_cost = 47;
  private:
  bool has_transfer_cost() const;
  public:
  void clear_transfer_cost();
  static const int kTransferCostFieldNumber = 47;
  float transfer_cost() const;
  void set_transfer_cost(float value);

  // optional float transfer_penalty = 48;
  private:
  bool has_transfer_penalty() const;
  public:
  void clear_transfer_penalty();
  static const int kTransferPenaltyFieldNumber = 48;
  float transfer_penalty() const;
  void set_transfer_penalty(float value);

  // optional .valhalla.FilterAction filter_stop_action = 49;
  void clear_filter_stop_action();
  static const int kFilterStopActionFieldNumber = 49;
  ::valhalla::FilterAction filter_stop_action() const;
  void set_filter_stop_action(::valhalla::FilterAction value);

  // repeated string filter_stop_ids = 50;
  int filter_stop_ids_size() const;
  void clear_filter_stop_ids();
  static const int kFilterStopIdsFieldNumber = 50;
  const ::std::string& filter_stop_ids(int index) const;
  ::std::string* mutable_filter_stop_ids(int index);
  void set_filter_stop_ids(int index, const ::std::string& value);
  void set_filter_stop_ids(int index, const char* value);
  void set_filter_stop_ids(int index, const char* value, size_t size);
  ::std::string* add_filter_stop_ids();
  void add_filter_stop_ids(const ::std::string& value);
  void add_filter_stop_ids(const char* value);
  void add_filter_stop_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_stop_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_stop_ids();

  // optional .valhalla.FilterAction filter_operator_action = 51;
  void clear_filter_operator_action();
  static const int kFilterOperatorActionFieldNumber = 51;
  ::valhalla::FilterAction filter_operator_action() const;
  void set_filter_operator_action(::valhalla::FilterAction value);

  // repeated string filter_operator_ids = 52;
  int filter_operator_ids_size() const;
  void clear_filter_operator_ids();
  static const int kFilterOperatorIdsFieldNumber = 52;
  const ::std::string& filter_operator_ids(int index) const;
  ::std::string* mutable_filter_operator_ids(int index);
  void set_filter_operator_ids(int index, const ::std::string& value);
  void set_filter_operator_ids(int index, const char* value);
  void set_filter_operator_ids(int index, const char* value, size_t size);
  ::std::string* add_filter_operator_ids();
  void add_filter_operator_ids(const ::std::string& value);
  void add_filter_operator_ids(const char* value);
  void add_filter_operator_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_operator_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_operator_ids();

  // optional .valhalla.FilterAction filter_route_action = 53;
  void clear_filter_route_action();
  static const int kFilterRouteActionFieldNumber = 53;
  ::valhalla::FilterAction filter_route_action() const;
  void set_filter_route_action(::valhalla::FilterAction value);

  // repeated string filter_route_ids = 54;
  int filter_route_ids_size() const;
  void clear_filter_route_ids();
  static const int kFilterRouteIdsFieldNumber = 54;
  const ::std::string& filter_route_ids(int index) const;
  ::std::string* mutable_filter_route_ids(int index);
  void set_filter_route_ids(int index, const ::std::string& value);
  void set_filter_route_ids(int index, const char* value);
  void set_filter_route_ids(int index, const char* value, size_t size);
  ::std::string* add_filter_route_ids();
  void add_filter_route_ids(const ::std::string& value);
  void add_filter_route_ids(const char* value);
  void add_filter_route_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_route_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_route_ids();

  // optional uint32 flow_mask = 55;
  private:
  bool has_flow_mask() const;
  public:
  void clear_flow_mask();
  static const int kFlowMaskFieldNumber = 55;
  ::google::protobuf::uint32 flow_mask() const;
  void set_flow_mask(::google::protobuf::uint32 value);

  // optional float bike_share_cost = 56;
  private:
  bool has_bike_share_cost() const;
  public:
  void clear_bike_share_cost();
  static const int kBikeShareCostFieldNumber = 56;
  float bike_share_cost() const;
  void set_bike_share_cost(float value);

  // optional float bike_share_penalty = 57;
  private:
  bool has_bike_share_penalty() const;
  public:
  void clear_bike_share_penalty();
  static const int kBikeSharePenaltyFieldNumber = 57;
  float bike_share_penalty() const;
  void set_bike_share_penalty(float value);

  // optional float rail_ferry_cost = 58;
  private:
  bool has_rail_ferry_cost() const;
  public:
  void clear_rail_ferry_cost();
  static const int kRailFerryCostFieldNumber = 58;
  float rail_ferry_cost() const;
  void set_rail_ferry_cost(float value);

  // optional float use_rail_ferry = 59;
  private:
  bool has_use_rail_ferry() const;
  public:
  void clear_use_rail_ferry();
  static const int kUseRailFerryFieldNumber = 59;
  float use_rail_ferry() const;
  void set_use_rail_ferry(float value);

  // optional bool ignore_restrictions = 60;
  private:
  bool has_ignore_restrictions() const;
  public:
  void clear_ignore_restrictions();
  static const int kIgnoreRestrictionsFieldNumber = 60;
  bool ignore_restrictions() const;
  void set_ignore_restrictions(bool value);

  // optional bool ignore_oneways = 61;
  private:
  bool has_ignore_oneways() const;
  public:
  void clear_ignore_oneways();
  static const int kIgnoreOnewaysFieldNumber = 61;
  bool ignore_oneways() const;
  void set_ignore_oneways(bool value);

  // optional bool ignore_access = 62;
  private:
  bool has_ignore_access() const;
  public:
  void clear_ignore_access();
  static const int kIgnoreAccessFieldNumber = 62;
  bool ignore_access() const;
  void set_ignore_access(bool value);

  // optional bool ignore_closures = 63;
  private:
  bool has_ignore_closures() const;
  public:
  void clear_ignore_closures();
  static const int kIgnoreClosuresFieldNumber = 63;
  bool ignore_closures() const;
  void set_ignore_closures(bool value);

  // optional bool shortest = 64;
  private:
  bool has_shortest() const;
  public:
  void clear_shortest();
  static const int kShortestFieldNumber = 64;
  bool shortest() const;
  void set_shortest(bool value);

  // optional float service_penalty = 65;
  private:
  bool has_service_penalty() const;
  public:
  void clear_service_penalty();
  static const int kServicePenaltyFieldNumber = 65;
  float service_penalty() const;
  void set_service_penalty(float value);

  // optional float use_tracks = 66;
  private:
  bool has_use_tracks() const;
  public:
  void clear_use_tracks();
  static const int kUseTracksFieldNumber = 66;
  float use_tracks() const;
  void set_use_tracks(float value);

  // optional float use_distance = 67;
  private:
  bool has_use_distance() const;
  public:
  void clear_use_distance();
  static const int kUseDistanceFieldNumber = 67;
  float use_distance() const;
  void set_use_distance(float value);

  // optional float use_living_streets = 68;
  private:
  bool has_use_living_streets() const;
  public:
  void clear_use_living_streets();
  static const int kUseLivingStreetsFieldNumber = 68;
  float use_living_streets() const;
  void set_use_living_streets(float value);

  // optional float service_factor = 69;
  private:
  bool has_service_factor() const;
  public:
  void clear_service_factor();
  static const int kServiceFactorFieldNumber = 69;
  float service_factor() const;
  void set_service_factor(float value);

  // optional float closure_factor = 70;
  private:
  bool has_closure_factor() const;
  public:
  void clear_closure_factor();
  static const int kClosureFactorFieldNumber = 70;
  float closure_factor() const;
  void set_closure_factor(float value);

  // optional float private_access_penalty = 71;
  private:
  bool has_private_access_penalty() const;
  public:
  void clear_private_access_penalty();
  static const int kPrivateAccessPenaltyFieldNumber = 71;
  float private_access_penalty() const;
  void set_private_access_penalty(float value);

  // optional bool exclude_unpaved = 72;
  private:
  bool has_exclude_unpaved() const;
  public:
  void clear_exclude_unpaved();
  static const int kExcludeUnpavedFieldNumber = 72;
  bool exclude_unpaved() const;
  void set_exclude_unpaved(bool value);

  // optional bool include_hot = 73;
  private:
  bool has_include_hot() const;
  public:
  void clear_include_hot();
  static const int kIncludeHotFieldNumber = 73;
  bool include_hot() const;
  void set_include_hot(bool value);

  // optional bool include_hov2 = 74;
  private:
  bool has_include_hov2() const;
  public:
  void clear_include_hov2();
  static const int kIncludeHov2FieldNumber = 74;
  bool include_hov2() const;
  void set_include_hov2(bool value);

  // optional bool include_hov3 = 75;
  private:
  bool has_include_hov3() const;
  public:
  void clear_include_hov3();
  static const int kIncludeHov3FieldNumber = 75;
  bool include_hov3() const;
  void set_include_hov3(bool value);

  // optional bool exclude_cash_only_tolls = 76;
  private:
  bool has_exclude_cash_only_tolls() const;
  public:
  void clear_exclude_cash_only_tolls();
  static const int kExcludeCashOnlyTollsFieldNumber = 76;
  bool exclude_cash_only_tolls() const;
  void set_exclude_cash_only_tolls(bool value);

  // optional uint32 restriction_probability = 77;
  private:
  bool has_restriction_probability() const;
  public:
  void clear_restriction_probability();
  static const int kRestrictionProbabilityFieldNumber = 77;
  ::google::protobuf::uint32 restriction_probability() const;
  void set_restriction_probability(::google::protobuf::uint32 value);

  // optional .valhalla.Costing costing = 90;
  private:
  bool has_costing() const;
  public:
  void clear_costing();
  static const int kCostingFieldNumber = 90;
  ::valhalla::Costing costing() const;
  void set_costing(::valhalla::Costing value);

  // optional string name = 91;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 91;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .valhalla.AvoidEdge exclude_edges = 92;
  int exclude_edges_size() const;
  void clear_exclude_edges();
  static const int kExcludeEdgesFieldNumber = 92;
  const ::valhalla::AvoidEdge& exclude_edges(int index) const;
  ::valhalla::AvoidEdge* mutable_exclude_edges(int index);
  ::valhalla::AvoidEdge* add_exclude_edges();
  ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >*
      mutable_exclude_edges();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >&
      exclude_edges() const;

  // optional bool filter_closures = 93;
  private:
  bool has_filter_closures() const;
  public:
  void clear_filter_closures();
  static const int kFilterClosuresFieldNumber = 93;
  bool filter_closures() const;
  void set_filter_closures(bool value);

  HasManeuverPenaltyCase has_maneuver_penalty_case() const;
  HasDestinationOnlyPenaltyCase has_destination_only_penalty_case() const;
  HasGateCostCase has_gate_cost_case() const;
  HasGatePenaltyCase has_gate_penalty_case() const;
  HasTollBoothCostCase has_toll_booth_cost_case() const;
  HasTollBoothPenaltyCase has_toll_booth_penalty_case() const;
  HasAlleyPenaltyCase has_alley_penalty_case() const;
  HasCountryCrossingCostCase has_country_crossing_cost_case() const;
  HasCountryCrossingPenaltyCase has_country_crossing_penalty_case() const;
  HasFerryCostCase has_ferry_cost_case() const;
  HasAvoidBadSurfacesCase has_avoid_bad_surfaces_case() const;
  HasUseFerryCase has_use_ferry_case() const;
  HasUseHighwaysCase has_use_highways_case() const;
  HasUseTollsCase has_use_tolls_case() const;
  HasUseRoadsCase has_use_roads_case() const;
  HasMaxDistanceCase has_max_distance_case() const;
  HasWalkingSpeedCase has_walking_speed_case() const;
  HasStepPenaltyCase has_step_penalty_case() const;
  HasMaxGradeCase has_max_grade_case() const;
  HasMaxHikingDifficultyCase has_max_hiking_difficulty_case() const;
  HasModeFactorCase has_mode_factor_case() const;
  HasWalkwayFactorCase has_walkway_factor_case() const;
  HasSidewalkFactorCase has_sidewalk_factor_case() const;
  HasAlleyFactorCase has_alley_factor_case() const;
  HasDrivewayFactorCase has_driveway_factor_case() const;
  HasDrivewayPenaltyCase has_driveway_penalty_case() const;
  HasTransitStartEndMaxDistanceCase has_transit_start_end_max_distance_case() const;
  HasTransitTransferMaxDistanceCase has_transit_transfer_max_distance_case() const;
  HasTransportTypeCase has_transport_type_case() const;
  HasTopSpeedCase has_top_speed_case() const;
  HasUseHillsCase has_use_hills_case() const;
  HasUsePrimaryCase has_use_primary_case() const;
  HasUseTrailsCase has_use_trails_case() const;
  HasLowClassPenaltyCase has_low_class_penalty_case() const;
  HasHazmatCase has_hazmat_case() const;
  HasWeightCase has_weight_case() const;
  HasAxleLoadCase has_axle_load_case() const;
  HasHeightCase has_height_case() const;
  HasWidthCase has_width_case() const;
  HasLengthCase has_length_case() const;
  HasCyclingSpeedCase has_cycling_speed_case() const;
  HasWheelchairCase has_wheelchair_case() const;
  HasBicycleCase has_bicycle_case() const;
  HasUseBusCase has_use_bus_case() const;
  HasUseRailCase has_use_rail_case() const;
  HasUseTransfersCase has_use_transfers_case() const;
  HasTransferCostCase has_transfer_cost_case() const;
  HasTransferPenaltyCase has_transfer_penalty_case() const;
  HasFlowMaskCase has_flow_mask_case() const;
  HasBikeShareCostCase has_bike_share_cost_case() const;
  HasBikeSharePenaltyCase has_bike_share_penalty_case() const;
  HasRailFerryCostCase has_rail_ferry_cost_case() const;
  HasUseRailFerryCase has_use_rail_ferry_case() const;
  HasIgnoreRestrictionsCase has_ignore_restrictions_case() const;
  HasIgnoreOnewaysCase has_ignore_oneways_case() const;
  HasIgnoreAccessCase has_ignore_access_case() const;
  HasIgnoreClosuresCase has_ignore_closures_case() const;
  HasShortestCase has_shortest_case() const;
  HasServicePenaltyCase has_service_penalty_case() const;
  HasUseTracksCase has_use_tracks_case() const;
  HasUseDistanceCase has_use_distance_case() const;
  HasUseLivingStreetsCase has_use_living_streets_case() const;
  HasServiceFactorCase has_service_factor_case() const;
  HasClosureFactorCase has_closure_factor_case() const;
  HasPrivateAccessPenaltyCase has_private_access_penalty_case() const;
  HasExcludeUnpavedCase has_exclude_unpaved_case() const;
  HasIncludeHotCase has_include_hot_case() const;
  HasIncludeHov2Case has_include_hov2_case() const;
  HasIncludeHov3Case has_include_hov3_case() const;
  HasExcludeCashOnlyTollsCase has_exclude_cash_only_tolls_case() const;
  HasRestrictionProbabilityCase has_restriction_probability_case() const;
  HasCostingCase has_costing_case() const;
  HasNameCase has_name_case() const;
  HasFilterClosuresCase has_filter_closures_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.CostingOptions)
 private:
  inline void set_has_maneuver_penalty();
  inline void set_has_destination_only_penalty();
  inline void set_has_gate_cost();
  inline void set_has_gate_penalty();
  inline void set_has_toll_booth_cost();
  inline void set_has_toll_booth_penalty();
  inline void set_has_alley_penalty();
  inline void set_has_country_crossing_cost();
  inline void set_has_country_crossing_penalty();
  inline void set_has_ferry_cost();
  inline void set_has_avoid_bad_surfaces();
  inline void set_has_use_ferry();
  inline void set_has_use_highways();
  inline void set_has_use_tolls();
  inline void set_has_use_roads();
  inline void set_has_max_distance();
  inline void set_has_walking_speed();
  inline void set_has_step_penalty();
  inline void set_has_max_grade();
  inline void set_has_max_hiking_difficulty();
  inline void set_has_mode_factor();
  inline void set_has_walkway_factor();
  inline void set_has_sidewalk_factor();
  inline void set_has_alley_factor();
  inline void set_has_driveway_factor();
  inline void set_has_driveway_penalty();
  inline void set_has_transit_start_end_max_distance();
  inline void set_has_transit_transfer_max_distance();
  inline void set_has_transport_type();
  inline void set_has_top_speed();
  inline void set_has_use_hills();
  inline void set_has_use_primary();
  inline void set_has_use_trails();
  inline void set_has_low_class_penalty();
  inline void set_has_hazmat();
  inline void set_has_weight();
  inline void set_has_axle_load();
  inline void set_has_height();
  inline void set_has_width();
  inline void set_has_length();
  inline void set_has_cycling_speed();
  inline void set_has_wheelchair();
  inline void set_has_bicycle();
  inline void set_has_use_bus();
  inline void set_has_use_rail();
  inline void set_has_use_transfers();
  inline void set_has_transfer_cost();
  inline void set_has_transfer_penalty();
  inline void set_has_flow_mask();
  inline void set_has_bike_share_cost();
  inline void set_has_bike_share_penalty();
  inline void set_has_rail_ferry_cost();
  inline void set_has_use_rail_ferry();
  inline void set_has_ignore_restrictions();
  inline void set_has_ignore_oneways();
  inline void set_has_ignore_access();
  inline void set_has_ignore_closures();
  inline void set_has_shortest();
  inline void set_has_service_penalty();
  inline void set_has_use_tracks();
  inline void set_has_use_distance();
  inline void set_has_use_living_streets();
  inline void set_has_service_factor();
  inline void set_has_closure_factor();
  inline void set_has_private_access_penalty();
  inline void set_has_exclude_unpaved();
  inline void set_has_include_hot();
  inline void set_has_include_hov2();
  inline void set_has_include_hov3();
  inline void set_has_exclude_cash_only_tolls();
  inline void set_has_restriction_probability();
  inline void set_has_costing();
  inline void set_has_name();
  inline void set_has_filter_closures();

  inline bool has_has_maneuver_penalty() const;
  void clear_has_maneuver_penalty();
  inline void clear_has_has_maneuver_penalty();

  inline bool has_has_destination_only_penalty() const;
  void clear_has_destination_only_penalty();
  inline void clear_has_has_destination_only_penalty();

  inline bool has_has_gate_cost() const;
  void clear_has_gate_cost();
  inline void clear_has_has_gate_cost();

  inline bool has_has_gate_penalty() const;
  void clear_has_gate_penalty();
  inline void clear_has_has_gate_penalty();

  inline bool has_has_toll_booth_cost() const;
  void clear_has_toll_booth_cost();
  inline void clear_has_has_toll_booth_cost();

  inline bool has_has_toll_booth_penalty() const;
  void clear_has_toll_booth_penalty();
  inline void clear_has_has_toll_booth_penalty();

  inline bool has_has_alley_penalty() const;
  void clear_has_alley_penalty();
  inline void clear_has_has_alley_penalty();

  inline bool has_has_country_crossing_cost() const;
  void clear_has_country_crossing_cost();
  inline void clear_has_has_country_crossing_cost();

  inline bool has_has_country_crossing_penalty() const;
  void clear_has_country_crossing_penalty();
  inline void clear_has_has_country_crossing_penalty();

  inline bool has_has_ferry_cost() const;
  void clear_has_ferry_cost();
  inline void clear_has_has_ferry_cost();

  inline bool has_has_avoid_bad_surfaces() const;
  void clear_has_avoid_bad_surfaces();
  inline void clear_has_has_avoid_bad_surfaces();

  inline bool has_has_use_ferry() const;
  void clear_has_use_ferry();
  inline void clear_has_has_use_ferry();

  inline bool has_has_use_highways() const;
  void clear_has_use_highways();
  inline void clear_has_has_use_highways();

  inline bool has_has_use_tolls() const;
  void clear_has_use_tolls();
  inline void clear_has_has_use_tolls();

  inline bool has_has_use_roads() const;
  void clear_has_use_roads();
  inline void clear_has_has_use_roads();

  inline bool has_has_max_distance() const;
  void clear_has_max_distance();
  inline void clear_has_has_max_distance();

  inline bool has_has_walking_speed() const;
  void clear_has_walking_speed();
  inline void clear_has_has_walking_speed();

  inline bool has_has_step_penalty() const;
  void clear_has_step_penalty();
  inline void clear_has_has_step_penalty();

  inline bool has_has_max_grade() const;
  void clear_has_max_grade();
  inline void clear_has_has_max_grade();

  inline bool has_has_max_hiking_difficulty() const;
  void clear_has_max_hiking_difficulty();
  inline void clear_has_has_max_hiking_difficulty();

  inline bool has_has_mode_factor() const;
  void clear_has_mode_factor();
  inline void clear_has_has_mode_factor();

  inline bool has_has_walkway_factor() const;
  void clear_has_walkway_factor();
  inline void clear_has_has_walkway_factor();

  inline bool has_has_sidewalk_factor() const;
  void clear_has_sidewalk_factor();
  inline void clear_has_has_sidewalk_factor();

  inline bool has_has_alley_factor() const;
  void clear_has_alley_factor();
  inline void clear_has_has_alley_factor();

  inline bool has_has_driveway_factor() const;
  void clear_has_driveway_factor();
  inline void clear_has_has_driveway_factor();

  inline bool has_has_driveway_penalty() const;
  void clear_has_driveway_penalty();
  inline void clear_has_has_driveway_penalty();

  inline bool has_has_transit_start_end_max_distance() const;
  void clear_has_transit_start_end_max_distance();
  inline void clear_has_has_transit_start_end_max_distance();

  inline bool has_has_transit_transfer_max_distance() const;
  void clear_has_transit_transfer_max_distance();
  inline void clear_has_has_transit_transfer_max_distance();

  inline bool has_has_transport_type() const;
  void clear_has_transport_type();
  inline void clear_has_has_transport_type();

  inline bool has_has_top_speed() const;
  void clear_has_top_speed();
  inline void clear_has_has_top_speed();

  inline bool has_has_use_hills() const;
  void clear_has_use_hills();
  inline void clear_has_has_use_hills();

  inline bool has_has_use_primary() const;
  void clear_has_use_primary();
  inline void clear_has_has_use_primary();

  inline bool has_has_use_trails() const;
  void clear_has_use_trails();
  inline void clear_has_has_use_trails();

  inline bool has_has_low_class_penalty() const;
  void clear_has_low_class_penalty();
  inline void clear_has_has_low_class_penalty();

  inline bool has_has_hazmat() const;
  void clear_has_hazmat();
  inline void clear_has_has_hazmat();

  inline bool has_has_weight() const;
  void clear_has_weight();
  inline void clear_has_has_weight();

  inline bool has_has_axle_load() const;
  void clear_has_axle_load();
  inline void clear_has_has_axle_load();

  inline bool has_has_height() const;
  void clear_has_height();
  inline void clear_has_has_height();

  inline bool has_has_width() const;
  void clear_has_width();
  inline void clear_has_has_width();

  inline bool has_has_length() const;
  void clear_has_length();
  inline void clear_has_has_length();

  inline bool has_has_cycling_speed() const;
  void clear_has_cycling_speed();
  inline void clear_has_has_cycling_speed();

  inline bool has_has_wheelchair() const;
  void clear_has_wheelchair();
  inline void clear_has_has_wheelchair();

  inline bool has_has_bicycle() const;
  void clear_has_bicycle();
  inline void clear_has_has_bicycle();

  inline bool has_has_use_bus() const;
  void clear_has_use_bus();
  inline void clear_has_has_use_bus();

  inline bool has_has_use_rail() const;
  void clear_has_use_rail();
  inline void clear_has_has_use_rail();

  inline bool has_has_use_transfers() const;
  void clear_has_use_transfers();
  inline void clear_has_has_use_transfers();

  inline bool has_has_transfer_cost() const;
  void clear_has_transfer_cost();
  inline void clear_has_has_transfer_cost();

  inline bool has_has_transfer_penalty() const;
  void clear_has_transfer_penalty();
  inline void clear_has_has_transfer_penalty();

  inline bool has_has_flow_mask() const;
  void clear_has_flow_mask();
  inline void clear_has_has_flow_mask();

  inline bool has_has_bike_share_cost() const;
  void clear_has_bike_share_cost();
  inline void clear_has_has_bike_share_cost();

  inline bool has_has_bike_share_penalty() const;
  void clear_has_bike_share_penalty();
  inline void clear_has_has_bike_share_penalty();

  inline bool has_has_rail_ferry_cost() const;
  void clear_has_rail_ferry_cost();
  inline void clear_has_has_rail_ferry_cost();

  inline bool has_has_use_rail_ferry() const;
  void clear_has_use_rail_ferry();
  inline void clear_has_has_use_rail_ferry();

  inline bool has_has_ignore_restrictions() const;
  void clear_has_ignore_restrictions();
  inline void clear_has_has_ignore_restrictions();

  inline bool has_has_ignore_oneways() const;
  void clear_has_ignore_oneways();
  inline void clear_has_has_ignore_oneways();

  inline bool has_has_ignore_access() const;
  void clear_has_ignore_access();
  inline void clear_has_has_ignore_access();

  inline bool has_has_ignore_closures() const;
  void clear_has_ignore_closures();
  inline void clear_has_has_ignore_closures();

  inline bool has_has_shortest() const;
  void clear_has_shortest();
  inline void clear_has_has_shortest();

  inline bool has_has_service_penalty() const;
  void clear_has_service_penalty();
  inline void clear_has_has_service_penalty();

  inline bool has_has_use_tracks() const;
  void clear_has_use_tracks();
  inline void clear_has_has_use_tracks();

  inline bool has_has_use_distance() const;
  void clear_has_use_distance();
  inline void clear_has_has_use_distance();

  inline bool has_has_use_living_streets() const;
  void clear_has_use_living_streets();
  inline void clear_has_has_use_living_streets();

  inline bool has_has_service_factor() const;
  void clear_has_service_factor();
  inline void clear_has_has_service_factor();

  inline bool has_has_closure_factor() const;
  void clear_has_closure_factor();
  inline void clear_has_has_closure_factor();

  inline bool has_has_private_access_penalty() const;
  void clear_has_private_access_penalty();
  inline void clear_has_has_private_access_penalty();

  inline bool has_has_exclude_unpaved() const;
  void clear_has_exclude_unpaved();
  inline void clear_has_has_exclude_unpaved();

  inline bool has_has_include_hot() const;
  void clear_has_include_hot();
  inline void clear_has_has_include_hot();

  inline bool has_has_include_hov2() const;
  void clear_has_include_hov2();
  inline void clear_has_has_include_hov2();

  inline bool has_has_include_hov3() const;
  void clear_has_include_hov3();
  inline void clear_has_has_include_hov3();

  inline bool has_has_exclude_cash_only_tolls() const;
  void clear_has_exclude_cash_only_tolls();
  inline void clear_has_has_exclude_cash_only_tolls();

  inline bool has_has_restriction_probability() const;
  void clear_has_restriction_probability();
  inline void clear_has_has_restriction_probability();

  inline bool has_has_costing() const;
  void clear_has_costing();
  inline void clear_has_has_costing();

  inline bool has_has_name() const;
  void clear_has_name();
  inline void clear_has_has_name();

  inline bool has_has_filter_closures() const;
  void clear_has_filter_closures();
  inline void clear_has_has_filter_closures();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_stop_ids_;
  int filter_stop_action_;
  int filter_operator_action_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_operator_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_route_ids_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge > exclude_edges_;
  int filter_route_action_;
  union HasManeuverPenaltyUnion {
    HasManeuverPenaltyUnion() {}
    float maneuver_penalty_;
  } has_maneuver_penalty_;
  union HasDestinationOnlyPenaltyUnion {
    HasDestinationOnlyPenaltyUnion() {}
    float destination_only_penalty_;
  } has_destination_only_penalty_;
  union HasGateCostUnion {
    HasGateCostUnion() {}
    float gate_cost_;
  } has_gate_cost_;
  union HasGatePenaltyUnion {
    HasGatePenaltyUnion() {}
    float gate_penalty_;
  } has_gate_penalty_;
  union HasTollBoothCostUnion {
    HasTollBoothCostUnion() {}
    float toll_booth_cost_;
  } has_toll_booth_cost_;
  union HasTollBoothPenaltyUnion {
    HasTollBoothPenaltyUnion() {}
    float toll_booth_penalty_;
  } has_toll_booth_penalty_;
  union HasAlleyPenaltyUnion {
    HasAlleyPenaltyUnion() {}
    float alley_penalty_;
  } has_alley_penalty_;
  union HasCountryCrossingCostUnion {
    HasCountryCrossingCostUnion() {}
    float country_crossing_cost_;
  } has_country_crossing_cost_;
  union HasCountryCrossingPenaltyUnion {
    HasCountryCrossingPenaltyUnion() {}
    float country_crossing_penalty_;
  } has_country_crossing_penalty_;
  union HasFerryCostUnion {
    HasFerryCostUnion() {}
    float ferry_cost_;
  } has_ferry_cost_;
  union HasAvoidBadSurfacesUnion {
    HasAvoidBadSurfacesUnion() {}
    float avoid_bad_surfaces_;
  } has_avoid_bad_surfaces_;
  union HasUseFerryUnion {
    HasUseFerryUnion() {}
    float use_ferry_;
  } has_use_ferry_;
  union HasUseHighwaysUnion {
    HasUseHighwaysUnion() {}
    float use_highways_;
  } has_use_highways_;
  union HasUseTollsUnion {
    HasUseTollsUnion() {}
    float use_tolls_;
  } has_use_tolls_;
  union HasUseRoadsUnion {
    HasUseRoadsUnion() {}
    float use_roads_;
  } has_use_roads_;
  union HasMaxDistanceUnion {
    HasMaxDistanceUnion() {}
    ::google::protobuf::uint32 max_distance_;
  } has_max_distance_;
  union HasWalkingSpeedUnion {
    HasWalkingSpeedUnion() {}
    float walking_speed_;
  } has_walking_speed_;
  union HasStepPenaltyUnion {
    HasStepPenaltyUnion() {}
    float step_penalty_;
  } has_step_penalty_;
  union HasMaxGradeUnion {
    HasMaxGradeUnion() {}
    ::google::protobuf::uint32 max_grade_;
  } has_max_grade_;
  union HasMaxHikingDifficultyUnion {
    HasMaxHikingDifficultyUnion() {}
    ::google::protobuf::uint32 max_hiking_difficulty_;
  } has_max_hiking_difficulty_;
  union HasModeFactorUnion {
    HasModeFactorUnion() {}
    float mode_factor_;
  } has_mode_factor_;
  union HasWalkwayFactorUnion {
    HasWalkwayFactorUnion() {}
    float walkway_factor_;
  } has_walkway_factor_;
  union HasSidewalkFactorUnion {
    HasSidewalkFactorUnion() {}
    float sidewalk_factor_;
  } has_sidewalk_factor_;
  union HasAlleyFactorUnion {
    HasAlleyFactorUnion() {}
    float alley_factor_;
  } has_alley_factor_;
  union HasDrivewayFactorUnion {
    HasDrivewayFactorUnion() {}
    float driveway_factor_;
  } has_driveway_factor_;
  union HasDrivewayPenaltyUnion {
    HasDrivewayPenaltyUnion() {}
    float driveway_penalty_;
  } has_driveway_penalty_;
  union HasTransitStartEndMaxDistanceUnion {
    HasTransitStartEndMaxDistanceUnion() {}
    ::google::protobuf::uint32 transit_start_end_max_distance_;
  } has_transit_start_end_max_distance_;
  union HasTransitTransferMaxDistanceUnion {
    HasTransitTransferMaxDistanceUnion() {}
    ::google::protobuf::uint32 transit_transfer_max_distance_;
  } has_transit_transfer_max_distance_;
  union HasTransportTypeUnion {
    HasTransportTypeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr transport_type_;
  } has_transport_type_;
  union HasTopSpeedUnion {
    HasTopSpeedUnion() {}
    float top_speed_;
  } has_top_speed_;
  union HasUseHillsUnion {
    HasUseHillsUnion() {}
    float use_hills_;
  } has_use_hills_;
  union HasUsePrimaryUnion {
    HasUsePrimaryUnion() {}
    float use_primary_;
  } has_use_primary_;
  union HasUseTrailsUnion {
    HasUseTrailsUnion() {}
    float use_trails_;
  } has_use_trails_;
  union HasLowClassPenaltyUnion {
    HasLowClassPenaltyUnion() {}
    float low_class_penalty_;
  } has_low_class_penalty_;
  union HasHazmatUnion {
    HasHazmatUnion() {}
    bool hazmat_;
  } has_hazmat_;
  union HasWeightUnion {
    HasWeightUnion() {}
    float weight_;
  } has_weight_;
  union HasAxleLoadUnion {
    HasAxleLoadUnion() {}
    float axle_load_;
  } has_axle_load_;
  union HasHeightUnion {
    HasHeightUnion() {}
    float height_;
  } has_height_;
  union HasWidthUnion {
    HasWidthUnion() {}
    float width_;
  } has_width_;
  union HasLengthUnion {
    HasLengthUnion() {}
    float length_;
  } has_length_;
  union HasCyclingSpeedUnion {
    HasCyclingSpeedUnion() {}
    float cycling_speed_;
  } has_cycling_speed_;
  union HasWheelchairUnion {
    HasWheelchairUnion() {}
    bool wheelchair_;
  } has_wheelchair_;
  union HasBicycleUnion {
    HasBicycleUnion() {}
    bool bicycle_;
  } has_bicycle_;
  union HasUseBusUnion {
    HasUseBusUnion() {}
    float use_bus_;
  } has_use_bus_;
  union HasUseRailUnion {
    HasUseRailUnion() {}
    float use_rail_;
  } has_use_rail_;
  union HasUseTransfersUnion {
    HasUseTransfersUnion() {}
    float use_transfers_;
  } has_use_transfers_;
  union HasTransferCostUnion {
    HasTransferCostUnion() {}
    float transfer_cost_;
  } has_transfer_cost_;
  union HasTransferPenaltyUnion {
    HasTransferPenaltyUnion() {}
    float transfer_penalty_;
  } has_transfer_penalty_;
  union HasFlowMaskUnion {
    HasFlowMaskUnion() {}
    ::google::protobuf::uint32 flow_mask_;
  } has_flow_mask_;
  union HasBikeShareCostUnion {
    HasBikeShareCostUnion() {}
    float bike_share_cost_;
  } has_bike_share_cost_;
  union HasBikeSharePenaltyUnion {
    HasBikeSharePenaltyUnion() {}
    float bike_share_penalty_;
  } has_bike_share_penalty_;
  union HasRailFerryCostUnion {
    HasRailFerryCostUnion() {}
    float rail_ferry_cost_;
  } has_rail_ferry_cost_;
  union HasUseRailFerryUnion {
    HasUseRailFerryUnion() {}
    float use_rail_ferry_;
  } has_use_rail_ferry_;
  union HasIgnoreRestrictionsUnion {
    HasIgnoreRestrictionsUnion() {}
    bool ignore_restrictions_;
  } has_ignore_restrictions_;
  union HasIgnoreOnewaysUnion {
    HasIgnoreOnewaysUnion() {}
    bool ignore_oneways_;
  } has_ignore_oneways_;
  union HasIgnoreAccessUnion {
    HasIgnoreAccessUnion() {}
    bool ignore_access_;
  } has_ignore_access_;
  union HasIgnoreClosuresUnion {
    HasIgnoreClosuresUnion() {}
    bool ignore_closures_;
  } has_ignore_closures_;
  union HasShortestUnion {
    HasShortestUnion() {}
    bool shortest_;
  } has_shortest_;
  union HasServicePenaltyUnion {
    HasServicePenaltyUnion() {}
    float service_penalty_;
  } has_service_penalty_;
  union HasUseTracksUnion {
    HasUseTracksUnion() {}
    float use_tracks_;
  } has_use_tracks_;
  union HasUseDistanceUnion {
    HasUseDistanceUnion() {}
    float use_distance_;
  } has_use_distance_;
  union HasUseLivingStreetsUnion {
    HasUseLivingStreetsUnion() {}
    float use_living_streets_;
  } has_use_living_streets_;
  union HasServiceFactorUnion {
    HasServiceFactorUnion() {}
    float service_factor_;
  } has_service_factor_;
  union HasClosureFactorUnion {
    HasClosureFactorUnion() {}
    float closure_factor_;
  } has_closure_factor_;
  union HasPrivateAccessPenaltyUnion {
    HasPrivateAccessPenaltyUnion() {}
    float private_access_penalty_;
  } has_private_access_penalty_;
  union HasExcludeUnpavedUnion {
    HasExcludeUnpavedUnion() {}
    bool exclude_unpaved_;
  } has_exclude_unpaved_;
  union HasIncludeHotUnion {
    HasIncludeHotUnion() {}
    bool include_hot_;
  } has_include_hot_;
  union HasIncludeHov2Union {
    HasIncludeHov2Union() {}
    bool include_hov2_;
  } has_include_hov2_;
  union HasIncludeHov3Union {
    HasIncludeHov3Union() {}
    bool include_hov3_;
  } has_include_hov3_;
  union HasExcludeCashOnlyTollsUnion {
    HasExcludeCashOnlyTollsUnion() {}
    bool exclude_cash_only_tolls_;
  } has_exclude_cash_only_tolls_;
  union HasRestrictionProbabilityUnion {
    HasRestrictionProbabilityUnion() {}
    ::google::protobuf::uint32 restriction_probability_;
  } has_restriction_probability_;
  union HasCostingUnion {
    HasCostingUnion() {}
    int costing_;
  } has_costing_;
  union HasNameUnion {
    HasNameUnion() {}
    ::google::protobuf::internal::ArenaStringPtr name_;
  } has_name_;
  union HasFilterClosuresUnion {
    HasFilterClosuresUnion() {}
    bool filter_closures_;
  } has_filter_closures_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[74];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static CostingOptions* default_instance_;
};
// -------------------------------------------------------------------

class Options_Ring : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Options.Ring) */ {
 public:
  Options_Ring();
  virtual ~Options_Ring();

  Options_Ring(const Options_Ring& from);

  inline Options_Ring& operator=(const Options_Ring& from) {
    CopyFrom(from);
    return *this;
  }

  static const Options_Ring& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Options_Ring* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Options_Ring* other);

  // implements Message ----------------------------------------------

  inline Options_Ring* New() const { return New(NULL); }

  Options_Ring* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Options_Ring& from);
  void MergeFrom(const Options_Ring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Options_Ring* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.LatLng coords = 1;
  int coords_size() const;
  void clear_coords();
  static const int kCoordsFieldNumber = 1;
  const ::valhalla::LatLng& coords(int index) const;
  ::valhalla::LatLng* mutable_coords(int index);
  ::valhalla::LatLng* add_coords();
  ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng >*
      mutable_coords();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng >&
      coords() const;

  // @@protoc_insertion_point(class_scope:valhalla.Options.Ring)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng > coords_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static Options_Ring* default_instance_;
};
// -------------------------------------------------------------------

class Options : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Options) */ {
 public:
  Options();
  virtual ~Options();

  Options(const Options& from);

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }

  static const Options& default_instance();

  enum HasUnitsCase {
    kUnits = 1,
    HAS_UNITS_NOT_SET = 0,
  };

  enum HasLanguageCase {
    kLanguage = 2,
    HAS_LANGUAGE_NOT_SET = 0,
  };

  enum HasDirectionsTypeCase {
    kDirectionsType = 3,
    HAS_DIRECTIONS_TYPE_NOT_SET = 0,
  };

  enum HasFormatCase {
    kFormat = 4,
    HAS_FORMAT_NOT_SET = 0,
  };

  enum HasIdCase {
    kId = 5,
    HAS_ID_NOT_SET = 0,
  };

  enum HasJsonpCase {
    kJsonp = 6,
    HAS_JSONP_NOT_SET = 0,
  };

  enum HasEncodedPolylineCase {
    kEncodedPolyline = 7,
    HAS_ENCODED_POLYLINE_NOT_SET = 0,
  };

  enum HasActionCase {
    kAction = 8,
    HAS_ACTION_NOT_SET = 0,
  };

  enum HasRangeCase {
    kRange = 10,
    HAS_RANGE_NOT_SET = 0,
  };

  enum HasVerboseCase {
    kVerbose = 11,
    HAS_VERBOSE_NOT_SET = 0,
  };

  enum HasCostingCase {
    kCosting = 12,
    HAS_COSTING_NOT_SET = 0,
  };

  enum HasDateTimeTypeCase {
    kDateTimeType = 18,
    HAS_DATE_TIME_TYPE_NOT_SET = 0,
  };

  enum HasDateTimeCase {
    kDateTime = 19,
    HAS_DATE_TIME_NOT_SET = 0,
  };

  enum HasResampleDistanceCase {
    kResampleDistance = 21,
    HAS_RESAMPLE_DISTANCE_NOT_SET = 0,
  };

  enum HasPolygonsCase {
    kPolygons = 23,
    HAS_POLYGONS_NOT_SET = 0,
  };

  enum HasDenoiseCase {
    kDenoise = 24,
    HAS_DENOISE_NOT_SET = 0,
  };

  enum HasGeneralizeCase {
    kGeneralize = 25,
    HAS_GENERALIZE_NOT_SET = 0,
  };

  enum HasShowLocationsCase {
    kShowLocations = 26,
    HAS_SHOW_LOCATIONS_NOT_SET = 0,
  };

  enum HasShapeMatchCase {
    kShapeMatch = 28,
    HAS_SHAPE_MATCH_NOT_SET = 0,
  };

  enum HasGpsAccuracyCase {
    kGpsAccuracy = 30,
    HAS_GPS_ACCURACY_NOT_SET = 0,
  };

  enum HasSearchRadiusCase {
    kSearchRadius = 31,
    HAS_SEARCH_RADIUS_NOT_SET = 0,
  };

  enum HasTurnPenaltyFactorCase {
    kTurnPenaltyFactor = 32,
    HAS_TURN_PENALTY_FACTOR_NOT_SET = 0,
  };

  enum HasBreakageDistanceCase {
    kBreakageDistance = 36,
    HAS_BREAKAGE_DISTANCE_NOT_SET = 0,
  };

  enum HasUseTimestampsCase {
    kUseTimestamps = 37,
    HAS_USE_TIMESTAMPS_NOT_SET = 0,
  };

  enum HasShapeFormatCase {
    kShapeFormat = 38,
    HAS_SHAPE_FORMAT_NOT_SET = 0,
  };

  enum HasAlternatesCase {
    kAlternates = 39,
    HAS_ALTERNATES_NOT_SET = 0,
  };

  enum HasInterpolationDistanceCase {
    kInterpolationDistance = 40,
    HAS_INTERPOLATION_DISTANCE_NOT_SET = 0,
  };

  enum HasGuidanceViewsCase {
    kGuidanceViews = 41,
    HAS_GUIDANCE_VIEWS_NOT_SET = 0,
  };

  enum HasHeightPrecisionCase {
    kHeightPrecision = 43,
    HAS_HEIGHT_PRECISION_NOT_SET = 0,
  };

  enum HasRoundaboutExitsCase {
    kRoundaboutExits = 44,
    HAS_ROUNDABOUT_EXITS_NOT_SET = 0,
  };

  enum HasLinearReferencesCase {
    kLinearReferences = 45,
    HAS_LINEAR_REFERENCES_NOT_SET = 0,
  };

  enum HasPrioritizeBidirectionalCase {
    kPrioritizeBidirectional = 48,
    HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET = 0,
  };

  enum HasExpansionActionCase {
    kExpansionAction = 49,
    HAS_EXPANSION_ACTION_NOT_SET = 0,
  };

  enum HasSkipOppositesCase {
    kSkipOpposites = 50,
    HAS_SKIP_OPPOSITES_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Options* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Options* other);

  // implements Message ----------------------------------------------

  inline Options* New() const { return New(NULL); }

  Options* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Options* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Options_Ring Ring;

  typedef Options_Units Units;
  static const Units kilometers =
    Options_Units_kilometers;
  static const Units miles =
    Options_Units_miles;
  static inline bool Units_IsValid(int value) {
    return Options_Units_IsValid(value);
  }
  static const Units Units_MIN =
    Options_Units_Units_MIN;
  static const Units Units_MAX =
    Options_Units_Units_MAX;
  static const int Units_ARRAYSIZE =
    Options_Units_Units_ARRAYSIZE;

  typedef Options_Format Format;
  static const Format json =
    Options_Format_json;
  static const Format gpx =
    Options_Format_gpx;
  static const Format osrm =
    Options_Format_osrm;
  static const Format pbf =
    Options_Format_pbf;
  static inline bool Format_IsValid(int value) {
    return Options_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Options_Format_Format_MIN;
  static const Format Format_MAX =
    Options_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Options_Format_Format_ARRAYSIZE;

  typedef Options_Action Action;
  static const Action route =
    Options_Action_route;
  static const Action locate =
    Options_Action_locate;
  static const Action sources_to_targets =
    Options_Action_sources_to_targets;
  static const Action optimized_route =
    Options_Action_optimized_route;
  static const Action isochrone =
    Options_Action_isochrone;
  static const Action trace_route =
    Options_Action_trace_route;
  static const Action trace_attributes =
    Options_Action_trace_attributes;
  static const Action height =
    Options_Action_height;
  static const Action transit_available =
    Options_Action_transit_available;
  static const Action expansion =
    Options_Action_expansion;
  static const Action centroid =
    Options_Action_centroid;
  static const Action status =
    Options_Action_status;
  static const Action livespeed =
    Options_Action_livespeed;
  static inline bool Action_IsValid(int value) {
    return Options_Action_IsValid(value);
  }
  static const Action Action_MIN =
    Options_Action_Action_MIN;
  static const Action Action_MAX =
    Options_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    Options_Action_Action_ARRAYSIZE;

  typedef Options_DateTimeType DateTimeType;
  static const DateTimeType current =
    Options_DateTimeType_current;
  static const DateTimeType depart_at =
    Options_DateTimeType_depart_at;
  static const DateTimeType arrive_by =
    Options_DateTimeType_arrive_by;
  static const DateTimeType invariant =
    Options_DateTimeType_invariant;
  static inline bool DateTimeType_IsValid(int value) {
    return Options_DateTimeType_IsValid(value);
  }
  static const DateTimeType DateTimeType_MIN =
    Options_DateTimeType_DateTimeType_MIN;
  static const DateTimeType DateTimeType_MAX =
    Options_DateTimeType_DateTimeType_MAX;
  static const int DateTimeType_ARRAYSIZE =
    Options_DateTimeType_DateTimeType_ARRAYSIZE;

  typedef Options_ExpansionProperties ExpansionProperties;
  static const ExpansionProperties costs =
    Options_ExpansionProperties_costs;
  static const ExpansionProperties durations =
    Options_ExpansionProperties_durations;
  static const ExpansionProperties distances =
    Options_ExpansionProperties_distances;
  static const ExpansionProperties statuses =
    Options_ExpansionProperties_statuses;
  static const ExpansionProperties edge_ids =
    Options_ExpansionProperties_edge_ids;
  static inline bool ExpansionProperties_IsValid(int value) {
    return Options_ExpansionProperties_IsValid(value);
  }
  static const ExpansionProperties ExpansionProperties_MIN =
    Options_ExpansionProperties_ExpansionProperties_MIN;
  static const ExpansionProperties ExpansionProperties_MAX =
    Options_ExpansionProperties_ExpansionProperties_MAX;
  static const int ExpansionProperties_ARRAYSIZE =
    Options_ExpansionProperties_ExpansionProperties_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.Options.Units units = 1;
  private:
  bool has_units() const;
  public:
  void clear_units();
  static const int kUnitsFieldNumber = 1;
  ::valhalla::Options_Units units() const;
  void set_units(::valhalla::Options_Units value);

  // optional string language = 2;
  private:
  bool has_language() const;
  public:
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional .valhalla.DirectionsType directions_type = 3;
  private:
  bool has_directions_type() const;
  public:
  void clear_directions_type();
  static const int kDirectionsTypeFieldNumber = 3;
  ::valhalla::DirectionsType directions_type() const;
  void set_directions_type(::valhalla::DirectionsType value);

  // optional .valhalla.Options.Format format = 4;
  private:
  bool has_format() const;
  public:
  void clear_format();
  static const int kFormatFieldNumber = 4;
  ::valhalla::Options_Format format() const;
  void set_format(::valhalla::Options_Format value);

  // optional string id = 5;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 5;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string jsonp = 6;
  private:
  bool has_jsonp() const;
  public:
  void clear_jsonp();
  static const int kJsonpFieldNumber = 6;
  const ::std::string& jsonp() const;
  void set_jsonp(const ::std::string& value);
  void set_jsonp(const char* value);
  void set_jsonp(const char* value, size_t size);
  ::std::string* mutable_jsonp();
  ::std::string* release_jsonp();
  void set_allocated_jsonp(::std::string* jsonp);

  // optional string encoded_polyline = 7;
  private:
  bool has_encoded_polyline() const;
  public:
  void clear_encoded_polyline();
  static const int kEncodedPolylineFieldNumber = 7;
  const ::std::string& encoded_polyline() const;
  void set_encoded_polyline(const ::std::string& value);
  void set_encoded_polyline(const char* value);
  void set_encoded_polyline(const char* value, size_t size);
  ::std::string* mutable_encoded_polyline();
  ::std::string* release_encoded_polyline();
  void set_allocated_encoded_polyline(::std::string* encoded_polyline);

  // optional .valhalla.Options.Action action = 8;
  private:
  bool has_action() const;
  public:
  void clear_action();
  static const int kActionFieldNumber = 8;
  ::valhalla::Options_Action action() const;
  void set_action(::valhalla::Options_Action value);

  // optional bool range = 10;
  private:
  bool has_range() const;
  public:
  void clear_range();
  static const int kRangeFieldNumber = 10;
  bool range() const;
  void set_range(bool value);

  // optional bool verbose = 11;
  private:
  bool has_verbose() const;
  public:
  void clear_verbose();
  static const int kVerboseFieldNumber = 11;
  bool verbose() const;
  void set_verbose(bool value);

  // optional .valhalla.Costing costing = 12;
  private:
  bool has_costing() const;
  public:
  void clear_costing();
  static const int kCostingFieldNumber = 12;
  ::valhalla::Costing costing() const;
  void set_costing(::valhalla::Costing value);

  // map<int32, .valhalla.CostingOptions> costing_options = 13;
  int costing_options_size() const;
  void clear_costing_options();
  static const int kCostingOptionsFieldNumber = 13;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::valhalla::CostingOptions >&
      costing_options() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::valhalla::CostingOptions >*
      mutable_costing_options();

  // repeated .valhalla.Location locations = 14;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 14;
  const ::valhalla::Location& locations(int index) const;
  ::valhalla::Location* mutable_locations(int index);
  ::valhalla::Location* add_locations();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_locations();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      locations() const;

  // repeated .valhalla.Location exclude_locations = 15;
  int exclude_locations_size() const;
  void clear_exclude_locations();
  static const int kExcludeLocationsFieldNumber = 15;
  const ::valhalla::Location& exclude_locations(int index) const;
  ::valhalla::Location* mutable_exclude_locations(int index);
  ::valhalla::Location* add_exclude_locations();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_exclude_locations();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      exclude_locations() const;

  // repeated .valhalla.Location sources = 16;
  int sources_size() const;
  void clear_sources();
  static const int kSourcesFieldNumber = 16;
  const ::valhalla::Location& sources(int index) const;
  ::valhalla::Location* mutable_sources(int index);
  ::valhalla::Location* add_sources();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_sources();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      sources() const;

  // repeated .valhalla.Location targets = 17;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 17;
  const ::valhalla::Location& targets(int index) const;
  ::valhalla::Location* mutable_targets(int index);
  ::valhalla::Location* add_targets();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_targets();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      targets() const;

  // optional .valhalla.Options.DateTimeType date_time_type = 18;
  private:
  bool has_date_time_type() const;
  public:
  void clear_date_time_type();
  static const int kDateTimeTypeFieldNumber = 18;
  ::valhalla::Options_DateTimeType date_time_type() const;
  void set_date_time_type(::valhalla::Options_DateTimeType value);

  // optional string date_time = 19;
  private:
  bool has_date_time() const;
  public:
  void clear_date_time();
  static const int kDateTimeFieldNumber = 19;
  const ::std::string& date_time() const;
  void set_date_time(const ::std::string& value);
  void set_date_time(const char* value);
  void set_date_time(const char* value, size_t size);
  ::std::string* mutable_date_time();
  ::std::string* release_date_time();
  void set_allocated_date_time(::std::string* date_time);

  // repeated .valhalla.Location shape = 20;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 20;
  const ::valhalla::Location& shape(int index) const;
  ::valhalla::Location* mutable_shape(int index);
  ::valhalla::Location* add_shape();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_shape();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      shape() const;

  // optional double resample_distance = 21;
  private:
  bool has_resample_distance() const;
  public:
  void clear_resample_distance();
  static const int kResampleDistanceFieldNumber = 21;
  double resample_distance() const;
  void set_resample_distance(double value);

  // repeated .valhalla.Contour contours = 22;
  int contours_size() const;
  void clear_contours();
  static const int kContoursFieldNumber = 22;
  const ::valhalla::Contour& contours(int index) const;
  ::valhalla::Contour* mutable_contours(int index);
  ::valhalla::Contour* add_contours();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >*
      mutable_contours();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >&
      contours() const;

  // optional bool polygons = 23;
  private:
  bool has_polygons() const;
  public:
  void clear_polygons();
  static const int kPolygonsFieldNumber = 23;
  bool polygons() const;
  void set_polygons(bool value);

  // optional float denoise = 24;
  private:
  bool has_denoise() const;
  public:
  void clear_denoise();
  static const int kDenoiseFieldNumber = 24;
  float denoise() const;
  void set_denoise(float value);

  // optional float generalize = 25;
  private:
  bool has_generalize() const;
  public:
  void clear_generalize();
  static const int kGeneralizeFieldNumber = 25;
  float generalize() const;
  void set_generalize(float value);

  // optional bool show_locations = 26;
  private:
  bool has_show_locations() const;
  public:
  void clear_show_locations();
  static const int kShowLocationsFieldNumber = 26;
  bool show_locations() const;
  void set_show_locations(bool value);

  // repeated .valhalla.Location trace = 27;
  int trace_size() const;
  void clear_trace();
  static const int kTraceFieldNumber = 27;
  const ::valhalla::Location& trace(int index) const;
  ::valhalla::Location* mutable_trace(int index);
  ::valhalla::Location* add_trace();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_trace();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      trace() const;

  // optional .valhalla.ShapeMatch shape_match = 28;
  private:
  bool has_shape_match() const;
  public:
  void clear_shape_match();
  static const int kShapeMatchFieldNumber = 28;
  ::valhalla::ShapeMatch shape_match() const;
  void set_shape_match(::valhalla::ShapeMatch value);

  // optional float gps_accuracy = 30;
  private:
  bool has_gps_accuracy() const;
  public:
  void clear_gps_accuracy();
  static const int kGpsAccuracyFieldNumber = 30;
  float gps_accuracy() const;
  void set_gps_accuracy(float value);

  // optional float search_radius = 31;
  private:
  bool has_search_radius() const;
  public:
  void clear_search_radius();
  static const int kSearchRadiusFieldNumber = 31;
  float search_radius() const;
  void set_search_radius(float value);

  // optional float turn_penalty_factor = 32;
  private:
  bool has_turn_penalty_factor() const;
  public:
  void clear_turn_penalty_factor();
  static const int kTurnPenaltyFactorFieldNumber = 32;
  float turn_penalty_factor() const;
  void set_turn_penalty_factor(float value);

  // optional .valhalla.FilterAction filter_action = 33;
  void clear_filter_action();
  static const int kFilterActionFieldNumber = 33;
  ::valhalla::FilterAction filter_action() const;
  void set_filter_action(::valhalla::FilterAction value);

  // repeated string filter_attributes = 34;
  int filter_attributes_size() const;
  void clear_filter_attributes();
  static const int kFilterAttributesFieldNumber = 34;
  const ::std::string& filter_attributes(int index) const;
  ::std::string* mutable_filter_attributes(int index);
  void set_filter_attributes(int index, const ::std::string& value);
  void set_filter_attributes(int index, const char* value);
  void set_filter_attributes(int index, const char* value, size_t size);
  ::std::string* add_filter_attributes();
  void add_filter_attributes(const ::std::string& value);
  void add_filter_attributes(const char* value);
  void add_filter_attributes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_attributes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_attributes();

  // optional float breakage_distance = 36;
  private:
  bool has_breakage_distance() const;
  public:
  void clear_breakage_distance();
  static const int kBreakageDistanceFieldNumber = 36;
  float breakage_distance() const;
  void set_breakage_distance(float value);

  // optional bool use_timestamps = 37;
  private:
  bool has_use_timestamps() const;
  public:
  void clear_use_timestamps();
  static const int kUseTimestampsFieldNumber = 37;
  bool use_timestamps() const;
  void set_use_timestamps(bool value);

  // optional .valhalla.ShapeFormat shape_format = 38;
  private:
  bool has_shape_format() const;
  public:
  void clear_shape_format();
  static const int kShapeFormatFieldNumber = 38;
  ::valhalla::ShapeFormat shape_format() const;
  void set_shape_format(::valhalla::ShapeFormat value);

  // optional uint32 alternates = 39;
  private:
  bool has_alternates() const;
  public:
  void clear_alternates();
  static const int kAlternatesFieldNumber = 39;
  ::google::protobuf::uint32 alternates() const;
  void set_alternates(::google::protobuf::uint32 value);

  // optional float interpolation_distance = 40;
  private:
  bool has_interpolation_distance() const;
  public:
  void clear_interpolation_distance();
  static const int kInterpolationDistanceFieldNumber = 40;
  float interpolation_distance() const;
  void set_interpolation_distance(float value);

  // optional bool guidance_views = 41;
  private:
  bool has_guidance_views() const;
  public:
  void clear_guidance_views();
  static const int kGuidanceViewsFieldNumber = 41;
  bool guidance_views() const;
  void set_guidance_views(bool value);

  // optional uint32 height_precision = 43;
  private:
  bool has_height_precision() const;
  public:
  void clear_height_precision();
  static const int kHeightPrecisionFieldNumber = 43;
  ::google::protobuf::uint32 height_precision() const;
  void set_height_precision(::google::protobuf::uint32 value);

  // optional bool roundabout_exits = 44;
  private:
  bool has_roundabout_exits() const;
  public:
  void clear_roundabout_exits();
  static const int kRoundaboutExitsFieldNumber = 44;
  bool roundabout_exits() const;
  void set_roundabout_exits(bool value);

  // optional bool linear_references = 45;
  private:
  bool has_linear_references() const;
  public:
  void clear_linear_references();
  static const int kLinearReferencesFieldNumber = 45;
  bool linear_references() const;
  void set_linear_references(bool value);

  // repeated .valhalla.CostingOptions recostings = 46;
  int recostings_size() const;
  void clear_recostings();
  static const int kRecostingsFieldNumber = 46;
  const ::valhalla::CostingOptions& recostings(int index) const;
  ::valhalla::CostingOptions* mutable_recostings(int index);
  ::valhalla::CostingOptions* add_recostings();
  ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >*
      mutable_recostings();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >&
      recostings() const;

  // repeated .valhalla.Options.Ring exclude_polygons = 47;
  int exclude_polygons_size() const;
  void clear_exclude_polygons();
  static const int kExcludePolygonsFieldNumber = 47;
  const ::valhalla::Options_Ring& exclude_polygons(int index) const;
  ::valhalla::Options_Ring* mutable_exclude_polygons(int index);
  ::valhalla::Options_Ring* add_exclude_polygons();
  ::google::protobuf::RepeatedPtrField< ::valhalla::Options_Ring >*
      mutable_exclude_polygons();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Options_Ring >&
      exclude_polygons() const;

  // optional bool prioritize_bidirectional = 48;
  private:
  bool has_prioritize_bidirectional() const;
  public:
  void clear_prioritize_bidirectional();
  static const int kPrioritizeBidirectionalFieldNumber = 48;
  bool prioritize_bidirectional() const;
  void set_prioritize_bidirectional(bool value);

  // optional .valhalla.Options.Action expansion_action = 49;
  private:
  bool has_expansion_action() const;
  public:
  void clear_expansion_action();
  static const int kExpansionActionFieldNumber = 49;
  ::valhalla::Options_Action expansion_action() const;
  void set_expansion_action(::valhalla::Options_Action value);

  // optional bool skip_opposites = 50;
  private:
  bool has_skip_opposites() const;
  public:
  void clear_skip_opposites();
  static const int kSkipOppositesFieldNumber = 50;
  bool skip_opposites() const;
  void set_skip_opposites(bool value);

  // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
  int expansion_properties_size() const;
  void clear_expansion_properties();
  static const int kExpansionPropertiesFieldNumber = 51;
  ::valhalla::Options_ExpansionProperties expansion_properties(int index) const;
  void set_expansion_properties(int index, ::valhalla::Options_ExpansionProperties value);
  void add_expansion_properties(::valhalla::Options_ExpansionProperties value);
  const ::google::protobuf::RepeatedField<int>& expansion_properties() const;
  ::google::protobuf::RepeatedField<int>* mutable_expansion_properties();

  HasUnitsCase has_units_case() const;
  HasLanguageCase has_language_case() const;
  HasDirectionsTypeCase has_directions_type_case() const;
  HasFormatCase has_format_case() const;
  HasIdCase has_id_case() const;
  HasJsonpCase has_jsonp_case() const;
  HasEncodedPolylineCase has_encoded_polyline_case() const;
  HasActionCase has_action_case() const;
  HasRangeCase has_range_case() const;
  HasVerboseCase has_verbose_case() const;
  HasCostingCase has_costing_case() const;
  HasDateTimeTypeCase has_date_time_type_case() const;
  HasDateTimeCase has_date_time_case() const;
  HasResampleDistanceCase has_resample_distance_case() const;
  HasPolygonsCase has_polygons_case() const;
  HasDenoiseCase has_denoise_case() const;
  HasGeneralizeCase has_generalize_case() const;
  HasShowLocationsCase has_show_locations_case() const;
  HasShapeMatchCase has_shape_match_case() const;
  HasGpsAccuracyCase has_gps_accuracy_case() const;
  HasSearchRadiusCase has_search_radius_case() const;
  HasTurnPenaltyFactorCase has_turn_penalty_factor_case() const;
  HasBreakageDistanceCase has_breakage_distance_case() const;
  HasUseTimestampsCase has_use_timestamps_case() const;
  HasShapeFormatCase has_shape_format_case() const;
  HasAlternatesCase has_alternates_case() const;
  HasInterpolationDistanceCase has_interpolation_distance_case() const;
  HasGuidanceViewsCase has_guidance_views_case() const;
  HasHeightPrecisionCase has_height_precision_case() const;
  HasRoundaboutExitsCase has_roundabout_exits_case() const;
  HasLinearReferencesCase has_linear_references_case() const;
  HasPrioritizeBidirectionalCase has_prioritize_bidirectional_case() const;
  HasExpansionActionCase has_expansion_action_case() const;
  HasSkipOppositesCase has_skip_opposites_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Options)
 private:
  inline void set_has_units();
  inline void set_has_language();
  inline void set_has_directions_type();
  inline void set_has_format();
  inline void set_has_id();
  inline void set_has_jsonp();
  inline void set_has_encoded_polyline();
  inline void set_has_action();
  inline void set_has_range();
  inline void set_has_verbose();
  inline void set_has_costing();
  inline void set_has_date_time_type();
  inline void set_has_date_time();
  inline void set_has_resample_distance();
  inline void set_has_polygons();
  inline void set_has_denoise();
  inline void set_has_generalize();
  inline void set_has_show_locations();
  inline void set_has_shape_match();
  inline void set_has_gps_accuracy();
  inline void set_has_search_radius();
  inline void set_has_turn_penalty_factor();
  inline void set_has_breakage_distance();
  inline void set_has_use_timestamps();
  inline void set_has_shape_format();
  inline void set_has_alternates();
  inline void set_has_interpolation_distance();
  inline void set_has_guidance_views();
  inline void set_has_height_precision();
  inline void set_has_roundabout_exits();
  inline void set_has_linear_references();
  inline void set_has_prioritize_bidirectional();
  inline void set_has_expansion_action();
  inline void set_has_skip_opposites();

  inline bool has_has_units() const;
  void clear_has_units();
  inline void clear_has_has_units();

  inline bool has_has_language() const;
  void clear_has_language();
  inline void clear_has_has_language();

  inline bool has_has_directions_type() const;
  void clear_has_directions_type();
  inline void clear_has_has_directions_type();

  inline bool has_has_format() const;
  void clear_has_format();
  inline void clear_has_has_format();

  inline bool has_has_id() const;
  void clear_has_id();
  inline void clear_has_has_id();

  inline bool has_has_jsonp() const;
  void clear_has_jsonp();
  inline void clear_has_has_jsonp();

  inline bool has_has_encoded_polyline() const;
  void clear_has_encoded_polyline();
  inline void clear_has_has_encoded_polyline();

  inline bool has_has_action() const;
  void clear_has_action();
  inline void clear_has_has_action();

  inline bool has_has_range() const;
  void clear_has_range();
  inline void clear_has_has_range();

  inline bool has_has_verbose() const;
  void clear_has_verbose();
  inline void clear_has_has_verbose();

  inline bool has_has_costing() const;
  void clear_has_costing();
  inline void clear_has_has_costing();

  inline bool has_has_date_time_type() const;
  void clear_has_date_time_type();
  inline void clear_has_has_date_time_type();

  inline bool has_has_date_time() const;
  void clear_has_date_time();
  inline void clear_has_has_date_time();

  inline bool has_has_resample_distance() const;
  void clear_has_resample_distance();
  inline void clear_has_has_resample_distance();

  inline bool has_has_polygons() const;
  void clear_has_polygons();
  inline void clear_has_has_polygons();

  inline bool has_has_denoise() const;
  void clear_has_denoise();
  inline void clear_has_has_denoise();

  inline bool has_has_generalize() const;
  void clear_has_generalize();
  inline void clear_has_has_generalize();

  inline bool has_has_show_locations() const;
  void clear_has_show_locations();
  inline void clear_has_has_show_locations();

  inline bool has_has_shape_match() const;
  void clear_has_shape_match();
  inline void clear_has_has_shape_match();

  inline bool has_has_gps_accuracy() const;
  void clear_has_gps_accuracy();
  inline void clear_has_has_gps_accuracy();

  inline bool has_has_search_radius() const;
  void clear_has_search_radius();
  inline void clear_has_has_search_radius();

  inline bool has_has_turn_penalty_factor() const;
  void clear_has_turn_penalty_factor();
  inline void clear_has_has_turn_penalty_factor();

  inline bool has_has_breakage_distance() const;
  void clear_has_breakage_distance();
  inline void clear_has_has_breakage_distance();

  inline bool has_has_use_timestamps() const;
  void clear_has_use_timestamps();
  inline void clear_has_has_use_timestamps();

  inline bool has_has_shape_format() const;
  void clear_has_shape_format();
  inline void clear_has_has_shape_format();

  inline bool has_has_alternates() const;
  void clear_has_alternates();
  inline void clear_has_has_alternates();

  inline bool has_has_interpolation_distance() const;
  void clear_has_interpolation_distance();
  inline void clear_has_has_interpolation_distance();

  inline bool has_has_guidance_views() const;
  void clear_has_guidance_views();
  inline void clear_has_has_guidance_views();

  inline bool has_has_height_precision() const;
  void clear_has_height_precision();
  inline void clear_has_has_height_precision();

  inline bool has_has_roundabout_exits() const;
  void clear_has_roundabout_exits();
  inline void clear_has_has_roundabout_exits();

  inline bool has_has_linear_references() const;
  void clear_has_linear_references();
  inline void clear_has_has_linear_references();

  inline bool has_has_prioritize_bidirectional() const;
  void clear_has_prioritize_bidirectional();
  inline void clear_has_has_prioritize_bidirectional();

  inline bool has_has_expansion_action() const;
  void clear_has_expansion_action();
  inline void clear_has_has_expansion_action();

  inline bool has_has_skip_opposites() const;
  void clear_has_skip_opposites();
  inline void clear_has_has_skip_opposites();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::google::protobuf::int32, ::valhalla::CostingOptions,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Options_CostingOptionsEntry;
  ::google::protobuf::internal::MapFieldLite<
      ::google::protobuf::int32, ::valhalla::CostingOptions,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > costing_options_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > exclude_locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > sources_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > targets_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > shape_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Contour > contours_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > trace_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_attributes_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions > recostings_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Options_Ring > exclude_polygons_;
  ::google::protobuf::RepeatedField<int> expansion_properties_;
  mutable int _expansion_properties_cached_byte_size_;
  int filter_action_;
  union HasUnitsUnion {
    HasUnitsUnion() {}
    int units_;
  } has_units_;
  union HasLanguageUnion {
    HasLanguageUnion() {}
    ::google::protobuf::internal::ArenaStringPtr language_;
  } has_language_;
  union HasDirectionsTypeUnion {
    HasDirectionsTypeUnion() {}
    int directions_type_;
  } has_directions_type_;
  union HasFormatUnion {
    HasFormatUnion() {}
    int format_;
  } has_format_;
  union HasIdUnion {
    HasIdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr id_;
  } has_id_;
  union HasJsonpUnion {
    HasJsonpUnion() {}
    ::google::protobuf::internal::ArenaStringPtr jsonp_;
  } has_jsonp_;
  union HasEncodedPolylineUnion {
    HasEncodedPolylineUnion() {}
    ::google::protobuf::internal::ArenaStringPtr encoded_polyline_;
  } has_encoded_polyline_;
  union HasActionUnion {
    HasActionUnion() {}
    int action_;
  } has_action_;
  union HasRangeUnion {
    HasRangeUnion() {}
    bool range_;
  } has_range_;
  union HasVerboseUnion {
    HasVerboseUnion() {}
    bool verbose_;
  } has_verbose_;
  union HasCostingUnion {
    HasCostingUnion() {}
    int costing_;
  } has_costing_;
  union HasDateTimeTypeUnion {
    HasDateTimeTypeUnion() {}
    int date_time_type_;
  } has_date_time_type_;
  union HasDateTimeUnion {
    HasDateTimeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr date_time_;
  } has_date_time_;
  union HasResampleDistanceUnion {
    HasResampleDistanceUnion() {}
    double resample_distance_;
  } has_resample_distance_;
  union HasPolygonsUnion {
    HasPolygonsUnion() {}
    bool polygons_;
  } has_polygons_;
  union HasDenoiseUnion {
    HasDenoiseUnion() {}
    float denoise_;
  } has_denoise_;
  union HasGeneralizeUnion {
    HasGeneralizeUnion() {}
    float generalize_;
  } has_generalize_;
  union HasShowLocationsUnion {
    HasShowLocationsUnion() {}
    bool show_locations_;
  } has_show_locations_;
  union HasShapeMatchUnion {
    HasShapeMatchUnion() {}
    int shape_match_;
  } has_shape_match_;
  union HasGpsAccuracyUnion {
    HasGpsAccuracyUnion() {}
    float gps_accuracy_;
  } has_gps_accuracy_;
  union HasSearchRadiusUnion {
    HasSearchRadiusUnion() {}
    float search_radius_;
  } has_search_radius_;
  union HasTurnPenaltyFactorUnion {
    HasTurnPenaltyFactorUnion() {}
    float turn_penalty_factor_;
  } has_turn_penalty_factor_;
  union HasBreakageDistanceUnion {
    HasBreakageDistanceUnion() {}
    float breakage_distance_;
  } has_breakage_distance_;
  union HasUseTimestampsUnion {
    HasUseTimestampsUnion() {}
    bool use_timestamps_;
  } has_use_timestamps_;
  union HasShapeFormatUnion {
    HasShapeFormatUnion() {}
    int shape_format_;
  } has_shape_format_;
  union HasAlternatesUnion {
    HasAlternatesUnion() {}
    ::google::protobuf::uint32 alternates_;
  } has_alternates_;
  union HasInterpolationDistanceUnion {
    HasInterpolationDistanceUnion() {}
    float interpolation_distance_;
  } has_interpolation_distance_;
  union HasGuidanceViewsUnion {
    HasGuidanceViewsUnion() {}
    bool guidance_views_;
  } has_guidance_views_;
  union HasHeightPrecisionUnion {
    HasHeightPrecisionUnion() {}
    ::google::protobuf::uint32 height_precision_;
  } has_height_precision_;
  union HasRoundaboutExitsUnion {
    HasRoundaboutExitsUnion() {}
    bool roundabout_exits_;
  } has_roundabout_exits_;
  union HasLinearReferencesUnion {
    HasLinearReferencesUnion() {}
    bool linear_references_;
  } has_linear_references_;
  union HasPrioritizeBidirectionalUnion {
    HasPrioritizeBidirectionalUnion() {}
    bool prioritize_bidirectional_;
  } has_prioritize_bidirectional_;
  union HasExpansionActionUnion {
    HasExpansionActionUnion() {}
    int expansion_action_;
  } has_expansion_action_;
  union HasSkipOppositesUnion {
    HasSkipOppositesUnion() {}
    bool skip_opposites_;
  } has_skip_opposites_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[34];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static Options* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Contour

// optional float time = 1;
inline bool Contour::has_time() const {
  return has_time_case() == kTime;
}
inline void Contour::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void Contour::clear_time() {
  if (has_time()) {
    has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline float Contour::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.time)
  if (has_time()) {
    return has_time_.time_;
  }
  return 0;
}
inline void Contour::set_time(float value) {
  if (!has_time()) {
    clear_has_time();
    set_has_time();
  }
  has_time_.time_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Contour.time)
}

// optional string color = 2;
inline bool Contour::has_color() const {
  return has_color_case() == kColor;
}
inline void Contour::set_has_color() {
  _oneof_case_[1] = kColor;
}
inline void Contour::clear_color() {
  if (has_color()) {
    has_color_.color_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_color();
  }
}
inline const ::std::string& Contour::color() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.color)
  if (has_color()) {
    return has_color_.color_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Contour::set_color(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Contour.color)
  if (!has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_color_.color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.color)
}
inline void Contour::set_color(const char* value) {
  if (!has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_color_.color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Contour.color)
}
inline void Contour::set_color(const char* value, size_t size) {
  if (!has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_color_.color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Contour.color)
}
inline ::std::string* Contour::mutable_color() {
  if (!has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Contour.color)
  return has_color_.color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Contour::release_color() {
  // @@protoc_insertion_point(field_release:valhalla.Contour.color)
  if (has_color()) {
    clear_has_has_color();
    return has_color_.color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Contour::set_allocated_color(::std::string* color) {
  if (!has_color()) {
    has_color_.color_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_color();
  if (color != NULL) {
    set_has_color();
    has_color_.color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        color);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Contour.color)
}

// optional float distance = 3;
inline bool Contour::has_distance() const {
  return has_distance_case() == kDistance;
}
inline void Contour::set_has_distance() {
  _oneof_case_[2] = kDistance;
}
inline void Contour::clear_distance() {
  if (has_distance()) {
    has_distance_.distance_ = 0;
    clear_has_has_distance();
  }
}
inline float Contour::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.distance)
  if (has_distance()) {
    return has_distance_.distance_;
  }
  return 0;
}
inline void Contour::set_distance(float value) {
  if (!has_distance()) {
    clear_has_distance();
    set_has_distance();
  }
  has_distance_.distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Contour.distance)
}

inline bool Contour::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void Contour::clear_has_has_time() {
  _oneof_case_[0] = HAS_TIME_NOT_SET;
}
inline bool Contour::has_has_color() const {
  return has_color_case() != HAS_COLOR_NOT_SET;
}
inline void Contour::clear_has_has_color() {
  _oneof_case_[1] = HAS_COLOR_NOT_SET;
}
inline bool Contour::has_has_distance() const {
  return has_distance_case() != HAS_DISTANCE_NOT_SET;
}
inline void Contour::clear_has_has_distance() {
  _oneof_case_[2] = HAS_DISTANCE_NOT_SET;
}
inline Contour::HasTimeCase Contour::has_time_case() const {
  return Contour::HasTimeCase(_oneof_case_[0]);
}
inline Contour::HasColorCase Contour::has_color_case() const {
  return Contour::HasColorCase(_oneof_case_[1]);
}
inline Contour::HasDistanceCase Contour::has_distance_case() const {
  return Contour::HasDistanceCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// AvoidEdge

// optional uint64 id = 1;
inline bool AvoidEdge::has_id() const {
  return has_id_case() == kId;
}
inline void AvoidEdge::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void AvoidEdge::clear_id() {
  if (has_id()) {
    has_id_.id_ = GOOGLE_ULONGLONG(0);
    clear_has_has_id();
  }
}
inline ::google::protobuf::uint64 AvoidEdge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.id)
  if (has_id()) {
    return has_id_.id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void AvoidEdge::set_id(::google::protobuf::uint64 value) {
  if (!has_id()) {
    clear_has_id();
    set_has_id();
  }
  has_id_.id_ = value;
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.id)
}

// optional float percent_along = 2;
inline bool AvoidEdge::has_percent_along() const {
  return has_percent_along_case() == kPercentAlong;
}
inline void AvoidEdge::set_has_percent_along() {
  _oneof_case_[1] = kPercentAlong;
}
inline void AvoidEdge::clear_percent_along() {
  if (has_percent_along()) {
    has_percent_along_.percent_along_ = 0;
    clear_has_has_percent_along();
  }
}
inline float AvoidEdge::percent_along() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.percent_along)
  if (has_percent_along()) {
    return has_percent_along_.percent_along_;
  }
  return 0;
}
inline void AvoidEdge::set_percent_along(float value) {
  if (!has_percent_along()) {
    clear_has_percent_along();
    set_has_percent_along();
  }
  has_percent_along_.percent_along_ = value;
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.percent_along)
}

inline bool AvoidEdge::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void AvoidEdge::clear_has_has_id() {
  _oneof_case_[0] = HAS_ID_NOT_SET;
}
inline bool AvoidEdge::has_has_percent_along() const {
  return has_percent_along_case() != HAS_PERCENT_ALONG_NOT_SET;
}
inline void AvoidEdge::clear_has_has_percent_along() {
  _oneof_case_[1] = HAS_PERCENT_ALONG_NOT_SET;
}
inline AvoidEdge::HasIdCase AvoidEdge::has_id_case() const {
  return AvoidEdge::HasIdCase(_oneof_case_[0]);
}
inline AvoidEdge::HasPercentAlongCase AvoidEdge::has_percent_along_case() const {
  return AvoidEdge::HasPercentAlongCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// CostingOptions

// optional float maneuver_penalty = 1;
inline bool CostingOptions::has_maneuver_penalty() const {
  return has_maneuver_penalty_case() == kManeuverPenalty;
}
inline void CostingOptions::set_has_maneuver_penalty() {
  _oneof_case_[0] = kManeuverPenalty;
}
inline void CostingOptions::clear_maneuver_penalty() {
  if (has_maneuver_penalty()) {
    has_maneuver_penalty_.maneuver_penalty_ = 0;
    clear_has_has_maneuver_penalty();
  }
}
inline float CostingOptions::maneuver_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.maneuver_penalty)
  if (has_maneuver_penalty()) {
    return has_maneuver_penalty_.maneuver_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_maneuver_penalty(float value) {
  if (!has_maneuver_penalty()) {
    clear_has_maneuver_penalty();
    set_has_maneuver_penalty();
  }
  has_maneuver_penalty_.maneuver_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.maneuver_penalty)
}

// optional float destination_only_penalty = 2;
inline bool CostingOptions::has_destination_only_penalty() const {
  return has_destination_only_penalty_case() == kDestinationOnlyPenalty;
}
inline void CostingOptions::set_has_destination_only_penalty() {
  _oneof_case_[1] = kDestinationOnlyPenalty;
}
inline void CostingOptions::clear_destination_only_penalty() {
  if (has_destination_only_penalty()) {
    has_destination_only_penalty_.destination_only_penalty_ = 0;
    clear_has_has_destination_only_penalty();
  }
}
inline float CostingOptions::destination_only_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.destination_only_penalty)
  if (has_destination_only_penalty()) {
    return has_destination_only_penalty_.destination_only_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_destination_only_penalty(float value) {
  if (!has_destination_only_penalty()) {
    clear_has_destination_only_penalty();
    set_has_destination_only_penalty();
  }
  has_destination_only_penalty_.destination_only_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.destination_only_penalty)
}

// optional float gate_cost = 3;
inline bool CostingOptions::has_gate_cost() const {
  return has_gate_cost_case() == kGateCost;
}
inline void CostingOptions::set_has_gate_cost() {
  _oneof_case_[2] = kGateCost;
}
inline void CostingOptions::clear_gate_cost() {
  if (has_gate_cost()) {
    has_gate_cost_.gate_cost_ = 0;
    clear_has_has_gate_cost();
  }
}
inline float CostingOptions::gate_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.gate_cost)
  if (has_gate_cost()) {
    return has_gate_cost_.gate_cost_;
  }
  return 0;
}
inline void CostingOptions::set_gate_cost(float value) {
  if (!has_gate_cost()) {
    clear_has_gate_cost();
    set_has_gate_cost();
  }
  has_gate_cost_.gate_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.gate_cost)
}

// optional float gate_penalty = 4;
inline bool CostingOptions::has_gate_penalty() const {
  return has_gate_penalty_case() == kGatePenalty;
}
inline void CostingOptions::set_has_gate_penalty() {
  _oneof_case_[3] = kGatePenalty;
}
inline void CostingOptions::clear_gate_penalty() {
  if (has_gate_penalty()) {
    has_gate_penalty_.gate_penalty_ = 0;
    clear_has_has_gate_penalty();
  }
}
inline float CostingOptions::gate_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.gate_penalty)
  if (has_gate_penalty()) {
    return has_gate_penalty_.gate_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_gate_penalty(float value) {
  if (!has_gate_penalty()) {
    clear_has_gate_penalty();
    set_has_gate_penalty();
  }
  has_gate_penalty_.gate_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.gate_penalty)
}

// optional float toll_booth_cost = 5;
inline bool CostingOptions::has_toll_booth_cost() const {
  return has_toll_booth_cost_case() == kTollBoothCost;
}
inline void CostingOptions::set_has_toll_booth_cost() {
  _oneof_case_[4] = kTollBoothCost;
}
inline void CostingOptions::clear_toll_booth_cost() {
  if (has_toll_booth_cost()) {
    has_toll_booth_cost_.toll_booth_cost_ = 0;
    clear_has_has_toll_booth_cost();
  }
}
inline float CostingOptions::toll_booth_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.toll_booth_cost)
  if (has_toll_booth_cost()) {
    return has_toll_booth_cost_.toll_booth_cost_;
  }
  return 0;
}
inline void CostingOptions::set_toll_booth_cost(float value) {
  if (!has_toll_booth_cost()) {
    clear_has_toll_booth_cost();
    set_has_toll_booth_cost();
  }
  has_toll_booth_cost_.toll_booth_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.toll_booth_cost)
}

// optional float toll_booth_penalty = 6;
inline bool CostingOptions::has_toll_booth_penalty() const {
  return has_toll_booth_penalty_case() == kTollBoothPenalty;
}
inline void CostingOptions::set_has_toll_booth_penalty() {
  _oneof_case_[5] = kTollBoothPenalty;
}
inline void CostingOptions::clear_toll_booth_penalty() {
  if (has_toll_booth_penalty()) {
    has_toll_booth_penalty_.toll_booth_penalty_ = 0;
    clear_has_has_toll_booth_penalty();
  }
}
inline float CostingOptions::toll_booth_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.toll_booth_penalty)
  if (has_toll_booth_penalty()) {
    return has_toll_booth_penalty_.toll_booth_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_toll_booth_penalty(float value) {
  if (!has_toll_booth_penalty()) {
    clear_has_toll_booth_penalty();
    set_has_toll_booth_penalty();
  }
  has_toll_booth_penalty_.toll_booth_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.toll_booth_penalty)
}

// optional float alley_penalty = 7;
inline bool CostingOptions::has_alley_penalty() const {
  return has_alley_penalty_case() == kAlleyPenalty;
}
inline void CostingOptions::set_has_alley_penalty() {
  _oneof_case_[6] = kAlleyPenalty;
}
inline void CostingOptions::clear_alley_penalty() {
  if (has_alley_penalty()) {
    has_alley_penalty_.alley_penalty_ = 0;
    clear_has_has_alley_penalty();
  }
}
inline float CostingOptions::alley_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.alley_penalty)
  if (has_alley_penalty()) {
    return has_alley_penalty_.alley_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_alley_penalty(float value) {
  if (!has_alley_penalty()) {
    clear_has_alley_penalty();
    set_has_alley_penalty();
  }
  has_alley_penalty_.alley_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.alley_penalty)
}

// optional float country_crossing_cost = 8;
inline bool CostingOptions::has_country_crossing_cost() const {
  return has_country_crossing_cost_case() == kCountryCrossingCost;
}
inline void CostingOptions::set_has_country_crossing_cost() {
  _oneof_case_[7] = kCountryCrossingCost;
}
inline void CostingOptions::clear_country_crossing_cost() {
  if (has_country_crossing_cost()) {
    has_country_crossing_cost_.country_crossing_cost_ = 0;
    clear_has_has_country_crossing_cost();
  }
}
inline float CostingOptions::country_crossing_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.country_crossing_cost)
  if (has_country_crossing_cost()) {
    return has_country_crossing_cost_.country_crossing_cost_;
  }
  return 0;
}
inline void CostingOptions::set_country_crossing_cost(float value) {
  if (!has_country_crossing_cost()) {
    clear_has_country_crossing_cost();
    set_has_country_crossing_cost();
  }
  has_country_crossing_cost_.country_crossing_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.country_crossing_cost)
}

// optional float country_crossing_penalty = 9;
inline bool CostingOptions::has_country_crossing_penalty() const {
  return has_country_crossing_penalty_case() == kCountryCrossingPenalty;
}
inline void CostingOptions::set_has_country_crossing_penalty() {
  _oneof_case_[8] = kCountryCrossingPenalty;
}
inline void CostingOptions::clear_country_crossing_penalty() {
  if (has_country_crossing_penalty()) {
    has_country_crossing_penalty_.country_crossing_penalty_ = 0;
    clear_has_has_country_crossing_penalty();
  }
}
inline float CostingOptions::country_crossing_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.country_crossing_penalty)
  if (has_country_crossing_penalty()) {
    return has_country_crossing_penalty_.country_crossing_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_country_crossing_penalty(float value) {
  if (!has_country_crossing_penalty()) {
    clear_has_country_crossing_penalty();
    set_has_country_crossing_penalty();
  }
  has_country_crossing_penalty_.country_crossing_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.country_crossing_penalty)
}

// optional float ferry_cost = 10;
inline bool CostingOptions::has_ferry_cost() const {
  return has_ferry_cost_case() == kFerryCost;
}
inline void CostingOptions::set_has_ferry_cost() {
  _oneof_case_[9] = kFerryCost;
}
inline void CostingOptions::clear_ferry_cost() {
  if (has_ferry_cost()) {
    has_ferry_cost_.ferry_cost_ = 0;
    clear_has_has_ferry_cost();
  }
}
inline float CostingOptions::ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ferry_cost)
  if (has_ferry_cost()) {
    return has_ferry_cost_.ferry_cost_;
  }
  return 0;
}
inline void CostingOptions::set_ferry_cost(float value) {
  if (!has_ferry_cost()) {
    clear_has_ferry_cost();
    set_has_ferry_cost();
  }
  has_ferry_cost_.ferry_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ferry_cost)
}

// optional float avoid_bad_surfaces = 11;
inline bool CostingOptions::has_avoid_bad_surfaces() const {
  return has_avoid_bad_surfaces_case() == kAvoidBadSurfaces;
}
inline void CostingOptions::set_has_avoid_bad_surfaces() {
  _oneof_case_[10] = kAvoidBadSurfaces;
}
inline void CostingOptions::clear_avoid_bad_surfaces() {
  if (has_avoid_bad_surfaces()) {
    has_avoid_bad_surfaces_.avoid_bad_surfaces_ = 0;
    clear_has_has_avoid_bad_surfaces();
  }
}
inline float CostingOptions::avoid_bad_surfaces() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.avoid_bad_surfaces)
  if (has_avoid_bad_surfaces()) {
    return has_avoid_bad_surfaces_.avoid_bad_surfaces_;
  }
  return 0;
}
inline void CostingOptions::set_avoid_bad_surfaces(float value) {
  if (!has_avoid_bad_surfaces()) {
    clear_has_avoid_bad_surfaces();
    set_has_avoid_bad_surfaces();
  }
  has_avoid_bad_surfaces_.avoid_bad_surfaces_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.avoid_bad_surfaces)
}

// optional float use_ferry = 12;
inline bool CostingOptions::has_use_ferry() const {
  return has_use_ferry_case() == kUseFerry;
}
inline void CostingOptions::set_has_use_ferry() {
  _oneof_case_[11] = kUseFerry;
}
inline void CostingOptions::clear_use_ferry() {
  if (has_use_ferry()) {
    has_use_ferry_.use_ferry_ = 0;
    clear_has_has_use_ferry();
  }
}
inline float CostingOptions::use_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_ferry)
  if (has_use_ferry()) {
    return has_use_ferry_.use_ferry_;
  }
  return 0;
}
inline void CostingOptions::set_use_ferry(float value) {
  if (!has_use_ferry()) {
    clear_has_use_ferry();
    set_has_use_ferry();
  }
  has_use_ferry_.use_ferry_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_ferry)
}

// optional float use_highways = 13;
inline bool CostingOptions::has_use_highways() const {
  return has_use_highways_case() == kUseHighways;
}
inline void CostingOptions::set_has_use_highways() {
  _oneof_case_[12] = kUseHighways;
}
inline void CostingOptions::clear_use_highways() {
  if (has_use_highways()) {
    has_use_highways_.use_highways_ = 0;
    clear_has_has_use_highways();
  }
}
inline float CostingOptions::use_highways() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_highways)
  if (has_use_highways()) {
    return has_use_highways_.use_highways_;
  }
  return 0;
}
inline void CostingOptions::set_use_highways(float value) {
  if (!has_use_highways()) {
    clear_has_use_highways();
    set_has_use_highways();
  }
  has_use_highways_.use_highways_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_highways)
}

// optional float use_tolls = 14;
inline bool CostingOptions::has_use_tolls() const {
  return has_use_tolls_case() == kUseTolls;
}
inline void CostingOptions::set_has_use_tolls() {
  _oneof_case_[13] = kUseTolls;
}
inline void CostingOptions::clear_use_tolls() {
  if (has_use_tolls()) {
    has_use_tolls_.use_tolls_ = 0;
    clear_has_has_use_tolls();
  }
}
inline float CostingOptions::use_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_tolls)
  if (has_use_tolls()) {
    return has_use_tolls_.use_tolls_;
  }
  return 0;
}
inline void CostingOptions::set_use_tolls(float value) {
  if (!has_use_tolls()) {
    clear_has_use_tolls();
    set_has_use_tolls();
  }
  has_use_tolls_.use_tolls_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_tolls)
}

// optional float use_roads = 15;
inline bool CostingOptions::has_use_roads() const {
  return has_use_roads_case() == kUseRoads;
}
inline void CostingOptions::set_has_use_roads() {
  _oneof_case_[14] = kUseRoads;
}
inline void CostingOptions::clear_use_roads() {
  if (has_use_roads()) {
    has_use_roads_.use_roads_ = 0;
    clear_has_has_use_roads();
  }
}
inline float CostingOptions::use_roads() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_roads)
  if (has_use_roads()) {
    return has_use_roads_.use_roads_;
  }
  return 0;
}
inline void CostingOptions::set_use_roads(float value) {
  if (!has_use_roads()) {
    clear_has_use_roads();
    set_has_use_roads();
  }
  has_use_roads_.use_roads_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_roads)
}

// optional uint32 max_distance = 16;
inline bool CostingOptions::has_max_distance() const {
  return has_max_distance_case() == kMaxDistance;
}
inline void CostingOptions::set_has_max_distance() {
  _oneof_case_[15] = kMaxDistance;
}
inline void CostingOptions::clear_max_distance() {
  if (has_max_distance()) {
    has_max_distance_.max_distance_ = 0u;
    clear_has_has_max_distance();
  }
}
inline ::google::protobuf::uint32 CostingOptions::max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.max_distance)
  if (has_max_distance()) {
    return has_max_distance_.max_distance_;
  }
  return 0u;
}
inline void CostingOptions::set_max_distance(::google::protobuf::uint32 value) {
  if (!has_max_distance()) {
    clear_has_max_distance();
    set_has_max_distance();
  }
  has_max_distance_.max_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.max_distance)
}

// optional float walking_speed = 17;
inline bool CostingOptions::has_walking_speed() const {
  return has_walking_speed_case() == kWalkingSpeed;
}
inline void CostingOptions::set_has_walking_speed() {
  _oneof_case_[16] = kWalkingSpeed;
}
inline void CostingOptions::clear_walking_speed() {
  if (has_walking_speed()) {
    has_walking_speed_.walking_speed_ = 0;
    clear_has_has_walking_speed();
  }
}
inline float CostingOptions::walking_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.walking_speed)
  if (has_walking_speed()) {
    return has_walking_speed_.walking_speed_;
  }
  return 0;
}
inline void CostingOptions::set_walking_speed(float value) {
  if (!has_walking_speed()) {
    clear_has_walking_speed();
    set_has_walking_speed();
  }
  has_walking_speed_.walking_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.walking_speed)
}

// optional float step_penalty = 18;
inline bool CostingOptions::has_step_penalty() const {
  return has_step_penalty_case() == kStepPenalty;
}
inline void CostingOptions::set_has_step_penalty() {
  _oneof_case_[17] = kStepPenalty;
}
inline void CostingOptions::clear_step_penalty() {
  if (has_step_penalty()) {
    has_step_penalty_.step_penalty_ = 0;
    clear_has_has_step_penalty();
  }
}
inline float CostingOptions::step_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.step_penalty)
  if (has_step_penalty()) {
    return has_step_penalty_.step_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_step_penalty(float value) {
  if (!has_step_penalty()) {
    clear_has_step_penalty();
    set_has_step_penalty();
  }
  has_step_penalty_.step_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.step_penalty)
}

// optional uint32 max_grade = 19;
inline bool CostingOptions::has_max_grade() const {
  return has_max_grade_case() == kMaxGrade;
}
inline void CostingOptions::set_has_max_grade() {
  _oneof_case_[18] = kMaxGrade;
}
inline void CostingOptions::clear_max_grade() {
  if (has_max_grade()) {
    has_max_grade_.max_grade_ = 0u;
    clear_has_has_max_grade();
  }
}
inline ::google::protobuf::uint32 CostingOptions::max_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.max_grade)
  if (has_max_grade()) {
    return has_max_grade_.max_grade_;
  }
  return 0u;
}
inline void CostingOptions::set_max_grade(::google::protobuf::uint32 value) {
  if (!has_max_grade()) {
    clear_has_max_grade();
    set_has_max_grade();
  }
  has_max_grade_.max_grade_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.max_grade)
}

// optional uint32 max_hiking_difficulty = 20;
inline bool CostingOptions::has_max_hiking_difficulty() const {
  return has_max_hiking_difficulty_case() == kMaxHikingDifficulty;
}
inline void CostingOptions::set_has_max_hiking_difficulty() {
  _oneof_case_[19] = kMaxHikingDifficulty;
}
inline void CostingOptions::clear_max_hiking_difficulty() {
  if (has_max_hiking_difficulty()) {
    has_max_hiking_difficulty_.max_hiking_difficulty_ = 0u;
    clear_has_has_max_hiking_difficulty();
  }
}
inline ::google::protobuf::uint32 CostingOptions::max_hiking_difficulty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.max_hiking_difficulty)
  if (has_max_hiking_difficulty()) {
    return has_max_hiking_difficulty_.max_hiking_difficulty_;
  }
  return 0u;
}
inline void CostingOptions::set_max_hiking_difficulty(::google::protobuf::uint32 value) {
  if (!has_max_hiking_difficulty()) {
    clear_has_max_hiking_difficulty();
    set_has_max_hiking_difficulty();
  }
  has_max_hiking_difficulty_.max_hiking_difficulty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.max_hiking_difficulty)
}

// optional float mode_factor = 21;
inline bool CostingOptions::has_mode_factor() const {
  return has_mode_factor_case() == kModeFactor;
}
inline void CostingOptions::set_has_mode_factor() {
  _oneof_case_[20] = kModeFactor;
}
inline void CostingOptions::clear_mode_factor() {
  if (has_mode_factor()) {
    has_mode_factor_.mode_factor_ = 0;
    clear_has_has_mode_factor();
  }
}
inline float CostingOptions::mode_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.mode_factor)
  if (has_mode_factor()) {
    return has_mode_factor_.mode_factor_;
  }
  return 0;
}
inline void CostingOptions::set_mode_factor(float value) {
  if (!has_mode_factor()) {
    clear_has_mode_factor();
    set_has_mode_factor();
  }
  has_mode_factor_.mode_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.mode_factor)
}

// optional float walkway_factor = 22;
inline bool CostingOptions::has_walkway_factor() const {
  return has_walkway_factor_case() == kWalkwayFactor;
}
inline void CostingOptions::set_has_walkway_factor() {
  _oneof_case_[21] = kWalkwayFactor;
}
inline void CostingOptions::clear_walkway_factor() {
  if (has_walkway_factor()) {
    has_walkway_factor_.walkway_factor_ = 0;
    clear_has_has_walkway_factor();
  }
}
inline float CostingOptions::walkway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.walkway_factor)
  if (has_walkway_factor()) {
    return has_walkway_factor_.walkway_factor_;
  }
  return 0;
}
inline void CostingOptions::set_walkway_factor(float value) {
  if (!has_walkway_factor()) {
    clear_has_walkway_factor();
    set_has_walkway_factor();
  }
  has_walkway_factor_.walkway_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.walkway_factor)
}

// optional float sidewalk_factor = 23;
inline bool CostingOptions::has_sidewalk_factor() const {
  return has_sidewalk_factor_case() == kSidewalkFactor;
}
inline void CostingOptions::set_has_sidewalk_factor() {
  _oneof_case_[22] = kSidewalkFactor;
}
inline void CostingOptions::clear_sidewalk_factor() {
  if (has_sidewalk_factor()) {
    has_sidewalk_factor_.sidewalk_factor_ = 0;
    clear_has_has_sidewalk_factor();
  }
}
inline float CostingOptions::sidewalk_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.sidewalk_factor)
  if (has_sidewalk_factor()) {
    return has_sidewalk_factor_.sidewalk_factor_;
  }
  return 0;
}
inline void CostingOptions::set_sidewalk_factor(float value) {
  if (!has_sidewalk_factor()) {
    clear_has_sidewalk_factor();
    set_has_sidewalk_factor();
  }
  has_sidewalk_factor_.sidewalk_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.sidewalk_factor)
}

// optional float alley_factor = 24;
inline bool CostingOptions::has_alley_factor() const {
  return has_alley_factor_case() == kAlleyFactor;
}
inline void CostingOptions::set_has_alley_factor() {
  _oneof_case_[23] = kAlleyFactor;
}
inline void CostingOptions::clear_alley_factor() {
  if (has_alley_factor()) {
    has_alley_factor_.alley_factor_ = 0;
    clear_has_has_alley_factor();
  }
}
inline float CostingOptions::alley_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.alley_factor)
  if (has_alley_factor()) {
    return has_alley_factor_.alley_factor_;
  }
  return 0;
}
inline void CostingOptions::set_alley_factor(float value) {
  if (!has_alley_factor()) {
    clear_has_alley_factor();
    set_has_alley_factor();
  }
  has_alley_factor_.alley_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.alley_factor)
}

// optional float driveway_factor = 25;
inline bool CostingOptions::has_driveway_factor() const {
  return has_driveway_factor_case() == kDrivewayFactor;
}
inline void CostingOptions::set_has_driveway_factor() {
  _oneof_case_[24] = kDrivewayFactor;
}
inline void CostingOptions::clear_driveway_factor() {
  if (has_driveway_factor()) {
    has_driveway_factor_.driveway_factor_ = 0;
    clear_has_has_driveway_factor();
  }
}
inline float CostingOptions::driveway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.driveway_factor)
  if (has_driveway_factor()) {
    return has_driveway_factor_.driveway_factor_;
  }
  return 0;
}
inline void CostingOptions::set_driveway_factor(float value) {
  if (!has_driveway_factor()) {
    clear_has_driveway_factor();
    set_has_driveway_factor();
  }
  has_driveway_factor_.driveway_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.driveway_factor)
}

// optional float driveway_penalty = 26;
inline bool CostingOptions::has_driveway_penalty() const {
  return has_driveway_penalty_case() == kDrivewayPenalty;
}
inline void CostingOptions::set_has_driveway_penalty() {
  _oneof_case_[25] = kDrivewayPenalty;
}
inline void CostingOptions::clear_driveway_penalty() {
  if (has_driveway_penalty()) {
    has_driveway_penalty_.driveway_penalty_ = 0;
    clear_has_has_driveway_penalty();
  }
}
inline float CostingOptions::driveway_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.driveway_penalty)
  if (has_driveway_penalty()) {
    return has_driveway_penalty_.driveway_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_driveway_penalty(float value) {
  if (!has_driveway_penalty()) {
    clear_has_driveway_penalty();
    set_has_driveway_penalty();
  }
  has_driveway_penalty_.driveway_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.driveway_penalty)
}

// optional uint32 transit_start_end_max_distance = 27;
inline bool CostingOptions::has_transit_start_end_max_distance() const {
  return has_transit_start_end_max_distance_case() == kTransitStartEndMaxDistance;
}
inline void CostingOptions::set_has_transit_start_end_max_distance() {
  _oneof_case_[26] = kTransitStartEndMaxDistance;
}
inline void CostingOptions::clear_transit_start_end_max_distance() {
  if (has_transit_start_end_max_distance()) {
    has_transit_start_end_max_distance_.transit_start_end_max_distance_ = 0u;
    clear_has_has_transit_start_end_max_distance();
  }
}
inline ::google::protobuf::uint32 CostingOptions::transit_start_end_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transit_start_end_max_distance)
  if (has_transit_start_end_max_distance()) {
    return has_transit_start_end_max_distance_.transit_start_end_max_distance_;
  }
  return 0u;
}
inline void CostingOptions::set_transit_start_end_max_distance(::google::protobuf::uint32 value) {
  if (!has_transit_start_end_max_distance()) {
    clear_has_transit_start_end_max_distance();
    set_has_transit_start_end_max_distance();
  }
  has_transit_start_end_max_distance_.transit_start_end_max_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transit_start_end_max_distance)
}

// optional uint32 transit_transfer_max_distance = 28;
inline bool CostingOptions::has_transit_transfer_max_distance() const {
  return has_transit_transfer_max_distance_case() == kTransitTransferMaxDistance;
}
inline void CostingOptions::set_has_transit_transfer_max_distance() {
  _oneof_case_[27] = kTransitTransferMaxDistance;
}
inline void CostingOptions::clear_transit_transfer_max_distance() {
  if (has_transit_transfer_max_distance()) {
    has_transit_transfer_max_distance_.transit_transfer_max_distance_ = 0u;
    clear_has_has_transit_transfer_max_distance();
  }
}
inline ::google::protobuf::uint32 CostingOptions::transit_transfer_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transit_transfer_max_distance)
  if (has_transit_transfer_max_distance()) {
    return has_transit_transfer_max_distance_.transit_transfer_max_distance_;
  }
  return 0u;
}
inline void CostingOptions::set_transit_transfer_max_distance(::google::protobuf::uint32 value) {
  if (!has_transit_transfer_max_distance()) {
    clear_has_transit_transfer_max_distance();
    set_has_transit_transfer_max_distance();
  }
  has_transit_transfer_max_distance_.transit_transfer_max_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transit_transfer_max_distance)
}

// optional string transport_type = 29;
inline bool CostingOptions::has_transport_type() const {
  return has_transport_type_case() == kTransportType;
}
inline void CostingOptions::set_has_transport_type() {
  _oneof_case_[28] = kTransportType;
}
inline void CostingOptions::clear_transport_type() {
  if (has_transport_type()) {
    has_transport_type_.transport_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_transport_type();
  }
}
inline const ::std::string& CostingOptions::transport_type() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transport_type)
  if (has_transport_type()) {
    return has_transport_type_.transport_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void CostingOptions::set_transport_type(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transport_type)
  if (!has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_transport_type_.transport_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transport_type)
}
inline void CostingOptions::set_transport_type(const char* value) {
  if (!has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_transport_type_.transport_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.transport_type)
}
inline void CostingOptions::set_transport_type(const char* value, size_t size) {
  if (!has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_transport_type_.transport_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.transport_type)
}
inline ::std::string* CostingOptions::mutable_transport_type() {
  if (!has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.transport_type)
  return has_transport_type_.transport_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostingOptions::release_transport_type() {
  // @@protoc_insertion_point(field_release:valhalla.CostingOptions.transport_type)
  if (has_transport_type()) {
    clear_has_has_transport_type();
    return has_transport_type_.transport_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void CostingOptions::set_allocated_transport_type(::std::string* transport_type) {
  if (!has_transport_type()) {
    has_transport_type_.transport_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_transport_type();
  if (transport_type != NULL) {
    set_has_transport_type();
    has_transport_type_.transport_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        transport_type);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.CostingOptions.transport_type)
}

// optional float top_speed = 30;
inline bool CostingOptions::has_top_speed() const {
  return has_top_speed_case() == kTopSpeed;
}
inline void CostingOptions::set_has_top_speed() {
  _oneof_case_[29] = kTopSpeed;
}
inline void CostingOptions::clear_top_speed() {
  if (has_top_speed()) {
    has_top_speed_.top_speed_ = 0;
    clear_has_has_top_speed();
  }
}
inline float CostingOptions::top_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.top_speed)
  if (has_top_speed()) {
    return has_top_speed_.top_speed_;
  }
  return 0;
}
inline void CostingOptions::set_top_speed(float value) {
  if (!has_top_speed()) {
    clear_has_top_speed();
    set_has_top_speed();
  }
  has_top_speed_.top_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.top_speed)
}

// optional float use_hills = 31;
inline bool CostingOptions::has_use_hills() const {
  return has_use_hills_case() == kUseHills;
}
inline void CostingOptions::set_has_use_hills() {
  _oneof_case_[30] = kUseHills;
}
inline void CostingOptions::clear_use_hills() {
  if (has_use_hills()) {
    has_use_hills_.use_hills_ = 0;
    clear_has_has_use_hills();
  }
}
inline float CostingOptions::use_hills() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_hills)
  if (has_use_hills()) {
    return has_use_hills_.use_hills_;
  }
  return 0;
}
inline void CostingOptions::set_use_hills(float value) {
  if (!has_use_hills()) {
    clear_has_use_hills();
    set_has_use_hills();
  }
  has_use_hills_.use_hills_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_hills)
}

// optional float use_primary = 32;
inline bool CostingOptions::has_use_primary() const {
  return has_use_primary_case() == kUsePrimary;
}
inline void CostingOptions::set_has_use_primary() {
  _oneof_case_[31] = kUsePrimary;
}
inline void CostingOptions::clear_use_primary() {
  if (has_use_primary()) {
    has_use_primary_.use_primary_ = 0;
    clear_has_has_use_primary();
  }
}
inline float CostingOptions::use_primary() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_primary)
  if (has_use_primary()) {
    return has_use_primary_.use_primary_;
  }
  return 0;
}
inline void CostingOptions::set_use_primary(float value) {
  if (!has_use_primary()) {
    clear_has_use_primary();
    set_has_use_primary();
  }
  has_use_primary_.use_primary_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_primary)
}

// optional float use_trails = 33;
inline bool CostingOptions::has_use_trails() const {
  return has_use_trails_case() == kUseTrails;
}
inline void CostingOptions::set_has_use_trails() {
  _oneof_case_[32] = kUseTrails;
}
inline void CostingOptions::clear_use_trails() {
  if (has_use_trails()) {
    has_use_trails_.use_trails_ = 0;
    clear_has_has_use_trails();
  }
}
inline float CostingOptions::use_trails() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_trails)
  if (has_use_trails()) {
    return has_use_trails_.use_trails_;
  }
  return 0;
}
inline void CostingOptions::set_use_trails(float value) {
  if (!has_use_trails()) {
    clear_has_use_trails();
    set_has_use_trails();
  }
  has_use_trails_.use_trails_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_trails)
}

// optional float low_class_penalty = 34;
inline bool CostingOptions::has_low_class_penalty() const {
  return has_low_class_penalty_case() == kLowClassPenalty;
}
inline void CostingOptions::set_has_low_class_penalty() {
  _oneof_case_[33] = kLowClassPenalty;
}
inline void CostingOptions::clear_low_class_penalty() {
  if (has_low_class_penalty()) {
    has_low_class_penalty_.low_class_penalty_ = 0;
    clear_has_has_low_class_penalty();
  }
}
inline float CostingOptions::low_class_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.low_class_penalty)
  if (has_low_class_penalty()) {
    return has_low_class_penalty_.low_class_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_low_class_penalty(float value) {
  if (!has_low_class_penalty()) {
    clear_has_low_class_penalty();
    set_has_low_class_penalty();
  }
  has_low_class_penalty_.low_class_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.low_class_penalty)
}

// optional bool hazmat = 35;
inline bool CostingOptions::has_hazmat() const {
  return has_hazmat_case() == kHazmat;
}
inline void CostingOptions::set_has_hazmat() {
  _oneof_case_[34] = kHazmat;
}
inline void CostingOptions::clear_hazmat() {
  if (has_hazmat()) {
    has_hazmat_.hazmat_ = false;
    clear_has_has_hazmat();
  }
}
inline bool CostingOptions::hazmat() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.hazmat)
  if (has_hazmat()) {
    return has_hazmat_.hazmat_;
  }
  return false;
}
inline void CostingOptions::set_hazmat(bool value) {
  if (!has_hazmat()) {
    clear_has_hazmat();
    set_has_hazmat();
  }
  has_hazmat_.hazmat_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.hazmat)
}

// optional float weight = 36;
inline bool CostingOptions::has_weight() const {
  return has_weight_case() == kWeight;
}
inline void CostingOptions::set_has_weight() {
  _oneof_case_[35] = kWeight;
}
inline void CostingOptions::clear_weight() {
  if (has_weight()) {
    has_weight_.weight_ = 0;
    clear_has_has_weight();
  }
}
inline float CostingOptions::weight() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.weight)
  if (has_weight()) {
    return has_weight_.weight_;
  }
  return 0;
}
inline void CostingOptions::set_weight(float value) {
  if (!has_weight()) {
    clear_has_weight();
    set_has_weight();
  }
  has_weight_.weight_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.weight)
}

// optional float axle_load = 37;
inline bool CostingOptions::has_axle_load() const {
  return has_axle_load_case() == kAxleLoad;
}
inline void CostingOptions::set_has_axle_load() {
  _oneof_case_[36] = kAxleLoad;
}
inline void CostingOptions::clear_axle_load() {
  if (has_axle_load()) {
    has_axle_load_.axle_load_ = 0;
    clear_has_has_axle_load();
  }
}
inline float CostingOptions::axle_load() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.axle_load)
  if (has_axle_load()) {
    return has_axle_load_.axle_load_;
  }
  return 0;
}
inline void CostingOptions::set_axle_load(float value) {
  if (!has_axle_load()) {
    clear_has_axle_load();
    set_has_axle_load();
  }
  has_axle_load_.axle_load_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.axle_load)
}

// optional float height = 38;
inline bool CostingOptions::has_height() const {
  return has_height_case() == kHeight;
}
inline void CostingOptions::set_has_height() {
  _oneof_case_[37] = kHeight;
}
inline void CostingOptions::clear_height() {
  if (has_height()) {
    has_height_.height_ = 0;
    clear_has_has_height();
  }
}
inline float CostingOptions::height() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.height)
  if (has_height()) {
    return has_height_.height_;
  }
  return 0;
}
inline void CostingOptions::set_height(float value) {
  if (!has_height()) {
    clear_has_height();
    set_has_height();
  }
  has_height_.height_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.height)
}

// optional float width = 39;
inline bool CostingOptions::has_width() const {
  return has_width_case() == kWidth;
}
inline void CostingOptions::set_has_width() {
  _oneof_case_[38] = kWidth;
}
inline void CostingOptions::clear_width() {
  if (has_width()) {
    has_width_.width_ = 0;
    clear_has_has_width();
  }
}
inline float CostingOptions::width() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.width)
  if (has_width()) {
    return has_width_.width_;
  }
  return 0;
}
inline void CostingOptions::set_width(float value) {
  if (!has_width()) {
    clear_has_width();
    set_has_width();
  }
  has_width_.width_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.width)
}

// optional float length = 40;
inline bool CostingOptions::has_length() const {
  return has_length_case() == kLength;
}
inline void CostingOptions::set_has_length() {
  _oneof_case_[39] = kLength;
}
inline void CostingOptions::clear_length() {
  if (has_length()) {
    has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float CostingOptions::length() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.length)
  if (has_length()) {
    return has_length_.length_;
  }
  return 0;
}
inline void CostingOptions::set_length(float value) {
  if (!has_length()) {
    clear_has_length();
    set_has_length();
  }
  has_length_.length_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.length)
}

// optional float cycling_speed = 41;
inline bool CostingOptions::has_cycling_speed() const {
  return has_cycling_speed_case() == kCyclingSpeed;
}
inline void CostingOptions::set_has_cycling_speed() {
  _oneof_case_[40] = kCyclingSpeed;
}
inline void CostingOptions::clear_cycling_speed() {
  if (has_cycling_speed()) {
    has_cycling_speed_.cycling_speed_ = 0;
    clear_has_has_cycling_speed();
  }
}
inline float CostingOptions::cycling_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.cycling_speed)
  if (has_cycling_speed()) {
    return has_cycling_speed_.cycling_speed_;
  }
  return 0;
}
inline void CostingOptions::set_cycling_speed(float value) {
  if (!has_cycling_speed()) {
    clear_has_cycling_speed();
    set_has_cycling_speed();
  }
  has_cycling_speed_.cycling_speed_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.cycling_speed)
}

// optional bool wheelchair = 42;
inline bool CostingOptions::has_wheelchair() const {
  return has_wheelchair_case() == kWheelchair;
}
inline void CostingOptions::set_has_wheelchair() {
  _oneof_case_[41] = kWheelchair;
}
inline void CostingOptions::clear_wheelchair() {
  if (has_wheelchair()) {
    has_wheelchair_.wheelchair_ = false;
    clear_has_has_wheelchair();
  }
}
inline bool CostingOptions::wheelchair() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.wheelchair)
  if (has_wheelchair()) {
    return has_wheelchair_.wheelchair_;
  }
  return false;
}
inline void CostingOptions::set_wheelchair(bool value) {
  if (!has_wheelchair()) {
    clear_has_wheelchair();
    set_has_wheelchair();
  }
  has_wheelchair_.wheelchair_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.wheelchair)
}

// optional bool bicycle = 43;
inline bool CostingOptions::has_bicycle() const {
  return has_bicycle_case() == kBicycle;
}
inline void CostingOptions::set_has_bicycle() {
  _oneof_case_[42] = kBicycle;
}
inline void CostingOptions::clear_bicycle() {
  if (has_bicycle()) {
    has_bicycle_.bicycle_ = false;
    clear_has_has_bicycle();
  }
}
inline bool CostingOptions::bicycle() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.bicycle)
  if (has_bicycle()) {
    return has_bicycle_.bicycle_;
  }
  return false;
}
inline void CostingOptions::set_bicycle(bool value) {
  if (!has_bicycle()) {
    clear_has_bicycle();
    set_has_bicycle();
  }
  has_bicycle_.bicycle_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.bicycle)
}

// optional float use_bus = 44;
inline bool CostingOptions::has_use_bus() const {
  return has_use_bus_case() == kUseBus;
}
inline void CostingOptions::set_has_use_bus() {
  _oneof_case_[43] = kUseBus;
}
inline void CostingOptions::clear_use_bus() {
  if (has_use_bus()) {
    has_use_bus_.use_bus_ = 0;
    clear_has_has_use_bus();
  }
}
inline float CostingOptions::use_bus() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_bus)
  if (has_use_bus()) {
    return has_use_bus_.use_bus_;
  }
  return 0;
}
inline void CostingOptions::set_use_bus(float value) {
  if (!has_use_bus()) {
    clear_has_use_bus();
    set_has_use_bus();
  }
  has_use_bus_.use_bus_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_bus)
}

// optional float use_rail = 45;
inline bool CostingOptions::has_use_rail() const {
  return has_use_rail_case() == kUseRail;
}
inline void CostingOptions::set_has_use_rail() {
  _oneof_case_[44] = kUseRail;
}
inline void CostingOptions::clear_use_rail() {
  if (has_use_rail()) {
    has_use_rail_.use_rail_ = 0;
    clear_has_has_use_rail();
  }
}
inline float CostingOptions::use_rail() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_rail)
  if (has_use_rail()) {
    return has_use_rail_.use_rail_;
  }
  return 0;
}
inline void CostingOptions::set_use_rail(float value) {
  if (!has_use_rail()) {
    clear_has_use_rail();
    set_has_use_rail();
  }
  has_use_rail_.use_rail_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_rail)
}

// optional float use_transfers = 46;
inline bool CostingOptions::has_use_transfers() const {
  return has_use_transfers_case() == kUseTransfers;
}
inline void CostingOptions::set_has_use_transfers() {
  _oneof_case_[45] = kUseTransfers;
}
inline void CostingOptions::clear_use_transfers() {
  if (has_use_transfers()) {
    has_use_transfers_.use_transfers_ = 0;
    clear_has_has_use_transfers();
  }
}
inline float CostingOptions::use_transfers() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_transfers)
  if (has_use_transfers()) {
    return has_use_transfers_.use_transfers_;
  }
  return 0;
}
inline void CostingOptions::set_use_transfers(float value) {
  if (!has_use_transfers()) {
    clear_has_use_transfers();
    set_has_use_transfers();
  }
  has_use_transfers_.use_transfers_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_transfers)
}

// optional float transfer_cost = 47;
inline bool CostingOptions::has_transfer_cost() const {
  return has_transfer_cost_case() == kTransferCost;
}
inline void CostingOptions::set_has_transfer_cost() {
  _oneof_case_[46] = kTransferCost;
}
inline void CostingOptions::clear_transfer_cost() {
  if (has_transfer_cost()) {
    has_transfer_cost_.transfer_cost_ = 0;
    clear_has_has_transfer_cost();
  }
}
inline float CostingOptions::transfer_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transfer_cost)
  if (has_transfer_cost()) {
    return has_transfer_cost_.transfer_cost_;
  }
  return 0;
}
inline void CostingOptions::set_transfer_cost(float value) {
  if (!has_transfer_cost()) {
    clear_has_transfer_cost();
    set_has_transfer_cost();
  }
  has_transfer_cost_.transfer_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transfer_cost)
}

// optional float transfer_penalty = 48;
inline bool CostingOptions::has_transfer_penalty() const {
  return has_transfer_penalty_case() == kTransferPenalty;
}
inline void CostingOptions::set_has_transfer_penalty() {
  _oneof_case_[47] = kTransferPenalty;
}
inline void CostingOptions::clear_transfer_penalty() {
  if (has_transfer_penalty()) {
    has_transfer_penalty_.transfer_penalty_ = 0;
    clear_has_has_transfer_penalty();
  }
}
inline float CostingOptions::transfer_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transfer_penalty)
  if (has_transfer_penalty()) {
    return has_transfer_penalty_.transfer_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_transfer_penalty(float value) {
  if (!has_transfer_penalty()) {
    clear_has_transfer_penalty();
    set_has_transfer_penalty();
  }
  has_transfer_penalty_.transfer_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transfer_penalty)
}

// optional .valhalla.FilterAction filter_stop_action = 49;
inline void CostingOptions::clear_filter_stop_action() {
  filter_stop_action_ = 0;
}
inline ::valhalla::FilterAction CostingOptions::filter_stop_action() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_stop_action)
  return static_cast< ::valhalla::FilterAction >(filter_stop_action_);
}
inline void CostingOptions::set_filter_stop_action(::valhalla::FilterAction value) {
  
  filter_stop_action_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_stop_action)
}

// repeated string filter_stop_ids = 50;
inline int CostingOptions::filter_stop_ids_size() const {
  return filter_stop_ids_.size();
}
inline void CostingOptions::clear_filter_stop_ids() {
  filter_stop_ids_.Clear();
}
inline const ::std::string& CostingOptions::filter_stop_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_stop_ids)
  return filter_stop_ids_.Get(index);
}
inline ::std::string* CostingOptions::mutable_filter_stop_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.filter_stop_ids)
  return filter_stop_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_stop_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_stop_ids)
  filter_stop_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_stop_ids(int index, const char* value) {
  filter_stop_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::set_filter_stop_ids(int index, const char* value, size_t size) {
  filter_stop_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.filter_stop_ids)
}
inline ::std::string* CostingOptions::add_filter_stop_ids() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.CostingOptions.filter_stop_ids)
  return filter_stop_ids_.Add();
}
inline void CostingOptions::add_filter_stop_ids(const ::std::string& value) {
  filter_stop_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::add_filter_stop_ids(const char* value) {
  filter_stop_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::add_filter_stop_ids(const char* value, size_t size) {
  filter_stop_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.CostingOptions.filter_stop_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostingOptions::filter_stop_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.filter_stop_ids)
  return filter_stop_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostingOptions::mutable_filter_stop_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.filter_stop_ids)
  return &filter_stop_ids_;
}

// optional .valhalla.FilterAction filter_operator_action = 51;
inline void CostingOptions::clear_filter_operator_action() {
  filter_operator_action_ = 0;
}
inline ::valhalla::FilterAction CostingOptions::filter_operator_action() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_operator_action)
  return static_cast< ::valhalla::FilterAction >(filter_operator_action_);
}
inline void CostingOptions::set_filter_operator_action(::valhalla::FilterAction value) {
  
  filter_operator_action_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_operator_action)
}

// repeated string filter_operator_ids = 52;
inline int CostingOptions::filter_operator_ids_size() const {
  return filter_operator_ids_.size();
}
inline void CostingOptions::clear_filter_operator_ids() {
  filter_operator_ids_.Clear();
}
inline const ::std::string& CostingOptions::filter_operator_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_operator_ids)
  return filter_operator_ids_.Get(index);
}
inline ::std::string* CostingOptions::mutable_filter_operator_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.filter_operator_ids)
  return filter_operator_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_operator_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_operator_ids)
  filter_operator_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_operator_ids(int index, const char* value) {
  filter_operator_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::set_filter_operator_ids(int index, const char* value, size_t size) {
  filter_operator_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.filter_operator_ids)
}
inline ::std::string* CostingOptions::add_filter_operator_ids() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.CostingOptions.filter_operator_ids)
  return filter_operator_ids_.Add();
}
inline void CostingOptions::add_filter_operator_ids(const ::std::string& value) {
  filter_operator_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::add_filter_operator_ids(const char* value) {
  filter_operator_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::add_filter_operator_ids(const char* value, size_t size) {
  filter_operator_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.CostingOptions.filter_operator_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostingOptions::filter_operator_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.filter_operator_ids)
  return filter_operator_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostingOptions::mutable_filter_operator_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.filter_operator_ids)
  return &filter_operator_ids_;
}

// optional .valhalla.FilterAction filter_route_action = 53;
inline void CostingOptions::clear_filter_route_action() {
  filter_route_action_ = 0;
}
inline ::valhalla::FilterAction CostingOptions::filter_route_action() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_route_action)
  return static_cast< ::valhalla::FilterAction >(filter_route_action_);
}
inline void CostingOptions::set_filter_route_action(::valhalla::FilterAction value) {
  
  filter_route_action_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_route_action)
}

// repeated string filter_route_ids = 54;
inline int CostingOptions::filter_route_ids_size() const {
  return filter_route_ids_.size();
}
inline void CostingOptions::clear_filter_route_ids() {
  filter_route_ids_.Clear();
}
inline const ::std::string& CostingOptions::filter_route_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_route_ids)
  return filter_route_ids_.Get(index);
}
inline ::std::string* CostingOptions::mutable_filter_route_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.filter_route_ids)
  return filter_route_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_route_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_route_ids)
  filter_route_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_route_ids(int index, const char* value) {
  filter_route_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::set_filter_route_ids(int index, const char* value, size_t size) {
  filter_route_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.filter_route_ids)
}
inline ::std::string* CostingOptions::add_filter_route_ids() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.CostingOptions.filter_route_ids)
  return filter_route_ids_.Add();
}
inline void CostingOptions::add_filter_route_ids(const ::std::string& value) {
  filter_route_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::add_filter_route_ids(const char* value) {
  filter_route_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::add_filter_route_ids(const char* value, size_t size) {
  filter_route_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.CostingOptions.filter_route_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostingOptions::filter_route_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.filter_route_ids)
  return filter_route_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostingOptions::mutable_filter_route_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.filter_route_ids)
  return &filter_route_ids_;
}

// optional uint32 flow_mask = 55;
inline bool CostingOptions::has_flow_mask() const {
  return has_flow_mask_case() == kFlowMask;
}
inline void CostingOptions::set_has_flow_mask() {
  _oneof_case_[48] = kFlowMask;
}
inline void CostingOptions::clear_flow_mask() {
  if (has_flow_mask()) {
    has_flow_mask_.flow_mask_ = 0u;
    clear_has_has_flow_mask();
  }
}
inline ::google::protobuf::uint32 CostingOptions::flow_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.flow_mask)
  if (has_flow_mask()) {
    return has_flow_mask_.flow_mask_;
  }
  return 0u;
}
inline void CostingOptions::set_flow_mask(::google::protobuf::uint32 value) {
  if (!has_flow_mask()) {
    clear_has_flow_mask();
    set_has_flow_mask();
  }
  has_flow_mask_.flow_mask_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.flow_mask)
}

// optional float bike_share_cost = 56;
inline bool CostingOptions::has_bike_share_cost() const {
  return has_bike_share_cost_case() == kBikeShareCost;
}
inline void CostingOptions::set_has_bike_share_cost() {
  _oneof_case_[49] = kBikeShareCost;
}
inline void CostingOptions::clear_bike_share_cost() {
  if (has_bike_share_cost()) {
    has_bike_share_cost_.bike_share_cost_ = 0;
    clear_has_has_bike_share_cost();
  }
}
inline float CostingOptions::bike_share_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.bike_share_cost)
  if (has_bike_share_cost()) {
    return has_bike_share_cost_.bike_share_cost_;
  }
  return 0;
}
inline void CostingOptions::set_bike_share_cost(float value) {
  if (!has_bike_share_cost()) {
    clear_has_bike_share_cost();
    set_has_bike_share_cost();
  }
  has_bike_share_cost_.bike_share_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.bike_share_cost)
}

// optional float bike_share_penalty = 57;
inline bool CostingOptions::has_bike_share_penalty() const {
  return has_bike_share_penalty_case() == kBikeSharePenalty;
}
inline void CostingOptions::set_has_bike_share_penalty() {
  _oneof_case_[50] = kBikeSharePenalty;
}
inline void CostingOptions::clear_bike_share_penalty() {
  if (has_bike_share_penalty()) {
    has_bike_share_penalty_.bike_share_penalty_ = 0;
    clear_has_has_bike_share_penalty();
  }
}
inline float CostingOptions::bike_share_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.bike_share_penalty)
  if (has_bike_share_penalty()) {
    return has_bike_share_penalty_.bike_share_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_bike_share_penalty(float value) {
  if (!has_bike_share_penalty()) {
    clear_has_bike_share_penalty();
    set_has_bike_share_penalty();
  }
  has_bike_share_penalty_.bike_share_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.bike_share_penalty)
}

// optional float rail_ferry_cost = 58;
inline bool CostingOptions::has_rail_ferry_cost() const {
  return has_rail_ferry_cost_case() == kRailFerryCost;
}
inline void CostingOptions::set_has_rail_ferry_cost() {
  _oneof_case_[51] = kRailFerryCost;
}
inline void CostingOptions::clear_rail_ferry_cost() {
  if (has_rail_ferry_cost()) {
    has_rail_ferry_cost_.rail_ferry_cost_ = 0;
    clear_has_has_rail_ferry_cost();
  }
}
inline float CostingOptions::rail_ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.rail_ferry_cost)
  if (has_rail_ferry_cost()) {
    return has_rail_ferry_cost_.rail_ferry_cost_;
  }
  return 0;
}
inline void CostingOptions::set_rail_ferry_cost(float value) {
  if (!has_rail_ferry_cost()) {
    clear_has_rail_ferry_cost();
    set_has_rail_ferry_cost();
  }
  has_rail_ferry_cost_.rail_ferry_cost_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.rail_ferry_cost)
}

// optional float use_rail_ferry = 59;
inline bool CostingOptions::has_use_rail_ferry() const {
  return has_use_rail_ferry_case() == kUseRailFerry;
}
inline void CostingOptions::set_has_use_rail_ferry() {
  _oneof_case_[52] = kUseRailFerry;
}
inline void CostingOptions::clear_use_rail_ferry() {
  if (has_use_rail_ferry()) {
    has_use_rail_ferry_.use_rail_ferry_ = 0;
    clear_has_has_use_rail_ferry();
  }
}
inline float CostingOptions::use_rail_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_rail_ferry)
  if (has_use_rail_ferry()) {
    return has_use_rail_ferry_.use_rail_ferry_;
  }
  return 0;
}
inline void CostingOptions::set_use_rail_ferry(float value) {
  if (!has_use_rail_ferry()) {
    clear_has_use_rail_ferry();
    set_has_use_rail_ferry();
  }
  has_use_rail_ferry_.use_rail_ferry_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_rail_ferry)
}

// optional bool ignore_restrictions = 60;
inline bool CostingOptions::has_ignore_restrictions() const {
  return has_ignore_restrictions_case() == kIgnoreRestrictions;
}
inline void CostingOptions::set_has_ignore_restrictions() {
  _oneof_case_[53] = kIgnoreRestrictions;
}
inline void CostingOptions::clear_ignore_restrictions() {
  if (has_ignore_restrictions()) {
    has_ignore_restrictions_.ignore_restrictions_ = false;
    clear_has_has_ignore_restrictions();
  }
}
inline bool CostingOptions::ignore_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_restrictions)
  if (has_ignore_restrictions()) {
    return has_ignore_restrictions_.ignore_restrictions_;
  }
  return false;
}
inline void CostingOptions::set_ignore_restrictions(bool value) {
  if (!has_ignore_restrictions()) {
    clear_has_ignore_restrictions();
    set_has_ignore_restrictions();
  }
  has_ignore_restrictions_.ignore_restrictions_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_restrictions)
}

// optional bool ignore_oneways = 61;
inline bool CostingOptions::has_ignore_oneways() const {
  return has_ignore_oneways_case() == kIgnoreOneways;
}
inline void CostingOptions::set_has_ignore_oneways() {
  _oneof_case_[54] = kIgnoreOneways;
}
inline void CostingOptions::clear_ignore_oneways() {
  if (has_ignore_oneways()) {
    has_ignore_oneways_.ignore_oneways_ = false;
    clear_has_has_ignore_oneways();
  }
}
inline bool CostingOptions::ignore_oneways() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_oneways)
  if (has_ignore_oneways()) {
    return has_ignore_oneways_.ignore_oneways_;
  }
  return false;
}
inline void CostingOptions::set_ignore_oneways(bool value) {
  if (!has_ignore_oneways()) {
    clear_has_ignore_oneways();
    set_has_ignore_oneways();
  }
  has_ignore_oneways_.ignore_oneways_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_oneways)
}

// optional bool ignore_access = 62;
inline bool CostingOptions::has_ignore_access() const {
  return has_ignore_access_case() == kIgnoreAccess;
}
inline void CostingOptions::set_has_ignore_access() {
  _oneof_case_[55] = kIgnoreAccess;
}
inline void CostingOptions::clear_ignore_access() {
  if (has_ignore_access()) {
    has_ignore_access_.ignore_access_ = false;
    clear_has_has_ignore_access();
  }
}
inline bool CostingOptions::ignore_access() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_access)
  if (has_ignore_access()) {
    return has_ignore_access_.ignore_access_;
  }
  return false;
}
inline void CostingOptions::set_ignore_access(bool value) {
  if (!has_ignore_access()) {
    clear_has_ignore_access();
    set_has_ignore_access();
  }
  has_ignore_access_.ignore_access_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_access)
}

// optional bool ignore_closures = 63;
inline bool CostingOptions::has_ignore_closures() const {
  return has_ignore_closures_case() == kIgnoreClosures;
}
inline void CostingOptions::set_has_ignore_closures() {
  _oneof_case_[56] = kIgnoreClosures;
}
inline void CostingOptions::clear_ignore_closures() {
  if (has_ignore_closures()) {
    has_ignore_closures_.ignore_closures_ = false;
    clear_has_has_ignore_closures();
  }
}
inline bool CostingOptions::ignore_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_closures)
  if (has_ignore_closures()) {
    return has_ignore_closures_.ignore_closures_;
  }
  return false;
}
inline void CostingOptions::set_ignore_closures(bool value) {
  if (!has_ignore_closures()) {
    clear_has_ignore_closures();
    set_has_ignore_closures();
  }
  has_ignore_closures_.ignore_closures_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_closures)
}

// optional bool shortest = 64;
inline bool CostingOptions::has_shortest() const {
  return has_shortest_case() == kShortest;
}
inline void CostingOptions::set_has_shortest() {
  _oneof_case_[57] = kShortest;
}
inline void CostingOptions::clear_shortest() {
  if (has_shortest()) {
    has_shortest_.shortest_ = false;
    clear_has_has_shortest();
  }
}
inline bool CostingOptions::shortest() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.shortest)
  if (has_shortest()) {
    return has_shortest_.shortest_;
  }
  return false;
}
inline void CostingOptions::set_shortest(bool value) {
  if (!has_shortest()) {
    clear_has_shortest();
    set_has_shortest();
  }
  has_shortest_.shortest_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.shortest)
}

// optional float service_penalty = 65;
inline bool CostingOptions::has_service_penalty() const {
  return has_service_penalty_case() == kServicePenalty;
}
inline void CostingOptions::set_has_service_penalty() {
  _oneof_case_[58] = kServicePenalty;
}
inline void CostingOptions::clear_service_penalty() {
  if (has_service_penalty()) {
    has_service_penalty_.service_penalty_ = 0;
    clear_has_has_service_penalty();
  }
}
inline float CostingOptions::service_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.service_penalty)
  if (has_service_penalty()) {
    return has_service_penalty_.service_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_service_penalty(float value) {
  if (!has_service_penalty()) {
    clear_has_service_penalty();
    set_has_service_penalty();
  }
  has_service_penalty_.service_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.service_penalty)
}

// optional float use_tracks = 66;
inline bool CostingOptions::has_use_tracks() const {
  return has_use_tracks_case() == kUseTracks;
}
inline void CostingOptions::set_has_use_tracks() {
  _oneof_case_[59] = kUseTracks;
}
inline void CostingOptions::clear_use_tracks() {
  if (has_use_tracks()) {
    has_use_tracks_.use_tracks_ = 0;
    clear_has_has_use_tracks();
  }
}
inline float CostingOptions::use_tracks() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_tracks)
  if (has_use_tracks()) {
    return has_use_tracks_.use_tracks_;
  }
  return 0;
}
inline void CostingOptions::set_use_tracks(float value) {
  if (!has_use_tracks()) {
    clear_has_use_tracks();
    set_has_use_tracks();
  }
  has_use_tracks_.use_tracks_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_tracks)
}

// optional float use_distance = 67;
inline bool CostingOptions::has_use_distance() const {
  return has_use_distance_case() == kUseDistance;
}
inline void CostingOptions::set_has_use_distance() {
  _oneof_case_[60] = kUseDistance;
}
inline void CostingOptions::clear_use_distance() {
  if (has_use_distance()) {
    has_use_distance_.use_distance_ = 0;
    clear_has_has_use_distance();
  }
}
inline float CostingOptions::use_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_distance)
  if (has_use_distance()) {
    return has_use_distance_.use_distance_;
  }
  return 0;
}
inline void CostingOptions::set_use_distance(float value) {
  if (!has_use_distance()) {
    clear_has_use_distance();
    set_has_use_distance();
  }
  has_use_distance_.use_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_distance)
}

// optional float use_living_streets = 68;
inline bool CostingOptions::has_use_living_streets() const {
  return has_use_living_streets_case() == kUseLivingStreets;
}
inline void CostingOptions::set_has_use_living_streets() {
  _oneof_case_[61] = kUseLivingStreets;
}
inline void CostingOptions::clear_use_living_streets() {
  if (has_use_living_streets()) {
    has_use_living_streets_.use_living_streets_ = 0;
    clear_has_has_use_living_streets();
  }
}
inline float CostingOptions::use_living_streets() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_living_streets)
  if (has_use_living_streets()) {
    return has_use_living_streets_.use_living_streets_;
  }
  return 0;
}
inline void CostingOptions::set_use_living_streets(float value) {
  if (!has_use_living_streets()) {
    clear_has_use_living_streets();
    set_has_use_living_streets();
  }
  has_use_living_streets_.use_living_streets_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_living_streets)
}

// optional float service_factor = 69;
inline bool CostingOptions::has_service_factor() const {
  return has_service_factor_case() == kServiceFactor;
}
inline void CostingOptions::set_has_service_factor() {
  _oneof_case_[62] = kServiceFactor;
}
inline void CostingOptions::clear_service_factor() {
  if (has_service_factor()) {
    has_service_factor_.service_factor_ = 0;
    clear_has_has_service_factor();
  }
}
inline float CostingOptions::service_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.service_factor)
  if (has_service_factor()) {
    return has_service_factor_.service_factor_;
  }
  return 0;
}
inline void CostingOptions::set_service_factor(float value) {
  if (!has_service_factor()) {
    clear_has_service_factor();
    set_has_service_factor();
  }
  has_service_factor_.service_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.service_factor)
}

// optional float closure_factor = 70;
inline bool CostingOptions::has_closure_factor() const {
  return has_closure_factor_case() == kClosureFactor;
}
inline void CostingOptions::set_has_closure_factor() {
  _oneof_case_[63] = kClosureFactor;
}
inline void CostingOptions::clear_closure_factor() {
  if (has_closure_factor()) {
    has_closure_factor_.closure_factor_ = 0;
    clear_has_has_closure_factor();
  }
}
inline float CostingOptions::closure_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.closure_factor)
  if (has_closure_factor()) {
    return has_closure_factor_.closure_factor_;
  }
  return 0;
}
inline void CostingOptions::set_closure_factor(float value) {
  if (!has_closure_factor()) {
    clear_has_closure_factor();
    set_has_closure_factor();
  }
  has_closure_factor_.closure_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.closure_factor)
}

// optional float private_access_penalty = 71;
inline bool CostingOptions::has_private_access_penalty() const {
  return has_private_access_penalty_case() == kPrivateAccessPenalty;
}
inline void CostingOptions::set_has_private_access_penalty() {
  _oneof_case_[64] = kPrivateAccessPenalty;
}
inline void CostingOptions::clear_private_access_penalty() {
  if (has_private_access_penalty()) {
    has_private_access_penalty_.private_access_penalty_ = 0;
    clear_has_has_private_access_penalty();
  }
}
inline float CostingOptions::private_access_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.private_access_penalty)
  if (has_private_access_penalty()) {
    return has_private_access_penalty_.private_access_penalty_;
  }
  return 0;
}
inline void CostingOptions::set_private_access_penalty(float value) {
  if (!has_private_access_penalty()) {
    clear_has_private_access_penalty();
    set_has_private_access_penalty();
  }
  has_private_access_penalty_.private_access_penalty_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.private_access_penalty)
}

// optional bool exclude_unpaved = 72;
inline bool CostingOptions::has_exclude_unpaved() const {
  return has_exclude_unpaved_case() == kExcludeUnpaved;
}
inline void CostingOptions::set_has_exclude_unpaved() {
  _oneof_case_[65] = kExcludeUnpaved;
}
inline void CostingOptions::clear_exclude_unpaved() {
  if (has_exclude_unpaved()) {
    has_exclude_unpaved_.exclude_unpaved_ = false;
    clear_has_has_exclude_unpaved();
  }
}
inline bool CostingOptions::exclude_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.exclude_unpaved)
  if (has_exclude_unpaved()) {
    return has_exclude_unpaved_.exclude_unpaved_;
  }
  return false;
}
inline void CostingOptions::set_exclude_unpaved(bool value) {
  if (!has_exclude_unpaved()) {
    clear_has_exclude_unpaved();
    set_has_exclude_unpaved();
  }
  has_exclude_unpaved_.exclude_unpaved_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.exclude_unpaved)
}

// optional bool include_hot = 73;
inline bool CostingOptions::has_include_hot() const {
  return has_include_hot_case() == kIncludeHot;
}
inline void CostingOptions::set_has_include_hot() {
  _oneof_case_[66] = kIncludeHot;
}
inline void CostingOptions::clear_include_hot() {
  if (has_include_hot()) {
    has_include_hot_.include_hot_ = false;
    clear_has_has_include_hot();
  }
}
inline bool CostingOptions::include_hot() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.include_hot)
  if (has_include_hot()) {
    return has_include_hot_.include_hot_;
  }
  return false;
}
inline void CostingOptions::set_include_hot(bool value) {
  if (!has_include_hot()) {
    clear_has_include_hot();
    set_has_include_hot();
  }
  has_include_hot_.include_hot_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.include_hot)
}

// optional bool include_hov2 = 74;
inline bool CostingOptions::has_include_hov2() const {
  return has_include_hov2_case() == kIncludeHov2;
}
inline void CostingOptions::set_has_include_hov2() {
  _oneof_case_[67] = kIncludeHov2;
}
inline void CostingOptions::clear_include_hov2() {
  if (has_include_hov2()) {
    has_include_hov2_.include_hov2_ = false;
    clear_has_has_include_hov2();
  }
}
inline bool CostingOptions::include_hov2() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.include_hov2)
  if (has_include_hov2()) {
    return has_include_hov2_.include_hov2_;
  }
  return false;
}
inline void CostingOptions::set_include_hov2(bool value) {
  if (!has_include_hov2()) {
    clear_has_include_hov2();
    set_has_include_hov2();
  }
  has_include_hov2_.include_hov2_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.include_hov2)
}

// optional bool include_hov3 = 75;
inline bool CostingOptions::has_include_hov3() const {
  return has_include_hov3_case() == kIncludeHov3;
}
inline void CostingOptions::set_has_include_hov3() {
  _oneof_case_[68] = kIncludeHov3;
}
inline void CostingOptions::clear_include_hov3() {
  if (has_include_hov3()) {
    has_include_hov3_.include_hov3_ = false;
    clear_has_has_include_hov3();
  }
}
inline bool CostingOptions::include_hov3() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.include_hov3)
  if (has_include_hov3()) {
    return has_include_hov3_.include_hov3_;
  }
  return false;
}
inline void CostingOptions::set_include_hov3(bool value) {
  if (!has_include_hov3()) {
    clear_has_include_hov3();
    set_has_include_hov3();
  }
  has_include_hov3_.include_hov3_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.include_hov3)
}

// optional bool exclude_cash_only_tolls = 76;
inline bool CostingOptions::has_exclude_cash_only_tolls() const {
  return has_exclude_cash_only_tolls_case() == kExcludeCashOnlyTolls;
}
inline void CostingOptions::set_has_exclude_cash_only_tolls() {
  _oneof_case_[69] = kExcludeCashOnlyTolls;
}
inline void CostingOptions::clear_exclude_cash_only_tolls() {
  if (has_exclude_cash_only_tolls()) {
    has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = false;
    clear_has_has_exclude_cash_only_tolls();
  }
}
inline bool CostingOptions::exclude_cash_only_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.exclude_cash_only_tolls)
  if (has_exclude_cash_only_tolls()) {
    return has_exclude_cash_only_tolls_.exclude_cash_only_tolls_;
  }
  return false;
}
inline void CostingOptions::set_exclude_cash_only_tolls(bool value) {
  if (!has_exclude_cash_only_tolls()) {
    clear_has_exclude_cash_only_tolls();
    set_has_exclude_cash_only_tolls();
  }
  has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.exclude_cash_only_tolls)
}

// optional uint32 restriction_probability = 77;
inline bool CostingOptions::has_restriction_probability() const {
  return has_restriction_probability_case() == kRestrictionProbability;
}
inline void CostingOptions::set_has_restriction_probability() {
  _oneof_case_[70] = kRestrictionProbability;
}
inline void CostingOptions::clear_restriction_probability() {
  if (has_restriction_probability()) {
    has_restriction_probability_.restriction_probability_ = 0u;
    clear_has_has_restriction_probability();
  }
}
inline ::google::protobuf::uint32 CostingOptions::restriction_probability() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.restriction_probability)
  if (has_restriction_probability()) {
    return has_restriction_probability_.restriction_probability_;
  }
  return 0u;
}
inline void CostingOptions::set_restriction_probability(::google::protobuf::uint32 value) {
  if (!has_restriction_probability()) {
    clear_has_restriction_probability();
    set_has_restriction_probability();
  }
  has_restriction_probability_.restriction_probability_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.restriction_probability)
}

// optional .valhalla.Costing costing = 90;
inline bool CostingOptions::has_costing() const {
  return has_costing_case() == kCosting;
}
inline void CostingOptions::set_has_costing() {
  _oneof_case_[71] = kCosting;
}
inline void CostingOptions::clear_costing() {
  if (has_costing()) {
    has_costing_.costing_ = 0;
    clear_has_has_costing();
  }
}
inline ::valhalla::Costing CostingOptions::costing() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.costing)
  if (has_costing()) {
    return static_cast< ::valhalla::Costing >(has_costing_.costing_);
  }
  return static_cast< ::valhalla::Costing >(0);
}
inline void CostingOptions::set_costing(::valhalla::Costing value) {
  if (!has_costing()) {
    clear_has_costing();
    set_has_costing();
  }
  has_costing_.costing_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.costing)
}

// optional string name = 91;
inline bool CostingOptions::has_name() const {
  return has_name_case() == kName;
}
inline void CostingOptions::set_has_name() {
  _oneof_case_[72] = kName;
}
inline void CostingOptions::clear_name() {
  if (has_name()) {
    has_name_.name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_name();
  }
}
inline const ::std::string& CostingOptions::name() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.name)
  if (has_name()) {
    return has_name_.name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void CostingOptions::set_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.name)
  if (!has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_name_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.name)
}
inline void CostingOptions::set_name(const char* value) {
  if (!has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_name_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.name)
}
inline void CostingOptions::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_name_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.name)
}
inline ::std::string* CostingOptions::mutable_name() {
  if (!has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.name)
  return has_name_.name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CostingOptions::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.CostingOptions.name)
  if (has_name()) {
    clear_has_has_name();
    return has_name_.name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void CostingOptions::set_allocated_name(::std::string* name) {
  if (!has_name()) {
    has_name_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_name();
  if (name != NULL) {
    set_has_name();
    has_name_.name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        name);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.CostingOptions.name)
}

// repeated .valhalla.AvoidEdge exclude_edges = 92;
inline int CostingOptions::exclude_edges_size() const {
  return exclude_edges_.size();
}
inline void CostingOptions::clear_exclude_edges() {
  exclude_edges_.Clear();
}
inline const ::valhalla::AvoidEdge& CostingOptions::exclude_edges(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.exclude_edges)
  return exclude_edges_.Get(index);
}
inline ::valhalla::AvoidEdge* CostingOptions::mutable_exclude_edges(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.exclude_edges)
  return exclude_edges_.Mutable(index);
}
inline ::valhalla::AvoidEdge* CostingOptions::add_exclude_edges() {
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.exclude_edges)
  return exclude_edges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >*
CostingOptions::mutable_exclude_edges() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.exclude_edges)
  return &exclude_edges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >&
CostingOptions::exclude_edges() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.exclude_edges)
  return exclude_edges_;
}

// optional bool filter_closures = 93;
inline bool CostingOptions::has_filter_closures() const {
  return has_filter_closures_case() == kFilterClosures;
}
inline void CostingOptions::set_has_filter_closures() {
  _oneof_case_[73] = kFilterClosures;
}
inline void CostingOptions::clear_filter_closures() {
  if (has_filter_closures()) {
    has_filter_closures_.filter_closures_ = false;
    clear_has_has_filter_closures();
  }
}
inline bool CostingOptions::filter_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_closures)
  if (has_filter_closures()) {
    return has_filter_closures_.filter_closures_;
  }
  return false;
}
inline void CostingOptions::set_filter_closures(bool value) {
  if (!has_filter_closures()) {
    clear_has_filter_closures();
    set_has_filter_closures();
  }
  has_filter_closures_.filter_closures_ = value;
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_closures)
}

inline bool CostingOptions::has_has_maneuver_penalty() const {
  return has_maneuver_penalty_case() != HAS_MANEUVER_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_maneuver_penalty() {
  _oneof_case_[0] = HAS_MANEUVER_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_destination_only_penalty() const {
  return has_destination_only_penalty_case() != HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_destination_only_penalty() {
  _oneof_case_[1] = HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_gate_cost() const {
  return has_gate_cost_case() != HAS_GATE_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_gate_cost() {
  _oneof_case_[2] = HAS_GATE_COST_NOT_SET;
}
inline bool CostingOptions::has_has_gate_penalty() const {
  return has_gate_penalty_case() != HAS_GATE_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_gate_penalty() {
  _oneof_case_[3] = HAS_GATE_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_toll_booth_cost() const {
  return has_toll_booth_cost_case() != HAS_TOLL_BOOTH_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_toll_booth_cost() {
  _oneof_case_[4] = HAS_TOLL_BOOTH_COST_NOT_SET;
}
inline bool CostingOptions::has_has_toll_booth_penalty() const {
  return has_toll_booth_penalty_case() != HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_toll_booth_penalty() {
  _oneof_case_[5] = HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_alley_penalty() const {
  return has_alley_penalty_case() != HAS_ALLEY_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_alley_penalty() {
  _oneof_case_[6] = HAS_ALLEY_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_country_crossing_cost() const {
  return has_country_crossing_cost_case() != HAS_COUNTRY_CROSSING_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_country_crossing_cost() {
  _oneof_case_[7] = HAS_COUNTRY_CROSSING_COST_NOT_SET;
}
inline bool CostingOptions::has_has_country_crossing_penalty() const {
  return has_country_crossing_penalty_case() != HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_country_crossing_penalty() {
  _oneof_case_[8] = HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_ferry_cost() const {
  return has_ferry_cost_case() != HAS_FERRY_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_ferry_cost() {
  _oneof_case_[9] = HAS_FERRY_COST_NOT_SET;
}
inline bool CostingOptions::has_has_avoid_bad_surfaces() const {
  return has_avoid_bad_surfaces_case() != HAS_AVOID_BAD_SURFACES_NOT_SET;
}
inline void CostingOptions::clear_has_has_avoid_bad_surfaces() {
  _oneof_case_[10] = HAS_AVOID_BAD_SURFACES_NOT_SET;
}
inline bool CostingOptions::has_has_use_ferry() const {
  return has_use_ferry_case() != HAS_USE_FERRY_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_ferry() {
  _oneof_case_[11] = HAS_USE_FERRY_NOT_SET;
}
inline bool CostingOptions::has_has_use_highways() const {
  return has_use_highways_case() != HAS_USE_HIGHWAYS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_highways() {
  _oneof_case_[12] = HAS_USE_HIGHWAYS_NOT_SET;
}
inline bool CostingOptions::has_has_use_tolls() const {
  return has_use_tolls_case() != HAS_USE_TOLLS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_tolls() {
  _oneof_case_[13] = HAS_USE_TOLLS_NOT_SET;
}
inline bool CostingOptions::has_has_use_roads() const {
  return has_use_roads_case() != HAS_USE_ROADS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_roads() {
  _oneof_case_[14] = HAS_USE_ROADS_NOT_SET;
}
inline bool CostingOptions::has_has_max_distance() const {
  return has_max_distance_case() != HAS_MAX_DISTANCE_NOT_SET;
}
inline void CostingOptions::clear_has_has_max_distance() {
  _oneof_case_[15] = HAS_MAX_DISTANCE_NOT_SET;
}
inline bool CostingOptions::has_has_walking_speed() const {
  return has_walking_speed_case() != HAS_WALKING_SPEED_NOT_SET;
}
inline void CostingOptions::clear_has_has_walking_speed() {
  _oneof_case_[16] = HAS_WALKING_SPEED_NOT_SET;
}
inline bool CostingOptions::has_has_step_penalty() const {
  return has_step_penalty_case() != HAS_STEP_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_step_penalty() {
  _oneof_case_[17] = HAS_STEP_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_max_grade() const {
  return has_max_grade_case() != HAS_MAX_GRADE_NOT_SET;
}
inline void CostingOptions::clear_has_has_max_grade() {
  _oneof_case_[18] = HAS_MAX_GRADE_NOT_SET;
}
inline bool CostingOptions::has_has_max_hiking_difficulty() const {
  return has_max_hiking_difficulty_case() != HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_max_hiking_difficulty() {
  _oneof_case_[19] = HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}
inline bool CostingOptions::has_has_mode_factor() const {
  return has_mode_factor_case() != HAS_MODE_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_mode_factor() {
  _oneof_case_[20] = HAS_MODE_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_walkway_factor() const {
  return has_walkway_factor_case() != HAS_WALKWAY_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_walkway_factor() {
  _oneof_case_[21] = HAS_WALKWAY_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_sidewalk_factor() const {
  return has_sidewalk_factor_case() != HAS_SIDEWALK_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_sidewalk_factor() {
  _oneof_case_[22] = HAS_SIDEWALK_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_alley_factor() const {
  return has_alley_factor_case() != HAS_ALLEY_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_alley_factor() {
  _oneof_case_[23] = HAS_ALLEY_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_driveway_factor() const {
  return has_driveway_factor_case() != HAS_DRIVEWAY_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_driveway_factor() {
  _oneof_case_[24] = HAS_DRIVEWAY_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_driveway_penalty() const {
  return has_driveway_penalty_case() != HAS_DRIVEWAY_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_driveway_penalty() {
  _oneof_case_[25] = HAS_DRIVEWAY_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_transit_start_end_max_distance() const {
  return has_transit_start_end_max_distance_case() != HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}
inline void CostingOptions::clear_has_has_transit_start_end_max_distance() {
  _oneof_case_[26] = HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}
inline bool CostingOptions::has_has_transit_transfer_max_distance() const {
  return has_transit_transfer_max_distance_case() != HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}
inline void CostingOptions::clear_has_has_transit_transfer_max_distance() {
  _oneof_case_[27] = HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}
inline bool CostingOptions::has_has_transport_type() const {
  return has_transport_type_case() != HAS_TRANSPORT_TYPE_NOT_SET;
}
inline void CostingOptions::clear_has_has_transport_type() {
  _oneof_case_[28] = HAS_TRANSPORT_TYPE_NOT_SET;
}
inline bool CostingOptions::has_has_top_speed() const {
  return has_top_speed_case() != HAS_TOP_SPEED_NOT_SET;
}
inline void CostingOptions::clear_has_has_top_speed() {
  _oneof_case_[29] = HAS_TOP_SPEED_NOT_SET;
}
inline bool CostingOptions::has_has_use_hills() const {
  return has_use_hills_case() != HAS_USE_HILLS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_hills() {
  _oneof_case_[30] = HAS_USE_HILLS_NOT_SET;
}
inline bool CostingOptions::has_has_use_primary() const {
  return has_use_primary_case() != HAS_USE_PRIMARY_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_primary() {
  _oneof_case_[31] = HAS_USE_PRIMARY_NOT_SET;
}
inline bool CostingOptions::has_has_use_trails() const {
  return has_use_trails_case() != HAS_USE_TRAILS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_trails() {
  _oneof_case_[32] = HAS_USE_TRAILS_NOT_SET;
}
inline bool CostingOptions::has_has_low_class_penalty() const {
  return has_low_class_penalty_case() != HAS_LOW_CLASS_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_low_class_penalty() {
  _oneof_case_[33] = HAS_LOW_CLASS_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_hazmat() const {
  return has_hazmat_case() != HAS_HAZMAT_NOT_SET;
}
inline void CostingOptions::clear_has_has_hazmat() {
  _oneof_case_[34] = HAS_HAZMAT_NOT_SET;
}
inline bool CostingOptions::has_has_weight() const {
  return has_weight_case() != HAS_WEIGHT_NOT_SET;
}
inline void CostingOptions::clear_has_has_weight() {
  _oneof_case_[35] = HAS_WEIGHT_NOT_SET;
}
inline bool CostingOptions::has_has_axle_load() const {
  return has_axle_load_case() != HAS_AXLE_LOAD_NOT_SET;
}
inline void CostingOptions::clear_has_has_axle_load() {
  _oneof_case_[36] = HAS_AXLE_LOAD_NOT_SET;
}
inline bool CostingOptions::has_has_height() const {
  return has_height_case() != HAS_HEIGHT_NOT_SET;
}
inline void CostingOptions::clear_has_has_height() {
  _oneof_case_[37] = HAS_HEIGHT_NOT_SET;
}
inline bool CostingOptions::has_has_width() const {
  return has_width_case() != HAS_WIDTH_NOT_SET;
}
inline void CostingOptions::clear_has_has_width() {
  _oneof_case_[38] = HAS_WIDTH_NOT_SET;
}
inline bool CostingOptions::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void CostingOptions::clear_has_has_length() {
  _oneof_case_[39] = HAS_LENGTH_NOT_SET;
}
inline bool CostingOptions::has_has_cycling_speed() const {
  return has_cycling_speed_case() != HAS_CYCLING_SPEED_NOT_SET;
}
inline void CostingOptions::clear_has_has_cycling_speed() {
  _oneof_case_[40] = HAS_CYCLING_SPEED_NOT_SET;
}
inline bool CostingOptions::has_has_wheelchair() const {
  return has_wheelchair_case() != HAS_WHEELCHAIR_NOT_SET;
}
inline void CostingOptions::clear_has_has_wheelchair() {
  _oneof_case_[41] = HAS_WHEELCHAIR_NOT_SET;
}
inline bool CostingOptions::has_has_bicycle() const {
  return has_bicycle_case() != HAS_BICYCLE_NOT_SET;
}
inline void CostingOptions::clear_has_has_bicycle() {
  _oneof_case_[42] = HAS_BICYCLE_NOT_SET;
}
inline bool CostingOptions::has_has_use_bus() const {
  return has_use_bus_case() != HAS_USE_BUS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_bus() {
  _oneof_case_[43] = HAS_USE_BUS_NOT_SET;
}
inline bool CostingOptions::has_has_use_rail() const {
  return has_use_rail_case() != HAS_USE_RAIL_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_rail() {
  _oneof_case_[44] = HAS_USE_RAIL_NOT_SET;
}
inline bool CostingOptions::has_has_use_transfers() const {
  return has_use_transfers_case() != HAS_USE_TRANSFERS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_transfers() {
  _oneof_case_[45] = HAS_USE_TRANSFERS_NOT_SET;
}
inline bool CostingOptions::has_has_transfer_cost() const {
  return has_transfer_cost_case() != HAS_TRANSFER_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_transfer_cost() {
  _oneof_case_[46] = HAS_TRANSFER_COST_NOT_SET;
}
inline bool CostingOptions::has_has_transfer_penalty() const {
  return has_transfer_penalty_case() != HAS_TRANSFER_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_transfer_penalty() {
  _oneof_case_[47] = HAS_TRANSFER_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_flow_mask() const {
  return has_flow_mask_case() != HAS_FLOW_MASK_NOT_SET;
}
inline void CostingOptions::clear_has_has_flow_mask() {
  _oneof_case_[48] = HAS_FLOW_MASK_NOT_SET;
}
inline bool CostingOptions::has_has_bike_share_cost() const {
  return has_bike_share_cost_case() != HAS_BIKE_SHARE_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_bike_share_cost() {
  _oneof_case_[49] = HAS_BIKE_SHARE_COST_NOT_SET;
}
inline bool CostingOptions::has_has_bike_share_penalty() const {
  return has_bike_share_penalty_case() != HAS_BIKE_SHARE_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_bike_share_penalty() {
  _oneof_case_[50] = HAS_BIKE_SHARE_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_rail_ferry_cost() const {
  return has_rail_ferry_cost_case() != HAS_RAIL_FERRY_COST_NOT_SET;
}
inline void CostingOptions::clear_has_has_rail_ferry_cost() {
  _oneof_case_[51] = HAS_RAIL_FERRY_COST_NOT_SET;
}
inline bool CostingOptions::has_has_use_rail_ferry() const {
  return has_use_rail_ferry_case() != HAS_USE_RAIL_FERRY_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_rail_ferry() {
  _oneof_case_[52] = HAS_USE_RAIL_FERRY_NOT_SET;
}
inline bool CostingOptions::has_has_ignore_restrictions() const {
  return has_ignore_restrictions_case() != HAS_IGNORE_RESTRICTIONS_NOT_SET;
}
inline void CostingOptions::clear_has_has_ignore_restrictions() {
  _oneof_case_[53] = HAS_IGNORE_RESTRICTIONS_NOT_SET;
}
inline bool CostingOptions::has_has_ignore_oneways() const {
  return has_ignore_oneways_case() != HAS_IGNORE_ONEWAYS_NOT_SET;
}
inline void CostingOptions::clear_has_has_ignore_oneways() {
  _oneof_case_[54] = HAS_IGNORE_ONEWAYS_NOT_SET;
}
inline bool CostingOptions::has_has_ignore_access() const {
  return has_ignore_access_case() != HAS_IGNORE_ACCESS_NOT_SET;
}
inline void CostingOptions::clear_has_has_ignore_access() {
  _oneof_case_[55] = HAS_IGNORE_ACCESS_NOT_SET;
}
inline bool CostingOptions::has_has_ignore_closures() const {
  return has_ignore_closures_case() != HAS_IGNORE_CLOSURES_NOT_SET;
}
inline void CostingOptions::clear_has_has_ignore_closures() {
  _oneof_case_[56] = HAS_IGNORE_CLOSURES_NOT_SET;
}
inline bool CostingOptions::has_has_shortest() const {
  return has_shortest_case() != HAS_SHORTEST_NOT_SET;
}
inline void CostingOptions::clear_has_has_shortest() {
  _oneof_case_[57] = HAS_SHORTEST_NOT_SET;
}
inline bool CostingOptions::has_has_service_penalty() const {
  return has_service_penalty_case() != HAS_SERVICE_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_service_penalty() {
  _oneof_case_[58] = HAS_SERVICE_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_use_tracks() const {
  return has_use_tracks_case() != HAS_USE_TRACKS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_tracks() {
  _oneof_case_[59] = HAS_USE_TRACKS_NOT_SET;
}
inline bool CostingOptions::has_has_use_distance() const {
  return has_use_distance_case() != HAS_USE_DISTANCE_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_distance() {
  _oneof_case_[60] = HAS_USE_DISTANCE_NOT_SET;
}
inline bool CostingOptions::has_has_use_living_streets() const {
  return has_use_living_streets_case() != HAS_USE_LIVING_STREETS_NOT_SET;
}
inline void CostingOptions::clear_has_has_use_living_streets() {
  _oneof_case_[61] = HAS_USE_LIVING_STREETS_NOT_SET;
}
inline bool CostingOptions::has_has_service_factor() const {
  return has_service_factor_case() != HAS_SERVICE_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_service_factor() {
  _oneof_case_[62] = HAS_SERVICE_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_closure_factor() const {
  return has_closure_factor_case() != HAS_CLOSURE_FACTOR_NOT_SET;
}
inline void CostingOptions::clear_has_has_closure_factor() {
  _oneof_case_[63] = HAS_CLOSURE_FACTOR_NOT_SET;
}
inline bool CostingOptions::has_has_private_access_penalty() const {
  return has_private_access_penalty_case() != HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}
inline void CostingOptions::clear_has_has_private_access_penalty() {
  _oneof_case_[64] = HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}
inline bool CostingOptions::has_has_exclude_unpaved() const {
  return has_exclude_unpaved_case() != HAS_EXCLUDE_UNPAVED_NOT_SET;
}
inline void CostingOptions::clear_has_has_exclude_unpaved() {
  _oneof_case_[65] = HAS_EXCLUDE_UNPAVED_NOT_SET;
}
inline bool CostingOptions::has_has_include_hot() const {
  return has_include_hot_case() != HAS_INCLUDE_HOT_NOT_SET;
}
inline void CostingOptions::clear_has_has_include_hot() {
  _oneof_case_[66] = HAS_INCLUDE_HOT_NOT_SET;
}
inline bool CostingOptions::has_has_include_hov2() const {
  return has_include_hov2_case() != HAS_INCLUDE_HOV2_NOT_SET;
}
inline void CostingOptions::clear_has_has_include_hov2() {
  _oneof_case_[67] = HAS_INCLUDE_HOV2_NOT_SET;
}
inline bool CostingOptions::has_has_include_hov3() const {
  return has_include_hov3_case() != HAS_INCLUDE_HOV3_NOT_SET;
}
inline void CostingOptions::clear_has_has_include_hov3() {
  _oneof_case_[68] = HAS_INCLUDE_HOV3_NOT_SET;
}
inline bool CostingOptions::has_has_exclude_cash_only_tolls() const {
  return has_exclude_cash_only_tolls_case() != HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}
inline void CostingOptions::clear_has_has_exclude_cash_only_tolls() {
  _oneof_case_[69] = HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}
inline bool CostingOptions::has_has_restriction_probability() const {
  return has_restriction_probability_case() != HAS_RESTRICTION_PROBABILITY_NOT_SET;
}
inline void CostingOptions::clear_has_has_restriction_probability() {
  _oneof_case_[70] = HAS_RESTRICTION_PROBABILITY_NOT_SET;
}
inline bool CostingOptions::has_has_costing() const {
  return has_costing_case() != HAS_COSTING_NOT_SET;
}
inline void CostingOptions::clear_has_has_costing() {
  _oneof_case_[71] = HAS_COSTING_NOT_SET;
}
inline bool CostingOptions::has_has_name() const {
  return has_name_case() != HAS_NAME_NOT_SET;
}
inline void CostingOptions::clear_has_has_name() {
  _oneof_case_[72] = HAS_NAME_NOT_SET;
}
inline bool CostingOptions::has_has_filter_closures() const {
  return has_filter_closures_case() != HAS_FILTER_CLOSURES_NOT_SET;
}
inline void CostingOptions::clear_has_has_filter_closures() {
  _oneof_case_[73] = HAS_FILTER_CLOSURES_NOT_SET;
}
inline CostingOptions::HasManeuverPenaltyCase CostingOptions::has_maneuver_penalty_case() const {
  return CostingOptions::HasManeuverPenaltyCase(_oneof_case_[0]);
}
inline CostingOptions::HasDestinationOnlyPenaltyCase CostingOptions::has_destination_only_penalty_case() const {
  return CostingOptions::HasDestinationOnlyPenaltyCase(_oneof_case_[1]);
}
inline CostingOptions::HasGateCostCase CostingOptions::has_gate_cost_case() const {
  return CostingOptions::HasGateCostCase(_oneof_case_[2]);
}
inline CostingOptions::HasGatePenaltyCase CostingOptions::has_gate_penalty_case() const {
  return CostingOptions::HasGatePenaltyCase(_oneof_case_[3]);
}
inline CostingOptions::HasTollBoothCostCase CostingOptions::has_toll_booth_cost_case() const {
  return CostingOptions::HasTollBoothCostCase(_oneof_case_[4]);
}
inline CostingOptions::HasTollBoothPenaltyCase CostingOptions::has_toll_booth_penalty_case() const {
  return CostingOptions::HasTollBoothPenaltyCase(_oneof_case_[5]);
}
inline CostingOptions::HasAlleyPenaltyCase CostingOptions::has_alley_penalty_case() const {
  return CostingOptions::HasAlleyPenaltyCase(_oneof_case_[6]);
}
inline CostingOptions::HasCountryCrossingCostCase CostingOptions::has_country_crossing_cost_case() const {
  return CostingOptions::HasCountryCrossingCostCase(_oneof_case_[7]);
}
inline CostingOptions::HasCountryCrossingPenaltyCase CostingOptions::has_country_crossing_penalty_case() const {
  return CostingOptions::HasCountryCrossingPenaltyCase(_oneof_case_[8]);
}
inline CostingOptions::HasFerryCostCase CostingOptions::has_ferry_cost_case() const {
  return CostingOptions::HasFerryCostCase(_oneof_case_[9]);
}
inline CostingOptions::HasAvoidBadSurfacesCase CostingOptions::has_avoid_bad_surfaces_case() const {
  return CostingOptions::HasAvoidBadSurfacesCase(_oneof_case_[10]);
}
inline CostingOptions::HasUseFerryCase CostingOptions::has_use_ferry_case() const {
  return CostingOptions::HasUseFerryCase(_oneof_case_[11]);
}
inline CostingOptions::HasUseHighwaysCase CostingOptions::has_use_highways_case() const {
  return CostingOptions::HasUseHighwaysCase(_oneof_case_[12]);
}
inline CostingOptions::HasUseTollsCase CostingOptions::has_use_tolls_case() const {
  return CostingOptions::HasUseTollsCase(_oneof_case_[13]);
}
inline CostingOptions::HasUseRoadsCase CostingOptions::has_use_roads_case() const {
  return CostingOptions::HasUseRoadsCase(_oneof_case_[14]);
}
inline CostingOptions::HasMaxDistanceCase CostingOptions::has_max_distance_case() const {
  return CostingOptions::HasMaxDistanceCase(_oneof_case_[15]);
}
inline CostingOptions::HasWalkingSpeedCase CostingOptions::has_walking_speed_case() const {
  return CostingOptions::HasWalkingSpeedCase(_oneof_case_[16]);
}
inline CostingOptions::HasStepPenaltyCase CostingOptions::has_step_penalty_case() const {
  return CostingOptions::HasStepPenaltyCase(_oneof_case_[17]);
}
inline CostingOptions::HasMaxGradeCase CostingOptions::has_max_grade_case() const {
  return CostingOptions::HasMaxGradeCase(_oneof_case_[18]);
}
inline CostingOptions::HasMaxHikingDifficultyCase CostingOptions::has_max_hiking_difficulty_case() const {
  return CostingOptions::HasMaxHikingDifficultyCase(_oneof_case_[19]);
}
inline CostingOptions::HasModeFactorCase CostingOptions::has_mode_factor_case() const {
  return CostingOptions::HasModeFactorCase(_oneof_case_[20]);
}
inline CostingOptions::HasWalkwayFactorCase CostingOptions::has_walkway_factor_case() const {
  return CostingOptions::HasWalkwayFactorCase(_oneof_case_[21]);
}
inline CostingOptions::HasSidewalkFactorCase CostingOptions::has_sidewalk_factor_case() const {
  return CostingOptions::HasSidewalkFactorCase(_oneof_case_[22]);
}
inline CostingOptions::HasAlleyFactorCase CostingOptions::has_alley_factor_case() const {
  return CostingOptions::HasAlleyFactorCase(_oneof_case_[23]);
}
inline CostingOptions::HasDrivewayFactorCase CostingOptions::has_driveway_factor_case() const {
  return CostingOptions::HasDrivewayFactorCase(_oneof_case_[24]);
}
inline CostingOptions::HasDrivewayPenaltyCase CostingOptions::has_driveway_penalty_case() const {
  return CostingOptions::HasDrivewayPenaltyCase(_oneof_case_[25]);
}
inline CostingOptions::HasTransitStartEndMaxDistanceCase CostingOptions::has_transit_start_end_max_distance_case() const {
  return CostingOptions::HasTransitStartEndMaxDistanceCase(_oneof_case_[26]);
}
inline CostingOptions::HasTransitTransferMaxDistanceCase CostingOptions::has_transit_transfer_max_distance_case() const {
  return CostingOptions::HasTransitTransferMaxDistanceCase(_oneof_case_[27]);
}
inline CostingOptions::HasTransportTypeCase CostingOptions::has_transport_type_case() const {
  return CostingOptions::HasTransportTypeCase(_oneof_case_[28]);
}
inline CostingOptions::HasTopSpeedCase CostingOptions::has_top_speed_case() const {
  return CostingOptions::HasTopSpeedCase(_oneof_case_[29]);
}
inline CostingOptions::HasUseHillsCase CostingOptions::has_use_hills_case() const {
  return CostingOptions::HasUseHillsCase(_oneof_case_[30]);
}
inline CostingOptions::HasUsePrimaryCase CostingOptions::has_use_primary_case() const {
  return CostingOptions::HasUsePrimaryCase(_oneof_case_[31]);
}
inline CostingOptions::HasUseTrailsCase CostingOptions::has_use_trails_case() const {
  return CostingOptions::HasUseTrailsCase(_oneof_case_[32]);
}
inline CostingOptions::HasLowClassPenaltyCase CostingOptions::has_low_class_penalty_case() const {
  return CostingOptions::HasLowClassPenaltyCase(_oneof_case_[33]);
}
inline CostingOptions::HasHazmatCase CostingOptions::has_hazmat_case() const {
  return CostingOptions::HasHazmatCase(_oneof_case_[34]);
}
inline CostingOptions::HasWeightCase CostingOptions::has_weight_case() const {
  return CostingOptions::HasWeightCase(_oneof_case_[35]);
}
inline CostingOptions::HasAxleLoadCase CostingOptions::has_axle_load_case() const {
  return CostingOptions::HasAxleLoadCase(_oneof_case_[36]);
}
inline CostingOptions::HasHeightCase CostingOptions::has_height_case() const {
  return CostingOptions::HasHeightCase(_oneof_case_[37]);
}
inline CostingOptions::HasWidthCase CostingOptions::has_width_case() const {
  return CostingOptions::HasWidthCase(_oneof_case_[38]);
}
inline CostingOptions::HasLengthCase CostingOptions::has_length_case() const {
  return CostingOptions::HasLengthCase(_oneof_case_[39]);
}
inline CostingOptions::HasCyclingSpeedCase CostingOptions::has_cycling_speed_case() const {
  return CostingOptions::HasCyclingSpeedCase(_oneof_case_[40]);
}
inline CostingOptions::HasWheelchairCase CostingOptions::has_wheelchair_case() const {
  return CostingOptions::HasWheelchairCase(_oneof_case_[41]);
}
inline CostingOptions::HasBicycleCase CostingOptions::has_bicycle_case() const {
  return CostingOptions::HasBicycleCase(_oneof_case_[42]);
}
inline CostingOptions::HasUseBusCase CostingOptions::has_use_bus_case() const {
  return CostingOptions::HasUseBusCase(_oneof_case_[43]);
}
inline CostingOptions::HasUseRailCase CostingOptions::has_use_rail_case() const {
  return CostingOptions::HasUseRailCase(_oneof_case_[44]);
}
inline CostingOptions::HasUseTransfersCase CostingOptions::has_use_transfers_case() const {
  return CostingOptions::HasUseTransfersCase(_oneof_case_[45]);
}
inline CostingOptions::HasTransferCostCase CostingOptions::has_transfer_cost_case() const {
  return CostingOptions::HasTransferCostCase(_oneof_case_[46]);
}
inline CostingOptions::HasTransferPenaltyCase CostingOptions::has_transfer_penalty_case() const {
  return CostingOptions::HasTransferPenaltyCase(_oneof_case_[47]);
}
inline CostingOptions::HasFlowMaskCase CostingOptions::has_flow_mask_case() const {
  return CostingOptions::HasFlowMaskCase(_oneof_case_[48]);
}
inline CostingOptions::HasBikeShareCostCase CostingOptions::has_bike_share_cost_case() const {
  return CostingOptions::HasBikeShareCostCase(_oneof_case_[49]);
}
inline CostingOptions::HasBikeSharePenaltyCase CostingOptions::has_bike_share_penalty_case() const {
  return CostingOptions::HasBikeSharePenaltyCase(_oneof_case_[50]);
}
inline CostingOptions::HasRailFerryCostCase CostingOptions::has_rail_ferry_cost_case() const {
  return CostingOptions::HasRailFerryCostCase(_oneof_case_[51]);
}
inline CostingOptions::HasUseRailFerryCase CostingOptions::has_use_rail_ferry_case() const {
  return CostingOptions::HasUseRailFerryCase(_oneof_case_[52]);
}
inline CostingOptions::HasIgnoreRestrictionsCase CostingOptions::has_ignore_restrictions_case() const {
  return CostingOptions::HasIgnoreRestrictionsCase(_oneof_case_[53]);
}
inline CostingOptions::HasIgnoreOnewaysCase CostingOptions::has_ignore_oneways_case() const {
  return CostingOptions::HasIgnoreOnewaysCase(_oneof_case_[54]);
}
inline CostingOptions::HasIgnoreAccessCase CostingOptions::has_ignore_access_case() const {
  return CostingOptions::HasIgnoreAccessCase(_oneof_case_[55]);
}
inline CostingOptions::HasIgnoreClosuresCase CostingOptions::has_ignore_closures_case() const {
  return CostingOptions::HasIgnoreClosuresCase(_oneof_case_[56]);
}
inline CostingOptions::HasShortestCase CostingOptions::has_shortest_case() const {
  return CostingOptions::HasShortestCase(_oneof_case_[57]);
}
inline CostingOptions::HasServicePenaltyCase CostingOptions::has_service_penalty_case() const {
  return CostingOptions::HasServicePenaltyCase(_oneof_case_[58]);
}
inline CostingOptions::HasUseTracksCase CostingOptions::has_use_tracks_case() const {
  return CostingOptions::HasUseTracksCase(_oneof_case_[59]);
}
inline CostingOptions::HasUseDistanceCase CostingOptions::has_use_distance_case() const {
  return CostingOptions::HasUseDistanceCase(_oneof_case_[60]);
}
inline CostingOptions::HasUseLivingStreetsCase CostingOptions::has_use_living_streets_case() const {
  return CostingOptions::HasUseLivingStreetsCase(_oneof_case_[61]);
}
inline CostingOptions::HasServiceFactorCase CostingOptions::has_service_factor_case() const {
  return CostingOptions::HasServiceFactorCase(_oneof_case_[62]);
}
inline CostingOptions::HasClosureFactorCase CostingOptions::has_closure_factor_case() const {
  return CostingOptions::HasClosureFactorCase(_oneof_case_[63]);
}
inline CostingOptions::HasPrivateAccessPenaltyCase CostingOptions::has_private_access_penalty_case() const {
  return CostingOptions::HasPrivateAccessPenaltyCase(_oneof_case_[64]);
}
inline CostingOptions::HasExcludeUnpavedCase CostingOptions::has_exclude_unpaved_case() const {
  return CostingOptions::HasExcludeUnpavedCase(_oneof_case_[65]);
}
inline CostingOptions::HasIncludeHotCase CostingOptions::has_include_hot_case() const {
  return CostingOptions::HasIncludeHotCase(_oneof_case_[66]);
}
inline CostingOptions::HasIncludeHov2Case CostingOptions::has_include_hov2_case() const {
  return CostingOptions::HasIncludeHov2Case(_oneof_case_[67]);
}
inline CostingOptions::HasIncludeHov3Case CostingOptions::has_include_hov3_case() const {
  return CostingOptions::HasIncludeHov3Case(_oneof_case_[68]);
}
inline CostingOptions::HasExcludeCashOnlyTollsCase CostingOptions::has_exclude_cash_only_tolls_case() const {
  return CostingOptions::HasExcludeCashOnlyTollsCase(_oneof_case_[69]);
}
inline CostingOptions::HasRestrictionProbabilityCase CostingOptions::has_restriction_probability_case() const {
  return CostingOptions::HasRestrictionProbabilityCase(_oneof_case_[70]);
}
inline CostingOptions::HasCostingCase CostingOptions::has_costing_case() const {
  return CostingOptions::HasCostingCase(_oneof_case_[71]);
}
inline CostingOptions::HasNameCase CostingOptions::has_name_case() const {
  return CostingOptions::HasNameCase(_oneof_case_[72]);
}
inline CostingOptions::HasFilterClosuresCase CostingOptions::has_filter_closures_case() const {
  return CostingOptions::HasFilterClosuresCase(_oneof_case_[73]);
}
// -------------------------------------------------------------------

// Options_Ring

// repeated .valhalla.LatLng coords = 1;
inline int Options_Ring::coords_size() const {
  return coords_.size();
}
inline void Options_Ring::clear_coords() {
  coords_.Clear();
}
inline const ::valhalla::LatLng& Options_Ring::coords(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.Ring.coords)
  return coords_.Get(index);
}
inline ::valhalla::LatLng* Options_Ring::mutable_coords(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.Ring.coords)
  return coords_.Mutable(index);
}
inline ::valhalla::LatLng* Options_Ring::add_coords() {
  // @@protoc_insertion_point(field_add:valhalla.Options.Ring.coords)
  return coords_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng >*
Options_Ring::mutable_coords() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.Ring.coords)
  return &coords_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng >&
Options_Ring::coords() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.Ring.coords)
  return coords_;
}

// -------------------------------------------------------------------

// Options

// optional .valhalla.Options.Units units = 1;
inline bool Options::has_units() const {
  return has_units_case() == kUnits;
}
inline void Options::set_has_units() {
  _oneof_case_[0] = kUnits;
}
inline void Options::clear_units() {
  if (has_units()) {
    has_units_.units_ = 0;
    clear_has_has_units();
  }
}
inline ::valhalla::Options_Units Options::units() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.units)
  if (has_units()) {
    return static_cast< ::valhalla::Options_Units >(has_units_.units_);
  }
  return static_cast< ::valhalla::Options_Units >(0);
}
inline void Options::set_units(::valhalla::Options_Units value) {
  if (!has_units()) {
    clear_has_units();
    set_has_units();
  }
  has_units_.units_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.units)
}

// optional string language = 2;
inline bool Options::has_language() const {
  return has_language_case() == kLanguage;
}
inline void Options::set_has_language() {
  _oneof_case_[1] = kLanguage;
}
inline void Options::clear_language() {
  if (has_language()) {
    has_language_.language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_language();
  }
}
inline const ::std::string& Options::language() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.language)
  if (has_language()) {
    return has_language_.language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Options::set_language(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Options.language)
  if (!has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_language_.language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Options.language)
}
inline void Options::set_language(const char* value) {
  if (!has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_language_.language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Options.language)
}
inline void Options::set_language(const char* value, size_t size) {
  if (!has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_language_.language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.language)
}
inline ::std::string* Options::mutable_language() {
  if (!has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Options.language)
  return has_language_.language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Options::release_language() {
  // @@protoc_insertion_point(field_release:valhalla.Options.language)
  if (has_language()) {
    clear_has_has_language();
    return has_language_.language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Options::set_allocated_language(::std::string* language) {
  if (!has_language()) {
    has_language_.language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_language();
  if (language != NULL) {
    set_has_language();
    has_language_.language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        language);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.language)
}

// optional .valhalla.DirectionsType directions_type = 3;
inline bool Options::has_directions_type() const {
  return has_directions_type_case() == kDirectionsType;
}
inline void Options::set_has_directions_type() {
  _oneof_case_[2] = kDirectionsType;
}
inline void Options::clear_directions_type() {
  if (has_directions_type()) {
    has_directions_type_.directions_type_ = 0;
    clear_has_has_directions_type();
  }
}
inline ::valhalla::DirectionsType Options::directions_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.directions_type)
  if (has_directions_type()) {
    return static_cast< ::valhalla::DirectionsType >(has_directions_type_.directions_type_);
  }
  return static_cast< ::valhalla::DirectionsType >(0);
}
inline void Options::set_directions_type(::valhalla::DirectionsType value) {
  if (!has_directions_type()) {
    clear_has_directions_type();
    set_has_directions_type();
  }
  has_directions_type_.directions_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.directions_type)
}

// optional .valhalla.Options.Format format = 4;
inline bool Options::has_format() const {
  return has_format_case() == kFormat;
}
inline void Options::set_has_format() {
  _oneof_case_[3] = kFormat;
}
inline void Options::clear_format() {
  if (has_format()) {
    has_format_.format_ = 0;
    clear_has_has_format();
  }
}
inline ::valhalla::Options_Format Options::format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.format)
  if (has_format()) {
    return static_cast< ::valhalla::Options_Format >(has_format_.format_);
  }
  return static_cast< ::valhalla::Options_Format >(0);
}
inline void Options::set_format(::valhalla::Options_Format value) {
  if (!has_format()) {
    clear_has_format();
    set_has_format();
  }
  has_format_.format_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.format)
}

// optional string id = 5;
inline bool Options::has_id() const {
  return has_id_case() == kId;
}
inline void Options::set_has_id() {
  _oneof_case_[4] = kId;
}
inline void Options::clear_id() {
  if (has_id()) {
    has_id_.id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_id();
  }
}
inline const ::std::string& Options::id() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.id)
  if (has_id()) {
    return has_id_.id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Options::set_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Options.id)
  if (!has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_id_.id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Options.id)
}
inline void Options::set_id(const char* value) {
  if (!has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_id_.id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Options.id)
}
inline void Options::set_id(const char* value, size_t size) {
  if (!has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_id_.id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.id)
}
inline ::std::string* Options::mutable_id() {
  if (!has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Options.id)
  return has_id_.id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Options::release_id() {
  // @@protoc_insertion_point(field_release:valhalla.Options.id)
  if (has_id()) {
    clear_has_has_id();
    return has_id_.id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Options::set_allocated_id(::std::string* id) {
  if (!has_id()) {
    has_id_.id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_id();
  if (id != NULL) {
    set_has_id();
    has_id_.id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        id);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.id)
}

// optional string jsonp = 6;
inline bool Options::has_jsonp() const {
  return has_jsonp_case() == kJsonp;
}
inline void Options::set_has_jsonp() {
  _oneof_case_[5] = kJsonp;
}
inline void Options::clear_jsonp() {
  if (has_jsonp()) {
    has_jsonp_.jsonp_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_jsonp();
  }
}
inline const ::std::string& Options::jsonp() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.jsonp)
  if (has_jsonp()) {
    return has_jsonp_.jsonp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Options::set_jsonp(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Options.jsonp)
  if (!has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_jsonp_.jsonp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Options.jsonp)
}
inline void Options::set_jsonp(const char* value) {
  if (!has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_jsonp_.jsonp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Options.jsonp)
}
inline void Options::set_jsonp(const char* value, size_t size) {
  if (!has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_jsonp_.jsonp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.jsonp)
}
inline ::std::string* Options::mutable_jsonp() {
  if (!has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Options.jsonp)
  return has_jsonp_.jsonp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Options::release_jsonp() {
  // @@protoc_insertion_point(field_release:valhalla.Options.jsonp)
  if (has_jsonp()) {
    clear_has_has_jsonp();
    return has_jsonp_.jsonp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Options::set_allocated_jsonp(::std::string* jsonp) {
  if (!has_jsonp()) {
    has_jsonp_.jsonp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_jsonp();
  if (jsonp != NULL) {
    set_has_jsonp();
    has_jsonp_.jsonp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        jsonp);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.jsonp)
}

// optional string encoded_polyline = 7;
inline bool Options::has_encoded_polyline() const {
  return has_encoded_polyline_case() == kEncodedPolyline;
}
inline void Options::set_has_encoded_polyline() {
  _oneof_case_[6] = kEncodedPolyline;
}
inline void Options::clear_encoded_polyline() {
  if (has_encoded_polyline()) {
    has_encoded_polyline_.encoded_polyline_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_encoded_polyline();
  }
}
inline const ::std::string& Options::encoded_polyline() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.encoded_polyline)
  if (has_encoded_polyline()) {
    return has_encoded_polyline_.encoded_polyline_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Options::set_encoded_polyline(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Options.encoded_polyline)
  if (!has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_encoded_polyline_.encoded_polyline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Options.encoded_polyline)
}
inline void Options::set_encoded_polyline(const char* value) {
  if (!has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_encoded_polyline_.encoded_polyline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Options.encoded_polyline)
}
inline void Options::set_encoded_polyline(const char* value, size_t size) {
  if (!has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_encoded_polyline_.encoded_polyline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.encoded_polyline)
}
inline ::std::string* Options::mutable_encoded_polyline() {
  if (!has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Options.encoded_polyline)
  return has_encoded_polyline_.encoded_polyline_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Options::release_encoded_polyline() {
  // @@protoc_insertion_point(field_release:valhalla.Options.encoded_polyline)
  if (has_encoded_polyline()) {
    clear_has_has_encoded_polyline();
    return has_encoded_polyline_.encoded_polyline_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Options::set_allocated_encoded_polyline(::std::string* encoded_polyline) {
  if (!has_encoded_polyline()) {
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_encoded_polyline();
  if (encoded_polyline != NULL) {
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        encoded_polyline);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.encoded_polyline)
}

// optional .valhalla.Options.Action action = 8;
inline bool Options::has_action() const {
  return has_action_case() == kAction;
}
inline void Options::set_has_action() {
  _oneof_case_[7] = kAction;
}
inline void Options::clear_action() {
  if (has_action()) {
    has_action_.action_ = 0;
    clear_has_has_action();
  }
}
inline ::valhalla::Options_Action Options::action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.action)
  if (has_action()) {
    return static_cast< ::valhalla::Options_Action >(has_action_.action_);
  }
  return static_cast< ::valhalla::Options_Action >(0);
}
inline void Options::set_action(::valhalla::Options_Action value) {
  if (!has_action()) {
    clear_has_action();
    set_has_action();
  }
  has_action_.action_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.action)
}

// optional bool range = 10;
inline bool Options::has_range() const {
  return has_range_case() == kRange;
}
inline void Options::set_has_range() {
  _oneof_case_[8] = kRange;
}
inline void Options::clear_range() {
  if (has_range()) {
    has_range_.range_ = false;
    clear_has_has_range();
  }
}
inline bool Options::range() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.range)
  if (has_range()) {
    return has_range_.range_;
  }
  return false;
}
inline void Options::set_range(bool value) {
  if (!has_range()) {
    clear_has_range();
    set_has_range();
  }
  has_range_.range_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.range)
}

// optional bool verbose = 11;
inline bool Options::has_verbose() const {
  return has_verbose_case() == kVerbose;
}
inline void Options::set_has_verbose() {
  _oneof_case_[9] = kVerbose;
}
inline void Options::clear_verbose() {
  if (has_verbose()) {
    has_verbose_.verbose_ = false;
    clear_has_has_verbose();
  }
}
inline bool Options::verbose() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.verbose)
  if (has_verbose()) {
    return has_verbose_.verbose_;
  }
  return false;
}
inline void Options::set_verbose(bool value) {
  if (!has_verbose()) {
    clear_has_verbose();
    set_has_verbose();
  }
  has_verbose_.verbose_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.verbose)
}

// optional .valhalla.Costing costing = 12;
inline bool Options::has_costing() const {
  return has_costing_case() == kCosting;
}
inline void Options::set_has_costing() {
  _oneof_case_[10] = kCosting;
}
inline void Options::clear_costing() {
  if (has_costing()) {
    has_costing_.costing_ = 0;
    clear_has_has_costing();
  }
}
inline ::valhalla::Costing Options::costing() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.costing)
  if (has_costing()) {
    return static_cast< ::valhalla::Costing >(has_costing_.costing_);
  }
  return static_cast< ::valhalla::Costing >(0);
}
inline void Options::set_costing(::valhalla::Costing value) {
  if (!has_costing()) {
    clear_has_costing();
    set_has_costing();
  }
  has_costing_.costing_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.costing)
}

// map<int32, .valhalla.CostingOptions> costing_options = 13;
inline int Options::costing_options_size() const {
  return costing_options_.size();
}
inline void Options::clear_costing_options() {
  costing_options_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::valhalla::CostingOptions >&
Options::costing_options() const {
  // @@protoc_insertion_point(field_map:valhalla.Options.costing_options)
  return costing_options_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::valhalla::CostingOptions >*
Options::mutable_costing_options() {
  // @@protoc_insertion_point(field_mutable_map:valhalla.Options.costing_options)
  return costing_options_.MutableMap();
}

// repeated .valhalla.Location locations = 14;
inline int Options::locations_size() const {
  return locations_.size();
}
inline void Options::clear_locations() {
  locations_.Clear();
}
inline const ::valhalla::Location& Options::locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.locations)
  return locations_.Get(index);
}
inline ::valhalla::Location* Options::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.locations)
  return locations_.Mutable(index);
}
inline ::valhalla::Location* Options::add_locations() {
  // @@protoc_insertion_point(field_add:valhalla.Options.locations)
  return locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.locations)
  return &locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.locations)
  return locations_;
}

// repeated .valhalla.Location exclude_locations = 15;
inline int Options::exclude_locations_size() const {
  return exclude_locations_.size();
}
inline void Options::clear_exclude_locations() {
  exclude_locations_.Clear();
}
inline const ::valhalla::Location& Options::exclude_locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.exclude_locations)
  return exclude_locations_.Get(index);
}
inline ::valhalla::Location* Options::mutable_exclude_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.exclude_locations)
  return exclude_locations_.Mutable(index);
}
inline ::valhalla::Location* Options::add_exclude_locations() {
  // @@protoc_insertion_point(field_add:valhalla.Options.exclude_locations)
  return exclude_locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_exclude_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.exclude_locations)
  return &exclude_locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::exclude_locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.exclude_locations)
  return exclude_locations_;
}

// repeated .valhalla.Location sources = 16;
inline int Options::sources_size() const {
  return sources_.size();
}
inline void Options::clear_sources() {
  sources_.Clear();
}
inline const ::valhalla::Location& Options::sources(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.sources)
  return sources_.Get(index);
}
inline ::valhalla::Location* Options::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.sources)
  return sources_.Mutable(index);
}
inline ::valhalla::Location* Options::add_sources() {
  // @@protoc_insertion_point(field_add:valhalla.Options.sources)
  return sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.sources)
  return &sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::sources() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.sources)
  return sources_;
}

// repeated .valhalla.Location targets = 17;
inline int Options::targets_size() const {
  return targets_.size();
}
inline void Options::clear_targets() {
  targets_.Clear();
}
inline const ::valhalla::Location& Options::targets(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.targets)
  return targets_.Get(index);
}
inline ::valhalla::Location* Options::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.targets)
  return targets_.Mutable(index);
}
inline ::valhalla::Location* Options::add_targets() {
  // @@protoc_insertion_point(field_add:valhalla.Options.targets)
  return targets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.targets)
  return &targets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::targets() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.targets)
  return targets_;
}

// optional .valhalla.Options.DateTimeType date_time_type = 18;
inline bool Options::has_date_time_type() const {
  return has_date_time_type_case() == kDateTimeType;
}
inline void Options::set_has_date_time_type() {
  _oneof_case_[11] = kDateTimeType;
}
inline void Options::clear_date_time_type() {
  if (has_date_time_type()) {
    has_date_time_type_.date_time_type_ = 0;
    clear_has_has_date_time_type();
  }
}
inline ::valhalla::Options_DateTimeType Options::date_time_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time_type)
  if (has_date_time_type()) {
    return static_cast< ::valhalla::Options_DateTimeType >(has_date_time_type_.date_time_type_);
  }
  return static_cast< ::valhalla::Options_DateTimeType >(0);
}
inline void Options::set_date_time_type(::valhalla::Options_DateTimeType value) {
  if (!has_date_time_type()) {
    clear_has_date_time_type();
    set_has_date_time_type();
  }
  has_date_time_type_.date_time_type_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time_type)
}

// optional string date_time = 19;
inline bool Options::has_date_time() const {
  return has_date_time_case() == kDateTime;
}
inline void Options::set_has_date_time() {
  _oneof_case_[12] = kDateTime;
}
inline void Options::clear_date_time() {
  if (has_date_time()) {
    has_date_time_.date_time_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_has_date_time();
  }
}
inline const ::std::string& Options::date_time() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time)
  if (has_date_time()) {
    return has_date_time_.date_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Options::set_date_time(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time)
  if (!has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_date_time_.date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time)
}
inline void Options::set_date_time(const char* value) {
  if (!has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_date_time_.date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:valhalla.Options.date_time)
}
inline void Options::set_date_time(const char* value, size_t size) {
  if (!has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  has_date_time_.date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.date_time)
}
inline ::std::string* Options::mutable_date_time() {
  if (!has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Options.date_time)
  return has_date_time_.date_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Options::release_date_time() {
  // @@protoc_insertion_point(field_release:valhalla.Options.date_time)
  if (has_date_time()) {
    clear_has_has_date_time();
    return has_date_time_.date_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Options::set_allocated_date_time(::std::string* date_time) {
  if (!has_date_time()) {
    has_date_time_.date_time_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_has_date_time();
  if (date_time != NULL) {
    set_has_date_time();
    has_date_time_.date_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        date_time);
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.date_time)
}

// repeated .valhalla.Location shape = 20;
inline int Options::shape_size() const {
  return shape_.size();
}
inline void Options::clear_shape() {
  shape_.Clear();
}
inline const ::valhalla::Location& Options::shape(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape)
  return shape_.Get(index);
}
inline ::valhalla::Location* Options::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.shape)
  return shape_.Mutable(index);
}
inline ::valhalla::Location* Options::add_shape() {
  // @@protoc_insertion_point(field_add:valhalla.Options.shape)
  return shape_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.shape)
  return &shape_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::shape() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.shape)
  return shape_;
}

// optional double resample_distance = 21;
inline bool Options::has_resample_distance() const {
  return has_resample_distance_case() == kResampleDistance;
}
inline void Options::set_has_resample_distance() {
  _oneof_case_[13] = kResampleDistance;
}
inline void Options::clear_resample_distance() {
  if (has_resample_distance()) {
    has_resample_distance_.resample_distance_ = 0;
    clear_has_has_resample_distance();
  }
}
inline double Options::resample_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.resample_distance)
  if (has_resample_distance()) {
    return has_resample_distance_.resample_distance_;
  }
  return 0;
}
inline void Options::set_resample_distance(double value) {
  if (!has_resample_distance()) {
    clear_has_resample_distance();
    set_has_resample_distance();
  }
  has_resample_distance_.resample_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.resample_distance)
}

// repeated .valhalla.Contour contours = 22;
inline int Options::contours_size() const {
  return contours_.size();
}
inline void Options::clear_contours() {
  contours_.Clear();
}
inline const ::valhalla::Contour& Options::contours(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.contours)
  return contours_.Get(index);
}
inline ::valhalla::Contour* Options::mutable_contours(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.contours)
  return contours_.Mutable(index);
}
inline ::valhalla::Contour* Options::add_contours() {
  // @@protoc_insertion_point(field_add:valhalla.Options.contours)
  return contours_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >*
Options::mutable_contours() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.contours)
  return &contours_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >&
Options::contours() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.contours)
  return contours_;
}

// optional bool polygons = 23;
inline bool Options::has_polygons() const {
  return has_polygons_case() == kPolygons;
}
inline void Options::set_has_polygons() {
  _oneof_case_[14] = kPolygons;
}
inline void Options::clear_polygons() {
  if (has_polygons()) {
    has_polygons_.polygons_ = false;
    clear_has_has_polygons();
  }
}
inline bool Options::polygons() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.polygons)
  if (has_polygons()) {
    return has_polygons_.polygons_;
  }
  return false;
}
inline void Options::set_polygons(bool value) {
  if (!has_polygons()) {
    clear_has_polygons();
    set_has_polygons();
  }
  has_polygons_.polygons_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.polygons)
}

// optional float denoise = 24;
inline bool Options::has_denoise() const {
  return has_denoise_case() == kDenoise;
}
inline void Options::set_has_denoise() {
  _oneof_case_[15] = kDenoise;
}
inline void Options::clear_denoise() {
  if (has_denoise()) {
    has_denoise_.denoise_ = 0;
    clear_has_has_denoise();
  }
}
inline float Options::denoise() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.denoise)
  if (has_denoise()) {
    return has_denoise_.denoise_;
  }
  return 0;
}
inline void Options::set_denoise(float value) {
  if (!has_denoise()) {
    clear_has_denoise();
    set_has_denoise();
  }
  has_denoise_.denoise_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.denoise)
}

// optional float generalize = 25;
inline bool Options::has_generalize() const {
  return has_generalize_case() == kGeneralize;
}
inline void Options::set_has_generalize() {
  _oneof_case_[16] = kGeneralize;
}
inline void Options::clear_generalize() {
  if (has_generalize()) {
    has_generalize_.generalize_ = 0;
    clear_has_has_generalize();
  }
}
inline float Options::generalize() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.generalize)
  if (has_generalize()) {
    return has_generalize_.generalize_;
  }
  return 0;
}
inline void Options::set_generalize(float value) {
  if (!has_generalize()) {
    clear_has_generalize();
    set_has_generalize();
  }
  has_generalize_.generalize_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.generalize)
}

// optional bool show_locations = 26;
inline bool Options::has_show_locations() const {
  return has_show_locations_case() == kShowLocations;
}
inline void Options::set_has_show_locations() {
  _oneof_case_[17] = kShowLocations;
}
inline void Options::clear_show_locations() {
  if (has_show_locations()) {
    has_show_locations_.show_locations_ = false;
    clear_has_has_show_locations();
  }
}
inline bool Options::show_locations() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.show_locations)
  if (has_show_locations()) {
    return has_show_locations_.show_locations_;
  }
  return false;
}
inline void Options::set_show_locations(bool value) {
  if (!has_show_locations()) {
    clear_has_show_locations();
    set_has_show_locations();
  }
  has_show_locations_.show_locations_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.show_locations)
}

// repeated .valhalla.Location trace = 27;
inline int Options::trace_size() const {
  return trace_.size();
}
inline void Options::clear_trace() {
  trace_.Clear();
}
inline const ::valhalla::Location& Options::trace(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.trace)
  return trace_.Get(index);
}
inline ::valhalla::Location* Options::mutable_trace(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.trace)
  return trace_.Mutable(index);
}
inline ::valhalla::Location* Options::add_trace() {
  // @@protoc_insertion_point(field_add:valhalla.Options.trace)
  return trace_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_trace() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.trace)
  return &trace_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::trace() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.trace)
  return trace_;
}

// optional .valhalla.ShapeMatch shape_match = 28;
inline bool Options::has_shape_match() const {
  return has_shape_match_case() == kShapeMatch;
}
inline void Options::set_has_shape_match() {
  _oneof_case_[18] = kShapeMatch;
}
inline void Options::clear_shape_match() {
  if (has_shape_match()) {
    has_shape_match_.shape_match_ = 0;
    clear_has_has_shape_match();
  }
}
inline ::valhalla::ShapeMatch Options::shape_match() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_match)
  if (has_shape_match()) {
    return static_cast< ::valhalla::ShapeMatch >(has_shape_match_.shape_match_);
  }
  return static_cast< ::valhalla::ShapeMatch >(0);
}
inline void Options::set_shape_match(::valhalla::ShapeMatch value) {
  if (!has_shape_match()) {
    clear_has_shape_match();
    set_has_shape_match();
  }
  has_shape_match_.shape_match_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_match)
}

// optional float gps_accuracy = 30;
inline bool Options::has_gps_accuracy() const {
  return has_gps_accuracy_case() == kGpsAccuracy;
}
inline void Options::set_has_gps_accuracy() {
  _oneof_case_[19] = kGpsAccuracy;
}
inline void Options::clear_gps_accuracy() {
  if (has_gps_accuracy()) {
    has_gps_accuracy_.gps_accuracy_ = 0;
    clear_has_has_gps_accuracy();
  }
}
inline float Options::gps_accuracy() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.gps_accuracy)
  if (has_gps_accuracy()) {
    return has_gps_accuracy_.gps_accuracy_;
  }
  return 0;
}
inline void Options::set_gps_accuracy(float value) {
  if (!has_gps_accuracy()) {
    clear_has_gps_accuracy();
    set_has_gps_accuracy();
  }
  has_gps_accuracy_.gps_accuracy_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.gps_accuracy)
}

// optional float search_radius = 31;
inline bool Options::has_search_radius() const {
  return has_search_radius_case() == kSearchRadius;
}
inline void Options::set_has_search_radius() {
  _oneof_case_[20] = kSearchRadius;
}
inline void Options::clear_search_radius() {
  if (has_search_radius()) {
    has_search_radius_.search_radius_ = 0;
    clear_has_has_search_radius();
  }
}
inline float Options::search_radius() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.search_radius)
  if (has_search_radius()) {
    return has_search_radius_.search_radius_;
  }
  return 0;
}
inline void Options::set_search_radius(float value) {
  if (!has_search_radius()) {
    clear_has_search_radius();
    set_has_search_radius();
  }
  has_search_radius_.search_radius_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.search_radius)
}

// optional float turn_penalty_factor = 32;
inline bool Options::has_turn_penalty_factor() const {
  return has_turn_penalty_factor_case() == kTurnPenaltyFactor;
}
inline void Options::set_has_turn_penalty_factor() {
  _oneof_case_[21] = kTurnPenaltyFactor;
}
inline void Options::clear_turn_penalty_factor() {
  if (has_turn_penalty_factor()) {
    has_turn_penalty_factor_.turn_penalty_factor_ = 0;
    clear_has_has_turn_penalty_factor();
  }
}
inline float Options::turn_penalty_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.turn_penalty_factor)
  if (has_turn_penalty_factor()) {
    return has_turn_penalty_factor_.turn_penalty_factor_;
  }
  return 0;
}
inline void Options::set_turn_penalty_factor(float value) {
  if (!has_turn_penalty_factor()) {
    clear_has_turn_penalty_factor();
    set_has_turn_penalty_factor();
  }
  has_turn_penalty_factor_.turn_penalty_factor_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.turn_penalty_factor)
}

// optional .valhalla.FilterAction filter_action = 33;
inline void Options::clear_filter_action() {
  filter_action_ = 0;
}
inline ::valhalla::FilterAction Options::filter_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_action)
  return static_cast< ::valhalla::FilterAction >(filter_action_);
}
inline void Options::set_filter_action(::valhalla::FilterAction value) {
  
  filter_action_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_action)
}

// repeated string filter_attributes = 34;
inline int Options::filter_attributes_size() const {
  return filter_attributes_.size();
}
inline void Options::clear_filter_attributes() {
  filter_attributes_.Clear();
}
inline const ::std::string& Options::filter_attributes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_attributes)
  return filter_attributes_.Get(index);
}
inline ::std::string* Options::mutable_filter_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.filter_attributes)
  return filter_attributes_.Mutable(index);
}
inline void Options::set_filter_attributes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
  filter_attributes_.Mutable(index)->assign(value);
}
inline void Options::set_filter_attributes(int index, const char* value) {
  filter_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value, size_t size) {
  filter_attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.filter_attributes)
}
inline ::std::string* Options::add_filter_attributes() {
  // @@protoc_insertion_point(field_add_mutable:valhalla.Options.filter_attributes)
  return filter_attributes_.Add();
}
inline void Options::add_filter_attributes(const ::std::string& value) {
  filter_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value) {
  filter_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value, size_t size) {
  filter_attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Options.filter_attributes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Options::filter_attributes() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.filter_attributes)
  return filter_attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Options::mutable_filter_attributes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.filter_attributes)
  return &filter_attributes_;
}

// optional float breakage_distance = 36;
inline bool Options::has_breakage_distance() const {
  return has_breakage_distance_case() == kBreakageDistance;
}
inline void Options::set_has_breakage_distance() {
  _oneof_case_[22] = kBreakageDistance;
}
inline void Options::clear_breakage_distance() {
  if (has_breakage_distance()) {
    has_breakage_distance_.breakage_distance_ = 0;
    clear_has_has_breakage_distance();
  }
}
inline float Options::breakage_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.breakage_distance)
  if (has_breakage_distance()) {
    return has_breakage_distance_.breakage_distance_;
  }
  return 0;
}
inline void Options::set_breakage_distance(float value) {
  if (!has_breakage_distance()) {
    clear_has_breakage_distance();
    set_has_breakage_distance();
  }
  has_breakage_distance_.breakage_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.breakage_distance)
}

// optional bool use_timestamps = 37;
inline bool Options::has_use_timestamps() const {
  return has_use_timestamps_case() == kUseTimestamps;
}
inline void Options::set_has_use_timestamps() {
  _oneof_case_[23] = kUseTimestamps;
}
inline void Options::clear_use_timestamps() {
  if (has_use_timestamps()) {
    has_use_timestamps_.use_timestamps_ = false;
    clear_has_has_use_timestamps();
  }
}
inline bool Options::use_timestamps() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.use_timestamps)
  if (has_use_timestamps()) {
    return has_use_timestamps_.use_timestamps_;
  }
  return false;
}
inline void Options::set_use_timestamps(bool value) {
  if (!has_use_timestamps()) {
    clear_has_use_timestamps();
    set_has_use_timestamps();
  }
  has_use_timestamps_.use_timestamps_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.use_timestamps)
}

// optional .valhalla.ShapeFormat shape_format = 38;
inline bool Options::has_shape_format() const {
  return has_shape_format_case() == kShapeFormat;
}
inline void Options::set_has_shape_format() {
  _oneof_case_[24] = kShapeFormat;
}
inline void Options::clear_shape_format() {
  if (has_shape_format()) {
    has_shape_format_.shape_format_ = 0;
    clear_has_has_shape_format();
  }
}
inline ::valhalla::ShapeFormat Options::shape_format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_format)
  if (has_shape_format()) {
    return static_cast< ::valhalla::ShapeFormat >(has_shape_format_.shape_format_);
  }
  return static_cast< ::valhalla::ShapeFormat >(0);
}
inline void Options::set_shape_format(::valhalla::ShapeFormat value) {
  if (!has_shape_format()) {
    clear_has_shape_format();
    set_has_shape_format();
  }
  has_shape_format_.shape_format_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_format)
}

// optional uint32 alternates = 39;
inline bool Options::has_alternates() const {
  return has_alternates_case() == kAlternates;
}
inline void Options::set_has_alternates() {
  _oneof_case_[25] = kAlternates;
}
inline void Options::clear_alternates() {
  if (has_alternates()) {
    has_alternates_.alternates_ = 0u;
    clear_has_has_alternates();
  }
}
inline ::google::protobuf::uint32 Options::alternates() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.alternates)
  if (has_alternates()) {
    return has_alternates_.alternates_;
  }
  return 0u;
}
inline void Options::set_alternates(::google::protobuf::uint32 value) {
  if (!has_alternates()) {
    clear_has_alternates();
    set_has_alternates();
  }
  has_alternates_.alternates_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.alternates)
}

// optional float interpolation_distance = 40;
inline bool Options::has_interpolation_distance() const {
  return has_interpolation_distance_case() == kInterpolationDistance;
}
inline void Options::set_has_interpolation_distance() {
  _oneof_case_[26] = kInterpolationDistance;
}
inline void Options::clear_interpolation_distance() {
  if (has_interpolation_distance()) {
    has_interpolation_distance_.interpolation_distance_ = 0;
    clear_has_has_interpolation_distance();
  }
}
inline float Options::interpolation_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.interpolation_distance)
  if (has_interpolation_distance()) {
    return has_interpolation_distance_.interpolation_distance_;
  }
  return 0;
}
inline void Options::set_interpolation_distance(float value) {
  if (!has_interpolation_distance()) {
    clear_has_interpolation_distance();
    set_has_interpolation_distance();
  }
  has_interpolation_distance_.interpolation_distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.interpolation_distance)
}

// optional bool guidance_views = 41;
inline bool Options::has_guidance_views() const {
  return has_guidance_views_case() == kGuidanceViews;
}
inline void Options::set_has_guidance_views() {
  _oneof_case_[27] = kGuidanceViews;
}
inline void Options::clear_guidance_views() {
  if (has_guidance_views()) {
    has_guidance_views_.guidance_views_ = false;
    clear_has_has_guidance_views();
  }
}
inline bool Options::guidance_views() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.guidance_views)
  if (has_guidance_views()) {
    return has_guidance_views_.guidance_views_;
  }
  return false;
}
inline void Options::set_guidance_views(bool value) {
  if (!has_guidance_views()) {
    clear_has_guidance_views();
    set_has_guidance_views();
  }
  has_guidance_views_.guidance_views_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.guidance_views)
}

// optional uint32 height_precision = 43;
inline bool Options::has_height_precision() const {
  return has_height_precision_case() == kHeightPrecision;
}
inline void Options::set_has_height_precision() {
  _oneof_case_[28] = kHeightPrecision;
}
inline void Options::clear_height_precision() {
  if (has_height_precision()) {
    has_height_precision_.height_precision_ = 0u;
    clear_has_has_height_precision();
  }
}
inline ::google::protobuf::uint32 Options::height_precision() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.height_precision)
  if (has_height_precision()) {
    return has_height_precision_.height_precision_;
  }
  return 0u;
}
inline void Options::set_height_precision(::google::protobuf::uint32 value) {
  if (!has_height_precision()) {
    clear_has_height_precision();
    set_has_height_precision();
  }
  has_height_precision_.height_precision_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.height_precision)
}

// optional bool roundabout_exits = 44;
inline bool Options::has_roundabout_exits() const {
  return has_roundabout_exits_case() == kRoundaboutExits;
}
inline void Options::set_has_roundabout_exits() {
  _oneof_case_[29] = kRoundaboutExits;
}
inline void Options::clear_roundabout_exits() {
  if (has_roundabout_exits()) {
    has_roundabout_exits_.roundabout_exits_ = false;
    clear_has_has_roundabout_exits();
  }
}
inline bool Options::roundabout_exits() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.roundabout_exits)
  if (has_roundabout_exits()) {
    return has_roundabout_exits_.roundabout_exits_;
  }
  return false;
}
inline void Options::set_roundabout_exits(bool value) {
  if (!has_roundabout_exits()) {
    clear_has_roundabout_exits();
    set_has_roundabout_exits();
  }
  has_roundabout_exits_.roundabout_exits_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.roundabout_exits)
}

// optional bool linear_references = 45;
inline bool Options::has_linear_references() const {
  return has_linear_references_case() == kLinearReferences;
}
inline void Options::set_has_linear_references() {
  _oneof_case_[30] = kLinearReferences;
}
inline void Options::clear_linear_references() {
  if (has_linear_references()) {
    has_linear_references_.linear_references_ = false;
    clear_has_has_linear_references();
  }
}
inline bool Options::linear_references() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.linear_references)
  if (has_linear_references()) {
    return has_linear_references_.linear_references_;
  }
  return false;
}
inline void Options::set_linear_references(bool value) {
  if (!has_linear_references()) {
    clear_has_linear_references();
    set_has_linear_references();
  }
  has_linear_references_.linear_references_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.linear_references)
}

// repeated .valhalla.CostingOptions recostings = 46;
inline int Options::recostings_size() const {
  return recostings_.size();
}
inline void Options::clear_recostings() {
  recostings_.Clear();
}
inline const ::valhalla::CostingOptions& Options::recostings(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.recostings)
  return recostings_.Get(index);
}
inline ::valhalla::CostingOptions* Options::mutable_recostings(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.recostings)
  return recostings_.Mutable(index);
}
inline ::valhalla::CostingOptions* Options::add_recostings() {
  // @@protoc_insertion_point(field_add:valhalla.Options.recostings)
  return recostings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >*
Options::mutable_recostings() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.recostings)
  return &recostings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >&
Options::recostings() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.recostings)
  return recostings_;
}

// repeated .valhalla.Options.Ring exclude_polygons = 47;
inline int Options::exclude_polygons_size() const {
  return exclude_polygons_.size();
}
inline void Options::clear_exclude_polygons() {
  exclude_polygons_.Clear();
}
inline const ::valhalla::Options_Ring& Options::exclude_polygons(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.exclude_polygons)
  return exclude_polygons_.Get(index);
}
inline ::valhalla::Options_Ring* Options::mutable_exclude_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.exclude_polygons)
  return exclude_polygons_.Mutable(index);
}
inline ::valhalla::Options_Ring* Options::add_exclude_polygons() {
  // @@protoc_insertion_point(field_add:valhalla.Options.exclude_polygons)
  return exclude_polygons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Options_Ring >*
Options::mutable_exclude_polygons() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.exclude_polygons)
  return &exclude_polygons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Options_Ring >&
Options::exclude_polygons() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.exclude_polygons)
  return exclude_polygons_;
}

// optional bool prioritize_bidirectional = 48;
inline bool Options::has_prioritize_bidirectional() const {
  return has_prioritize_bidirectional_case() == kPrioritizeBidirectional;
}
inline void Options::set_has_prioritize_bidirectional() {
  _oneof_case_[31] = kPrioritizeBidirectional;
}
inline void Options::clear_prioritize_bidirectional() {
  if (has_prioritize_bidirectional()) {
    has_prioritize_bidirectional_.prioritize_bidirectional_ = false;
    clear_has_has_prioritize_bidirectional();
  }
}
inline bool Options::prioritize_bidirectional() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.prioritize_bidirectional)
  if (has_prioritize_bidirectional()) {
    return has_prioritize_bidirectional_.prioritize_bidirectional_;
  }
  return false;
}
inline void Options::set_prioritize_bidirectional(bool value) {
  if (!has_prioritize_bidirectional()) {
    clear_has_prioritize_bidirectional();
    set_has_prioritize_bidirectional();
  }
  has_prioritize_bidirectional_.prioritize_bidirectional_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.prioritize_bidirectional)
}

// optional .valhalla.Options.Action expansion_action = 49;
inline bool Options::has_expansion_action() const {
  return has_expansion_action_case() == kExpansionAction;
}
inline void Options::set_has_expansion_action() {
  _oneof_case_[32] = kExpansionAction;
}
inline void Options::clear_expansion_action() {
  if (has_expansion_action()) {
    has_expansion_action_.expansion_action_ = 0;
    clear_has_has_expansion_action();
  }
}
inline ::valhalla::Options_Action Options::expansion_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.expansion_action)
  if (has_expansion_action()) {
    return static_cast< ::valhalla::Options_Action >(has_expansion_action_.expansion_action_);
  }
  return static_cast< ::valhalla::Options_Action >(0);
}
inline void Options::set_expansion_action(::valhalla::Options_Action value) {
  if (!has_expansion_action()) {
    clear_has_expansion_action();
    set_has_expansion_action();
  }
  has_expansion_action_.expansion_action_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.expansion_action)
}

// optional bool skip_opposites = 50;
inline bool Options::has_skip_opposites() const {
  return has_skip_opposites_case() == kSkipOpposites;
}
inline void Options::set_has_skip_opposites() {
  _oneof_case_[33] = kSkipOpposites;
}
inline void Options::clear_skip_opposites() {
  if (has_skip_opposites()) {
    has_skip_opposites_.skip_opposites_ = false;
    clear_has_has_skip_opposites();
  }
}
inline bool Options::skip_opposites() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.skip_opposites)
  if (has_skip_opposites()) {
    return has_skip_opposites_.skip_opposites_;
  }
  return false;
}
inline void Options::set_skip_opposites(bool value) {
  if (!has_skip_opposites()) {
    clear_has_skip_opposites();
    set_has_skip_opposites();
  }
  has_skip_opposites_.skip_opposites_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Options.skip_opposites)
}

// repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
inline int Options::expansion_properties_size() const {
  return expansion_properties_.size();
}
inline void Options::clear_expansion_properties() {
  expansion_properties_.Clear();
}
inline ::valhalla::Options_ExpansionProperties Options::expansion_properties(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.expansion_properties)
  return static_cast< ::valhalla::Options_ExpansionProperties >(expansion_properties_.Get(index));
}
inline void Options::set_expansion_properties(int index, ::valhalla::Options_ExpansionProperties value) {
  expansion_properties_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.Options.expansion_properties)
}
inline void Options::add_expansion_properties(::valhalla::Options_ExpansionProperties value) {
  expansion_properties_.Add(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.expansion_properties)
}
inline const ::google::protobuf::RepeatedField<int>&
Options::expansion_properties() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.expansion_properties)
  return expansion_properties_;
}
inline ::google::protobuf::RepeatedField<int>*
Options::mutable_expansion_properties() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.expansion_properties)
  return &expansion_properties_;
}

inline bool Options::has_has_units() const {
  return has_units_case() != HAS_UNITS_NOT_SET;
}
inline void Options::clear_has_has_units() {
  _oneof_case_[0] = HAS_UNITS_NOT_SET;
}
inline bool Options::has_has_language() const {
  return has_language_case() != HAS_LANGUAGE_NOT_SET;
}
inline void Options::clear_has_has_language() {
  _oneof_case_[1] = HAS_LANGUAGE_NOT_SET;
}
inline bool Options::has_has_directions_type() const {
  return has_directions_type_case() != HAS_DIRECTIONS_TYPE_NOT_SET;
}
inline void Options::clear_has_has_directions_type() {
  _oneof_case_[2] = HAS_DIRECTIONS_TYPE_NOT_SET;
}
inline bool Options::has_has_format() const {
  return has_format_case() != HAS_FORMAT_NOT_SET;
}
inline void Options::clear_has_has_format() {
  _oneof_case_[3] = HAS_FORMAT_NOT_SET;
}
inline bool Options::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void Options::clear_has_has_id() {
  _oneof_case_[4] = HAS_ID_NOT_SET;
}
inline bool Options::has_has_jsonp() const {
  return has_jsonp_case() != HAS_JSONP_NOT_SET;
}
inline void Options::clear_has_has_jsonp() {
  _oneof_case_[5] = HAS_JSONP_NOT_SET;
}
inline bool Options::has_has_encoded_polyline() const {
  return has_encoded_polyline_case() != HAS_ENCODED_POLYLINE_NOT_SET;
}
inline void Options::clear_has_has_encoded_polyline() {
  _oneof_case_[6] = HAS_ENCODED_POLYLINE_NOT_SET;
}
inline bool Options::has_has_action() const {
  return has_action_case() != HAS_ACTION_NOT_SET;
}
inline void Options::clear_has_has_action() {
  _oneof_case_[7] = HAS_ACTION_NOT_SET;
}
inline bool Options::has_has_range() const {
  return has_range_case() != HAS_RANGE_NOT_SET;
}
inline void Options::clear_has_has_range() {
  _oneof_case_[8] = HAS_RANGE_NOT_SET;
}
inline bool Options::has_has_verbose() const {
  return has_verbose_case() != HAS_VERBOSE_NOT_SET;
}
inline void Options::clear_has_has_verbose() {
  _oneof_case_[9] = HAS_VERBOSE_NOT_SET;
}
inline bool Options::has_has_costing() const {
  return has_costing_case() != HAS_COSTING_NOT_SET;
}
inline void Options::clear_has_has_costing() {
  _oneof_case_[10] = HAS_COSTING_NOT_SET;
}
inline bool Options::has_has_date_time_type() const {
  return has_date_time_type_case() != HAS_DATE_TIME_TYPE_NOT_SET;
}
inline void Options::clear_has_has_date_time_type() {
  _oneof_case_[11] = HAS_DATE_TIME_TYPE_NOT_SET;
}
inline bool Options::has_has_date_time() const {
  return has_date_time_case() != HAS_DATE_TIME_NOT_SET;
}
inline void Options::clear_has_has_date_time() {
  _oneof_case_[12] = HAS_DATE_TIME_NOT_SET;
}
inline bool Options::has_has_resample_distance() const {
  return has_resample_distance_case() != HAS_RESAMPLE_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_resample_distance() {
  _oneof_case_[13] = HAS_RESAMPLE_DISTANCE_NOT_SET;
}
inline bool Options::has_has_polygons() const {
  return has_polygons_case() != HAS_POLYGONS_NOT_SET;
}
inline void Options::clear_has_has_polygons() {
  _oneof_case_[14] = HAS_POLYGONS_NOT_SET;
}
inline bool Options::has_has_denoise() const {
  return has_denoise_case() != HAS_DENOISE_NOT_SET;
}
inline void Options::clear_has_has_denoise() {
  _oneof_case_[15] = HAS_DENOISE_NOT_SET;
}
inline bool Options::has_has_generalize() const {
  return has_generalize_case() != HAS_GENERALIZE_NOT_SET;
}
inline void Options::clear_has_has_generalize() {
  _oneof_case_[16] = HAS_GENERALIZE_NOT_SET;
}
inline bool Options::has_has_show_locations() const {
  return has_show_locations_case() != HAS_SHOW_LOCATIONS_NOT_SET;
}
inline void Options::clear_has_has_show_locations() {
  _oneof_case_[17] = HAS_SHOW_LOCATIONS_NOT_SET;
}
inline bool Options::has_has_shape_match() const {
  return has_shape_match_case() != HAS_SHAPE_MATCH_NOT_SET;
}
inline void Options::clear_has_has_shape_match() {
  _oneof_case_[18] = HAS_SHAPE_MATCH_NOT_SET;
}
inline bool Options::has_has_gps_accuracy() const {
  return has_gps_accuracy_case() != HAS_GPS_ACCURACY_NOT_SET;
}
inline void Options::clear_has_has_gps_accuracy() {
  _oneof_case_[19] = HAS_GPS_ACCURACY_NOT_SET;
}
inline bool Options::has_has_search_radius() const {
  return has_search_radius_case() != HAS_SEARCH_RADIUS_NOT_SET;
}
inline void Options::clear_has_has_search_radius() {
  _oneof_case_[20] = HAS_SEARCH_RADIUS_NOT_SET;
}
inline bool Options::has_has_turn_penalty_factor() const {
  return has_turn_penalty_factor_case() != HAS_TURN_PENALTY_FACTOR_NOT_SET;
}
inline void Options::clear_has_has_turn_penalty_factor() {
  _oneof_case_[21] = HAS_TURN_PENALTY_FACTOR_NOT_SET;
}
inline bool Options::has_has_breakage_distance() const {
  return has_breakage_distance_case() != HAS_BREAKAGE_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_breakage_distance() {
  _oneof_case_[22] = HAS_BREAKAGE_DISTANCE_NOT_SET;
}
inline bool Options::has_has_use_timestamps() const {
  return has_use_timestamps_case() != HAS_USE_TIMESTAMPS_NOT_SET;
}
inline void Options::clear_has_has_use_timestamps() {
  _oneof_case_[23] = HAS_USE_TIMESTAMPS_NOT_SET;
}
inline bool Options::has_has_shape_format() const {
  return has_shape_format_case() != HAS_SHAPE_FORMAT_NOT_SET;
}
inline void Options::clear_has_has_shape_format() {
  _oneof_case_[24] = HAS_SHAPE_FORMAT_NOT_SET;
}
inline bool Options::has_has_alternates() const {
  return has_alternates_case() != HAS_ALTERNATES_NOT_SET;
}
inline void Options::clear_has_has_alternates() {
  _oneof_case_[25] = HAS_ALTERNATES_NOT_SET;
}
inline bool Options::has_has_interpolation_distance() const {
  return has_interpolation_distance_case() != HAS_INTERPOLATION_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_interpolation_distance() {
  _oneof_case_[26] = HAS_INTERPOLATION_DISTANCE_NOT_SET;
}
inline bool Options::has_has_guidance_views() const {
  return has_guidance_views_case() != HAS_GUIDANCE_VIEWS_NOT_SET;
}
inline void Options::clear_has_has_guidance_views() {
  _oneof_case_[27] = HAS_GUIDANCE_VIEWS_NOT_SET;
}
inline bool Options::has_has_height_precision() const {
  return has_height_precision_case() != HAS_HEIGHT_PRECISION_NOT_SET;
}
inline void Options::clear_has_has_height_precision() {
  _oneof_case_[28] = HAS_HEIGHT_PRECISION_NOT_SET;
}
inline bool Options::has_has_roundabout_exits() const {
  return has_roundabout_exits_case() != HAS_ROUNDABOUT_EXITS_NOT_SET;
}
inline void Options::clear_has_has_roundabout_exits() {
  _oneof_case_[29] = HAS_ROUNDABOUT_EXITS_NOT_SET;
}
inline bool Options::has_has_linear_references() const {
  return has_linear_references_case() != HAS_LINEAR_REFERENCES_NOT_SET;
}
inline void Options::clear_has_has_linear_references() {
  _oneof_case_[30] = HAS_LINEAR_REFERENCES_NOT_SET;
}
inline bool Options::has_has_prioritize_bidirectional() const {
  return has_prioritize_bidirectional_case() != HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}
inline void Options::clear_has_has_prioritize_bidirectional() {
  _oneof_case_[31] = HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}
inline bool Options::has_has_expansion_action() const {
  return has_expansion_action_case() != HAS_EXPANSION_ACTION_NOT_SET;
}
inline void Options::clear_has_has_expansion_action() {
  _oneof_case_[32] = HAS_EXPANSION_ACTION_NOT_SET;
}
inline bool Options::has_has_skip_opposites() const {
  return has_skip_opposites_case() != HAS_SKIP_OPPOSITES_NOT_SET;
}
inline void Options::clear_has_has_skip_opposites() {
  _oneof_case_[33] = HAS_SKIP_OPPOSITES_NOT_SET;
}
inline Options::HasUnitsCase Options::has_units_case() const {
  return Options::HasUnitsCase(_oneof_case_[0]);
}
inline Options::HasLanguageCase Options::has_language_case() const {
  return Options::HasLanguageCase(_oneof_case_[1]);
}
inline Options::HasDirectionsTypeCase Options::has_directions_type_case() const {
  return Options::HasDirectionsTypeCase(_oneof_case_[2]);
}
inline Options::HasFormatCase Options::has_format_case() const {
  return Options::HasFormatCase(_oneof_case_[3]);
}
inline Options::HasIdCase Options::has_id_case() const {
  return Options::HasIdCase(_oneof_case_[4]);
}
inline Options::HasJsonpCase Options::has_jsonp_case() const {
  return Options::HasJsonpCase(_oneof_case_[5]);
}
inline Options::HasEncodedPolylineCase Options::has_encoded_polyline_case() const {
  return Options::HasEncodedPolylineCase(_oneof_case_[6]);
}
inline Options::HasActionCase Options::has_action_case() const {
  return Options::HasActionCase(_oneof_case_[7]);
}
inline Options::HasRangeCase Options::has_range_case() const {
  return Options::HasRangeCase(_oneof_case_[8]);
}
inline Options::HasVerboseCase Options::has_verbose_case() const {
  return Options::HasVerboseCase(_oneof_case_[9]);
}
inline Options::HasCostingCase Options::has_costing_case() const {
  return Options::HasCostingCase(_oneof_case_[10]);
}
inline Options::HasDateTimeTypeCase Options::has_date_time_type_case() const {
  return Options::HasDateTimeTypeCase(_oneof_case_[11]);
}
inline Options::HasDateTimeCase Options::has_date_time_case() const {
  return Options::HasDateTimeCase(_oneof_case_[12]);
}
inline Options::HasResampleDistanceCase Options::has_resample_distance_case() const {
  return Options::HasResampleDistanceCase(_oneof_case_[13]);
}
inline Options::HasPolygonsCase Options::has_polygons_case() const {
  return Options::HasPolygonsCase(_oneof_case_[14]);
}
inline Options::HasDenoiseCase Options::has_denoise_case() const {
  return Options::HasDenoiseCase(_oneof_case_[15]);
}
inline Options::HasGeneralizeCase Options::has_generalize_case() const {
  return Options::HasGeneralizeCase(_oneof_case_[16]);
}
inline Options::HasShowLocationsCase Options::has_show_locations_case() const {
  return Options::HasShowLocationsCase(_oneof_case_[17]);
}
inline Options::HasShapeMatchCase Options::has_shape_match_case() const {
  return Options::HasShapeMatchCase(_oneof_case_[18]);
}
inline Options::HasGpsAccuracyCase Options::has_gps_accuracy_case() const {
  return Options::HasGpsAccuracyCase(_oneof_case_[19]);
}
inline Options::HasSearchRadiusCase Options::has_search_radius_case() const {
  return Options::HasSearchRadiusCase(_oneof_case_[20]);
}
inline Options::HasTurnPenaltyFactorCase Options::has_turn_penalty_factor_case() const {
  return Options::HasTurnPenaltyFactorCase(_oneof_case_[21]);
}
inline Options::HasBreakageDistanceCase Options::has_breakage_distance_case() const {
  return Options::HasBreakageDistanceCase(_oneof_case_[22]);
}
inline Options::HasUseTimestampsCase Options::has_use_timestamps_case() const {
  return Options::HasUseTimestampsCase(_oneof_case_[23]);
}
inline Options::HasShapeFormatCase Options::has_shape_format_case() const {
  return Options::HasShapeFormatCase(_oneof_case_[24]);
}
inline Options::HasAlternatesCase Options::has_alternates_case() const {
  return Options::HasAlternatesCase(_oneof_case_[25]);
}
inline Options::HasInterpolationDistanceCase Options::has_interpolation_distance_case() const {
  return Options::HasInterpolationDistanceCase(_oneof_case_[26]);
}
inline Options::HasGuidanceViewsCase Options::has_guidance_views_case() const {
  return Options::HasGuidanceViewsCase(_oneof_case_[27]);
}
inline Options::HasHeightPrecisionCase Options::has_height_precision_case() const {
  return Options::HasHeightPrecisionCase(_oneof_case_[28]);
}
inline Options::HasRoundaboutExitsCase Options::has_roundabout_exits_case() const {
  return Options::HasRoundaboutExitsCase(_oneof_case_[29]);
}
inline Options::HasLinearReferencesCase Options::has_linear_references_case() const {
  return Options::HasLinearReferencesCase(_oneof_case_[30]);
}
inline Options::HasPrioritizeBidirectionalCase Options::has_prioritize_bidirectional_case() const {
  return Options::HasPrioritizeBidirectionalCase(_oneof_case_[31]);
}
inline Options::HasExpansionActionCase Options::has_expansion_action_case() const {
  return Options::HasExpansionActionCase(_oneof_case_[32]);
}
inline Options::HasSkipOppositesCase Options::has_skip_opposites_case() const {
  return Options::HasSkipOppositesCase(_oneof_case_[33]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::valhalla::Options_Units> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Format> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Action> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_DateTimeType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_ExpansionProperties> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::ShapeMatch> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::FilterAction> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::ShapeFormat> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::valhalla::Costing> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_options_2eproto__INCLUDED
