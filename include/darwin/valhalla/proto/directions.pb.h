// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_directions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_directions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"
#include "sign.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_directions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_directions_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace valhalla {
class Directions;
struct DirectionsDefaultTypeInternal;
extern DirectionsDefaultTypeInternal _Directions_default_instance_;
class DirectionsLeg;
struct DirectionsLegDefaultTypeInternal;
extern DirectionsLegDefaultTypeInternal _DirectionsLeg_default_instance_;
class DirectionsLeg_GuidanceView;
struct DirectionsLeg_GuidanceViewDefaultTypeInternal;
extern DirectionsLeg_GuidanceViewDefaultTypeInternal _DirectionsLeg_GuidanceView_default_instance_;
class DirectionsLeg_Maneuver;
struct DirectionsLeg_ManeuverDefaultTypeInternal;
extern DirectionsLeg_ManeuverDefaultTypeInternal _DirectionsLeg_Maneuver_default_instance_;
class DirectionsLeg_Summary;
struct DirectionsLeg_SummaryDefaultTypeInternal;
extern DirectionsLeg_SummaryDefaultTypeInternal _DirectionsLeg_Summary_default_instance_;
class DirectionsRoute;
struct DirectionsRouteDefaultTypeInternal;
extern DirectionsRouteDefaultTypeInternal _DirectionsRoute_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::Directions* Arena::CreateMaybeMessage<::valhalla::Directions>(Arena*);
template<> ::valhalla::DirectionsLeg* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg>(Arena*);
template<> ::valhalla::DirectionsLeg_GuidanceView* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_GuidanceView>(Arena*);
template<> ::valhalla::DirectionsLeg_Maneuver* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Maneuver>(Arena*);
template<> ::valhalla::DirectionsLeg_Summary* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Summary>(Arena*);
template<> ::valhalla::DirectionsRoute* Arena::CreateMaybeMessage<::valhalla::DirectionsRoute>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum DirectionsLeg_GuidanceView_Type : int {
  DirectionsLeg_GuidanceView_Type_kJunction = 0,
  DirectionsLeg_GuidanceView_Type_kSapa = 1,
  DirectionsLeg_GuidanceView_Type_kTollbranch = 2,
  DirectionsLeg_GuidanceView_Type_kAftertoll = 3,
  DirectionsLeg_GuidanceView_Type_kEnt = 4,
  DirectionsLeg_GuidanceView_Type_kExit = 5,
  DirectionsLeg_GuidanceView_Type_kCityreal = 6,
  DirectionsLeg_GuidanceView_Type_kDirectionboard = 7,
  DirectionsLeg_GuidanceView_Type_kSignboard = 8,
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DirectionsLeg_GuidanceView_Type_IsValid(int value);
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MIN = DirectionsLeg_GuidanceView_Type_kJunction;
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MAX = DirectionsLeg_GuidanceView_Type_kSignboard;
constexpr int DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE = DirectionsLeg_GuidanceView_Type_Type_MAX + 1;

const std::string& DirectionsLeg_GuidanceView_Type_Name(DirectionsLeg_GuidanceView_Type value);
template<typename T>
inline const std::string& DirectionsLeg_GuidanceView_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_GuidanceView_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_GuidanceView_Type_Name.");
  return DirectionsLeg_GuidanceView_Type_Name(static_cast<DirectionsLeg_GuidanceView_Type>(enum_t_value));
}
bool DirectionsLeg_GuidanceView_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_GuidanceView_Type* value);
enum DirectionsLeg_Maneuver_CardinalDirection : int {
  DirectionsLeg_Maneuver_CardinalDirection_kNorth = 0,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthEast = 1,
  DirectionsLeg_Maneuver_CardinalDirection_kEast = 2,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthEast = 3,
  DirectionsLeg_Maneuver_CardinalDirection_kSouth = 4,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthWest = 5,
  DirectionsLeg_Maneuver_CardinalDirection_kWest = 6,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthWest = 7,
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value);
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
constexpr int DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX + 1;

const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(DirectionsLeg_Maneuver_CardinalDirection value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_CardinalDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_CardinalDirection_Name.");
  return DirectionsLeg_Maneuver_CardinalDirection_Name(static_cast<DirectionsLeg_Maneuver_CardinalDirection>(enum_t_value));
}
bool DirectionsLeg_Maneuver_CardinalDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_CardinalDirection* value);
enum DirectionsLeg_Maneuver_Type : int {
  DirectionsLeg_Maneuver_Type_kNone = 0,
  DirectionsLeg_Maneuver_Type_kStart = 1,
  DirectionsLeg_Maneuver_Type_kStartRight = 2,
  DirectionsLeg_Maneuver_Type_kStartLeft = 3,
  DirectionsLeg_Maneuver_Type_kDestination = 4,
  DirectionsLeg_Maneuver_Type_kDestinationRight = 5,
  DirectionsLeg_Maneuver_Type_kDestinationLeft = 6,
  DirectionsLeg_Maneuver_Type_kBecomes = 7,
  DirectionsLeg_Maneuver_Type_kContinue = 8,
  DirectionsLeg_Maneuver_Type_kSlightRight = 9,
  DirectionsLeg_Maneuver_Type_kRight = 10,
  DirectionsLeg_Maneuver_Type_kSharpRight = 11,
  DirectionsLeg_Maneuver_Type_kUturnRight = 12,
  DirectionsLeg_Maneuver_Type_kUturnLeft = 13,
  DirectionsLeg_Maneuver_Type_kSharpLeft = 14,
  DirectionsLeg_Maneuver_Type_kLeft = 15,
  DirectionsLeg_Maneuver_Type_kSlightLeft = 16,
  DirectionsLeg_Maneuver_Type_kRampStraight = 17,
  DirectionsLeg_Maneuver_Type_kRampRight = 18,
  DirectionsLeg_Maneuver_Type_kRampLeft = 19,
  DirectionsLeg_Maneuver_Type_kExitRight = 20,
  DirectionsLeg_Maneuver_Type_kExitLeft = 21,
  DirectionsLeg_Maneuver_Type_kStayStraight = 22,
  DirectionsLeg_Maneuver_Type_kStayRight = 23,
  DirectionsLeg_Maneuver_Type_kStayLeft = 24,
  DirectionsLeg_Maneuver_Type_kMerge = 25,
  DirectionsLeg_Maneuver_Type_kRoundaboutEnter = 26,
  DirectionsLeg_Maneuver_Type_kRoundaboutExit = 27,
  DirectionsLeg_Maneuver_Type_kFerryEnter = 28,
  DirectionsLeg_Maneuver_Type_kFerryExit = 29,
  DirectionsLeg_Maneuver_Type_kTransit = 30,
  DirectionsLeg_Maneuver_Type_kTransitTransfer = 31,
  DirectionsLeg_Maneuver_Type_kTransitRemainOn = 32,
  DirectionsLeg_Maneuver_Type_kTransitConnectionStart = 33,
  DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer = 34,
  DirectionsLeg_Maneuver_Type_kTransitConnectionDestination = 35,
  DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination = 36,
  DirectionsLeg_Maneuver_Type_kMergeRight = 37,
  DirectionsLeg_Maneuver_Type_kMergeLeft = 38,
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DirectionsLeg_Maneuver_Type_IsValid(int value);
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MIN = DirectionsLeg_Maneuver_Type_kNone;
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MAX = DirectionsLeg_Maneuver_Type_kMergeLeft;
constexpr int DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE = DirectionsLeg_Maneuver_Type_Type_MAX + 1;

const std::string& DirectionsLeg_Maneuver_Type_Name(DirectionsLeg_Maneuver_Type value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_Type_Name.");
  return DirectionsLeg_Maneuver_Type_Name(static_cast<DirectionsLeg_Maneuver_Type>(enum_t_value));
}
bool DirectionsLeg_Maneuver_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_Type* value);
enum DirectionsLeg_Maneuver_BssManeuverType : int {
  DirectionsLeg_Maneuver_BssManeuverType_kNoneAction = 0,
  DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare = 1,
  DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare = 2,
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DirectionsLeg_Maneuver_BssManeuverType_IsValid(int value);
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN = DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX = DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
constexpr int DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX + 1;

const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(DirectionsLeg_Maneuver_BssManeuverType value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_BssManeuverType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_BssManeuverType_Name.");
  return DirectionsLeg_Maneuver_BssManeuverType_Name(static_cast<DirectionsLeg_Maneuver_BssManeuverType>(enum_t_value));
}
bool DirectionsLeg_Maneuver_BssManeuverType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_BssManeuverType* value);
// ===================================================================

class DirectionsLeg_Summary final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Summary) */ {
 public:
  inline DirectionsLeg_Summary() : DirectionsLeg_Summary(nullptr) {}
  ~DirectionsLeg_Summary() override;
  explicit constexpr DirectionsLeg_Summary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Summary(const DirectionsLeg_Summary& from);
  DirectionsLeg_Summary(DirectionsLeg_Summary&& from) noexcept
    : DirectionsLeg_Summary() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Summary& operator=(const DirectionsLeg_Summary& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Summary& operator=(DirectionsLeg_Summary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg_Summary& default_instance() {
    return *internal_default_instance();
  }
  enum HasLengthCase {
    kLength = 1,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasTimeCase {
    kTime = 2,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasHasTimeRestrictionsCase {
    kHasTimeRestrictions = 4,
    HAS_HAS_TIME_RESTRICTIONS_NOT_SET = 0,
  };

  static inline const DirectionsLeg_Summary* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Summary*>(
               &_DirectionsLeg_Summary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DirectionsLeg_Summary& a, DirectionsLeg_Summary& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Summary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Summary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Summary* New() const final {
    return new DirectionsLeg_Summary();
  }

  DirectionsLeg_Summary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_Summary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Summary& from);
  void MergeFrom(const DirectionsLeg_Summary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Summary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Summary";
  }
  protected:
  explicit DirectionsLeg_Summary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBboxFieldNumber = 3,
    kLengthFieldNumber = 1,
    kTimeFieldNumber = 2,
    kHasTimeRestrictionsFieldNumber = 4,
  };
  // .valhalla.BoundingBox bbox = 3;
  bool has_bbox() const;
  private:
  bool _internal_has_bbox() const;
  public:
  void clear_bbox();
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);
  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();
  public:
  void unsafe_arena_set_allocated_bbox(
      ::valhalla::BoundingBox* bbox);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  // float length = 1;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // double time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // bool has_time_restrictions = 4;
  bool has_has_time_restrictions() const;
  private:
  bool _internal_has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  void clear_has_length();
  HasLengthCase has_length_case() const;
  void clear_has_time();
  HasTimeCase has_time_case() const;
  void clear_has_has_time_restrictions();
  HasHasTimeRestrictionsCase has_has_time_restrictions_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Summary)
 private:
  class _Internal;
  void set_has_length();
  void set_has_time();
  void set_has_has_time_restrictions();

  inline bool has_has_length() const;
  inline void clear_has_has_length();

  inline bool has_has_time() const;
  inline void clear_has_has_time();

  inline bool has_has_has_time_restrictions() const;
  inline void clear_has_has_has_time_restrictions();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::valhalla::BoundingBox* bbox_;
  union HasLengthUnion {
    constexpr HasLengthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float length_;
  } has_length_;
  union HasTimeUnion {
    constexpr HasTimeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double time_;
  } has_time_;
  union HasHasTimeRestrictionsUnion {
    constexpr HasHasTimeRestrictionsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool has_time_restrictions_;
  } has_has_time_restrictions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[3];

  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_GuidanceView final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.GuidanceView) */ {
 public:
  inline DirectionsLeg_GuidanceView() : DirectionsLeg_GuidanceView(nullptr) {}
  ~DirectionsLeg_GuidanceView() override;
  explicit constexpr DirectionsLeg_GuidanceView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_GuidanceView(const DirectionsLeg_GuidanceView& from);
  DirectionsLeg_GuidanceView(DirectionsLeg_GuidanceView&& from) noexcept
    : DirectionsLeg_GuidanceView() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_GuidanceView& operator=(const DirectionsLeg_GuidanceView& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_GuidanceView& operator=(DirectionsLeg_GuidanceView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg_GuidanceView& default_instance() {
    return *internal_default_instance();
  }
  enum HasDataIdCase {
    kDataId = 1,
    HAS_DATA_ID_NOT_SET = 0,
  };

  enum HasTypeCase {
    kType = 2,
    HAS_TYPE_NOT_SET = 0,
  };

  enum HasBaseIdCase {
    kBaseId = 3,
    HAS_BASE_ID_NOT_SET = 0,
  };

  static inline const DirectionsLeg_GuidanceView* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_GuidanceView*>(
               &_DirectionsLeg_GuidanceView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DirectionsLeg_GuidanceView& a, DirectionsLeg_GuidanceView& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_GuidanceView* New() const final {
    return new DirectionsLeg_GuidanceView();
  }

  DirectionsLeg_GuidanceView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_GuidanceView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_GuidanceView& from);
  void MergeFrom(const DirectionsLeg_GuidanceView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_GuidanceView* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.GuidanceView";
  }
  protected:
  explicit DirectionsLeg_GuidanceView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_GuidanceView_Type Type;
  static constexpr Type kJunction =
    DirectionsLeg_GuidanceView_Type_kJunction;
  static constexpr Type kSapa =
    DirectionsLeg_GuidanceView_Type_kSapa;
  static constexpr Type kTollbranch =
    DirectionsLeg_GuidanceView_Type_kTollbranch;
  static constexpr Type kAftertoll =
    DirectionsLeg_GuidanceView_Type_kAftertoll;
  static constexpr Type kEnt =
    DirectionsLeg_GuidanceView_Type_kEnt;
  static constexpr Type kExit =
    DirectionsLeg_GuidanceView_Type_kExit;
  static constexpr Type kCityreal =
    DirectionsLeg_GuidanceView_Type_kCityreal;
  static constexpr Type kDirectionboard =
    DirectionsLeg_GuidanceView_Type_kDirectionboard;
  static constexpr Type kSignboard =
    DirectionsLeg_GuidanceView_Type_kSignboard;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_GuidanceView_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DirectionsLeg_GuidanceView_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DirectionsLeg_GuidanceView_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DirectionsLeg_GuidanceView_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DirectionsLeg_GuidanceView_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayIdsFieldNumber = 4,
    kDataIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBaseIdFieldNumber = 3,
  };
  // repeated string overlay_ids = 4;
  int overlay_ids_size() const;
  private:
  int _internal_overlay_ids_size() const;
  public:
  void clear_overlay_ids();
  const std::string& overlay_ids(int index) const;
  std::string* mutable_overlay_ids(int index);
  void set_overlay_ids(int index, const std::string& value);
  void set_overlay_ids(int index, std::string&& value);
  void set_overlay_ids(int index, const char* value);
  void set_overlay_ids(int index, const char* value, size_t size);
  std::string* add_overlay_ids();
  void add_overlay_ids(const std::string& value);
  void add_overlay_ids(std::string&& value);
  void add_overlay_ids(const char* value);
  void add_overlay_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& overlay_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_overlay_ids();
  private:
  const std::string& _internal_overlay_ids(int index) const;
  std::string* _internal_add_overlay_ids();
  public:

  // string data_id = 1;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const std::string& data_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_id();
  void set_allocated_data_id(std::string* data_id);
  private:
  const std::string& _internal_data_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_id(const std::string& value);
  std::string* _internal_mutable_data_id();
  public:

  // .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::DirectionsLeg_GuidanceView_Type type() const;
  void set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);
  private:
  ::valhalla::DirectionsLeg_GuidanceView_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);
  public:

  // string base_id = 3;
  bool has_base_id() const;
  private:
  bool _internal_has_base_id() const;
  public:
  void clear_base_id();
  const std::string& base_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_base_id();
  void set_allocated_base_id(std::string* base_id);
  private:
  const std::string& _internal_base_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_id(const std::string& value);
  std::string* _internal_mutable_base_id();
  public:

  void clear_has_data_id();
  HasDataIdCase has_data_id_case() const;
  void clear_has_type();
  HasTypeCase has_type_case() const;
  void clear_has_base_id();
  HasBaseIdCase has_base_id_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.GuidanceView)
 private:
  class _Internal;
  void set_has_data_id();
  void set_has_type();
  void set_has_base_id();

  inline bool has_has_data_id() const;
  inline void clear_has_has_data_id();

  inline bool has_has_type() const;
  inline void clear_has_has_type();

  inline bool has_has_base_id() const;
  inline void clear_has_has_base_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> overlay_ids_;
  union HasDataIdUnion {
    constexpr HasDataIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_id_;
  } has_data_id_;
  union HasTypeUnion {
    constexpr HasTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int type_;
  } has_type_;
  union HasBaseIdUnion {
    constexpr HasBaseIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_id_;
  } has_base_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[3];

  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver) */ {
 public:
  inline DirectionsLeg_Maneuver() : DirectionsLeg_Maneuver(nullptr) {}
  ~DirectionsLeg_Maneuver() override;
  explicit constexpr DirectionsLeg_Maneuver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from);
  DirectionsLeg_Maneuver(DirectionsLeg_Maneuver&& from) noexcept
    : DirectionsLeg_Maneuver() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Maneuver& operator=(const DirectionsLeg_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Maneuver& operator=(DirectionsLeg_Maneuver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg_Maneuver& default_instance() {
    return *internal_default_instance();
  }
  enum HasTypeCase {
    kType = 1,
    HAS_TYPE_NOT_SET = 0,
  };

  enum HasTextInstructionCase {
    kTextInstruction = 2,
    HAS_TEXT_INSTRUCTION_NOT_SET = 0,
  };

  enum HasLengthCase {
    kLength = 4,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasTimeCase {
    kTime = 5,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasBeginCardinalDirectionCase {
    kBeginCardinalDirection = 6,
    HAS_BEGIN_CARDINAL_DIRECTION_NOT_SET = 0,
  };

  enum HasBeginHeadingCase {
    kBeginHeading = 7,
    HAS_BEGIN_HEADING_NOT_SET = 0,
  };

  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 8,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 9,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasPortionsTollCase {
    kPortionsToll = 10,
    HAS_PORTIONS_TOLL_NOT_SET = 0,
  };

  enum HasPortionsUnpavedCase {
    kPortionsUnpaved = 11,
    HAS_PORTIONS_UNPAVED_NOT_SET = 0,
  };

  enum HasVerbalTransitionAlertInstructionCase {
    kVerbalTransitionAlertInstruction = 12,
    HAS_VERBAL_TRANSITION_ALERT_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalPreTransitionInstructionCase {
    kVerbalPreTransitionInstruction = 13,
    HAS_VERBAL_PRE_TRANSITION_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalPostTransitionInstructionCase {
    kVerbalPostTransitionInstruction = 14,
    HAS_VERBAL_POST_TRANSITION_INSTRUCTION_NOT_SET = 0,
  };

  enum HasRoundaboutExitCountCase {
    kRoundaboutExitCount = 17,
    HAS_ROUNDABOUT_EXIT_COUNT_NOT_SET = 0,
  };

  enum HasDepartInstructionCase {
    kDepartInstruction = 18,
    HAS_DEPART_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalDepartInstructionCase {
    kVerbalDepartInstruction = 19,
    HAS_VERBAL_DEPART_INSTRUCTION_NOT_SET = 0,
  };

  enum HasArriveInstructionCase {
    kArriveInstruction = 20,
    HAS_ARRIVE_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalArriveInstructionCase {
    kVerbalArriveInstruction = 21,
    HAS_VERBAL_ARRIVE_INSTRUCTION_NOT_SET = 0,
  };

  enum HasVerbalMultiCueCase {
    kVerbalMultiCue = 23,
    HAS_VERBAL_MULTI_CUE_NOT_SET = 0,
  };

  enum HasTravelModeCase {
    kTravelMode = 24,
    HAS_TRAVEL_MODE_NOT_SET = 0,
  };

  enum HasVehicleTypeCase {
    kVehicleType = 25,
    HAS_VEHICLE_TYPE_NOT_SET = 0,
  };

  enum HasPedestrianTypeCase {
    kPedestrianType = 26,
    HAS_PEDESTRIAN_TYPE_NOT_SET = 0,
  };

  enum HasBicycleTypeCase {
    kBicycleType = 27,
    HAS_BICYCLE_TYPE_NOT_SET = 0,
  };

  enum HasTransitTypeCase {
    kTransitType = 28,
    HAS_TRANSIT_TYPE_NOT_SET = 0,
  };

  enum HasBeginPathIndexCase {
    kBeginPathIndex = 29,
    HAS_BEGIN_PATH_INDEX_NOT_SET = 0,
  };

  enum HasEndPathIndexCase {
    kEndPathIndex = 30,
    HAS_END_PATH_INDEX_NOT_SET = 0,
  };

  enum HasToStayOnCase {
    kToStayOn = 31,
    HAS_TO_STAY_ON_NOT_SET = 0,
  };

  enum HasTurnDegreeCase {
    kTurnDegree = 33,
    HAS_TURN_DEGREE_NOT_SET = 0,
  };

  enum HasHasTimeRestrictionsCase {
    kHasTimeRestrictions = 34,
    HAS_HAS_TIME_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasBssManeuverTypeCase {
    kBssManeuverType = 36,
    HAS_BSS_MANEUVER_TYPE_NOT_SET = 0,
  };

  enum HasVerbalSuccinctTransitionInstructionCase {
    kVerbalSuccinctTransitionInstruction = 37,
    HAS_VERBAL_SUCCINCT_TRANSITION_INSTRUCTION_NOT_SET = 0,
  };

  static inline const DirectionsLeg_Maneuver* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Maneuver*>(
               &_DirectionsLeg_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DirectionsLeg_Maneuver& a, DirectionsLeg_Maneuver& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Maneuver* New() const final {
    return new DirectionsLeg_Maneuver();
  }

  DirectionsLeg_Maneuver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_Maneuver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Maneuver& from);
  void MergeFrom(const DirectionsLeg_Maneuver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Maneuver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Maneuver";
  }
  protected:
  explicit DirectionsLeg_Maneuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Maneuver_CardinalDirection CardinalDirection;
  static constexpr CardinalDirection kNorth =
    DirectionsLeg_Maneuver_CardinalDirection_kNorth;
  static constexpr CardinalDirection kNorthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthEast;
  static constexpr CardinalDirection kEast =
    DirectionsLeg_Maneuver_CardinalDirection_kEast;
  static constexpr CardinalDirection kSouthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthEast;
  static constexpr CardinalDirection kSouth =
    DirectionsLeg_Maneuver_CardinalDirection_kSouth;
  static constexpr CardinalDirection kSouthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthWest;
  static constexpr CardinalDirection kWest =
    DirectionsLeg_Maneuver_CardinalDirection_kWest;
  static constexpr CardinalDirection kNorthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return DirectionsLeg_Maneuver_CardinalDirection_IsValid(value);
  }
  static constexpr CardinalDirection CardinalDirection_MIN =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static constexpr CardinalDirection CardinalDirection_MAX =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static constexpr int CardinalDirection_ARRAYSIZE =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CardinalDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CardinalDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CardinalDirection_Name.");
    return DirectionsLeg_Maneuver_CardinalDirection_Name(enum_t_value);
  }
  static inline bool CardinalDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CardinalDirection* value) {
    return DirectionsLeg_Maneuver_CardinalDirection_Parse(name, value);
  }

  typedef DirectionsLeg_Maneuver_Type Type;
  static constexpr Type kNone =
    DirectionsLeg_Maneuver_Type_kNone;
  static constexpr Type kStart =
    DirectionsLeg_Maneuver_Type_kStart;
  static constexpr Type kStartRight =
    DirectionsLeg_Maneuver_Type_kStartRight;
  static constexpr Type kStartLeft =
    DirectionsLeg_Maneuver_Type_kStartLeft;
  static constexpr Type kDestination =
    DirectionsLeg_Maneuver_Type_kDestination;
  static constexpr Type kDestinationRight =
    DirectionsLeg_Maneuver_Type_kDestinationRight;
  static constexpr Type kDestinationLeft =
    DirectionsLeg_Maneuver_Type_kDestinationLeft;
  static constexpr Type kBecomes =
    DirectionsLeg_Maneuver_Type_kBecomes;
  static constexpr Type kContinue =
    DirectionsLeg_Maneuver_Type_kContinue;
  static constexpr Type kSlightRight =
    DirectionsLeg_Maneuver_Type_kSlightRight;
  static constexpr Type kRight =
    DirectionsLeg_Maneuver_Type_kRight;
  static constexpr Type kSharpRight =
    DirectionsLeg_Maneuver_Type_kSharpRight;
  static constexpr Type kUturnRight =
    DirectionsLeg_Maneuver_Type_kUturnRight;
  static constexpr Type kUturnLeft =
    DirectionsLeg_Maneuver_Type_kUturnLeft;
  static constexpr Type kSharpLeft =
    DirectionsLeg_Maneuver_Type_kSharpLeft;
  static constexpr Type kLeft =
    DirectionsLeg_Maneuver_Type_kLeft;
  static constexpr Type kSlightLeft =
    DirectionsLeg_Maneuver_Type_kSlightLeft;
  static constexpr Type kRampStraight =
    DirectionsLeg_Maneuver_Type_kRampStraight;
  static constexpr Type kRampRight =
    DirectionsLeg_Maneuver_Type_kRampRight;
  static constexpr Type kRampLeft =
    DirectionsLeg_Maneuver_Type_kRampLeft;
  static constexpr Type kExitRight =
    DirectionsLeg_Maneuver_Type_kExitRight;
  static constexpr Type kExitLeft =
    DirectionsLeg_Maneuver_Type_kExitLeft;
  static constexpr Type kStayStraight =
    DirectionsLeg_Maneuver_Type_kStayStraight;
  static constexpr Type kStayRight =
    DirectionsLeg_Maneuver_Type_kStayRight;
  static constexpr Type kStayLeft =
    DirectionsLeg_Maneuver_Type_kStayLeft;
  static constexpr Type kMerge =
    DirectionsLeg_Maneuver_Type_kMerge;
  static constexpr Type kRoundaboutEnter =
    DirectionsLeg_Maneuver_Type_kRoundaboutEnter;
  static constexpr Type kRoundaboutExit =
    DirectionsLeg_Maneuver_Type_kRoundaboutExit;
  static constexpr Type kFerryEnter =
    DirectionsLeg_Maneuver_Type_kFerryEnter;
  static constexpr Type kFerryExit =
    DirectionsLeg_Maneuver_Type_kFerryExit;
  static constexpr Type kTransit =
    DirectionsLeg_Maneuver_Type_kTransit;
  static constexpr Type kTransitTransfer =
    DirectionsLeg_Maneuver_Type_kTransitTransfer;
  static constexpr Type kTransitRemainOn =
    DirectionsLeg_Maneuver_Type_kTransitRemainOn;
  static constexpr Type kTransitConnectionStart =
    DirectionsLeg_Maneuver_Type_kTransitConnectionStart;
  static constexpr Type kTransitConnectionTransfer =
    DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer;
  static constexpr Type kTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kTransitConnectionDestination;
  static constexpr Type kPostTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination;
  static constexpr Type kMergeRight =
    DirectionsLeg_Maneuver_Type_kMergeRight;
  static constexpr Type kMergeLeft =
    DirectionsLeg_Maneuver_Type_kMergeLeft;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_Maneuver_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DirectionsLeg_Maneuver_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DirectionsLeg_Maneuver_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DirectionsLeg_Maneuver_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DirectionsLeg_Maneuver_Type_Parse(name, value);
  }

  typedef DirectionsLeg_Maneuver_BssManeuverType BssManeuverType;
  static constexpr BssManeuverType kNoneAction =
    DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
  static constexpr BssManeuverType kRentBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare;
  static constexpr BssManeuverType kReturnBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
  static inline bool BssManeuverType_IsValid(int value) {
    return DirectionsLeg_Maneuver_BssManeuverType_IsValid(value);
  }
  static constexpr BssManeuverType BssManeuverType_MIN =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN;
  static constexpr BssManeuverType BssManeuverType_MAX =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX;
  static constexpr int BssManeuverType_ARRAYSIZE =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BssManeuverType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BssManeuverType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BssManeuverType_Name.");
    return DirectionsLeg_Maneuver_BssManeuverType_Name(enum_t_value);
  }
  static inline bool BssManeuverType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BssManeuverType* value) {
    return DirectionsLeg_Maneuver_BssManeuverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStreetNameFieldNumber = 3,
    kBeginStreetNameFieldNumber = 15,
    kRoundaboutExitStreetNamesFieldNumber = 32,
    kGuidanceViewsFieldNumber = 35,
    kSignFieldNumber = 16,
    kTransitInfoFieldNumber = 22,
    kBssInfoFieldNumber = 38,
    kTypeFieldNumber = 1,
    kTextInstructionFieldNumber = 2,
    kLengthFieldNumber = 4,
    kTimeFieldNumber = 5,
    kBeginCardinalDirectionFieldNumber = 6,
    kBeginHeadingFieldNumber = 7,
    kBeginShapeIndexFieldNumber = 8,
    kEndShapeIndexFieldNumber = 9,
    kPortionsTollFieldNumber = 10,
    kPortionsUnpavedFieldNumber = 11,
    kVerbalTransitionAlertInstructionFieldNumber = 12,
    kVerbalPreTransitionInstructionFieldNumber = 13,
    kVerbalPostTransitionInstructionFieldNumber = 14,
    kRoundaboutExitCountFieldNumber = 17,
    kDepartInstructionFieldNumber = 18,
    kVerbalDepartInstructionFieldNumber = 19,
    kArriveInstructionFieldNumber = 20,
    kVerbalArriveInstructionFieldNumber = 21,
    kVerbalMultiCueFieldNumber = 23,
    kTravelModeFieldNumber = 24,
    kVehicleTypeFieldNumber = 25,
    kPedestrianTypeFieldNumber = 26,
    kBicycleTypeFieldNumber = 27,
    kTransitTypeFieldNumber = 28,
    kBeginPathIndexFieldNumber = 29,
    kEndPathIndexFieldNumber = 30,
    kToStayOnFieldNumber = 31,
    kTurnDegreeFieldNumber = 33,
    kHasTimeRestrictionsFieldNumber = 34,
    kBssManeuverTypeFieldNumber = 36,
    kVerbalSuccinctTransitionInstructionFieldNumber = 37,
  };
  // repeated .valhalla.StreetName street_name = 3;
  int street_name_size() const;
  private:
  int _internal_street_name_size() const;
  public:
  void clear_street_name();
  ::valhalla::StreetName* mutable_street_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_name();
  private:
  const ::valhalla::StreetName& _internal_street_name(int index) const;
  ::valhalla::StreetName* _internal_add_street_name();
  public:
  const ::valhalla::StreetName& street_name(int index) const;
  ::valhalla::StreetName* add_street_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      street_name() const;

  // repeated .valhalla.StreetName begin_street_name = 15;
  int begin_street_name_size() const;
  private:
  int _internal_begin_street_name_size() const;
  public:
  void clear_begin_street_name();
  ::valhalla::StreetName* mutable_begin_street_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_begin_street_name();
  private:
  const ::valhalla::StreetName& _internal_begin_street_name(int index) const;
  ::valhalla::StreetName* _internal_add_begin_street_name();
  public:
  const ::valhalla::StreetName& begin_street_name(int index) const;
  ::valhalla::StreetName* add_begin_street_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      begin_street_name() const;

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  int roundabout_exit_street_names_size() const;
  private:
  int _internal_roundabout_exit_street_names_size() const;
  public:
  void clear_roundabout_exit_street_names();
  ::valhalla::StreetName* mutable_roundabout_exit_street_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_roundabout_exit_street_names();
  private:
  const ::valhalla::StreetName& _internal_roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* _internal_add_roundabout_exit_street_names();
  public:
  const ::valhalla::StreetName& roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* add_roundabout_exit_street_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      roundabout_exit_street_names() const;

  // repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
  int guidance_views_size() const;
  private:
  int _internal_guidance_views_size() const;
  public:
  void clear_guidance_views();
  ::valhalla::DirectionsLeg_GuidanceView* mutable_guidance_views(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
      mutable_guidance_views();
  private:
  const ::valhalla::DirectionsLeg_GuidanceView& _internal_guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* _internal_add_guidance_views();
  public:
  const ::valhalla::DirectionsLeg_GuidanceView& guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* add_guidance_views();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
      guidance_views() const;

  // .valhalla.TripSign sign = 16;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* sign);
  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::TripSign* sign);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  // .valhalla.TransitRouteInfo transit_info = 22;
  bool has_transit_info() const;
  private:
  bool _internal_has_transit_info() const;
  public:
  void clear_transit_info();
  const ::valhalla::TransitRouteInfo& transit_info() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::TransitRouteInfo* release_transit_info();
  ::valhalla::TransitRouteInfo* mutable_transit_info();
  void set_allocated_transit_info(::valhalla::TransitRouteInfo* transit_info);
  private:
  const ::valhalla::TransitRouteInfo& _internal_transit_info() const;
  ::valhalla::TransitRouteInfo* _internal_mutable_transit_info();
  public:
  void unsafe_arena_set_allocated_transit_info(
      ::valhalla::TransitRouteInfo* transit_info);
  ::valhalla::TransitRouteInfo* unsafe_arena_release_transit_info();

  // .valhalla.BikeShareStationInfo bss_info = 38;
  bool has_bss_info() const;
  private:
  bool _internal_has_bss_info() const;
  public:
  void clear_bss_info();
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::BikeShareStationInfo* release_bss_info();
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info);
  private:
  const ::valhalla::BikeShareStationInfo& _internal_bss_info() const;
  ::valhalla::BikeShareStationInfo* _internal_mutable_bss_info();
  public:
  void unsafe_arena_set_allocated_bss_info(
      ::valhalla::BikeShareStationInfo* bss_info);
  ::valhalla::BikeShareStationInfo* unsafe_arena_release_bss_info();

  // .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::DirectionsLeg_Maneuver_Type type() const;
  void set_type(::valhalla::DirectionsLeg_Maneuver_Type value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value);
  public:

  // string text_instruction = 2;
  bool has_text_instruction() const;
  private:
  bool _internal_has_text_instruction() const;
  public:
  void clear_text_instruction();
  const std::string& text_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_text_instruction();
  void set_allocated_text_instruction(std::string* text_instruction);
  private:
  const std::string& _internal_text_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_instruction(const std::string& value);
  std::string* _internal_mutable_text_instruction();
  public:

  // float length = 4;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // double time = 5;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  bool has_begin_cardinal_direction() const;
  private:
  bool _internal_has_begin_cardinal_direction() const;
  public:
  void clear_begin_cardinal_direction();
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection begin_cardinal_direction() const;
  void set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection _internal_begin_cardinal_direction() const;
  void _internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);
  public:

  // uint32 begin_heading = 7;
  bool has_begin_heading() const;
  private:
  bool _internal_has_begin_heading() const;
  public:
  void clear_begin_heading();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_heading() const;
  void set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_heading() const;
  void _internal_set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 begin_shape_index = 8;
  bool has_begin_shape_index() const;
  private:
  bool _internal_has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_shape_index() const;
  void set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 end_shape_index = 9;
  bool has_end_shape_index() const;
  private:
  bool _internal_has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_shape_index() const;
  void set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_shape_index() const;
  void _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool portions_toll = 10;
  bool has_portions_toll() const;
  private:
  bool _internal_has_portions_toll() const;
  public:
  void clear_portions_toll();
  bool portions_toll() const;
  void set_portions_toll(bool value);
  private:
  bool _internal_portions_toll() const;
  void _internal_set_portions_toll(bool value);
  public:

  // bool portions_unpaved = 11;
  bool has_portions_unpaved() const;
  private:
  bool _internal_has_portions_unpaved() const;
  public:
  void clear_portions_unpaved();
  bool portions_unpaved() const;
  void set_portions_unpaved(bool value);
  private:
  bool _internal_portions_unpaved() const;
  void _internal_set_portions_unpaved(bool value);
  public:

  // string verbal_transition_alert_instruction = 12;
  bool has_verbal_transition_alert_instruction() const;
  private:
  bool _internal_has_verbal_transition_alert_instruction() const;
  public:
  void clear_verbal_transition_alert_instruction();
  const std::string& verbal_transition_alert_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_transition_alert_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_transition_alert_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_transition_alert_instruction();
  void set_allocated_verbal_transition_alert_instruction(std::string* verbal_transition_alert_instruction);
  private:
  const std::string& _internal_verbal_transition_alert_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_transition_alert_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_transition_alert_instruction();
  public:

  // string verbal_pre_transition_instruction = 13;
  bool has_verbal_pre_transition_instruction() const;
  private:
  bool _internal_has_verbal_pre_transition_instruction() const;
  public:
  void clear_verbal_pre_transition_instruction();
  const std::string& verbal_pre_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_pre_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_pre_transition_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_pre_transition_instruction();
  void set_allocated_verbal_pre_transition_instruction(std::string* verbal_pre_transition_instruction);
  private:
  const std::string& _internal_verbal_pre_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_pre_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_pre_transition_instruction();
  public:

  // string verbal_post_transition_instruction = 14;
  bool has_verbal_post_transition_instruction() const;
  private:
  bool _internal_has_verbal_post_transition_instruction() const;
  public:
  void clear_verbal_post_transition_instruction();
  const std::string& verbal_post_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_post_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_post_transition_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_post_transition_instruction();
  void set_allocated_verbal_post_transition_instruction(std::string* verbal_post_transition_instruction);
  private:
  const std::string& _internal_verbal_post_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_post_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_post_transition_instruction();
  public:

  // uint32 roundabout_exit_count = 17;
  bool has_roundabout_exit_count() const;
  private:
  bool _internal_has_roundabout_exit_count() const;
  public:
  void clear_roundabout_exit_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 roundabout_exit_count() const;
  void set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_roundabout_exit_count() const;
  void _internal_set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // string depart_instruction = 18;
  bool has_depart_instruction() const;
  private:
  bool _internal_has_depart_instruction() const;
  public:
  void clear_depart_instruction();
  const std::string& depart_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depart_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depart_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_depart_instruction();
  void set_allocated_depart_instruction(std::string* depart_instruction);
  private:
  const std::string& _internal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_depart_instruction(const std::string& value);
  std::string* _internal_mutable_depart_instruction();
  public:

  // string verbal_depart_instruction = 19;
  bool has_verbal_depart_instruction() const;
  private:
  bool _internal_has_verbal_depart_instruction() const;
  public:
  void clear_verbal_depart_instruction();
  const std::string& verbal_depart_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_depart_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_depart_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_depart_instruction();
  void set_allocated_verbal_depart_instruction(std::string* verbal_depart_instruction);
  private:
  const std::string& _internal_verbal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_depart_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_depart_instruction();
  public:

  // string arrive_instruction = 20;
  bool has_arrive_instruction() const;
  private:
  bool _internal_has_arrive_instruction() const;
  public:
  void clear_arrive_instruction();
  const std::string& arrive_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arrive_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arrive_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_arrive_instruction();
  void set_allocated_arrive_instruction(std::string* arrive_instruction);
  private:
  const std::string& _internal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrive_instruction(const std::string& value);
  std::string* _internal_mutable_arrive_instruction();
  public:

  // string verbal_arrive_instruction = 21;
  bool has_verbal_arrive_instruction() const;
  private:
  bool _internal_has_verbal_arrive_instruction() const;
  public:
  void clear_verbal_arrive_instruction();
  const std::string& verbal_arrive_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_arrive_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_arrive_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_arrive_instruction();
  void set_allocated_verbal_arrive_instruction(std::string* verbal_arrive_instruction);
  private:
  const std::string& _internal_verbal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_arrive_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_arrive_instruction();
  public:

  // bool verbal_multi_cue = 23;
  bool has_verbal_multi_cue() const;
  private:
  bool _internal_has_verbal_multi_cue() const;
  public:
  void clear_verbal_multi_cue();
  bool verbal_multi_cue() const;
  void set_verbal_multi_cue(bool value);
  private:
  bool _internal_verbal_multi_cue() const;
  void _internal_set_verbal_multi_cue(bool value);
  public:

  // .valhalla.TravelMode travel_mode = 24;
  bool has_travel_mode() const;
  private:
  bool _internal_has_travel_mode() const;
  public:
  void clear_travel_mode();
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);
  private:
  ::valhalla::TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::TravelMode value);
  public:

  // .valhalla.VehicleType vehicle_type = 25;
  bool has_vehicle_type() const;
  private:
  bool _internal_has_vehicle_type() const;
  public:
  void clear_vehicle_type();
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);
  private:
  ::valhalla::VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::VehicleType value);
  public:

  // .valhalla.PedestrianType pedestrian_type = 26;
  bool has_pedestrian_type() const;
  private:
  bool _internal_has_pedestrian_type() const;
  public:
  void clear_pedestrian_type();
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);
  private:
  ::valhalla::PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::PedestrianType value);
  public:

  // .valhalla.BicycleType bicycle_type = 27;
  bool has_bicycle_type() const;
  private:
  bool _internal_has_bicycle_type() const;
  public:
  void clear_bicycle_type();
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);
  private:
  ::valhalla::BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::BicycleType value);
  public:

  // .valhalla.TransitType transit_type = 28;
  bool has_transit_type() const;
  private:
  bool _internal_has_transit_type() const;
  public:
  void clear_transit_type();
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);
  private:
  ::valhalla::TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::TransitType value);
  public:

  // uint32 begin_path_index = 29;
  bool has_begin_path_index() const;
  private:
  bool _internal_has_begin_path_index() const;
  public:
  void clear_begin_path_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_path_index() const;
  void set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_path_index() const;
  void _internal_set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 end_path_index = 30;
  bool has_end_path_index() const;
  private:
  bool _internal_has_end_path_index() const;
  public:
  void clear_end_path_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_path_index() const;
  void set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_path_index() const;
  void _internal_set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool to_stay_on = 31;
  bool has_to_stay_on() const;
  private:
  bool _internal_has_to_stay_on() const;
  public:
  void clear_to_stay_on();
  bool to_stay_on() const;
  void set_to_stay_on(bool value);
  private:
  bool _internal_to_stay_on() const;
  void _internal_set_to_stay_on(bool value);
  public:

  // uint32 turn_degree = 33;
  bool has_turn_degree() const;
  private:
  bool _internal_has_turn_degree() const;
  public:
  void clear_turn_degree();
  ::PROTOBUF_NAMESPACE_ID::uint32 turn_degree() const;
  void set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_turn_degree() const;
  void _internal_set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool has_time_restrictions = 34;
  bool has_has_time_restrictions() const;
  private:
  bool _internal_has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
  bool has_bss_maneuver_type() const;
  private:
  bool _internal_has_bss_maneuver_type() const;
  public:
  void clear_bss_maneuver_type();
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType bss_maneuver_type() const;
  void set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType _internal_bss_maneuver_type() const;
  void _internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);
  public:

  // string verbal_succinct_transition_instruction = 37;
  bool has_verbal_succinct_transition_instruction() const;
  private:
  bool _internal_has_verbal_succinct_transition_instruction() const;
  public:
  void clear_verbal_succinct_transition_instruction();
  const std::string& verbal_succinct_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_succinct_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_succinct_transition_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_succinct_transition_instruction();
  void set_allocated_verbal_succinct_transition_instruction(std::string* verbal_succinct_transition_instruction);
  private:
  const std::string& _internal_verbal_succinct_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_succinct_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_succinct_transition_instruction();
  public:

  void clear_has_type();
  HasTypeCase has_type_case() const;
  void clear_has_text_instruction();
  HasTextInstructionCase has_text_instruction_case() const;
  void clear_has_length();
  HasLengthCase has_length_case() const;
  void clear_has_time();
  HasTimeCase has_time_case() const;
  void clear_has_begin_cardinal_direction();
  HasBeginCardinalDirectionCase has_begin_cardinal_direction_case() const;
  void clear_has_begin_heading();
  HasBeginHeadingCase has_begin_heading_case() const;
  void clear_has_begin_shape_index();
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  void clear_has_end_shape_index();
  HasEndShapeIndexCase has_end_shape_index_case() const;
  void clear_has_portions_toll();
  HasPortionsTollCase has_portions_toll_case() const;
  void clear_has_portions_unpaved();
  HasPortionsUnpavedCase has_portions_unpaved_case() const;
  void clear_has_verbal_transition_alert_instruction();
  HasVerbalTransitionAlertInstructionCase has_verbal_transition_alert_instruction_case() const;
  void clear_has_verbal_pre_transition_instruction();
  HasVerbalPreTransitionInstructionCase has_verbal_pre_transition_instruction_case() const;
  void clear_has_verbal_post_transition_instruction();
  HasVerbalPostTransitionInstructionCase has_verbal_post_transition_instruction_case() const;
  void clear_has_roundabout_exit_count();
  HasRoundaboutExitCountCase has_roundabout_exit_count_case() const;
  void clear_has_depart_instruction();
  HasDepartInstructionCase has_depart_instruction_case() const;
  void clear_has_verbal_depart_instruction();
  HasVerbalDepartInstructionCase has_verbal_depart_instruction_case() const;
  void clear_has_arrive_instruction();
  HasArriveInstructionCase has_arrive_instruction_case() const;
  void clear_has_verbal_arrive_instruction();
  HasVerbalArriveInstructionCase has_verbal_arrive_instruction_case() const;
  void clear_has_verbal_multi_cue();
  HasVerbalMultiCueCase has_verbal_multi_cue_case() const;
  void clear_has_travel_mode();
  HasTravelModeCase has_travel_mode_case() const;
  void clear_has_vehicle_type();
  HasVehicleTypeCase has_vehicle_type_case() const;
  void clear_has_pedestrian_type();
  HasPedestrianTypeCase has_pedestrian_type_case() const;
  void clear_has_bicycle_type();
  HasBicycleTypeCase has_bicycle_type_case() const;
  void clear_has_transit_type();
  HasTransitTypeCase has_transit_type_case() const;
  void clear_has_begin_path_index();
  HasBeginPathIndexCase has_begin_path_index_case() const;
  void clear_has_end_path_index();
  HasEndPathIndexCase has_end_path_index_case() const;
  void clear_has_to_stay_on();
  HasToStayOnCase has_to_stay_on_case() const;
  void clear_has_turn_degree();
  HasTurnDegreeCase has_turn_degree_case() const;
  void clear_has_has_time_restrictions();
  HasHasTimeRestrictionsCase has_has_time_restrictions_case() const;
  void clear_has_bss_maneuver_type();
  HasBssManeuverTypeCase has_bss_maneuver_type_case() const;
  void clear_has_verbal_succinct_transition_instruction();
  HasVerbalSuccinctTransitionInstructionCase has_verbal_succinct_transition_instruction_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver)
 private:
  class _Internal;
  void set_has_type();
  void set_has_text_instruction();
  void set_has_length();
  void set_has_time();
  void set_has_begin_cardinal_direction();
  void set_has_begin_heading();
  void set_has_begin_shape_index();
  void set_has_end_shape_index();
  void set_has_portions_toll();
  void set_has_portions_unpaved();
  void set_has_verbal_transition_alert_instruction();
  void set_has_verbal_pre_transition_instruction();
  void set_has_verbal_post_transition_instruction();
  void set_has_roundabout_exit_count();
  void set_has_depart_instruction();
  void set_has_verbal_depart_instruction();
  void set_has_arrive_instruction();
  void set_has_verbal_arrive_instruction();
  void set_has_verbal_multi_cue();
  void set_has_travel_mode();
  void set_has_vehicle_type();
  void set_has_pedestrian_type();
  void set_has_bicycle_type();
  void set_has_transit_type();
  void set_has_begin_path_index();
  void set_has_end_path_index();
  void set_has_to_stay_on();
  void set_has_turn_degree();
  void set_has_has_time_restrictions();
  void set_has_bss_maneuver_type();
  void set_has_verbal_succinct_transition_instruction();

  inline bool has_has_type() const;
  inline void clear_has_has_type();

  inline bool has_has_text_instruction() const;
  inline void clear_has_has_text_instruction();

  inline bool has_has_length() const;
  inline void clear_has_has_length();

  inline bool has_has_time() const;
  inline void clear_has_has_time();

  inline bool has_has_begin_cardinal_direction() const;
  inline void clear_has_has_begin_cardinal_direction();

  inline bool has_has_begin_heading() const;
  inline void clear_has_has_begin_heading();

  inline bool has_has_begin_shape_index() const;
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  inline void clear_has_has_end_shape_index();

  inline bool has_has_portions_toll() const;
  inline void clear_has_has_portions_toll();

  inline bool has_has_portions_unpaved() const;
  inline void clear_has_has_portions_unpaved();

  inline bool has_has_verbal_transition_alert_instruction() const;
  inline void clear_has_has_verbal_transition_alert_instruction();

  inline bool has_has_verbal_pre_transition_instruction() const;
  inline void clear_has_has_verbal_pre_transition_instruction();

  inline bool has_has_verbal_post_transition_instruction() const;
  inline void clear_has_has_verbal_post_transition_instruction();

  inline bool has_has_roundabout_exit_count() const;
  inline void clear_has_has_roundabout_exit_count();

  inline bool has_has_depart_instruction() const;
  inline void clear_has_has_depart_instruction();

  inline bool has_has_verbal_depart_instruction() const;
  inline void clear_has_has_verbal_depart_instruction();

  inline bool has_has_arrive_instruction() const;
  inline void clear_has_has_arrive_instruction();

  inline bool has_has_verbal_arrive_instruction() const;
  inline void clear_has_has_verbal_arrive_instruction();

  inline bool has_has_verbal_multi_cue() const;
  inline void clear_has_has_verbal_multi_cue();

  inline bool has_has_travel_mode() const;
  inline void clear_has_has_travel_mode();

  inline bool has_has_vehicle_type() const;
  inline void clear_has_has_vehicle_type();

  inline bool has_has_pedestrian_type() const;
  inline void clear_has_has_pedestrian_type();

  inline bool has_has_bicycle_type() const;
  inline void clear_has_has_bicycle_type();

  inline bool has_has_transit_type() const;
  inline void clear_has_has_transit_type();

  inline bool has_has_begin_path_index() const;
  inline void clear_has_has_begin_path_index();

  inline bool has_has_end_path_index() const;
  inline void clear_has_has_end_path_index();

  inline bool has_has_to_stay_on() const;
  inline void clear_has_has_to_stay_on();

  inline bool has_has_turn_degree() const;
  inline void clear_has_has_turn_degree();

  inline bool has_has_has_time_restrictions() const;
  inline void clear_has_has_has_time_restrictions();

  inline bool has_has_bss_maneuver_type() const;
  inline void clear_has_has_bss_maneuver_type();

  inline bool has_has_verbal_succinct_transition_instruction() const;
  inline void clear_has_has_verbal_succinct_transition_instruction();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > street_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > begin_street_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > roundabout_exit_street_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView > guidance_views_;
  ::valhalla::TripSign* sign_;
  ::valhalla::TransitRouteInfo* transit_info_;
  ::valhalla::BikeShareStationInfo* bss_info_;
  union HasTypeUnion {
    constexpr HasTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int type_;
  } has_type_;
  union HasTextInstructionUnion {
    constexpr HasTextInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_instruction_;
  } has_text_instruction_;
  union HasLengthUnion {
    constexpr HasLengthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float length_;
  } has_length_;
  union HasTimeUnion {
    constexpr HasTimeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double time_;
  } has_time_;
  union HasBeginCardinalDirectionUnion {
    constexpr HasBeginCardinalDirectionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int begin_cardinal_direction_;
  } has_begin_cardinal_direction_;
  union HasBeginHeadingUnion {
    constexpr HasBeginHeadingUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 begin_heading_;
  } has_begin_heading_;
  union HasBeginShapeIndexUnion {
    constexpr HasBeginShapeIndexUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 begin_shape_index_;
  } has_begin_shape_index_;
  union HasEndShapeIndexUnion {
    constexpr HasEndShapeIndexUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 end_shape_index_;
  } has_end_shape_index_;
  union HasPortionsTollUnion {
    constexpr HasPortionsTollUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool portions_toll_;
  } has_portions_toll_;
  union HasPortionsUnpavedUnion {
    constexpr HasPortionsUnpavedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool portions_unpaved_;
  } has_portions_unpaved_;
  union HasVerbalTransitionAlertInstructionUnion {
    constexpr HasVerbalTransitionAlertInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_transition_alert_instruction_;
  } has_verbal_transition_alert_instruction_;
  union HasVerbalPreTransitionInstructionUnion {
    constexpr HasVerbalPreTransitionInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_pre_transition_instruction_;
  } has_verbal_pre_transition_instruction_;
  union HasVerbalPostTransitionInstructionUnion {
    constexpr HasVerbalPostTransitionInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_post_transition_instruction_;
  } has_verbal_post_transition_instruction_;
  union HasRoundaboutExitCountUnion {
    constexpr HasRoundaboutExitCountUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 roundabout_exit_count_;
  } has_roundabout_exit_count_;
  union HasDepartInstructionUnion {
    constexpr HasDepartInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depart_instruction_;
  } has_depart_instruction_;
  union HasVerbalDepartInstructionUnion {
    constexpr HasVerbalDepartInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_depart_instruction_;
  } has_verbal_depart_instruction_;
  union HasArriveInstructionUnion {
    constexpr HasArriveInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arrive_instruction_;
  } has_arrive_instruction_;
  union HasVerbalArriveInstructionUnion {
    constexpr HasVerbalArriveInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_arrive_instruction_;
  } has_verbal_arrive_instruction_;
  union HasVerbalMultiCueUnion {
    constexpr HasVerbalMultiCueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool verbal_multi_cue_;
  } has_verbal_multi_cue_;
  union HasTravelModeUnion {
    constexpr HasTravelModeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int travel_mode_;
  } has_travel_mode_;
  union HasVehicleTypeUnion {
    constexpr HasVehicleTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int vehicle_type_;
  } has_vehicle_type_;
  union HasPedestrianTypeUnion {
    constexpr HasPedestrianTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int pedestrian_type_;
  } has_pedestrian_type_;
  union HasBicycleTypeUnion {
    constexpr HasBicycleTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int bicycle_type_;
  } has_bicycle_type_;
  union HasTransitTypeUnion {
    constexpr HasTransitTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int transit_type_;
  } has_transit_type_;
  union HasBeginPathIndexUnion {
    constexpr HasBeginPathIndexUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 begin_path_index_;
  } has_begin_path_index_;
  union HasEndPathIndexUnion {
    constexpr HasEndPathIndexUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 end_path_index_;
  } has_end_path_index_;
  union HasToStayOnUnion {
    constexpr HasToStayOnUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool to_stay_on_;
  } has_to_stay_on_;
  union HasTurnDegreeUnion {
    constexpr HasTurnDegreeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 turn_degree_;
  } has_turn_degree_;
  union HasHasTimeRestrictionsUnion {
    constexpr HasHasTimeRestrictionsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool has_time_restrictions_;
  } has_has_time_restrictions_;
  union HasBssManeuverTypeUnion {
    constexpr HasBssManeuverTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int bss_maneuver_type_;
  } has_bss_maneuver_type_;
  union HasVerbalSuccinctTransitionInstructionUnion {
    constexpr HasVerbalSuccinctTransitionInstructionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_succinct_transition_instruction_;
  } has_verbal_succinct_transition_instruction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[31];

  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg) */ {
 public:
  inline DirectionsLeg() : DirectionsLeg(nullptr) {}
  ~DirectionsLeg() override;
  explicit constexpr DirectionsLeg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg(const DirectionsLeg& from);
  DirectionsLeg(DirectionsLeg&& from) noexcept
    : DirectionsLeg() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg& operator=(DirectionsLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsLeg& default_instance() {
    return *internal_default_instance();
  }
  enum HasTripIdCase {
    kTripId = 1,
    HAS_TRIP_ID_NOT_SET = 0,
  };

  enum HasLegIdCase {
    kLegId = 2,
    HAS_LEG_ID_NOT_SET = 0,
  };

  enum HasLegCountCase {
    kLegCount = 3,
    HAS_LEG_COUNT_NOT_SET = 0,
  };

  enum HasShapeCase {
    kShape = 7,
    HAS_SHAPE_NOT_SET = 0,
  };

  static inline const DirectionsLeg* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg*>(
               &_DirectionsLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DirectionsLeg& a, DirectionsLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg* New() const final {
    return new DirectionsLeg();
  }

  DirectionsLeg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg";
  }
  protected:
  explicit DirectionsLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Summary Summary;
  typedef DirectionsLeg_GuidanceView GuidanceView;
  typedef DirectionsLeg_Maneuver Maneuver;

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 4,
    kManeuverFieldNumber = 6,
    kSummaryFieldNumber = 5,
    kTripIdFieldNumber = 1,
    kLegIdFieldNumber = 2,
    kLegCountFieldNumber = 3,
    kShapeFieldNumber = 7,
  };
  // repeated .valhalla.Location location = 4;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::valhalla::Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::valhalla::Location& _internal_location(int index) const;
  ::valhalla::Location* _internal_add_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  int maneuver_size() const;
  private:
  int _internal_maneuver_size() const;
  public:
  void clear_maneuver();
  ::valhalla::DirectionsLeg_Maneuver* mutable_maneuver(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
      mutable_maneuver();
  private:
  const ::valhalla::DirectionsLeg_Maneuver& _internal_maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* _internal_add_maneuver();
  public:
  const ::valhalla::DirectionsLeg_Maneuver& maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* add_maneuver();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
      maneuver() const;

  // .valhalla.DirectionsLeg.Summary summary = 5;
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const ::valhalla::DirectionsLeg_Summary& summary() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::DirectionsLeg_Summary* release_summary();
  ::valhalla::DirectionsLeg_Summary* mutable_summary();
  void set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary);
  private:
  const ::valhalla::DirectionsLeg_Summary& _internal_summary() const;
  ::valhalla::DirectionsLeg_Summary* _internal_mutable_summary();
  public:
  void unsafe_arena_set_allocated_summary(
      ::valhalla::DirectionsLeg_Summary* summary);
  ::valhalla::DirectionsLeg_Summary* unsafe_arena_release_summary();

  // uint64 trip_id = 1;
  bool has_trip_id() const;
  private:
  bool _internal_has_trip_id() const;
  public:
  void clear_trip_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 trip_id() const;
  void set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_trip_id() const;
  void _internal_set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 leg_id = 2;
  bool has_leg_id() const;
  private:
  bool _internal_has_leg_id() const;
  public:
  void clear_leg_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 leg_id() const;
  void set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leg_id() const;
  void _internal_set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 leg_count = 3;
  bool has_leg_count() const;
  private:
  bool _internal_has_leg_count() const;
  public:
  void clear_leg_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 leg_count() const;
  void set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leg_count() const;
  void _internal_set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // string shape = 7;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const std::string& shape() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape();
  PROTOBUF_MUST_USE_RESULT std::string* release_shape();
  void set_allocated_shape(std::string* shape);
  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(const std::string& value);
  std::string* _internal_mutable_shape();
  public:

  void clear_has_trip_id();
  HasTripIdCase has_trip_id_case() const;
  void clear_has_leg_id();
  HasLegIdCase has_leg_id_case() const;
  void clear_has_leg_count();
  HasLegCountCase has_leg_count_case() const;
  void clear_has_shape();
  HasShapeCase has_shape_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg)
 private:
  class _Internal;
  void set_has_trip_id();
  void set_has_leg_id();
  void set_has_leg_count();
  void set_has_shape();

  inline bool has_has_trip_id() const;
  inline void clear_has_has_trip_id();

  inline bool has_has_leg_id() const;
  inline void clear_has_has_leg_id();

  inline bool has_has_leg_count() const;
  inline void clear_has_has_leg_count();

  inline bool has_has_shape() const;
  inline void clear_has_has_shape();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > location_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver > maneuver_;
  ::valhalla::DirectionsLeg_Summary* summary_;
  union HasTripIdUnion {
    constexpr HasTripIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint64 trip_id_;
  } has_trip_id_;
  union HasLegIdUnion {
    constexpr HasLegIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 leg_id_;
  } has_leg_id_;
  union HasLegCountUnion {
    constexpr HasLegCountUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 leg_count_;
  } has_leg_count_;
  union HasShapeUnion {
    constexpr HasShapeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_;
  } has_shape_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[4];

  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsRoute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsRoute) */ {
 public:
  inline DirectionsRoute() : DirectionsRoute(nullptr) {}
  ~DirectionsRoute() override;
  explicit constexpr DirectionsRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsRoute(const DirectionsRoute& from);
  DirectionsRoute(DirectionsRoute&& from) noexcept
    : DirectionsRoute() {
    *this = ::std::move(from);
  }

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsRoute& operator=(DirectionsRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DirectionsRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsRoute* internal_default_instance() {
    return reinterpret_cast<const DirectionsRoute*>(
               &_DirectionsRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DirectionsRoute& a, DirectionsRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsRoute* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsRoute* New() const final {
    return new DirectionsRoute();
  }

  DirectionsRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsRoute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsRoute";
  }
  protected:
  explicit DirectionsRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;
  public:
  void clear_legs();
  ::valhalla::DirectionsLeg* mutable_legs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >*
      mutable_legs();
  private:
  const ::valhalla::DirectionsLeg& _internal_legs(int index) const;
  ::valhalla::DirectionsLeg* _internal_add_legs();
  public:
  const ::valhalla::DirectionsLeg& legs(int index) const;
  ::valhalla::DirectionsLeg* add_legs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg > legs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class Directions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Directions) */ {
 public:
  inline Directions() : Directions(nullptr) {}
  ~Directions() override;
  explicit constexpr Directions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Directions(const Directions& from);
  Directions(Directions&& from) noexcept
    : Directions() {
    *this = ::std::move(from);
  }

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Directions& operator=(Directions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Directions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Directions* internal_default_instance() {
    return reinterpret_cast<const Directions*>(
               &_Directions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Directions& a, Directions& b) {
    a.Swap(&b);
  }
  inline void Swap(Directions* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Directions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Directions* New() const final {
    return new Directions();
  }

  Directions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Directions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Directions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Directions";
  }
  protected:
  explicit Directions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::valhalla::DirectionsRoute* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >*
      mutable_routes();
  private:
  const ::valhalla::DirectionsRoute& _internal_routes(int index) const;
  ::valhalla::DirectionsRoute* _internal_add_routes();
  public:
  const ::valhalla::DirectionsRoute& routes(int index) const;
  ::valhalla::DirectionsRoute* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute > routes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_directions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DirectionsLeg_Summary

// float length = 1;
inline bool DirectionsLeg_Summary::_internal_has_length() const {
  return has_length_case() == kLength;
}
inline bool DirectionsLeg_Summary::has_length() const {
  return _internal_has_length();
}
inline void DirectionsLeg_Summary::set_has_length() {
  _oneof_case_[0] = kLength;
}
inline void DirectionsLeg_Summary::clear_length() {
  if (_internal_has_length()) {
    has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float DirectionsLeg_Summary::_internal_length() const {
  if (_internal_has_length()) {
    return has_length_.length_;
  }
  return 0;
}
inline void DirectionsLeg_Summary::_internal_set_length(float value) {
  if (!_internal_has_length()) {
    clear_has_length();
    set_has_length();
  }
  has_length_.length_ = value;
}
inline float DirectionsLeg_Summary::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.length)
  return _internal_length();
}
inline void DirectionsLeg_Summary::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.length)
}

// double time = 2;
inline bool DirectionsLeg_Summary::_internal_has_time() const {
  return has_time_case() == kTime;
}
inline bool DirectionsLeg_Summary::has_time() const {
  return _internal_has_time();
}
inline void DirectionsLeg_Summary::set_has_time() {
  _oneof_case_[1] = kTime;
}
inline void DirectionsLeg_Summary::clear_time() {
  if (_internal_has_time()) {
    has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline double DirectionsLeg_Summary::_internal_time() const {
  if (_internal_has_time()) {
    return has_time_.time_;
  }
  return 0;
}
inline void DirectionsLeg_Summary::_internal_set_time(double value) {
  if (!_internal_has_time()) {
    clear_has_time();
    set_has_time();
  }
  has_time_.time_ = value;
}
inline double DirectionsLeg_Summary::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.time)
  return _internal_time();
}
inline void DirectionsLeg_Summary::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.time)
}

// .valhalla.BoundingBox bbox = 3;
inline bool DirectionsLeg_Summary::_internal_has_bbox() const {
  return this != internal_default_instance() && bbox_ != nullptr;
}
inline bool DirectionsLeg_Summary::has_bbox() const {
  return _internal_has_bbox();
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::_internal_bbox() const {
  const ::valhalla::BoundingBox* p = bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(
      ::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.bbox)
  return _internal_bbox();
}
inline void DirectionsLeg_Summary::unsafe_arena_set_allocated_bbox(
    ::valhalla::BoundingBox* bbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox_);
  }
  bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::release_bbox() {
  
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::unsafe_arena_release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Summary.bbox)
  
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::_internal_mutable_bbox() {
  
  if (bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArenaForAllocation());
    bbox_ = p;
  }
  return bbox_;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::mutable_bbox() {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Summary.bbox)
  return _msg;
}
inline void DirectionsLeg_Summary::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox));
    if (message_arena != submessage_arena) {
      bbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}

// bool has_time_restrictions = 4;
inline bool DirectionsLeg_Summary::_internal_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
inline bool DirectionsLeg_Summary::has_has_time_restrictions() const {
  return _internal_has_has_time_restrictions();
}
inline void DirectionsLeg_Summary::set_has_has_time_restrictions() {
  _oneof_case_[2] = kHasTimeRestrictions;
}
inline void DirectionsLeg_Summary::clear_has_time_restrictions() {
  if (_internal_has_has_time_restrictions()) {
    has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
inline bool DirectionsLeg_Summary::_internal_has_time_restrictions() const {
  if (_internal_has_has_time_restrictions()) {
    return has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
inline void DirectionsLeg_Summary::_internal_set_has_time_restrictions(bool value) {
  if (!_internal_has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  has_has_time_restrictions_.has_time_restrictions_ = value;
}
inline bool DirectionsLeg_Summary::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Summary::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_time_restrictions)
}

inline bool DirectionsLeg_Summary::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void DirectionsLeg_Summary::clear_has_has_length() {
  _oneof_case_[0] = HAS_LENGTH_NOT_SET;
}
inline bool DirectionsLeg_Summary::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void DirectionsLeg_Summary::clear_has_has_time() {
  _oneof_case_[1] = HAS_TIME_NOT_SET;
}
inline bool DirectionsLeg_Summary::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline void DirectionsLeg_Summary::clear_has_has_has_time_restrictions() {
  _oneof_case_[2] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline DirectionsLeg_Summary::HasLengthCase DirectionsLeg_Summary::has_length_case() const {
  return DirectionsLeg_Summary::HasLengthCase(_oneof_case_[0]);
}
inline DirectionsLeg_Summary::HasTimeCase DirectionsLeg_Summary::has_time_case() const {
  return DirectionsLeg_Summary::HasTimeCase(_oneof_case_[1]);
}
inline DirectionsLeg_Summary::HasHasTimeRestrictionsCase DirectionsLeg_Summary::has_has_time_restrictions_case() const {
  return DirectionsLeg_Summary::HasHasTimeRestrictionsCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// DirectionsLeg_GuidanceView

// string data_id = 1;
inline bool DirectionsLeg_GuidanceView::_internal_has_data_id() const {
  return has_data_id_case() == kDataId;
}
inline bool DirectionsLeg_GuidanceView::has_data_id() const {
  return _internal_has_data_id();
}
inline void DirectionsLeg_GuidanceView::set_has_data_id() {
  _oneof_case_[0] = kDataId;
}
inline void DirectionsLeg_GuidanceView::clear_data_id() {
  if (_internal_has_data_id()) {
    has_data_id_.data_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_data_id();
  }
}
inline const std::string& DirectionsLeg_GuidanceView::data_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _internal_data_id();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_GuidanceView::set_data_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_data_id_.data_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_data_id() {
  std::string* _s = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_data_id() const {
  if (_internal_has_data_id()) {
    return has_data_id_.data_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_GuidanceView::_internal_set_data_id(const std::string& value) {
  if (!_internal_has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_data_id_.data_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_data_id() {
  if (!_internal_has_data_id()) {
    clear_has_data_id();
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_data_id_.data_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::release_data_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.data_id)
  if (_internal_has_data_id()) {
    clear_has_has_data_id();
    return has_data_id_.data_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_GuidanceView::set_allocated_data_id(std::string* data_id) {
  if (has_has_data_id()) {
    clear_has_data_id();
  }
  if (data_id != nullptr) {
    set_has_data_id();
    has_data_id_.data_id_.UnsafeSetDefault(data_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(data_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.data_id)
}

// .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
inline bool DirectionsLeg_GuidanceView::_internal_has_type() const {
  return has_type_case() == kType;
}
inline bool DirectionsLeg_GuidanceView::has_type() const {
  return _internal_has_type();
}
inline void DirectionsLeg_GuidanceView::set_has_type() {
  _oneof_case_[1] = kType;
}
inline void DirectionsLeg_GuidanceView::clear_type() {
  if (_internal_has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::_internal_type() const {
  if (_internal_has_type()) {
    return static_cast< ::valhalla::DirectionsLeg_GuidanceView_Type >(has_type_.type_);
  }
  return static_cast< ::valhalla::DirectionsLeg_GuidanceView_Type >(0);
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.type)
  return _internal_type();
}
inline void DirectionsLeg_GuidanceView::_internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  if (!_internal_has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
}
inline void DirectionsLeg_GuidanceView::set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.type)
}

// string base_id = 3;
inline bool DirectionsLeg_GuidanceView::_internal_has_base_id() const {
  return has_base_id_case() == kBaseId;
}
inline bool DirectionsLeg_GuidanceView::has_base_id() const {
  return _internal_has_base_id();
}
inline void DirectionsLeg_GuidanceView::set_has_base_id() {
  _oneof_case_[2] = kBaseId;
}
inline void DirectionsLeg_GuidanceView::clear_base_id() {
  if (_internal_has_base_id()) {
    has_base_id_.base_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_base_id();
  }
}
inline const std::string& DirectionsLeg_GuidanceView::base_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _internal_base_id();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_GuidanceView::set_base_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_base_id_.base_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_base_id() {
  std::string* _s = _internal_mutable_base_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_base_id() const {
  if (_internal_has_base_id()) {
    return has_base_id_.base_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_GuidanceView::_internal_set_base_id(const std::string& value) {
  if (!_internal_has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_base_id_.base_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_base_id() {
  if (!_internal_has_base_id()) {
    clear_has_base_id();
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_base_id_.base_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::release_base_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.base_id)
  if (_internal_has_base_id()) {
    clear_has_has_base_id();
    return has_base_id_.base_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_GuidanceView::set_allocated_base_id(std::string* base_id) {
  if (has_has_base_id()) {
    clear_has_base_id();
  }
  if (base_id != nullptr) {
    set_has_base_id();
    has_base_id_.base_id_.UnsafeSetDefault(base_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(base_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.base_id)
}

// repeated string overlay_ids = 4;
inline int DirectionsLeg_GuidanceView::_internal_overlay_ids_size() const {
  return overlay_ids_.size();
}
inline int DirectionsLeg_GuidanceView::overlay_ids_size() const {
  return _internal_overlay_ids_size();
}
inline void DirectionsLeg_GuidanceView::clear_overlay_ids() {
  overlay_ids_.Clear();
}
inline std::string* DirectionsLeg_GuidanceView::add_overlay_ids() {
  std::string* _s = _internal_add_overlay_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_overlay_ids(int index) const {
  return overlay_ids_.Get(index);
}
inline const std::string& DirectionsLeg_GuidanceView::overlay_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _internal_overlay_ids(index);
}
inline std::string* DirectionsLeg_GuidanceView::mutable_overlay_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_.Mutable(index);
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const std::string& value) {
  overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, std::string&& value) {
  overlay_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value, size_t size) {
  overlay_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline std::string* DirectionsLeg_GuidanceView::_internal_add_overlay_ids() {
  return overlay_ids_.Add();
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const std::string& value) {
  overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(std::string&& value) {
  overlay_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value, size_t size) {
  overlay_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DirectionsLeg_GuidanceView::overlay_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DirectionsLeg_GuidanceView::mutable_overlay_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return &overlay_ids_;
}

inline bool DirectionsLeg_GuidanceView::has_has_data_id() const {
  return has_data_id_case() != HAS_DATA_ID_NOT_SET;
}
inline void DirectionsLeg_GuidanceView::clear_has_has_data_id() {
  _oneof_case_[0] = HAS_DATA_ID_NOT_SET;
}
inline bool DirectionsLeg_GuidanceView::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void DirectionsLeg_GuidanceView::clear_has_has_type() {
  _oneof_case_[1] = HAS_TYPE_NOT_SET;
}
inline bool DirectionsLeg_GuidanceView::has_has_base_id() const {
  return has_base_id_case() != HAS_BASE_ID_NOT_SET;
}
inline void DirectionsLeg_GuidanceView::clear_has_has_base_id() {
  _oneof_case_[2] = HAS_BASE_ID_NOT_SET;
}
inline DirectionsLeg_GuidanceView::HasDataIdCase DirectionsLeg_GuidanceView::has_data_id_case() const {
  return DirectionsLeg_GuidanceView::HasDataIdCase(_oneof_case_[0]);
}
inline DirectionsLeg_GuidanceView::HasTypeCase DirectionsLeg_GuidanceView::has_type_case() const {
  return DirectionsLeg_GuidanceView::HasTypeCase(_oneof_case_[1]);
}
inline DirectionsLeg_GuidanceView::HasBaseIdCase DirectionsLeg_GuidanceView::has_base_id_case() const {
  return DirectionsLeg_GuidanceView::HasBaseIdCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// DirectionsLeg_Maneuver

// .valhalla.DirectionsLeg.Maneuver.Type type = 1;
inline bool DirectionsLeg_Maneuver::_internal_has_type() const {
  return has_type_case() == kType;
}
inline bool DirectionsLeg_Maneuver::has_type() const {
  return _internal_has_type();
}
inline void DirectionsLeg_Maneuver::set_has_type() {
  _oneof_case_[0] = kType;
}
inline void DirectionsLeg_Maneuver::clear_type() {
  if (_internal_has_type()) {
    has_type_.type_ = 0;
    clear_has_has_type();
  }
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::_internal_type() const {
  if (_internal_has_type()) {
    return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(has_type_.type_);
  }
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(0);
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.type)
  return _internal_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  if (!_internal_has_type()) {
    clear_has_type();
    set_has_type();
  }
  has_type_.type_ = value;
}
inline void DirectionsLeg_Maneuver::set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.type)
}

// string text_instruction = 2;
inline bool DirectionsLeg_Maneuver::_internal_has_text_instruction() const {
  return has_text_instruction_case() == kTextInstruction;
}
inline bool DirectionsLeg_Maneuver::has_text_instruction() const {
  return _internal_has_text_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_text_instruction() {
  _oneof_case_[1] = kTextInstruction;
}
inline void DirectionsLeg_Maneuver::clear_text_instruction() {
  if (_internal_has_text_instruction()) {
    has_text_instruction_.text_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_text_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::text_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _internal_text_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_text_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_text_instruction_.text_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_text_instruction() {
  std::string* _s = _internal_mutable_text_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_text_instruction() const {
  if (_internal_has_text_instruction()) {
    return has_text_instruction_.text_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_text_instruction(const std::string& value) {
  if (!_internal_has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_text_instruction_.text_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_text_instruction() {
  if (!_internal_has_text_instruction()) {
    clear_has_text_instruction();
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_text_instruction_.text_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_text_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.text_instruction)
  if (_internal_has_text_instruction()) {
    clear_has_has_text_instruction();
    return has_text_instruction_.text_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_text_instruction(std::string* text_instruction) {
  if (has_has_text_instruction()) {
    clear_has_text_instruction();
  }
  if (text_instruction != nullptr) {
    set_has_text_instruction();
    has_text_instruction_.text_instruction_.UnsafeSetDefault(text_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(text_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.text_instruction)
}

// repeated .valhalla.StreetName street_name = 3;
inline int DirectionsLeg_Maneuver::_internal_street_name_size() const {
  return street_name_.size();
}
inline int DirectionsLeg_Maneuver::street_name_size() const {
  return _internal_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return &street_name_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_street_name(int index) const {
  return street_name_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.street_name)
  return _internal_street_name(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_street_name() {
  return street_name_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_street_name() {
  ::valhalla::StreetName* _add = _internal_add_street_name();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.street_name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_;
}

// float length = 4;
inline bool DirectionsLeg_Maneuver::_internal_has_length() const {
  return has_length_case() == kLength;
}
inline bool DirectionsLeg_Maneuver::has_length() const {
  return _internal_has_length();
}
inline void DirectionsLeg_Maneuver::set_has_length() {
  _oneof_case_[2] = kLength;
}
inline void DirectionsLeg_Maneuver::clear_length() {
  if (_internal_has_length()) {
    has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float DirectionsLeg_Maneuver::_internal_length() const {
  if (_internal_has_length()) {
    return has_length_.length_;
  }
  return 0;
}
inline void DirectionsLeg_Maneuver::_internal_set_length(float value) {
  if (!_internal_has_length()) {
    clear_has_length();
    set_has_length();
  }
  has_length_.length_ = value;
}
inline float DirectionsLeg_Maneuver::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.length)
  return _internal_length();
}
inline void DirectionsLeg_Maneuver::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.length)
}

// double time = 5;
inline bool DirectionsLeg_Maneuver::_internal_has_time() const {
  return has_time_case() == kTime;
}
inline bool DirectionsLeg_Maneuver::has_time() const {
  return _internal_has_time();
}
inline void DirectionsLeg_Maneuver::set_has_time() {
  _oneof_case_[3] = kTime;
}
inline void DirectionsLeg_Maneuver::clear_time() {
  if (_internal_has_time()) {
    has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline double DirectionsLeg_Maneuver::_internal_time() const {
  if (_internal_has_time()) {
    return has_time_.time_;
  }
  return 0;
}
inline void DirectionsLeg_Maneuver::_internal_set_time(double value) {
  if (!_internal_has_time()) {
    clear_has_time();
    set_has_time();
  }
  has_time_.time_ = value;
}
inline double DirectionsLeg_Maneuver::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.time)
  return _internal_time();
}
inline void DirectionsLeg_Maneuver::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.time)
}

// .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_cardinal_direction() const {
  return has_begin_cardinal_direction_case() == kBeginCardinalDirection;
}
inline bool DirectionsLeg_Maneuver::has_begin_cardinal_direction() const {
  return _internal_has_begin_cardinal_direction();
}
inline void DirectionsLeg_Maneuver::set_has_begin_cardinal_direction() {
  _oneof_case_[4] = kBeginCardinalDirection;
}
inline void DirectionsLeg_Maneuver::clear_begin_cardinal_direction() {
  if (_internal_has_begin_cardinal_direction()) {
    has_begin_cardinal_direction_.begin_cardinal_direction_ = 0;
    clear_has_has_begin_cardinal_direction();
  }
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::_internal_begin_cardinal_direction() const {
  if (_internal_has_begin_cardinal_direction()) {
    return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(has_begin_cardinal_direction_.begin_cardinal_direction_);
  }
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(0);
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::begin_cardinal_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
  return _internal_begin_cardinal_direction();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  if (!_internal_has_begin_cardinal_direction()) {
    clear_has_begin_cardinal_direction();
    set_has_begin_cardinal_direction();
  }
  has_begin_cardinal_direction_.begin_cardinal_direction_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  _internal_set_begin_cardinal_direction(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
}

// uint32 begin_heading = 7;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_heading() const {
  return has_begin_heading_case() == kBeginHeading;
}
inline bool DirectionsLeg_Maneuver::has_begin_heading() const {
  return _internal_has_begin_heading();
}
inline void DirectionsLeg_Maneuver::set_has_begin_heading() {
  _oneof_case_[5] = kBeginHeading;
}
inline void DirectionsLeg_Maneuver::clear_begin_heading() {
  if (_internal_has_begin_heading()) {
    has_begin_heading_.begin_heading_ = 0u;
    clear_has_has_begin_heading();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_begin_heading() const {
  if (_internal_has_begin_heading()) {
    return has_begin_heading_.begin_heading_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_begin_heading()) {
    clear_has_begin_heading();
    set_has_begin_heading();
  }
  has_begin_heading_.begin_heading_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_heading)
  return _internal_begin_heading();
}
inline void DirectionsLeg_Maneuver::set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_heading)
}

// uint32 begin_shape_index = 8;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline bool DirectionsLeg_Maneuver::has_begin_shape_index() const {
  return _internal_has_begin_shape_index();
}
inline void DirectionsLeg_Maneuver::set_has_begin_shape_index() {
  _oneof_case_[6] = kBeginShapeIndex;
}
inline void DirectionsLeg_Maneuver::clear_begin_shape_index() {
  if (_internal_has_begin_shape_index()) {
    has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_begin_shape_index() const {
  if (_internal_has_begin_shape_index()) {
    return has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_begin_shape_index()) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  has_begin_shape_index_.begin_shape_index_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void DirectionsLeg_Maneuver::set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
}

// uint32 end_shape_index = 9;
inline bool DirectionsLeg_Maneuver::_internal_has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline bool DirectionsLeg_Maneuver::has_end_shape_index() const {
  return _internal_has_end_shape_index();
}
inline void DirectionsLeg_Maneuver::set_has_end_shape_index() {
  _oneof_case_[7] = kEndShapeIndex;
}
inline void DirectionsLeg_Maneuver::clear_end_shape_index() {
  if (_internal_has_end_shape_index()) {
    has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_end_shape_index() const {
  if (_internal_has_end_shape_index()) {
    return has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_end_shape_index()) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  has_end_shape_index_.end_shape_index_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_shape_index)
  return _internal_end_shape_index();
}
inline void DirectionsLeg_Maneuver::set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_shape_index)
}

// bool portions_toll = 10;
inline bool DirectionsLeg_Maneuver::_internal_has_portions_toll() const {
  return has_portions_toll_case() == kPortionsToll;
}
inline bool DirectionsLeg_Maneuver::has_portions_toll() const {
  return _internal_has_portions_toll();
}
inline void DirectionsLeg_Maneuver::set_has_portions_toll() {
  _oneof_case_[8] = kPortionsToll;
}
inline void DirectionsLeg_Maneuver::clear_portions_toll() {
  if (_internal_has_portions_toll()) {
    has_portions_toll_.portions_toll_ = false;
    clear_has_has_portions_toll();
  }
}
inline bool DirectionsLeg_Maneuver::_internal_portions_toll() const {
  if (_internal_has_portions_toll()) {
    return has_portions_toll_.portions_toll_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_toll(bool value) {
  if (!_internal_has_portions_toll()) {
    clear_has_portions_toll();
    set_has_portions_toll();
  }
  has_portions_toll_.portions_toll_ = value;
}
inline bool DirectionsLeg_Maneuver::portions_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_toll)
  return _internal_portions_toll();
}
inline void DirectionsLeg_Maneuver::set_portions_toll(bool value) {
  _internal_set_portions_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_toll)
}

// bool portions_unpaved = 11;
inline bool DirectionsLeg_Maneuver::_internal_has_portions_unpaved() const {
  return has_portions_unpaved_case() == kPortionsUnpaved;
}
inline bool DirectionsLeg_Maneuver::has_portions_unpaved() const {
  return _internal_has_portions_unpaved();
}
inline void DirectionsLeg_Maneuver::set_has_portions_unpaved() {
  _oneof_case_[9] = kPortionsUnpaved;
}
inline void DirectionsLeg_Maneuver::clear_portions_unpaved() {
  if (_internal_has_portions_unpaved()) {
    has_portions_unpaved_.portions_unpaved_ = false;
    clear_has_has_portions_unpaved();
  }
}
inline bool DirectionsLeg_Maneuver::_internal_portions_unpaved() const {
  if (_internal_has_portions_unpaved()) {
    return has_portions_unpaved_.portions_unpaved_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_unpaved(bool value) {
  if (!_internal_has_portions_unpaved()) {
    clear_has_portions_unpaved();
    set_has_portions_unpaved();
  }
  has_portions_unpaved_.portions_unpaved_ = value;
}
inline bool DirectionsLeg_Maneuver::portions_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
  return _internal_portions_unpaved();
}
inline void DirectionsLeg_Maneuver::set_portions_unpaved(bool value) {
  _internal_set_portions_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
}

// string verbal_transition_alert_instruction = 12;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_transition_alert_instruction() const {
  return has_verbal_transition_alert_instruction_case() == kVerbalTransitionAlertInstruction;
}
inline bool DirectionsLeg_Maneuver::has_verbal_transition_alert_instruction() const {
  return _internal_has_verbal_transition_alert_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_transition_alert_instruction() {
  _oneof_case_[10] = kVerbalTransitionAlertInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_transition_alert_instruction() {
  if (_internal_has_verbal_transition_alert_instruction()) {
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_verbal_transition_alert_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::verbal_transition_alert_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _internal_verbal_transition_alert_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_transition_alert_instruction() {
  std::string* _s = _internal_mutable_verbal_transition_alert_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_transition_alert_instruction() const {
  if (_internal_has_verbal_transition_alert_instruction()) {
    return has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_transition_alert_instruction(const std::string& value) {
  if (!_internal_has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_transition_alert_instruction() {
  if (!_internal_has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_transition_alert_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  if (_internal_has_verbal_transition_alert_instruction()) {
    clear_has_has_verbal_transition_alert_instruction();
    return has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_transition_alert_instruction(std::string* verbal_transition_alert_instruction) {
  if (has_has_verbal_transition_alert_instruction()) {
    clear_has_verbal_transition_alert_instruction();
  }
  if (verbal_transition_alert_instruction != nullptr) {
    set_has_verbal_transition_alert_instruction();
    has_verbal_transition_alert_instruction_.verbal_transition_alert_instruction_.UnsafeSetDefault(verbal_transition_alert_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(verbal_transition_alert_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}

// string verbal_pre_transition_instruction = 13;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_pre_transition_instruction() const {
  return has_verbal_pre_transition_instruction_case() == kVerbalPreTransitionInstruction;
}
inline bool DirectionsLeg_Maneuver::has_verbal_pre_transition_instruction() const {
  return _internal_has_verbal_pre_transition_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_pre_transition_instruction() {
  _oneof_case_[11] = kVerbalPreTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_pre_transition_instruction() {
  if (_internal_has_verbal_pre_transition_instruction()) {
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_verbal_pre_transition_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::verbal_pre_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _internal_verbal_pre_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_pre_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_pre_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_pre_transition_instruction() const {
  if (_internal_has_verbal_pre_transition_instruction()) {
    return has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_pre_transition_instruction(const std::string& value) {
  if (!_internal_has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_pre_transition_instruction() {
  if (!_internal_has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_pre_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  if (_internal_has_verbal_pre_transition_instruction()) {
    clear_has_has_verbal_pre_transition_instruction();
    return has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_pre_transition_instruction(std::string* verbal_pre_transition_instruction) {
  if (has_has_verbal_pre_transition_instruction()) {
    clear_has_verbal_pre_transition_instruction();
  }
  if (verbal_pre_transition_instruction != nullptr) {
    set_has_verbal_pre_transition_instruction();
    has_verbal_pre_transition_instruction_.verbal_pre_transition_instruction_.UnsafeSetDefault(verbal_pre_transition_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(verbal_pre_transition_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}

// string verbal_post_transition_instruction = 14;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_post_transition_instruction() const {
  return has_verbal_post_transition_instruction_case() == kVerbalPostTransitionInstruction;
}
inline bool DirectionsLeg_Maneuver::has_verbal_post_transition_instruction() const {
  return _internal_has_verbal_post_transition_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_post_transition_instruction() {
  _oneof_case_[12] = kVerbalPostTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_post_transition_instruction() {
  if (_internal_has_verbal_post_transition_instruction()) {
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_verbal_post_transition_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::verbal_post_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _internal_verbal_post_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_post_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_post_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_post_transition_instruction() const {
  if (_internal_has_verbal_post_transition_instruction()) {
    return has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_post_transition_instruction(const std::string& value) {
  if (!_internal_has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_post_transition_instruction() {
  if (!_internal_has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_post_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  if (_internal_has_verbal_post_transition_instruction()) {
    clear_has_has_verbal_post_transition_instruction();
    return has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_post_transition_instruction(std::string* verbal_post_transition_instruction) {
  if (has_has_verbal_post_transition_instruction()) {
    clear_has_verbal_post_transition_instruction();
  }
  if (verbal_post_transition_instruction != nullptr) {
    set_has_verbal_post_transition_instruction();
    has_verbal_post_transition_instruction_.verbal_post_transition_instruction_.UnsafeSetDefault(verbal_post_transition_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(verbal_post_transition_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}

// repeated .valhalla.StreetName begin_street_name = 15;
inline int DirectionsLeg_Maneuver::_internal_begin_street_name_size() const {
  return begin_street_name_.size();
}
inline int DirectionsLeg_Maneuver::begin_street_name_size() const {
  return _internal_begin_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_begin_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_begin_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return &begin_street_name_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_begin_street_name(int index) const {
  return begin_street_name_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::begin_street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _internal_begin_street_name(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_begin_street_name() {
  return begin_street_name_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_begin_street_name() {
  ::valhalla::StreetName* _add = _internal_add_begin_street_name();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::begin_street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_;
}

// .valhalla.TripSign sign = 16;
inline bool DirectionsLeg_Maneuver::_internal_has_sign() const {
  return this != internal_default_instance() && sign_ != nullptr;
}
inline bool DirectionsLeg_Maneuver::has_sign() const {
  return _internal_has_sign();
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::_internal_sign() const {
  const ::valhalla::TripSign* p = sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(
      ::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.sign)
  return _internal_sign();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_sign(
    ::valhalla::TripSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign_);
  }
  sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::release_sign() {
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.sign)
  
  ::valhalla::TripSign* temp = sign_;
  sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::_internal_mutable_sign() {
  
  if (sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArenaForAllocation());
    sign_ = p;
  }
  return sign_;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::mutable_sign() {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.sign)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_sign(::valhalla::TripSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}

// uint32 roundabout_exit_count = 17;
inline bool DirectionsLeg_Maneuver::_internal_has_roundabout_exit_count() const {
  return has_roundabout_exit_count_case() == kRoundaboutExitCount;
}
inline bool DirectionsLeg_Maneuver::has_roundabout_exit_count() const {
  return _internal_has_roundabout_exit_count();
}
inline void DirectionsLeg_Maneuver::set_has_roundabout_exit_count() {
  _oneof_case_[13] = kRoundaboutExitCount;
}
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_count() {
  if (_internal_has_roundabout_exit_count()) {
    has_roundabout_exit_count_.roundabout_exit_count_ = 0u;
    clear_has_has_roundabout_exit_count();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_roundabout_exit_count() const {
  if (_internal_has_roundabout_exit_count()) {
    return has_roundabout_exit_count_.roundabout_exit_count_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_roundabout_exit_count()) {
    clear_has_roundabout_exit_count();
    set_has_roundabout_exit_count();
  }
  has_roundabout_exit_count_.roundabout_exit_count_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::roundabout_exit_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
  return _internal_roundabout_exit_count();
}
inline void DirectionsLeg_Maneuver::set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_roundabout_exit_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
}

// string depart_instruction = 18;
inline bool DirectionsLeg_Maneuver::_internal_has_depart_instruction() const {
  return has_depart_instruction_case() == kDepartInstruction;
}
inline bool DirectionsLeg_Maneuver::has_depart_instruction() const {
  return _internal_has_depart_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_depart_instruction() {
  _oneof_case_[14] = kDepartInstruction;
}
inline void DirectionsLeg_Maneuver::clear_depart_instruction() {
  if (_internal_has_depart_instruction()) {
    has_depart_instruction_.depart_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_depart_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _internal_depart_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_depart_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_depart_instruction_.depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_depart_instruction() {
  std::string* _s = _internal_mutable_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_depart_instruction() const {
  if (_internal_has_depart_instruction()) {
    return has_depart_instruction_.depart_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_depart_instruction(const std::string& value) {
  if (!_internal_has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_depart_instruction_.depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_depart_instruction() {
  if (!_internal_has_depart_instruction()) {
    clear_has_depart_instruction();
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_depart_instruction_.depart_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  if (_internal_has_depart_instruction()) {
    clear_has_has_depart_instruction();
    return has_depart_instruction_.depart_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_depart_instruction(std::string* depart_instruction) {
  if (has_has_depart_instruction()) {
    clear_has_depart_instruction();
  }
  if (depart_instruction != nullptr) {
    set_has_depart_instruction();
    has_depart_instruction_.depart_instruction_.UnsafeSetDefault(depart_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(depart_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}

// string verbal_depart_instruction = 19;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_depart_instruction() const {
  return has_verbal_depart_instruction_case() == kVerbalDepartInstruction;
}
inline bool DirectionsLeg_Maneuver::has_verbal_depart_instruction() const {
  return _internal_has_verbal_depart_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_depart_instruction() {
  _oneof_case_[15] = kVerbalDepartInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_depart_instruction() {
  if (_internal_has_verbal_depart_instruction()) {
    has_verbal_depart_instruction_.verbal_depart_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_verbal_depart_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::verbal_depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _internal_verbal_depart_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_depart_instruction_.verbal_depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_depart_instruction() {
  std::string* _s = _internal_mutable_verbal_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_depart_instruction() const {
  if (_internal_has_verbal_depart_instruction()) {
    return has_verbal_depart_instruction_.verbal_depart_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_depart_instruction(const std::string& value) {
  if (!_internal_has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_depart_instruction_.verbal_depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_depart_instruction() {
  if (!_internal_has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_verbal_depart_instruction_.verbal_depart_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  if (_internal_has_verbal_depart_instruction()) {
    clear_has_has_verbal_depart_instruction();
    return has_verbal_depart_instruction_.verbal_depart_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_depart_instruction(std::string* verbal_depart_instruction) {
  if (has_has_verbal_depart_instruction()) {
    clear_has_verbal_depart_instruction();
  }
  if (verbal_depart_instruction != nullptr) {
    set_has_verbal_depart_instruction();
    has_verbal_depart_instruction_.verbal_depart_instruction_.UnsafeSetDefault(verbal_depart_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(verbal_depart_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}

// string arrive_instruction = 20;
inline bool DirectionsLeg_Maneuver::_internal_has_arrive_instruction() const {
  return has_arrive_instruction_case() == kArriveInstruction;
}
inline bool DirectionsLeg_Maneuver::has_arrive_instruction() const {
  return _internal_has_arrive_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_arrive_instruction() {
  _oneof_case_[16] = kArriveInstruction;
}
inline void DirectionsLeg_Maneuver::clear_arrive_instruction() {
  if (_internal_has_arrive_instruction()) {
    has_arrive_instruction_.arrive_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_arrive_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _internal_arrive_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_arrive_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_arrive_instruction_.arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_arrive_instruction() {
  std::string* _s = _internal_mutable_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_arrive_instruction() const {
  if (_internal_has_arrive_instruction()) {
    return has_arrive_instruction_.arrive_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_arrive_instruction(const std::string& value) {
  if (!_internal_has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_arrive_instruction_.arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_arrive_instruction() {
  if (!_internal_has_arrive_instruction()) {
    clear_has_arrive_instruction();
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_arrive_instruction_.arrive_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  if (_internal_has_arrive_instruction()) {
    clear_has_has_arrive_instruction();
    return has_arrive_instruction_.arrive_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_arrive_instruction(std::string* arrive_instruction) {
  if (has_has_arrive_instruction()) {
    clear_has_arrive_instruction();
  }
  if (arrive_instruction != nullptr) {
    set_has_arrive_instruction();
    has_arrive_instruction_.arrive_instruction_.UnsafeSetDefault(arrive_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(arrive_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}

// string verbal_arrive_instruction = 21;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_arrive_instruction() const {
  return has_verbal_arrive_instruction_case() == kVerbalArriveInstruction;
}
inline bool DirectionsLeg_Maneuver::has_verbal_arrive_instruction() const {
  return _internal_has_verbal_arrive_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_arrive_instruction() {
  _oneof_case_[17] = kVerbalArriveInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_arrive_instruction() {
  if (_internal_has_verbal_arrive_instruction()) {
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_verbal_arrive_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::verbal_arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _internal_verbal_arrive_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_arrive_instruction_.verbal_arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_arrive_instruction() {
  std::string* _s = _internal_mutable_verbal_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_arrive_instruction() const {
  if (_internal_has_verbal_arrive_instruction()) {
    return has_verbal_arrive_instruction_.verbal_arrive_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_arrive_instruction(const std::string& value) {
  if (!_internal_has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_arrive_instruction_.verbal_arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_arrive_instruction() {
  if (!_internal_has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_verbal_arrive_instruction_.verbal_arrive_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  if (_internal_has_verbal_arrive_instruction()) {
    clear_has_has_verbal_arrive_instruction();
    return has_verbal_arrive_instruction_.verbal_arrive_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_arrive_instruction(std::string* verbal_arrive_instruction) {
  if (has_has_verbal_arrive_instruction()) {
    clear_has_verbal_arrive_instruction();
  }
  if (verbal_arrive_instruction != nullptr) {
    set_has_verbal_arrive_instruction();
    has_verbal_arrive_instruction_.verbal_arrive_instruction_.UnsafeSetDefault(verbal_arrive_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(verbal_arrive_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}

// .valhalla.TransitRouteInfo transit_info = 22;
inline bool DirectionsLeg_Maneuver::_internal_has_transit_info() const {
  return this != internal_default_instance() && transit_info_ != nullptr;
}
inline bool DirectionsLeg_Maneuver::has_transit_info() const {
  return _internal_has_transit_info();
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::_internal_transit_info() const {
  const ::valhalla::TransitRouteInfo* p = transit_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitRouteInfo&>(
      ::valhalla::_TransitRouteInfo_default_instance_);
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::transit_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _internal_transit_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_transit_info(
    ::valhalla::TransitRouteInfo* transit_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_info_);
  }
  transit_info_ = transit_info;
  if (transit_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::release_transit_info() {
  
  ::valhalla::TransitRouteInfo* temp = transit_info_;
  transit_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::unsafe_arena_release_transit_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.transit_info)
  
  ::valhalla::TransitRouteInfo* temp = transit_info_;
  transit_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::_internal_mutable_transit_info() {
  
  if (transit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitRouteInfo>(GetArenaForAllocation());
    transit_info_ = p;
  }
  return transit_info_;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::mutable_transit_info() {
  ::valhalla::TransitRouteInfo* _msg = _internal_mutable_transit_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_transit_info(::valhalla::TransitRouteInfo* transit_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_info_);
  }
  if (transit_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_info));
    if (message_arena != submessage_arena) {
      transit_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_info, submessage_arena);
    }
    
  } else {
    
  }
  transit_info_ = transit_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}

// bool verbal_multi_cue = 23;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_multi_cue() const {
  return has_verbal_multi_cue_case() == kVerbalMultiCue;
}
inline bool DirectionsLeg_Maneuver::has_verbal_multi_cue() const {
  return _internal_has_verbal_multi_cue();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_multi_cue() {
  _oneof_case_[18] = kVerbalMultiCue;
}
inline void DirectionsLeg_Maneuver::clear_verbal_multi_cue() {
  if (_internal_has_verbal_multi_cue()) {
    has_verbal_multi_cue_.verbal_multi_cue_ = false;
    clear_has_has_verbal_multi_cue();
  }
}
inline bool DirectionsLeg_Maneuver::_internal_verbal_multi_cue() const {
  if (_internal_has_verbal_multi_cue()) {
    return has_verbal_multi_cue_.verbal_multi_cue_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_multi_cue(bool value) {
  if (!_internal_has_verbal_multi_cue()) {
    clear_has_verbal_multi_cue();
    set_has_verbal_multi_cue();
  }
  has_verbal_multi_cue_.verbal_multi_cue_ = value;
}
inline bool DirectionsLeg_Maneuver::verbal_multi_cue() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
  return _internal_verbal_multi_cue();
}
inline void DirectionsLeg_Maneuver::set_verbal_multi_cue(bool value) {
  _internal_set_verbal_multi_cue(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
}

// .valhalla.TravelMode travel_mode = 24;
inline bool DirectionsLeg_Maneuver::_internal_has_travel_mode() const {
  return has_travel_mode_case() == kTravelMode;
}
inline bool DirectionsLeg_Maneuver::has_travel_mode() const {
  return _internal_has_travel_mode();
}
inline void DirectionsLeg_Maneuver::set_has_travel_mode() {
  _oneof_case_[19] = kTravelMode;
}
inline void DirectionsLeg_Maneuver::clear_travel_mode() {
  if (_internal_has_travel_mode()) {
    has_travel_mode_.travel_mode_ = 0;
    clear_has_has_travel_mode();
  }
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::_internal_travel_mode() const {
  if (_internal_has_travel_mode()) {
    return static_cast< ::valhalla::TravelMode >(has_travel_mode_.travel_mode_);
  }
  return static_cast< ::valhalla::TravelMode >(0);
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.travel_mode)
  return _internal_travel_mode();
}
inline void DirectionsLeg_Maneuver::_internal_set_travel_mode(::valhalla::TravelMode value) {
  if (!_internal_has_travel_mode()) {
    clear_has_travel_mode();
    set_has_travel_mode();
  }
  has_travel_mode_.travel_mode_ = value;
}
inline void DirectionsLeg_Maneuver::set_travel_mode(::valhalla::TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.travel_mode)
}

// .valhalla.VehicleType vehicle_type = 25;
inline bool DirectionsLeg_Maneuver::_internal_has_vehicle_type() const {
  return has_vehicle_type_case() == kVehicleType;
}
inline bool DirectionsLeg_Maneuver::has_vehicle_type() const {
  return _internal_has_vehicle_type();
}
inline void DirectionsLeg_Maneuver::set_has_vehicle_type() {
  _oneof_case_[20] = kVehicleType;
}
inline void DirectionsLeg_Maneuver::clear_vehicle_type() {
  if (_internal_has_vehicle_type()) {
    has_vehicle_type_.vehicle_type_ = 0;
    clear_has_has_vehicle_type();
  }
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::_internal_vehicle_type() const {
  if (_internal_has_vehicle_type()) {
    return static_cast< ::valhalla::VehicleType >(has_vehicle_type_.vehicle_type_);
  }
  return static_cast< ::valhalla::VehicleType >(0);
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.vehicle_type)
  return _internal_vehicle_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_vehicle_type(::valhalla::VehicleType value) {
  if (!_internal_has_vehicle_type()) {
    clear_has_vehicle_type();
    set_has_vehicle_type();
  }
  has_vehicle_type_.vehicle_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_vehicle_type(::valhalla::VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.vehicle_type)
}

// .valhalla.PedestrianType pedestrian_type = 26;
inline bool DirectionsLeg_Maneuver::_internal_has_pedestrian_type() const {
  return has_pedestrian_type_case() == kPedestrianType;
}
inline bool DirectionsLeg_Maneuver::has_pedestrian_type() const {
  return _internal_has_pedestrian_type();
}
inline void DirectionsLeg_Maneuver::set_has_pedestrian_type() {
  _oneof_case_[21] = kPedestrianType;
}
inline void DirectionsLeg_Maneuver::clear_pedestrian_type() {
  if (_internal_has_pedestrian_type()) {
    has_pedestrian_type_.pedestrian_type_ = 0;
    clear_has_has_pedestrian_type();
  }
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::_internal_pedestrian_type() const {
  if (_internal_has_pedestrian_type()) {
    return static_cast< ::valhalla::PedestrianType >(has_pedestrian_type_.pedestrian_type_);
  }
  return static_cast< ::valhalla::PedestrianType >(0);
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_pedestrian_type(::valhalla::PedestrianType value) {
  if (!_internal_has_pedestrian_type()) {
    clear_has_pedestrian_type();
    set_has_pedestrian_type();
  }
  has_pedestrian_type_.pedestrian_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_pedestrian_type(::valhalla::PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
}

// .valhalla.BicycleType bicycle_type = 27;
inline bool DirectionsLeg_Maneuver::_internal_has_bicycle_type() const {
  return has_bicycle_type_case() == kBicycleType;
}
inline bool DirectionsLeg_Maneuver::has_bicycle_type() const {
  return _internal_has_bicycle_type();
}
inline void DirectionsLeg_Maneuver::set_has_bicycle_type() {
  _oneof_case_[22] = kBicycleType;
}
inline void DirectionsLeg_Maneuver::clear_bicycle_type() {
  if (_internal_has_bicycle_type()) {
    has_bicycle_type_.bicycle_type_ = 0;
    clear_has_has_bicycle_type();
  }
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::_internal_bicycle_type() const {
  if (_internal_has_bicycle_type()) {
    return static_cast< ::valhalla::BicycleType >(has_bicycle_type_.bicycle_type_);
  }
  return static_cast< ::valhalla::BicycleType >(0);
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bicycle_type)
  return _internal_bicycle_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_bicycle_type(::valhalla::BicycleType value) {
  if (!_internal_has_bicycle_type()) {
    clear_has_bicycle_type();
    set_has_bicycle_type();
  }
  has_bicycle_type_.bicycle_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_bicycle_type(::valhalla::BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bicycle_type)
}

// .valhalla.TransitType transit_type = 28;
inline bool DirectionsLeg_Maneuver::_internal_has_transit_type() const {
  return has_transit_type_case() == kTransitType;
}
inline bool DirectionsLeg_Maneuver::has_transit_type() const {
  return _internal_has_transit_type();
}
inline void DirectionsLeg_Maneuver::set_has_transit_type() {
  _oneof_case_[23] = kTransitType;
}
inline void DirectionsLeg_Maneuver::clear_transit_type() {
  if (_internal_has_transit_type()) {
    has_transit_type_.transit_type_ = 0;
    clear_has_has_transit_type();
  }
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::_internal_transit_type() const {
  if (_internal_has_transit_type()) {
    return static_cast< ::valhalla::TransitType >(has_transit_type_.transit_type_);
  }
  return static_cast< ::valhalla::TransitType >(0);
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_type)
  return _internal_transit_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_transit_type(::valhalla::TransitType value) {
  if (!_internal_has_transit_type()) {
    clear_has_transit_type();
    set_has_transit_type();
  }
  has_transit_type_.transit_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_transit_type(::valhalla::TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.transit_type)
}

// uint32 begin_path_index = 29;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_path_index() const {
  return has_begin_path_index_case() == kBeginPathIndex;
}
inline bool DirectionsLeg_Maneuver::has_begin_path_index() const {
  return _internal_has_begin_path_index();
}
inline void DirectionsLeg_Maneuver::set_has_begin_path_index() {
  _oneof_case_[24] = kBeginPathIndex;
}
inline void DirectionsLeg_Maneuver::clear_begin_path_index() {
  if (_internal_has_begin_path_index()) {
    has_begin_path_index_.begin_path_index_ = 0u;
    clear_has_has_begin_path_index();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_begin_path_index() const {
  if (_internal_has_begin_path_index()) {
    return has_begin_path_index_.begin_path_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_begin_path_index()) {
    clear_has_begin_path_index();
    set_has_begin_path_index();
  }
  has_begin_path_index_.begin_path_index_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::begin_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_path_index)
  return _internal_begin_path_index();
}
inline void DirectionsLeg_Maneuver::set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_path_index)
}

// uint32 end_path_index = 30;
inline bool DirectionsLeg_Maneuver::_internal_has_end_path_index() const {
  return has_end_path_index_case() == kEndPathIndex;
}
inline bool DirectionsLeg_Maneuver::has_end_path_index() const {
  return _internal_has_end_path_index();
}
inline void DirectionsLeg_Maneuver::set_has_end_path_index() {
  _oneof_case_[25] = kEndPathIndex;
}
inline void DirectionsLeg_Maneuver::clear_end_path_index() {
  if (_internal_has_end_path_index()) {
    has_end_path_index_.end_path_index_ = 0u;
    clear_has_has_end_path_index();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_end_path_index() const {
  if (_internal_has_end_path_index()) {
    return has_end_path_index_.end_path_index_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_end_path_index()) {
    clear_has_end_path_index();
    set_has_end_path_index();
  }
  has_end_path_index_.end_path_index_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::end_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_path_index)
  return _internal_end_path_index();
}
inline void DirectionsLeg_Maneuver::set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_path_index)
}

// bool to_stay_on = 31;
inline bool DirectionsLeg_Maneuver::_internal_has_to_stay_on() const {
  return has_to_stay_on_case() == kToStayOn;
}
inline bool DirectionsLeg_Maneuver::has_to_stay_on() const {
  return _internal_has_to_stay_on();
}
inline void DirectionsLeg_Maneuver::set_has_to_stay_on() {
  _oneof_case_[26] = kToStayOn;
}
inline void DirectionsLeg_Maneuver::clear_to_stay_on() {
  if (_internal_has_to_stay_on()) {
    has_to_stay_on_.to_stay_on_ = false;
    clear_has_has_to_stay_on();
  }
}
inline bool DirectionsLeg_Maneuver::_internal_to_stay_on() const {
  if (_internal_has_to_stay_on()) {
    return has_to_stay_on_.to_stay_on_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::_internal_set_to_stay_on(bool value) {
  if (!_internal_has_to_stay_on()) {
    clear_has_to_stay_on();
    set_has_to_stay_on();
  }
  has_to_stay_on_.to_stay_on_ = value;
}
inline bool DirectionsLeg_Maneuver::to_stay_on() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.to_stay_on)
  return _internal_to_stay_on();
}
inline void DirectionsLeg_Maneuver::set_to_stay_on(bool value) {
  _internal_set_to_stay_on(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.to_stay_on)
}

// repeated .valhalla.StreetName roundabout_exit_street_names = 32;
inline int DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names_size() const {
  return roundabout_exit_street_names_.size();
}
inline int DirectionsLeg_Maneuver::roundabout_exit_street_names_size() const {
  return _internal_roundabout_exit_street_names_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return &roundabout_exit_street_names_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names(int index) const {
  return roundabout_exit_street_names_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::roundabout_exit_street_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _internal_roundabout_exit_street_names(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_roundabout_exit_street_names() {
  return roundabout_exit_street_names_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_roundabout_exit_street_names() {
  ::valhalla::StreetName* _add = _internal_add_roundabout_exit_street_names();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::roundabout_exit_street_names() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_;
}

// uint32 turn_degree = 33;
inline bool DirectionsLeg_Maneuver::_internal_has_turn_degree() const {
  return has_turn_degree_case() == kTurnDegree;
}
inline bool DirectionsLeg_Maneuver::has_turn_degree() const {
  return _internal_has_turn_degree();
}
inline void DirectionsLeg_Maneuver::set_has_turn_degree() {
  _oneof_case_[27] = kTurnDegree;
}
inline void DirectionsLeg_Maneuver::clear_turn_degree() {
  if (_internal_has_turn_degree()) {
    has_turn_degree_.turn_degree_ = 0u;
    clear_has_has_turn_degree();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_turn_degree() const {
  if (_internal_has_turn_degree()) {
    return has_turn_degree_.turn_degree_;
  }
  return 0u;
}
inline void DirectionsLeg_Maneuver::_internal_set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_turn_degree()) {
    clear_has_turn_degree();
    set_has_turn_degree();
  }
  has_turn_degree_.turn_degree_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::turn_degree() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.turn_degree)
  return _internal_turn_degree();
}
inline void DirectionsLeg_Maneuver::set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_turn_degree(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.turn_degree)
}

// bool has_time_restrictions = 34;
inline bool DirectionsLeg_Maneuver::_internal_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() == kHasTimeRestrictions;
}
inline bool DirectionsLeg_Maneuver::has_has_time_restrictions() const {
  return _internal_has_has_time_restrictions();
}
inline void DirectionsLeg_Maneuver::set_has_has_time_restrictions() {
  _oneof_case_[28] = kHasTimeRestrictions;
}
inline void DirectionsLeg_Maneuver::clear_has_time_restrictions() {
  if (_internal_has_has_time_restrictions()) {
    has_has_time_restrictions_.has_time_restrictions_ = false;
    clear_has_has_has_time_restrictions();
  }
}
inline bool DirectionsLeg_Maneuver::_internal_has_time_restrictions() const {
  if (_internal_has_has_time_restrictions()) {
    return has_has_time_restrictions_.has_time_restrictions_;
  }
  return false;
}
inline void DirectionsLeg_Maneuver::_internal_set_has_time_restrictions(bool value) {
  if (!_internal_has_has_time_restrictions()) {
    clear_has_has_time_restrictions();
    set_has_has_time_restrictions();
  }
  has_has_time_restrictions_.has_time_restrictions_ = value;
}
inline bool DirectionsLeg_Maneuver::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Maneuver::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
}

// repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
inline int DirectionsLeg_Maneuver::_internal_guidance_views_size() const {
  return guidance_views_.size();
}
inline int DirectionsLeg_Maneuver::guidance_views_size() const {
  return _internal_guidance_views_size();
}
inline void DirectionsLeg_Maneuver::clear_guidance_views() {
  guidance_views_.Clear();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::mutable_guidance_views(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
DirectionsLeg_Maneuver::mutable_guidance_views() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return &guidance_views_;
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::_internal_guidance_views(int index) const {
  return guidance_views_.Get(index);
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::guidance_views(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _internal_guidance_views(index);
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::_internal_add_guidance_views() {
  return guidance_views_.Add();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::add_guidance_views() {
  ::valhalla::DirectionsLeg_GuidanceView* _add = _internal_add_guidance_views();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
DirectionsLeg_Maneuver::guidance_views() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_;
}

// .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
inline bool DirectionsLeg_Maneuver::_internal_has_bss_maneuver_type() const {
  return has_bss_maneuver_type_case() == kBssManeuverType;
}
inline bool DirectionsLeg_Maneuver::has_bss_maneuver_type() const {
  return _internal_has_bss_maneuver_type();
}
inline void DirectionsLeg_Maneuver::set_has_bss_maneuver_type() {
  _oneof_case_[29] = kBssManeuverType;
}
inline void DirectionsLeg_Maneuver::clear_bss_maneuver_type() {
  if (_internal_has_bss_maneuver_type()) {
    has_bss_maneuver_type_.bss_maneuver_type_ = 0;
    clear_has_has_bss_maneuver_type();
  }
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::_internal_bss_maneuver_type() const {
  if (_internal_has_bss_maneuver_type()) {
    return static_cast< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType >(has_bss_maneuver_type_.bss_maneuver_type_);
  }
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType >(0);
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::bss_maneuver_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
  return _internal_bss_maneuver_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  if (!_internal_has_bss_maneuver_type()) {
    clear_has_bss_maneuver_type();
    set_has_bss_maneuver_type();
  }
  has_bss_maneuver_type_.bss_maneuver_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  _internal_set_bss_maneuver_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
}

// string verbal_succinct_transition_instruction = 37;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_succinct_transition_instruction() const {
  return has_verbal_succinct_transition_instruction_case() == kVerbalSuccinctTransitionInstruction;
}
inline bool DirectionsLeg_Maneuver::has_verbal_succinct_transition_instruction() const {
  return _internal_has_verbal_succinct_transition_instruction();
}
inline void DirectionsLeg_Maneuver::set_has_verbal_succinct_transition_instruction() {
  _oneof_case_[30] = kVerbalSuccinctTransitionInstruction;
}
inline void DirectionsLeg_Maneuver::clear_verbal_succinct_transition_instruction() {
  if (_internal_has_verbal_succinct_transition_instruction()) {
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_verbal_succinct_transition_instruction();
  }
}
inline const std::string& DirectionsLeg_Maneuver::verbal_succinct_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _internal_verbal_succinct_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg_Maneuver::set_verbal_succinct_transition_instruction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_succinct_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_succinct_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_succinct_transition_instruction() const {
  if (_internal_has_verbal_succinct_transition_instruction()) {
    return has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_succinct_transition_instruction(const std::string& value) {
  if (!_internal_has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_succinct_transition_instruction() {
  if (!_internal_has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_succinct_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  if (_internal_has_verbal_succinct_transition_instruction()) {
    clear_has_has_verbal_succinct_transition_instruction();
    return has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_succinct_transition_instruction(std::string* verbal_succinct_transition_instruction) {
  if (has_has_verbal_succinct_transition_instruction()) {
    clear_has_verbal_succinct_transition_instruction();
  }
  if (verbal_succinct_transition_instruction != nullptr) {
    set_has_verbal_succinct_transition_instruction();
    has_verbal_succinct_transition_instruction_.verbal_succinct_transition_instruction_.UnsafeSetDefault(verbal_succinct_transition_instruction);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(verbal_succinct_transition_instruction);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}

// .valhalla.BikeShareStationInfo bss_info = 38;
inline bool DirectionsLeg_Maneuver::_internal_has_bss_info() const {
  return this != internal_default_instance() && bss_info_ != nullptr;
}
inline bool DirectionsLeg_Maneuver::has_bss_info() const {
  return _internal_has_bss_info();
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::_internal_bss_info() const {
  const ::valhalla::BikeShareStationInfo* p = bss_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BikeShareStationInfo&>(
      ::valhalla::_BikeShareStationInfo_default_instance_);
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::bss_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_info)
  return _internal_bss_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_bss_info(
    ::valhalla::BikeShareStationInfo* bss_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bss_info_);
  }
  bss_info_ = bss_info;
  if (bss_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::release_bss_info() {
  
  ::valhalla::BikeShareStationInfo* temp = bss_info_;
  bss_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::unsafe_arena_release_bss_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.bss_info)
  
  ::valhalla::BikeShareStationInfo* temp = bss_info_;
  bss_info_ = nullptr;
  return temp;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::_internal_mutable_bss_info() {
  
  if (bss_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BikeShareStationInfo>(GetArenaForAllocation());
    bss_info_ = p;
  }
  return bss_info_;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::mutable_bss_info() {
  ::valhalla::BikeShareStationInfo* _msg = _internal_mutable_bss_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.bss_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_bss_info(::valhalla::BikeShareStationInfo* bss_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bss_info_);
  }
  if (bss_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bss_info));
    if (message_arena != submessage_arena) {
      bss_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bss_info, submessage_arena);
    }
    
  } else {
    
  }
  bss_info_ = bss_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}

inline bool DirectionsLeg_Maneuver::has_has_type() const {
  return has_type_case() != HAS_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_type() {
  _oneof_case_[0] = HAS_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_text_instruction() const {
  return has_text_instruction_case() != HAS_TEXT_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_text_instruction() {
  _oneof_case_[1] = HAS_TEXT_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_length() {
  _oneof_case_[2] = HAS_LENGTH_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_time() {
  _oneof_case_[3] = HAS_TIME_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_cardinal_direction() const {
  return has_begin_cardinal_direction_case() != HAS_BEGIN_CARDINAL_DIRECTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_cardinal_direction() {
  _oneof_case_[4] = HAS_BEGIN_CARDINAL_DIRECTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_heading() const {
  return has_begin_heading_case() != HAS_BEGIN_HEADING_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_heading() {
  _oneof_case_[5] = HAS_BEGIN_HEADING_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_shape_index() {
  _oneof_case_[6] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_end_shape_index() {
  _oneof_case_[7] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_portions_toll() const {
  return has_portions_toll_case() != HAS_PORTIONS_TOLL_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_portions_toll() {
  _oneof_case_[8] = HAS_PORTIONS_TOLL_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_portions_unpaved() const {
  return has_portions_unpaved_case() != HAS_PORTIONS_UNPAVED_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_portions_unpaved() {
  _oneof_case_[9] = HAS_PORTIONS_UNPAVED_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_transition_alert_instruction() const {
  return has_verbal_transition_alert_instruction_case() != HAS_VERBAL_TRANSITION_ALERT_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_transition_alert_instruction() {
  _oneof_case_[10] = HAS_VERBAL_TRANSITION_ALERT_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_pre_transition_instruction() const {
  return has_verbal_pre_transition_instruction_case() != HAS_VERBAL_PRE_TRANSITION_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_pre_transition_instruction() {
  _oneof_case_[11] = HAS_VERBAL_PRE_TRANSITION_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_post_transition_instruction() const {
  return has_verbal_post_transition_instruction_case() != HAS_VERBAL_POST_TRANSITION_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_post_transition_instruction() {
  _oneof_case_[12] = HAS_VERBAL_POST_TRANSITION_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_roundabout_exit_count() const {
  return has_roundabout_exit_count_case() != HAS_ROUNDABOUT_EXIT_COUNT_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_roundabout_exit_count() {
  _oneof_case_[13] = HAS_ROUNDABOUT_EXIT_COUNT_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_depart_instruction() const {
  return has_depart_instruction_case() != HAS_DEPART_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_depart_instruction() {
  _oneof_case_[14] = HAS_DEPART_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_depart_instruction() const {
  return has_verbal_depart_instruction_case() != HAS_VERBAL_DEPART_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_depart_instruction() {
  _oneof_case_[15] = HAS_VERBAL_DEPART_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_arrive_instruction() const {
  return has_arrive_instruction_case() != HAS_ARRIVE_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_arrive_instruction() {
  _oneof_case_[16] = HAS_ARRIVE_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_arrive_instruction() const {
  return has_verbal_arrive_instruction_case() != HAS_VERBAL_ARRIVE_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_arrive_instruction() {
  _oneof_case_[17] = HAS_VERBAL_ARRIVE_INSTRUCTION_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_multi_cue() const {
  return has_verbal_multi_cue_case() != HAS_VERBAL_MULTI_CUE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_multi_cue() {
  _oneof_case_[18] = HAS_VERBAL_MULTI_CUE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_travel_mode() const {
  return has_travel_mode_case() != HAS_TRAVEL_MODE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_travel_mode() {
  _oneof_case_[19] = HAS_TRAVEL_MODE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_vehicle_type() const {
  return has_vehicle_type_case() != HAS_VEHICLE_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_vehicle_type() {
  _oneof_case_[20] = HAS_VEHICLE_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_pedestrian_type() const {
  return has_pedestrian_type_case() != HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_pedestrian_type() {
  _oneof_case_[21] = HAS_PEDESTRIAN_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_bicycle_type() const {
  return has_bicycle_type_case() != HAS_BICYCLE_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_bicycle_type() {
  _oneof_case_[22] = HAS_BICYCLE_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_transit_type() const {
  return has_transit_type_case() != HAS_TRANSIT_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_transit_type() {
  _oneof_case_[23] = HAS_TRANSIT_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_begin_path_index() const {
  return has_begin_path_index_case() != HAS_BEGIN_PATH_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_begin_path_index() {
  _oneof_case_[24] = HAS_BEGIN_PATH_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_end_path_index() const {
  return has_end_path_index_case() != HAS_END_PATH_INDEX_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_end_path_index() {
  _oneof_case_[25] = HAS_END_PATH_INDEX_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_to_stay_on() const {
  return has_to_stay_on_case() != HAS_TO_STAY_ON_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_to_stay_on() {
  _oneof_case_[26] = HAS_TO_STAY_ON_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_turn_degree() const {
  return has_turn_degree_case() != HAS_TURN_DEGREE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_turn_degree() {
  _oneof_case_[27] = HAS_TURN_DEGREE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_has_time_restrictions() const {
  return has_has_time_restrictions_case() != HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_has_time_restrictions() {
  _oneof_case_[28] = HAS_HAS_TIME_RESTRICTIONS_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_bss_maneuver_type() const {
  return has_bss_maneuver_type_case() != HAS_BSS_MANEUVER_TYPE_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_bss_maneuver_type() {
  _oneof_case_[29] = HAS_BSS_MANEUVER_TYPE_NOT_SET;
}
inline bool DirectionsLeg_Maneuver::has_has_verbal_succinct_transition_instruction() const {
  return has_verbal_succinct_transition_instruction_case() != HAS_VERBAL_SUCCINCT_TRANSITION_INSTRUCTION_NOT_SET;
}
inline void DirectionsLeg_Maneuver::clear_has_has_verbal_succinct_transition_instruction() {
  _oneof_case_[30] = HAS_VERBAL_SUCCINCT_TRANSITION_INSTRUCTION_NOT_SET;
}
inline DirectionsLeg_Maneuver::HasTypeCase DirectionsLeg_Maneuver::has_type_case() const {
  return DirectionsLeg_Maneuver::HasTypeCase(_oneof_case_[0]);
}
inline DirectionsLeg_Maneuver::HasTextInstructionCase DirectionsLeg_Maneuver::has_text_instruction_case() const {
  return DirectionsLeg_Maneuver::HasTextInstructionCase(_oneof_case_[1]);
}
inline DirectionsLeg_Maneuver::HasLengthCase DirectionsLeg_Maneuver::has_length_case() const {
  return DirectionsLeg_Maneuver::HasLengthCase(_oneof_case_[2]);
}
inline DirectionsLeg_Maneuver::HasTimeCase DirectionsLeg_Maneuver::has_time_case() const {
  return DirectionsLeg_Maneuver::HasTimeCase(_oneof_case_[3]);
}
inline DirectionsLeg_Maneuver::HasBeginCardinalDirectionCase DirectionsLeg_Maneuver::has_begin_cardinal_direction_case() const {
  return DirectionsLeg_Maneuver::HasBeginCardinalDirectionCase(_oneof_case_[4]);
}
inline DirectionsLeg_Maneuver::HasBeginHeadingCase DirectionsLeg_Maneuver::has_begin_heading_case() const {
  return DirectionsLeg_Maneuver::HasBeginHeadingCase(_oneof_case_[5]);
}
inline DirectionsLeg_Maneuver::HasBeginShapeIndexCase DirectionsLeg_Maneuver::has_begin_shape_index_case() const {
  return DirectionsLeg_Maneuver::HasBeginShapeIndexCase(_oneof_case_[6]);
}
inline DirectionsLeg_Maneuver::HasEndShapeIndexCase DirectionsLeg_Maneuver::has_end_shape_index_case() const {
  return DirectionsLeg_Maneuver::HasEndShapeIndexCase(_oneof_case_[7]);
}
inline DirectionsLeg_Maneuver::HasPortionsTollCase DirectionsLeg_Maneuver::has_portions_toll_case() const {
  return DirectionsLeg_Maneuver::HasPortionsTollCase(_oneof_case_[8]);
}
inline DirectionsLeg_Maneuver::HasPortionsUnpavedCase DirectionsLeg_Maneuver::has_portions_unpaved_case() const {
  return DirectionsLeg_Maneuver::HasPortionsUnpavedCase(_oneof_case_[9]);
}
inline DirectionsLeg_Maneuver::HasVerbalTransitionAlertInstructionCase DirectionsLeg_Maneuver::has_verbal_transition_alert_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalTransitionAlertInstructionCase(_oneof_case_[10]);
}
inline DirectionsLeg_Maneuver::HasVerbalPreTransitionInstructionCase DirectionsLeg_Maneuver::has_verbal_pre_transition_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalPreTransitionInstructionCase(_oneof_case_[11]);
}
inline DirectionsLeg_Maneuver::HasVerbalPostTransitionInstructionCase DirectionsLeg_Maneuver::has_verbal_post_transition_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalPostTransitionInstructionCase(_oneof_case_[12]);
}
inline DirectionsLeg_Maneuver::HasRoundaboutExitCountCase DirectionsLeg_Maneuver::has_roundabout_exit_count_case() const {
  return DirectionsLeg_Maneuver::HasRoundaboutExitCountCase(_oneof_case_[13]);
}
inline DirectionsLeg_Maneuver::HasDepartInstructionCase DirectionsLeg_Maneuver::has_depart_instruction_case() const {
  return DirectionsLeg_Maneuver::HasDepartInstructionCase(_oneof_case_[14]);
}
inline DirectionsLeg_Maneuver::HasVerbalDepartInstructionCase DirectionsLeg_Maneuver::has_verbal_depart_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalDepartInstructionCase(_oneof_case_[15]);
}
inline DirectionsLeg_Maneuver::HasArriveInstructionCase DirectionsLeg_Maneuver::has_arrive_instruction_case() const {
  return DirectionsLeg_Maneuver::HasArriveInstructionCase(_oneof_case_[16]);
}
inline DirectionsLeg_Maneuver::HasVerbalArriveInstructionCase DirectionsLeg_Maneuver::has_verbal_arrive_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalArriveInstructionCase(_oneof_case_[17]);
}
inline DirectionsLeg_Maneuver::HasVerbalMultiCueCase DirectionsLeg_Maneuver::has_verbal_multi_cue_case() const {
  return DirectionsLeg_Maneuver::HasVerbalMultiCueCase(_oneof_case_[18]);
}
inline DirectionsLeg_Maneuver::HasTravelModeCase DirectionsLeg_Maneuver::has_travel_mode_case() const {
  return DirectionsLeg_Maneuver::HasTravelModeCase(_oneof_case_[19]);
}
inline DirectionsLeg_Maneuver::HasVehicleTypeCase DirectionsLeg_Maneuver::has_vehicle_type_case() const {
  return DirectionsLeg_Maneuver::HasVehicleTypeCase(_oneof_case_[20]);
}
inline DirectionsLeg_Maneuver::HasPedestrianTypeCase DirectionsLeg_Maneuver::has_pedestrian_type_case() const {
  return DirectionsLeg_Maneuver::HasPedestrianTypeCase(_oneof_case_[21]);
}
inline DirectionsLeg_Maneuver::HasBicycleTypeCase DirectionsLeg_Maneuver::has_bicycle_type_case() const {
  return DirectionsLeg_Maneuver::HasBicycleTypeCase(_oneof_case_[22]);
}
inline DirectionsLeg_Maneuver::HasTransitTypeCase DirectionsLeg_Maneuver::has_transit_type_case() const {
  return DirectionsLeg_Maneuver::HasTransitTypeCase(_oneof_case_[23]);
}
inline DirectionsLeg_Maneuver::HasBeginPathIndexCase DirectionsLeg_Maneuver::has_begin_path_index_case() const {
  return DirectionsLeg_Maneuver::HasBeginPathIndexCase(_oneof_case_[24]);
}
inline DirectionsLeg_Maneuver::HasEndPathIndexCase DirectionsLeg_Maneuver::has_end_path_index_case() const {
  return DirectionsLeg_Maneuver::HasEndPathIndexCase(_oneof_case_[25]);
}
inline DirectionsLeg_Maneuver::HasToStayOnCase DirectionsLeg_Maneuver::has_to_stay_on_case() const {
  return DirectionsLeg_Maneuver::HasToStayOnCase(_oneof_case_[26]);
}
inline DirectionsLeg_Maneuver::HasTurnDegreeCase DirectionsLeg_Maneuver::has_turn_degree_case() const {
  return DirectionsLeg_Maneuver::HasTurnDegreeCase(_oneof_case_[27]);
}
inline DirectionsLeg_Maneuver::HasHasTimeRestrictionsCase DirectionsLeg_Maneuver::has_has_time_restrictions_case() const {
  return DirectionsLeg_Maneuver::HasHasTimeRestrictionsCase(_oneof_case_[28]);
}
inline DirectionsLeg_Maneuver::HasBssManeuverTypeCase DirectionsLeg_Maneuver::has_bss_maneuver_type_case() const {
  return DirectionsLeg_Maneuver::HasBssManeuverTypeCase(_oneof_case_[29]);
}
inline DirectionsLeg_Maneuver::HasVerbalSuccinctTransitionInstructionCase DirectionsLeg_Maneuver::has_verbal_succinct_transition_instruction_case() const {
  return DirectionsLeg_Maneuver::HasVerbalSuccinctTransitionInstructionCase(_oneof_case_[30]);
}
// -------------------------------------------------------------------

// DirectionsLeg

// uint64 trip_id = 1;
inline bool DirectionsLeg::_internal_has_trip_id() const {
  return has_trip_id_case() == kTripId;
}
inline bool DirectionsLeg::has_trip_id() const {
  return _internal_has_trip_id();
}
inline void DirectionsLeg::set_has_trip_id() {
  _oneof_case_[0] = kTripId;
}
inline void DirectionsLeg::clear_trip_id() {
  if (_internal_has_trip_id()) {
    has_trip_id_.trip_id_ = uint64_t{0u};
    clear_has_has_trip_id();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DirectionsLeg::_internal_trip_id() const {
  if (_internal_has_trip_id()) {
    return has_trip_id_.trip_id_;
  }
  return uint64_t{0u};
}
inline void DirectionsLeg::_internal_set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_trip_id()) {
    clear_has_trip_id();
    set_has_trip_id();
  }
  has_trip_id_.trip_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DirectionsLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.trip_id)
  return _internal_trip_id();
}
inline void DirectionsLeg::set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.trip_id)
}

// uint32 leg_id = 2;
inline bool DirectionsLeg::_internal_has_leg_id() const {
  return has_leg_id_case() == kLegId;
}
inline bool DirectionsLeg::has_leg_id() const {
  return _internal_has_leg_id();
}
inline void DirectionsLeg::set_has_leg_id() {
  _oneof_case_[1] = kLegId;
}
inline void DirectionsLeg::clear_leg_id() {
  if (_internal_has_leg_id()) {
    has_leg_id_.leg_id_ = 0u;
    clear_has_has_leg_id();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::_internal_leg_id() const {
  if (_internal_has_leg_id()) {
    return has_leg_id_.leg_id_;
  }
  return 0u;
}
inline void DirectionsLeg::_internal_set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_leg_id()) {
    clear_has_leg_id();
    set_has_leg_id();
  }
  has_leg_id_.leg_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_id)
  return _internal_leg_id();
}
inline void DirectionsLeg::set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_id)
}

// uint32 leg_count = 3;
inline bool DirectionsLeg::_internal_has_leg_count() const {
  return has_leg_count_case() == kLegCount;
}
inline bool DirectionsLeg::has_leg_count() const {
  return _internal_has_leg_count();
}
inline void DirectionsLeg::set_has_leg_count() {
  _oneof_case_[2] = kLegCount;
}
inline void DirectionsLeg::clear_leg_count() {
  if (_internal_has_leg_count()) {
    has_leg_count_.leg_count_ = 0u;
    clear_has_has_leg_count();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::_internal_leg_count() const {
  if (_internal_has_leg_count()) {
    return has_leg_count_.leg_count_;
  }
  return 0u;
}
inline void DirectionsLeg::_internal_set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_leg_count()) {
    clear_has_leg_count();
    set_has_leg_count();
  }
  has_leg_count_.leg_count_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_count)
  return _internal_leg_count();
}
inline void DirectionsLeg::set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_count)
}

// repeated .valhalla.Location location = 4;
inline int DirectionsLeg::_internal_location_size() const {
  return location_.size();
}
inline int DirectionsLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* DirectionsLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.location)
  return location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
DirectionsLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.location)
  return &location_;
}
inline const ::valhalla::Location& DirectionsLeg::_internal_location(int index) const {
  return location_.Get(index);
}
inline const ::valhalla::Location& DirectionsLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.location)
  return _internal_location(index);
}
inline ::valhalla::Location* DirectionsLeg::_internal_add_location() {
  return location_.Add();
}
inline ::valhalla::Location* DirectionsLeg::add_location() {
  ::valhalla::Location* _add = _internal_add_location();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.location)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
DirectionsLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.location)
  return location_;
}

// .valhalla.DirectionsLeg.Summary summary = 5;
inline bool DirectionsLeg::_internal_has_summary() const {
  return this != internal_default_instance() && summary_ != nullptr;
}
inline bool DirectionsLeg::has_summary() const {
  return _internal_has_summary();
}
inline void DirectionsLeg::clear_summary() {
  if (GetArenaForAllocation() == nullptr && summary_ != nullptr) {
    delete summary_;
  }
  summary_ = nullptr;
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::_internal_summary() const {
  const ::valhalla::DirectionsLeg_Summary* p = summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::DirectionsLeg_Summary&>(
      ::valhalla::_DirectionsLeg_Summary_default_instance_);
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::summary() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.summary)
  return _internal_summary();
}
inline void DirectionsLeg::unsafe_arena_set_allocated_summary(
    ::valhalla::DirectionsLeg_Summary* summary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(summary_);
  }
  summary_ = summary;
  if (summary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.summary)
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::release_summary() {
  
  ::valhalla::DirectionsLeg_Summary* temp = summary_;
  summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::unsafe_arena_release_summary() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.summary)
  
  ::valhalla::DirectionsLeg_Summary* temp = summary_;
  summary_ = nullptr;
  return temp;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::_internal_mutable_summary() {
  
  if (summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::DirectionsLeg_Summary>(GetArenaForAllocation());
    summary_ = p;
  }
  return summary_;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::mutable_summary() {
  ::valhalla::DirectionsLeg_Summary* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.summary)
  return _msg;
}
inline void DirectionsLeg::set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete summary_;
  }
  if (summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::DirectionsLeg_Summary>::GetOwningArena(summary);
    if (message_arena != submessage_arena) {
      summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary, submessage_arena);
    }
    
  } else {
    
  }
  summary_ = summary;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.summary)
}

// repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
inline int DirectionsLeg::_internal_maneuver_size() const {
  return maneuver_.size();
}
inline int DirectionsLeg::maneuver_size() const {
  return _internal_maneuver_size();
}
inline void DirectionsLeg::clear_maneuver() {
  maneuver_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::mutable_maneuver(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.maneuver)
  return maneuver_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
DirectionsLeg::mutable_maneuver() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.maneuver)
  return &maneuver_;
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::_internal_maneuver(int index) const {
  return maneuver_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::maneuver(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.maneuver)
  return _internal_maneuver(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::_internal_add_maneuver() {
  return maneuver_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::add_maneuver() {
  ::valhalla::DirectionsLeg_Maneuver* _add = _internal_add_maneuver();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.maneuver)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
DirectionsLeg::maneuver() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.maneuver)
  return maneuver_;
}

// string shape = 7;
inline bool DirectionsLeg::_internal_has_shape() const {
  return has_shape_case() == kShape;
}
inline bool DirectionsLeg::has_shape() const {
  return _internal_has_shape();
}
inline void DirectionsLeg::set_has_shape() {
  _oneof_case_[3] = kShape;
}
inline void DirectionsLeg::clear_shape() {
  if (_internal_has_shape()) {
    has_shape_.shape_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_shape();
  }
}
inline const std::string& DirectionsLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.shape)
  return _internal_shape();
}
template <typename ArgT0, typename... ArgT>
inline void DirectionsLeg::set_shape(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.shape)
}
inline std::string* DirectionsLeg::mutable_shape() {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.shape)
  return _s;
}
inline const std::string& DirectionsLeg::_internal_shape() const {
  if (_internal_has_shape()) {
    return has_shape_.shape_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DirectionsLeg::_internal_set_shape(const std::string& value) {
  if (!_internal_has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_shape_.shape_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg::_internal_mutable_shape() {
  if (!_internal_has_shape()) {
    clear_has_shape();
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_shape_.shape_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.shape)
  if (_internal_has_shape()) {
    clear_has_has_shape();
    return has_shape_.shape_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DirectionsLeg::set_allocated_shape(std::string* shape) {
  if (has_has_shape()) {
    clear_has_shape();
  }
  if (shape != nullptr) {
    set_has_shape();
    has_shape_.shape_.UnsafeSetDefault(shape);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(shape);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.shape)
}

inline bool DirectionsLeg::has_has_trip_id() const {
  return has_trip_id_case() != HAS_TRIP_ID_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_trip_id() {
  _oneof_case_[0] = HAS_TRIP_ID_NOT_SET;
}
inline bool DirectionsLeg::has_has_leg_id() const {
  return has_leg_id_case() != HAS_LEG_ID_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_leg_id() {
  _oneof_case_[1] = HAS_LEG_ID_NOT_SET;
}
inline bool DirectionsLeg::has_has_leg_count() const {
  return has_leg_count_case() != HAS_LEG_COUNT_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_leg_count() {
  _oneof_case_[2] = HAS_LEG_COUNT_NOT_SET;
}
inline bool DirectionsLeg::has_has_shape() const {
  return has_shape_case() != HAS_SHAPE_NOT_SET;
}
inline void DirectionsLeg::clear_has_has_shape() {
  _oneof_case_[3] = HAS_SHAPE_NOT_SET;
}
inline DirectionsLeg::HasTripIdCase DirectionsLeg::has_trip_id_case() const {
  return DirectionsLeg::HasTripIdCase(_oneof_case_[0]);
}
inline DirectionsLeg::HasLegIdCase DirectionsLeg::has_leg_id_case() const {
  return DirectionsLeg::HasLegIdCase(_oneof_case_[1]);
}
inline DirectionsLeg::HasLegCountCase DirectionsLeg::has_leg_count_case() const {
  return DirectionsLeg::HasLegCountCase(_oneof_case_[2]);
}
inline DirectionsLeg::HasShapeCase DirectionsLeg::has_shape_case() const {
  return DirectionsLeg::HasShapeCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// DirectionsRoute

// repeated .valhalla.DirectionsLeg legs = 1;
inline int DirectionsRoute::_internal_legs_size() const {
  return legs_.size();
}
inline int DirectionsRoute::legs_size() const {
  return _internal_legs_size();
}
inline void DirectionsRoute::clear_legs() {
  legs_.Clear();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsRoute.legs)
  return legs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >*
DirectionsRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsRoute.legs)
  return &legs_;
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::_internal_legs(int index) const {
  return legs_.Get(index);
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsRoute.legs)
  return _internal_legs(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::_internal_add_legs() {
  return legs_.Add();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::add_legs() {
  ::valhalla::DirectionsLeg* _add = _internal_add_legs();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsRoute.legs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >&
DirectionsRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsRoute.legs)
  return legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.DirectionsRoute routes = 1;
inline int Directions::_internal_routes_size() const {
  return routes_.size();
}
inline int Directions::routes_size() const {
  return _internal_routes_size();
}
inline void Directions::clear_routes() {
  routes_.Clear();
}
inline ::valhalla::DirectionsRoute* Directions::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >*
Directions::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.routes)
  return &routes_;
}
inline const ::valhalla::DirectionsRoute& Directions::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::valhalla::DirectionsRoute& Directions::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.routes)
  return _internal_routes(index);
}
inline ::valhalla::DirectionsRoute* Directions::_internal_add_routes() {
  return routes_.Add();
}
inline ::valhalla::DirectionsRoute* Directions::add_routes() {
  ::valhalla::DirectionsRoute* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:valhalla.Directions.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >&
Directions::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Directions.routes)
  return routes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::DirectionsLeg_GuidanceView_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_directions_2eproto
