diff --git a/src/baldr/directededge.cc b/src/baldr/directededge.cc
index f52dd1a09..e73fbb0ab 100644
--- a/src/baldr/directededge.cc
+++ b/src/baldr/directededge.cc
@@ -575,57 +575,57 @@ void DirectedEdge::set_bss_connection(const bool bss_connection) {
 // Json representation
 json::MapPtr DirectedEdge::json() const {
   json::MapPtr map = json::map({
-      {"end_node", endnode().json()},
-      {"speeds", json::map({
-                     {"default", static_cast<uint64_t>(speed_)},
-                     {"type", to_string(static_cast<SpeedType>(speed_type_))},
-                     {"free_flow", static_cast<uint64_t>(free_flow_speed_)},
-                     {"constrained_flow", static_cast<uint64_t>(constrained_flow_speed_)},
-                     {"predicted", static_cast<bool>(has_predicted_speed_)},
-                 })},
-      //{"opp_index", static_cast<bool>(opp_index_)},
-      //{"edge_info_offset", static_cast<uint64_t>(edgeinfo_offset_)},
-      //{"restrictions", restrictions_},
-      {"access_restriction", static_cast<bool>(access_restriction_)},
-      {"start_restriction", access_json(start_restriction_)},
-      {"end_restriction", access_json(end_restriction_)},
-      {"part_of_complex_restriction", static_cast<bool>(complex_restriction_)},
-      {"has_sign", static_cast<bool>(sign_)},
-      {"toll", static_cast<bool>(toll_)},
-      {"seasonal", static_cast<bool>(seasonal_)},
-      {"destination_only", static_cast<bool>(dest_only_)},
-      {"tunnel", static_cast<bool>(tunnel_)},
-      {"bridge", static_cast<bool>(bridge_)},
-      {"round_about", static_cast<bool>(roundabout_)},
-      {"traffic_signal", static_cast<bool>(traffic_signal_)},
+//      {"end_node", endnode().json()},
+//      {"speeds", json::map({
+//                     {"default", static_cast<uint64_t>(speed_)},
+//                     {"type", to_string(static_cast<SpeedType>(speed_type_))},
+//                     {"free_flow", static_cast<uint64_t>(free_flow_speed_)},
+//                     {"constrained_flow", static_cast<uint64_t>(constrained_flow_speed_)},
+//                     {"predicted", static_cast<bool>(has_predicted_speed_)},
+//                 })},
+//      //{"opp_index", static_cast<bool>(opp_index_)},
+//      //{"edge_info_offset", static_cast<uint64_t>(edgeinfo_offset_)},
+//      //{"restrictions", restrictions_},
+//      {"access_restriction", static_cast<bool>(access_restriction_)},
+//      {"start_restriction", access_json(start_restriction_)},
+//      {"end_restriction", access_json(end_restriction_)},
+//      {"part_of_complex_restriction", static_cast<bool>(complex_restriction_)},
+//      {"has_sign", static_cast<bool>(sign_)},
+//      {"toll", static_cast<bool>(toll_)},
+//      {"seasonal", static_cast<bool>(seasonal_)},
+//      {"destination_only", static_cast<bool>(dest_only_)},
+//      {"tunnel", static_cast<bool>(tunnel_)},
+//      {"bridge", static_cast<bool>(bridge_)},
+//      {"round_about", static_cast<bool>(roundabout_)},
+//      {"traffic_signal", static_cast<bool>(traffic_signal_)},
       {"forward", static_cast<bool>(forward_)},
-      {"not_thru", static_cast<bool>(not_thru_)},
-      {"stop_sign", static_cast<bool>(stop_sign_)},
-      {"yield_sign", static_cast<bool>(yield_sign_)},
-      {"cycle_lane", to_string(static_cast<CycleLane>(cycle_lane_))},
-      {"bike_network", static_cast<bool>(bike_network_)},
-      {"truck_route", static_cast<bool>(truck_route_)},
-      {"lane_count", static_cast<uint64_t>(lanecount_)},
-      {"country_crossing", static_cast<bool>(ctry_crossing_)},
-      {"sidewalk_left", static_cast<bool>(sidewalk_left_)},
-      {"sidewalk_right", static_cast<bool>(sidewalk_right_)},
-      {"sac_scale", to_string(static_cast<SacScale>(sac_scale_))},
+//      {"not_thru", static_cast<bool>(not_thru_)},
+//      {"stop_sign", static_cast<bool>(stop_sign_)},
+//      {"yield_sign", static_cast<bool>(yield_sign_)},
+//      {"cycle_lane", to_string(static_cast<CycleLane>(cycle_lane_))},
+//      {"bike_network", static_cast<bool>(bike_network_)},
+//      {"truck_route", static_cast<bool>(truck_route_)},
+//      {"lane_count", static_cast<uint64_t>(lanecount_)},
+//      {"country_crossing", static_cast<bool>(ctry_crossing_)},
+//      {"sidewalk_left", static_cast<bool>(sidewalk_left_)},
+//      {"sidewalk_right", static_cast<bool>(sidewalk_right_)},
+//      {"sac_scale", to_string(static_cast<SacScale>(sac_scale_))},
       {"geo_attributes",
        json::map({
            {"length", static_cast<uint64_t>(length_)},
-           {"weighted_grade", json::fixed_t{static_cast<double>(weighted_grade_ - 6.0) / .6, 2}},
-           {"max_up_slope", json::fixed_t{static_cast<double>(max_up_slope()), 2}},
-           {"max_down_slope", json::fixed_t{static_cast<double>(max_down_slope()), 2}},
-           {"curvature", static_cast<uint64_t>(curvature_)},
+//           {"weighted_grade", json::fixed_t{static_cast<double>(weighted_grade_ - 6.0) / .6, 2}},
+//           {"max_up_slope", json::fixed_t{static_cast<double>(max_up_slope()), 2}},
+//           {"max_down_slope", json::fixed_t{static_cast<double>(max_down_slope()), 2}},
+//           {"curvature", static_cast<uint64_t>(curvature_)},
        })},
-      {"access", access_json(forwardaccess_)},
+//      {"access", access_json(forwardaccess_)},
       //{"access", access_json(reverseaccess_)},
       {"classification", json::map({
                              {"classification", to_string(static_cast<RoadClass>(classification_))},
-                             {"use", to_string(static_cast<Use>(use_))},
-                             {"surface", to_string(static_cast<Surface>(surface_))},
-                             {"link", static_cast<bool>(link_)},
-                             {"internal", static_cast<bool>(internal_)},
+//                             {"use", to_string(static_cast<Use>(use_))},
+//                             {"surface", to_string(static_cast<Surface>(surface_))},
+//                             {"link", static_cast<bool>(link_)},
+//                             {"internal", static_cast<bool>(internal_)},
                          })},
       /*{"hierarchy", json::map({
         {"local_edge_index", static_cast<uint64_t>(localedgeidx_)},
@@ -636,9 +636,9 @@ json::MapPtr DirectedEdge::json() const {
       })},*/
   });
 
-  if (is_hov_only()) {
-    map->emplace("hov_type", to_string(static_cast<HOVEdgeType>(hov_type_)));
-  }
+//  if (is_hov_only()) {
+//    map->emplace("hov_type", to_string(static_cast<HOVEdgeType>(hov_type_)));
+//  }
 
   return map;
 }
diff --git a/src/tyr/locate_serializer.cc b/src/tyr/locate_serializer.cc
index 8216dca61..b661b6418 100644
--- a/src/tyr/locate_serializer.cc
+++ b/src/tyr/locate_serializer.cc
@@ -67,37 +67,37 @@ json::ArrayPtr serialize_edges(const PathLocation& location, GraphReader& reader
         auto live_speed = traffic.json();
 
         // incident information
-        if (traffic.has_incidents) {
-          // TODO: incidents
-        }
+//        if (traffic.has_incidents) {
+//          // TODO: incidents
+//        }
 
         // historical traffic information
-        auto predicted_speeds = json::array({});
-        if (directed_edge->has_predicted_speed()) {
-          for (auto sec = 0; sec < midgard::kSecondsPerWeek; sec += 5 * midgard::kSecPerMinute) {
-            predicted_speeds->emplace_back(
-                static_cast<uint64_t>(tile->GetSpeed(directed_edge, kPredictedFlowMask, sec)));
-          }
-        }
+//        auto predicted_speeds = json::array({});
+//        if (directed_edge->has_predicted_speed()) {
+//          for (auto sec = 0; sec < midgard::kSecondsPerWeek; sec += 5 * midgard::kSecPerMinute) {
+//            predicted_speeds->emplace_back(
+//                static_cast<uint64_t>(tile->GetSpeed(directed_edge, kPredictedFlowMask, sec)));
+//          }
+//        }
 
         // basic rest of it plus edge metadata
         array->emplace_back(json::map({
             {"correlated_lat", json::fixed_t{edge.projected.lat(), 6}},
             {"correlated_lon", json::fixed_t{edge.projected.lng(), 6}},
-            {"side_of_street",
-             edge.sos == PathLocation::LEFT
-                 ? std::string("left")
-                 : (edge.sos == PathLocation::RIGHT ? std::string("right") : std::string("neither"))},
+//            {"side_of_street",
+//             edge.sos == PathLocation::LEFT
+//                 ? std::string("left")
+//                 : (edge.sos == PathLocation::RIGHT ? std::string("right") : std::string("neither"))},
             {"percent_along", json::fixed_t{edge.percent_along, 5}},
             {"distance", json::fixed_t{edge.distance, 1}},
             {"heading", json::fixed_t{edge.projected_heading, 1}},
-            {"outbound_reach", static_cast<int64_t>(edge.outbound_reach)},
-            {"inbound_reach", static_cast<int64_t>(edge.inbound_reach)},
+//            {"outbound_reach", static_cast<int64_t>(edge.outbound_reach)},
+//            {"inbound_reach", static_cast<int64_t>(edge.inbound_reach)},
             {"edge_id", edge.id.json()},
             {"edge", directed_edge->json()},
-            {"edge_info", edge_info.json()},
-            {"linear_reference", linear_reference(directed_edge, edge.percent_along, edge_info)},
-            {"predicted_speeds", predicted_speeds},
+//            {"edge_info", edge_info.json()},
+//            {"linear_reference", linear_reference(directed_edge, edge.percent_along, edge_info)},
+//            {"predicted_speeds", predicted_speeds},
             {"live_speed", live_speed},
         }));
       } // they want it lean and mean
@@ -166,9 +166,9 @@ json::MapPtr serialize(const PathLocation& location, GraphReader& reader, bool v
 json::MapPtr serialize(const midgard::PointLL& ll, const std::string& reason, bool verbose) {
   auto m = json::map({
       {"edges", static_cast<std::nullptr_t>(nullptr)},
-      {"nodes", static_cast<std::nullptr_t>(nullptr)},
-      {"input_lat", json::fixed_t{ll.lat(), 6}},
-      {"input_lon", json::fixed_t{ll.lng(), 6}},
+//      {"nodes", static_cast<std::nullptr_t>(nullptr)},
+//      {"input_lat", json::fixed_t{ll.lat(), 6}},
+//      {"input_lon", json::fixed_t{ll.lng(), 6}},
   });
   if (verbose) {
     m->emplace("reason", reason);
