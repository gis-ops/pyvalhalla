diff --git a/src/thor/triplegbuilder.cc b/src/thor/triplegbuilder.cc
index 8cb8469c5..3ad24cd25 100644
--- a/src/thor/triplegbuilder.cc
+++ b/src/thor/triplegbuilder.cc
@@ -1687,7 +1687,7 @@ void TripLegBuilder::Build(
     // Set length if requested. Convert to km
     if (controller.attributes.at(kEdgeLength)) {
       float km =
-          std::max(directededge->length() * kKmPerMeter * (trim_end_pct - trim_start_pct), 0.0f);
+          std::max(directededge->length() * kKmPerMeter, 0.0f);
       trip_edge->set_length_km(km);
     }
 
diff --git a/src/tyr/trace_serializer.cc b/src/tyr/trace_serializer.cc
index 68df54332..535944114 100644
--- a/src/tyr/trace_serializer.cc
+++ b/src/tyr/trace_serializer.cc
@@ -63,282 +63,290 @@ json::ArrayPtr serialize_edges(const AttributesController& controller,
 
       // Process each edge
       auto edge_map = json::map({});
-      if (edge.has_truck_route_case()) {
-        edge_map->emplace("truck_route", static_cast<bool>(edge.truck_route()));
-      }
-      if (edge.has_truck_speed_case() && (edge.truck_speed() > 0)) {
-        edge_map->emplace("truck_speed",
-                          static_cast<uint64_t>(std::round(edge.truck_speed() * scale)));
-      }
-      if (edge.has_speed_limit_case() && (edge.speed_limit() > 0)) {
-        if (edge.speed_limit() == kUnlimitedSpeedLimit) {
-          edge_map->emplace("speed_limit", std::string("unlimited"));
-        } else {
-          edge_map->emplace("speed_limit",
-                            static_cast<uint64_t>(std::round(edge.speed_limit() * scale)));
-        }
-      }
-      if (edge.has_density_case()) {
-        edge_map->emplace("density", static_cast<uint64_t>(edge.density()));
-      }
-      if (edge.has_sac_scale_case()) {
-        edge_map->emplace("sac_scale", static_cast<uint64_t>(edge.sac_scale()));
-      }
-      if (edge.has_shoulder_case()) {
-        edge_map->emplace("shoulder", static_cast<bool>(edge.shoulder()));
-      }
-      if (edge.has_sidewalk_case()) {
-        edge_map->emplace("sidewalk", to_string(edge.sidewalk()));
-      }
-      if (edge.has_bicycle_network_case()) {
-        edge_map->emplace("bicycle_network", static_cast<uint64_t>(edge.bicycle_network()));
-      }
-      if (edge.has_cycle_lane_case()) {
-        edge_map->emplace("cycle_lane", to_string(static_cast<CycleLane>(edge.cycle_lane())));
-      }
-      if (edge.has_lane_count_case()) {
-        edge_map->emplace("lane_count", static_cast<uint64_t>(edge.lane_count()));
-      }
-      if (edge.lane_connectivity_size()) {
-        auto lane_connectivity = json::array({});
-        for (const auto& l : edge.lane_connectivity()) {
-          auto element = json::map({});
-          element->emplace("from", l.from_way_id());
-          element->emplace("to_lanes", l.to_lanes());
-          element->emplace("from_lanes", l.from_lanes());
-          lane_connectivity->push_back(element);
-        }
-        edge_map->emplace("lane_connectivity", lane_connectivity);
-      }
-      if (edge.has_max_downward_grade_case()) {
-        edge_map->emplace("max_downward_grade", static_cast<int64_t>(edge.max_downward_grade()));
-      }
-      if (edge.has_max_upward_grade_case()) {
-        edge_map->emplace("max_upward_grade", static_cast<int64_t>(edge.max_upward_grade()));
-      }
-      if (edge.has_weighted_grade_case()) {
-        edge_map->emplace("weighted_grade", json::fixed_t{edge.weighted_grade(), 3});
-      }
-      if (edge.has_mean_elevation_case()) {
-        // Convert to feet if a valid elevation and units are miles
-        float mean = edge.mean_elevation();
-        if (mean != kNoElevationData && options.has_units_case() &&
-            options.units() == Options::miles) {
-          mean *= kFeetPerMeter;
-        }
-        edge_map->emplace("mean_elevation", static_cast<int64_t>(mean));
-      }
-      if (edge.has_way_id_case()) {
-        edge_map->emplace("way_id", static_cast<uint64_t>(edge.way_id()));
-      }
+//      if (edge.has_truck_route_case()) {
+//        edge_map->emplace("truck_route", static_cast<bool>(edge.truck_route()));
+//      }
+//      if (edge.has_truck_speed_case() && (edge.truck_speed() > 0)) {
+//        edge_map->emplace("truck_speed",
+//                          static_cast<uint64_t>(std::round(edge.truck_speed() * scale)));
+//      }
+//      if (edge.has_speed_limit_case() && (edge.speed_limit() > 0)) {
+//        if (edge.speed_limit() == kUnlimitedSpeedLimit) {
+//          edge_map->emplace("speed_limit", std::string("unlimited"));
+//        } else {
+//          edge_map->emplace("speed_limit",
+//                            static_cast<uint64_t>(std::round(edge.speed_limit() * scale)));
+//        }
+//      }
+//      if (edge.has_density_case()) {
+//        edge_map->emplace("density", static_cast<uint64_t>(edge.density()));
+//      }
+//      if (edge.has_sac_scale_case()) {
+//        edge_map->emplace("sac_scale", static_cast<uint64_t>(edge.sac_scale()));
+//      }
+//      if (edge.has_shoulder_case()) {
+//        edge_map->emplace("shoulder", static_cast<bool>(edge.shoulder()));
+//      }
+//      if (edge.has_sidewalk_case()) {
+//        edge_map->emplace("sidewalk", to_string(edge.sidewalk()));
+//      }
+//      if (edge.has_bicycle_network_case()) {
+//        edge_map->emplace("bicycle_network", static_cast<uint64_t>(edge.bicycle_network()));
+//      }
+//      if (edge.has_cycle_lane_case()) {
+//        edge_map->emplace("cycle_lane", to_string(static_cast<CycleLane>(edge.cycle_lane())));
+//      }
+//      if (edge.has_lane_count_case()) {
+//        edge_map->emplace("lane_count", static_cast<uint64_t>(edge.lane_count()));
+//      }
+//      if (edge.lane_connectivity_size()) {
+//        auto lane_connectivity = json::array({});
+//        for (const auto& l : edge.lane_connectivity()) {
+//          auto element = json::map({});
+//          element->emplace("from", l.from_way_id());
+//          element->emplace("to_lanes", l.to_lanes());
+//          element->emplace("from_lanes", l.from_lanes());
+//          lane_connectivity->push_back(element);
+//        }
+//        edge_map->emplace("lane_connectivity", lane_connectivity);
+//      }
+//      if (edge.has_max_downward_grade_case()) {
+//        edge_map->emplace("max_downward_grade", static_cast<int64_t>(edge.max_downward_grade()));
+//      }
+//      if (edge.has_max_upward_grade_case()) {
+//        edge_map->emplace("max_upward_grade", static_cast<int64_t>(edge.max_upward_grade()));
+//      }
+//      if (edge.has_weighted_grade_case()) {
+//        edge_map->emplace("weighted_grade", json::fixed_t{edge.weighted_grade(), 3});
+//      }
+//      if (edge.has_mean_elevation_case()) {
+//        // Convert to feet if a valid elevation and units are miles
+//        float mean = edge.mean_elevation();
+//        if (mean != kNoElevationData && options.has_units_case() &&
+//            options.units() == Options::miles) {
+//          mean *= kFeetPerMeter;
+//        }
+//        edge_map->emplace("mean_elevation", static_cast<int64_t>(mean));
+//      }
+//      if (edge.has_way_id_case()) {
+//        edge_map->emplace("way_id", static_cast<uint64_t>(edge.way_id()));
+//      }
       if (edge.has_id_case()) {
         edge_map->emplace("id", static_cast<uint64_t>(edge.id()));
       }
-      if (edge.has_travel_mode_case()) {
-        edge_map->emplace("travel_mode", to_string(edge.travel_mode()));
-      }
-      if (edge.has_vehicle_type_case()) {
-        edge_map->emplace("vehicle_type", to_string(edge.vehicle_type()));
-      }
-      if (edge.has_pedestrian_type_case()) {
-        edge_map->emplace("pedestrian_type", to_string(edge.pedestrian_type()));
-      }
-      if (edge.has_bicycle_type_case()) {
-        edge_map->emplace("bicycle_type", to_string(edge.bicycle_type()));
-      }
-      if (edge.has_surface_case()) {
-        edge_map->emplace("surface", to_string(static_cast<baldr::Surface>(edge.surface())));
-      }
-      if (edge.has_drive_on_left_case()) {
-        edge_map->emplace("drive_on_right", static_cast<bool>(!edge.drive_on_left()));
-      }
-      if (edge.has_internal_intersection_case()) {
-        edge_map->emplace("internal_intersection", static_cast<bool>(edge.internal_intersection()));
-      }
-      if (edge.has_roundabout_case()) {
-        edge_map->emplace("roundabout", static_cast<bool>(edge.roundabout()));
-      }
-      if (edge.has_bridge_case()) {
-        edge_map->emplace("bridge", static_cast<bool>(edge.bridge()));
-      }
-      if (edge.has_tunnel_case()) {
-        edge_map->emplace("tunnel", static_cast<bool>(edge.tunnel()));
-      }
-      if (edge.has_unpaved_case()) {
-        edge_map->emplace("unpaved", static_cast<bool>(edge.unpaved()));
-      }
-      if (edge.has_toll_case()) {
-        edge_map->emplace("toll", static_cast<bool>(edge.toll()));
-      }
-      if (edge.has_use_case()) {
-        edge_map->emplace("use", to_string(static_cast<baldr::Use>(edge.use())));
-      }
-      if (edge.has_traversability_case()) {
-        edge_map->emplace("traversability", to_string(edge.traversability()));
-      }
-      if (edge.has_end_shape_index_case()) {
-        edge_map->emplace("end_shape_index", static_cast<uint64_t>(edge.end_shape_index()));
-      }
-      if (edge.has_begin_shape_index_case()) {
-        edge_map->emplace("begin_shape_index", static_cast<uint64_t>(edge.begin_shape_index()));
-      }
-      if (edge.has_end_heading_case()) {
-        edge_map->emplace("end_heading", static_cast<uint64_t>(edge.end_heading()));
-      }
-      if (edge.has_begin_heading_case()) {
-        edge_map->emplace("begin_heading", static_cast<uint64_t>(edge.begin_heading()));
-      }
-      if (edge.has_road_class_case()) {
-        edge_map->emplace("road_class", to_string(static_cast<baldr::RoadClass>(edge.road_class())));
-      }
-      if (edge.has_speed_case()) {
-        edge_map->emplace("speed", static_cast<uint64_t>(std::round(edge.speed() * scale)));
+//      if (edge.has_travel_mode_case()) {
+//        edge_map->emplace("travel_mode", to_string(edge.travel_mode()));
+//      }
+//      if (edge.has_vehicle_type_case()) {
+//        edge_map->emplace("vehicle_type", to_string(edge.vehicle_type()));
+//      }
+//      if (edge.has_pedestrian_type_case()) {
+//        edge_map->emplace("pedestrian_type", to_string(edge.pedestrian_type()));
+//      }
+//      if (edge.has_bicycle_type_case()) {
+//        edge_map->emplace("bicycle_type", to_string(edge.bicycle_type()));
+//      }
+//      if (edge.has_surface_case()) {
+//        edge_map->emplace("surface", to_string(static_cast<baldr::Surface>(edge.surface())));
+//      }
+//      if (edge.has_drive_on_left_case()) {
+//        edge_map->emplace("drive_on_right", static_cast<bool>(!edge.drive_on_left()));
+//      }
+//      if (edge.has_internal_intersection_case()) {
+//        edge_map->emplace("internal_intersection", static_cast<bool>(edge.internal_intersection()));
+//      }
+//      if (edge.has_roundabout_case()) {
+//        edge_map->emplace("roundabout", static_cast<bool>(edge.roundabout()));
+//      }
+//      if (edge.has_bridge_case()) {
+//        edge_map->emplace("bridge", static_cast<bool>(edge.bridge()));
+//      }
+//      if (edge.has_tunnel_case()) {
+//        edge_map->emplace("tunnel", static_cast<bool>(edge.tunnel()));
+//      }
+//      if (edge.has_unpaved_case()) {
+//        edge_map->emplace("unpaved", static_cast<bool>(edge.unpaved()));
+//      }
+//      if (edge.has_toll_case()) {
+//        edge_map->emplace("toll", static_cast<bool>(edge.toll()));
+//      }
+//      if (edge.has_use_case()) {
+//        edge_map->emplace("use", to_string(static_cast<baldr::Use>(edge.use())));
+//      }
+//      if (edge.has_traversability_case()) {
+//        edge_map->emplace("traversability", to_string(edge.traversability()));
+//      }
+//      if (edge.has_end_shape_index_case()) {
+//        edge_map->emplace("end_shape_index", static_cast<uint64_t>(edge.end_shape_index()));
+//      }
+//      if (edge.has_begin_shape_index_case()) {
+//        edge_map->emplace("begin_shape_index", static_cast<uint64_t>(edge.begin_shape_index()));
+//      }
+//      if (edge.has_end_heading_case()) {
+//        edge_map->emplace("end_heading", static_cast<uint64_t>(edge.end_heading()));
+//      }
+//      if (edge.has_begin_heading_case()) {
+//        edge_map->emplace("begin_heading", static_cast<uint64_t>(edge.begin_heading()));
+//      }
+//      if (edge.has_road_class_case()) {
+//        edge_map->emplace("road_class", to_string(static_cast<baldr::RoadClass>(edge.road_class())));
+//      }
+//      if (edge.has_speed_case()) {
+//        edge_map->emplace("speed", static_cast<uint64_t>(std::round(edge.speed() * scale)));
+//      }
+      if (edge.has_source_along_edge_case()) {
+        auto r = edge.source_along_edge();
+        edge_map->emplace("source_percent_along", json::fixed_t{r, 2});
+      }
+      if (edge.has_target_along_edge_case()) {
+        auto r = edge.target_along_edge();
+        edge_map->emplace("target_percent_along", json::fixed_t{edge.target_along_edge(), 2});
       }
       if (edge.has_length_km_case()) {
         edge_map->emplace("length", json::fixed_t{edge.length_km() * scale, 3});
       }
       // TODO: do we want to output 'is_route_number'?
-      if (edge.name_size() > 0) {
-        auto names_array = json::array({});
-        for (const auto& name : edge.name()) {
-          names_array->push_back(name.value());
-        }
-        edge_map->emplace("names", names_array);
-      }
-      if (edge.traffic_segment().size() > 0) {
-        auto segments_array = json::array({});
-        for (const auto& segment : edge.traffic_segment()) {
-          json::MapPtr segmap =
-              json::map({{"segment_id", segment.segment_id()},
-                         {"begin_percent", json::fixed_t{segment.begin_percent(), 3}},
-                         {"end_percent", json::fixed_t{segment.end_percent(), 3}},
-                         {"starts_segment", segment.starts_segment()},
-                         {"ends_segment", segment.ends_segment()}});
-          segments_array->emplace_back(segmap);
-        }
-        edge_map->emplace("traffic_segments", segments_array);
-      }
-
-      // Process edge sign
-      // TODO: do we want to output 'is_route_number'?
-      if (edge.has_sign()) {
-        auto sign_map = json::map({});
-
-        // Populate exit number array
-        if (edge.sign().exit_numbers_size() > 0) {
-          auto exit_number_array = json::array({});
-          for (const auto& exit_number : edge.sign().exit_numbers()) {
-            exit_number_array->push_back(exit_number.text());
-          }
-          sign_map->emplace("exit_number", exit_number_array);
-        }
-
-        // Populate exit branch array
-        if (edge.sign().exit_onto_streets_size() > 0) {
-          auto exit_branch_array = json::array({});
-          for (const auto& exit_onto_street : edge.sign().exit_onto_streets()) {
-            exit_branch_array->push_back(exit_onto_street.text());
-          }
-          sign_map->emplace("exit_branch", exit_branch_array);
-        }
-
-        // Populate exit toward array
-        if (edge.sign().exit_toward_locations_size() > 0) {
-          auto exit_toward_array = json::array({});
-          for (const auto& exit_toward_location : edge.sign().exit_toward_locations()) {
-            exit_toward_array->push_back(exit_toward_location.text());
-          }
-          sign_map->emplace("exit_toward", exit_toward_array);
-        }
-
-        // Populate exit name array
-        if (edge.sign().exit_names_size() > 0) {
-          auto exit_name_array = json::array({});
-          for (const auto& exit_name : edge.sign().exit_names()) {
-            exit_name_array->push_back(exit_name.text());
-          }
-          sign_map->emplace("exit_name", exit_name_array);
-        }
-
-        edge_map->emplace("sign", sign_map);
-      }
-
-      // Process edge end node only if any node items are enabled
-      if (controller.category_attribute_enabled(kNodeCategory)) {
-        const auto& node = trip_path.node(i);
-        auto end_node_map = json::map({});
-
-        if (node.intersecting_edge_size() > 0) {
-          auto intersecting_edge_array = json::array({});
-          for (const auto& xedge : node.intersecting_edge()) {
-            auto xedge_map = json::map({});
-            if (xedge.has_walkability_case() &&
-                (xedge.walkability() != TripLeg_Traversability_kNone)) {
-              xedge_map->emplace("walkability", to_string(xedge.walkability()));
-            }
-            if (xedge.has_cyclability_case() &&
-                (xedge.cyclability() != TripLeg_Traversability_kNone)) {
-              xedge_map->emplace("cyclability", to_string(xedge.cyclability()));
-            }
-            if (xedge.has_driveability_case() &&
-                (xedge.driveability() != TripLeg_Traversability_kNone)) {
-              xedge_map->emplace("driveability", to_string(xedge.driveability()));
-            }
-            xedge_map->emplace("from_edge_name_consistency",
-                               static_cast<bool>(xedge.prev_name_consistency()));
-            xedge_map->emplace("to_edge_name_consistency",
-                               static_cast<bool>(xedge.curr_name_consistency()));
-            xedge_map->emplace("begin_heading", static_cast<uint64_t>(xedge.begin_heading()));
-
-            if (xedge.has_use_case()) {
-              xedge_map->emplace("use", to_string(static_cast<baldr::Use>(xedge.use())));
-            }
-
-            if (xedge.has_road_class_case()) {
-              xedge_map->emplace("road_class",
-                                 to_string(static_cast<baldr::RoadClass>(xedge.road_class())));
-            }
-
-            intersecting_edge_array->emplace_back(xedge_map);
-          }
-          end_node_map->emplace("intersecting_edges", intersecting_edge_array);
-        }
-
-        if (node.has_cost() && node.cost().has_elapsed_cost() &&
-            node.cost().elapsed_cost().has_seconds_case()) {
-          end_node_map->emplace("elapsed_time",
-                                json::fixed_t{node.cost().elapsed_cost().seconds(), 3});
-        }
-        if (node.has_admin_index_case()) {
-          end_node_map->emplace("admin_index", static_cast<uint64_t>(node.admin_index()));
-        }
-        if (node.has_type_case()) {
-          end_node_map->emplace("type", to_string(static_cast<baldr::NodeType>(node.type())));
-        }
-        if (node.has_fork_case()) {
-          end_node_map->emplace("fork", static_cast<bool>(node.fork()));
-        }
-        if (node.has_time_zone_case()) {
-          end_node_map->emplace("time_zone", node.time_zone());
-        }
-        if (node.has_cost() && node.cost().has_transition_cost() &&
-            node.cost().transition_cost().has_seconds_case()) {
-          end_node_map->emplace("transition_time",
-                                json::fixed_t{node.cost().transition_cost().seconds(), 3});
-        }
-
-        // TODO transit info at node
-        // kNodeTransitStopInfoType = "node.transit_stop_info.type";
-        // kNodeTransitStopInfoOnestopId = "node.transit_stop_info.onestop_id";
-        // kNodetransitStopInfoName = "node.transit_stop_info.name";
-        // kNodeTransitStopInfoArrivalDateTime = "node.transit_stop_info.arrival_date_time";
-        // kNodeTransitStopInfoDepartureDateTime = "node.transit_stop_info.departure_date_time";
-        // kNodeTransitStopInfoIsParentStop = "node.transit_stop_info.is_parent_stop";
-        // kNodeTransitStopInfoAssumedSchedule = "node.transit_stop_info.assumed_schedule";
-        // kNodeTransitStopInfoLatLon = "node.transit_stop_info.lat_lon";
-
-        edge_map->emplace("end_node", end_node_map);
-      }
+//      if (edge.name_size() > 0) {
+//        auto names_array = json::array({});
+//        for (const auto& name : edge.name()) {
+//          names_array->push_back(name.value());
+//        }
+//        edge_map->emplace("names", names_array);
+//      }
+//      if (edge.traffic_segment().size() > 0) {
+//        auto segments_array = json::array({});
+//        for (const auto& segment : edge.traffic_segment()) {
+//          json::MapPtr segmap =
+//              json::map({{"segment_id", segment.segment_id()},
+//                         {"begin_percent", json::fixed_t{segment.begin_percent(), 3}},
+//                         {"end_percent", json::fixed_t{segment.end_percent(), 3}},
+//                         {"starts_segment", segment.starts_segment()},
+//                         {"ends_segment", segment.ends_segment()}});
+//          segments_array->emplace_back(segmap);
+//        }
+//        edge_map->emplace("traffic_segments", segments_array);
+//      }
+//
+//      // Process edge sign
+//      // TODO: do we want to output 'is_route_number'?
+//      if (edge.has_sign()) {
+//        auto sign_map = json::map({});
+//
+//        // Populate exit number array
+//        if (edge.sign().exit_numbers_size() > 0) {
+//          auto exit_number_array = json::array({});
+//          for (const auto& exit_number : edge.sign().exit_numbers()) {
+//            exit_number_array->push_back(exit_number.text());
+//          }
+//          sign_map->emplace("exit_number", exit_number_array);
+//        }
+//
+//        // Populate exit branch array
+//        if (edge.sign().exit_onto_streets_size() > 0) {
+//          auto exit_branch_array = json::array({});
+//          for (const auto& exit_onto_street : edge.sign().exit_onto_streets()) {
+//            exit_branch_array->push_back(exit_onto_street.text());
+//          }
+//          sign_map->emplace("exit_branch", exit_branch_array);
+//        }
+//
+//        // Populate exit toward array
+//        if (edge.sign().exit_toward_locations_size() > 0) {
+//          auto exit_toward_array = json::array({});
+//          for (const auto& exit_toward_location : edge.sign().exit_toward_locations()) {
+//            exit_toward_array->push_back(exit_toward_location.text());
+//          }
+//          sign_map->emplace("exit_toward", exit_toward_array);
+//        }
+//
+//        // Populate exit name array
+//        if (edge.sign().exit_names_size() > 0) {
+//          auto exit_name_array = json::array({});
+//          for (const auto& exit_name : edge.sign().exit_names()) {
+//            exit_name_array->push_back(exit_name.text());
+//          }
+//          sign_map->emplace("exit_name", exit_name_array);
+//        }
+//
+//        edge_map->emplace("sign", sign_map);
+//      }
+//
+//      // Process edge end node only if any node items are enabled
+//      if (controller.category_attribute_enabled(kNodeCategory)) {
+//        const auto& node = trip_path.node(i);
+//        auto end_node_map = json::map({});
+//
+//        if (node.intersecting_edge_size() > 0) {
+//          auto intersecting_edge_array = json::array({});
+//          for (const auto& xedge : node.intersecting_edge()) {
+//            auto xedge_map = json::map({});
+//            if (xedge.has_walkability_case() &&
+//                (xedge.walkability() != TripLeg_Traversability_kNone)) {
+//              xedge_map->emplace("walkability", to_string(xedge.walkability()));
+//            }
+//            if (xedge.has_cyclability_case() &&
+//                (xedge.cyclability() != TripLeg_Traversability_kNone)) {
+//              xedge_map->emplace("cyclability", to_string(xedge.cyclability()));
+//            }
+//            if (xedge.has_driveability_case() &&
+//                (xedge.driveability() != TripLeg_Traversability_kNone)) {
+//              xedge_map->emplace("driveability", to_string(xedge.driveability()));
+//            }
+//            xedge_map->emplace("from_edge_name_consistency",
+//                               static_cast<bool>(xedge.prev_name_consistency()));
+//            xedge_map->emplace("to_edge_name_consistency",
+//                               static_cast<bool>(xedge.curr_name_consistency()));
+//            xedge_map->emplace("begin_heading", static_cast<uint64_t>(xedge.begin_heading()));
+//
+//            if (xedge.has_use_case()) {
+//              xedge_map->emplace("use", to_string(static_cast<baldr::Use>(xedge.use())));
+//            }
+//
+//            if (xedge.has_road_class_case()) {
+//              xedge_map->emplace("road_class",
+//                                 to_string(static_cast<baldr::RoadClass>(xedge.road_class())));
+//            }
+//
+//            intersecting_edge_array->emplace_back(xedge_map);
+//          }
+//          end_node_map->emplace("intersecting_edges", intersecting_edge_array);
+//        }
+//
+//        if (node.has_cost() && node.cost().has_elapsed_cost() &&
+//            node.cost().elapsed_cost().has_seconds_case()) {
+//          end_node_map->emplace("elapsed_time",
+//                                json::fixed_t{node.cost().elapsed_cost().seconds(), 3});
+//        }
+//        if (node.has_admin_index_case()) {
+//          end_node_map->emplace("admin_index", static_cast<uint64_t>(node.admin_index()));
+//        }
+//        if (node.has_type_case()) {
+//          end_node_map->emplace("type", to_string(static_cast<baldr::NodeType>(node.type())));
+//        }
+//        if (node.has_fork_case()) {
+//          end_node_map->emplace("fork", static_cast<bool>(node.fork()));
+//        }
+//        if (node.has_time_zone_case()) {
+//          end_node_map->emplace("time_zone", node.time_zone());
+//        }
+//        if (node.has_cost() && node.cost().has_transition_cost() &&
+//            node.cost().transition_cost().has_seconds_case()) {
+//          end_node_map->emplace("transition_time",
+//                                json::fixed_t{node.cost().transition_cost().seconds(), 3});
+//        }
+//
+//        // TODO transit info at node
+//        // kNodeTransitStopInfoType = "node.transit_stop_info.type";
+//        // kNodeTransitStopInfoOnestopId = "node.transit_stop_info.onestop_id";
+//        // kNodetransitStopInfoName = "node.transit_stop_info.name";
+//        // kNodeTransitStopInfoArrivalDateTime = "node.transit_stop_info.arrival_date_time";
+//        // kNodeTransitStopInfoDepartureDateTime = "node.transit_stop_info.departure_date_time";
+//        // kNodeTransitStopInfoIsParentStop = "node.transit_stop_info.is_parent_stop";
+//        // kNodeTransitStopInfoAssumedSchedule = "node.transit_stop_info.assumed_schedule";
+//        // kNodeTransitStopInfoLatLon = "node.transit_stop_info.lat_lon";
+//
+//        edge_map->emplace("end_node", end_node_map);
+//      }
 
       // TODO - transit info on edge
       // kEdgeTransitType = "edge.transit_type";
@@ -466,43 +474,43 @@ void append_trace_info(
   const auto& match_results = std::get<kMatchResultsIndex>(map_match_result);
 
   // Add osm_changeset
-  if (trip_path.has_osm_changeset_case()) {
-    json->emplace("osm_changeset", trip_path.osm_changeset());
-  }
-
-  // Add shape
-  if (trip_path.has_shape_case()) {
-    json->emplace("shape", trip_path.shape());
-  }
-
-  // Add confidence_score
-  if (controller.attributes.at(kConfidenceScore)) {
-    json->emplace("confidence_score",
-                  json::fixed_t{std::get<kConfidenceScoreIndex>(map_match_result), 3});
-  }
-
-  // Add raw_score
-  if (controller.attributes.at(kRawScore)) {
-    json->emplace("raw_score", json::fixed_t{std::get<kRawScoreIndex>(map_match_result), 3});
-  }
-
-  // Add admins list
-  if (trip_path.admin_size() > 0) {
-    json->emplace("admins", serialize_admins(trip_path));
-  }
+//  if (trip_path.has_osm_changeset_case()) {
+//    json->emplace("osm_changeset", trip_path.osm_changeset());
+//  }
+//
+//  // Add shape
+//  if (trip_path.has_shape_case()) {
+//    json->emplace("shape", trip_path.shape());
+//  }
+//
+//  // Add confidence_score
+//  if (controller.attributes.at(kConfidenceScore)) {
+//    json->emplace("confidence_score",
+//                  json::fixed_t{std::get<kConfidenceScoreIndex>(map_match_result), 3});
+//  }
+//
+//  // Add raw_score
+//  if (controller.attributes.at(kRawScore)) {
+//    json->emplace("raw_score", json::fixed_t{std::get<kRawScoreIndex>(map_match_result), 3});
+//  }
+//
+//  // Add admins list
+//  if (trip_path.admin_size() > 0) {
+//    json->emplace("admins", serialize_admins(trip_path));
+//  }
 
   // Add edges
   json->emplace("edges", serialize_edges(controller, options, trip_path));
 
-  // Add matched points, if requested
-  if (controller.category_attribute_enabled(kMatchedCategory) && !match_results.empty()) {
-    json->emplace("matched_points", serialize_matched_points(controller, match_results));
-  }
-
-  // Add shape_attributes, if requested
-  if (controller.category_attribute_enabled(kShapeAttributesCategory)) {
-    json->emplace("shape_attributes", serialize_shape_attributes(controller, trip_path));
-  }
+//  // Add matched points, if requested
+//  if (controller.category_attribute_enabled(kMatchedCategory) && !match_results.empty()) {
+//    json->emplace("matched_points", serialize_matched_points(controller, match_results));
+//  }
+//
+//  // Add shape_attributes, if requested
+//  if (controller.category_attribute_enabled(kShapeAttributesCategory)) {
+//    json->emplace("shape_attributes", serialize_shape_attributes(controller, trip_path));
+//  }
 }
 } // namespace
 
@@ -523,14 +531,14 @@ std::string serializeTraceAttributes(
   auto json = json::map({});
 
   // Add result id, if supplied
-  if (request.options().has_id_case()) {
-    json->emplace("id", request.options().id());
-  }
+//  if (request.options().has_id_case()) {
+//    json->emplace("id", request.options().id());
+//  }
 
   // Add units, if specified
-  if (request.options().has_units_case()) {
-    json->emplace("units", valhalla::Options_Units_Enum_Name(request.options().units()));
-  }
+//  if (request.options().has_units_case()) {
+//    json->emplace("units", valhalla::Options_Units_Enum_Name(request.options().units()));
+//  }
 
   // Loop over all results to process the best path
   // and the alternate paths (if alternates exist)
